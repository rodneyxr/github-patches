mod_version=0.10.1
minecraft_version=1.9.4
forge_version=12.17.0.1909-1.9.4
mcp_mappings_version=snapshot_20160516
cyclopscore_version=0.6.1-332
release_type=release

waila_version=1.7.0-B3_1.9.4
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=http\://services.gradle.org/distributions/gradle-2.12-all.zip
public EntityRedstoneGrenade(World world, double x, double y, double z) {
    protected void onImpact(RayTraceResult pos) {
        BlockPos blockPos = pos.getBlockPos();

        if (worldObj.isAirBlock(blockPos.add(pos.sideHit.getDirectionVec()))) {
			if(Configs.isEnabled(InvisibleRedstoneBlockConfig.class)) {
	            worldObj.setBlockState(blockPos.add(pos.sideHit.getDirectionVec()), InvisibleRedstoneBlock.getInstance().getDefaultState());
			}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
kxmlVersion=2.3.0
vaadinVersion=7.6.6
xmlunitVersion=1.6
activeMqVersion=5.13.2
sqlExplorerVersion=1.3.137

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private ParseTree parseThrowStatement() {
    SourcePosition start = getTreeStartLocation();
    eat(TokenType.THROW);
    ParseTree value = null;
    if (!peekImplicitSemiColon()) {
      value = parseExpression();
    }
    eatPossibleImplicitSemiColon();
public void testReturn() {
    parseError("return 1;", UNEXPECTED_RETURN);
  }

  public void testLabel1() {
    parse("foo:bar");
  }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /*
     * We have to use the f prefix until the next major release to ensure
     * serialization compatibility. 
     * See https://github.com/junit-team/junit4/issues/976
     */
    private final List<Integer> fIndices = new ArrayList<Integer>();
    private final String fMessage;

    /**
     * Construct a new <code>ArrayComparisonFailure</code> with an error text and the array's
     */
    public ArrayComparisonFailure(String message, AssertionError cause, int index) {
        this.fMessage = message;
        initCause(cause);
        addDimension(index);
    }

public void addDimension(int index) {
    }

    @Override
    public String getMessage() {
        StringBuilder sb = new StringBuilder();
        if (fMessage != null) {
        FailOnTimeoutTest.class,
        MethodSorterTest.class,
        StacktracePrintingMatcherTest.class,
        ThrowableCauseMatcherTest.class
})
public class AllInternalTests {
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public View getView(int position, View convertView, ViewGroup parent){
                }
            }
            if (location != null) {
                location.setText(i.get_gameType().getName());
            }
            if (time != null) {
                String timeStamp = new SimpleDateFormat("dd-MMM-yyyy hh:mm a zz").format(new Date(i.get_date()));
    WALLS3("MegaWalls", 13),
    ARCADE("Arcade", 14),
    ARENA("Arena", 17),
    MCGO("Cops and Crims", 21);

    private static GameType[] v = values();
    private final String name;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void updateLabels(CommentAddedEvent event) {
        }

        Account account = getAccountFromAttribute(event.author, accountCache, accountResolver);

        try (Repository repo = repoManager.openRepository(projectName);
             ReviewDb reviewDb = schemaFactory.open()) {
public static Account getAccountFromAttribute(AccountAttribute attribute,
                                                  AccountCache cache,
                                                  AccountResolver resolver) {
        //TODO this could be greatly simplified by adding Account.Id to AccountAttribute
        Account account = cache.getByUsername(attribute.username).getAccount();
        if (account == null) {
            try {
                account = resolver.findByNameOrEmail(attribute.email);
                if (account == null) {
                    account = resolver.findByNameOrEmail(attribute.name);
                }
            } catch (OrmException e) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import org.jdto.PropertyValueMerger;
import org.jdto.PropertyValueMergerInstanceManager;
import org.slf4j.Logger;
public DTOBinderBean(InputStream xmlFile, boolean eagerLoad) {

        boolean shouldReleaseThreadLocal = initBindingContextIfNecessary();
        try {

            //this will apply repeatedly the conversion results to a list.
            Object[] paramsBuffer = new Object[businessObjectsLists.length];

            List<T> ret = new ArrayList<T>();

            //the reference size will be the first list size
            int refSize = businessObjectsLists[0].size();

            //repeatedly run the simple binding.
            for (int i = 0; i < refSize; i++) {
                for (int j = 0; j < businessObjectsLists.length; j++) {
public PropertyValueMergerInstanceManager getMergerManager() {
    public void setMergerManager(PropertyValueMergerInstanceManager manager) {
        this.implementationDelegate.setMergerManager(manager);
    }
}
private Object applyCascadeLogic(List<Object> sourceValues, FieldMetadata fieldM
    }

    private List convertValueToList(Object value) {

        if (value instanceof List) {
            return (List) value;
        }
public void testCascadeList() {
        assertNotNull(cldto.getFormatDtos());
        assertTrue(cldto.getFormatDtos().size() == 2);
    }

    @Test
    public void testCascadeListArray() {
public void testNulls() {
        subject.mergeObjects(method, null);
    }
    
    @Test(expected=IllegalArgumentException.class)
    public void testUnexistentMethod() {
        
        String[] method = {"nonSenseMethod"};
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		public static int			SECTION_HEIGHT				= 100;
		public static int			MAX_CELL					= 10;
		public static int			CUSTOM_BORDER_HEIGTH_OFFSET	= 2;
		final public static String	VERSION						= "V 10.6";
	}
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

import javax.swing.JLabel;

import org.grandviewtech.constants.CustomBorderList;
import org.grandviewtech.entity.bo.ClipBoard;
import org.grandviewtech.entity.bo.Screen;
public void actionPerformed(ActionEvent event)
									}
								break;
							}
						
					}
					
			}
private void paste()
								ColumnScreen copiedColumn = copiedRow.getColumnScreens(columnIndex);
								if (copiedColumn.isBlank() == false)
									{
										pasteColumn.setCoilType(copiedColumn.getCoilType());
										pasteColumn.setValue(copiedColumn.getValue());
										pasteColumn.setTag(copiedColumn.getTag());
										pasteColumn.requestFocus();
										SearchEngine.index(pasteColumn);
									}
								columnIndex = columnIndex + 1;
								
							}
						i$ = i$ + 1;
					}
				if (ClipBoard.getClipboardAction() == CLIPBOARD_ACTION.CUT)
					{
						Set<Integer> deletedRowNumbers = new LinkedHashSet<Integer>();
						List<Rung> copiedRungs = ClipBoard.getCopiedRung();
private void paste()
								deletedRowNumbers.add(rung.getRowNumber());
							}
						RowGenerator.deleteRows(deletedRowNumbers);
					}
			}
	}
import org.grandviewtech.entity.enums.NoNc;
import org.grandviewtech.entity.helper.Dimension;
import org.grandviewtech.runner.Application;
import org.grandviewtech.service.runtime.user.useractivity.Activities;
import org.grandviewtech.service.searching.SearchEngine;
import org.grandviewtech.service.system.PropertyReader;

import com.thoughtworks.xstream.XStream;

public class ColumnConfigurationScreen extends JFrame
	{
		private static org.apache.log4j.Logger	logger				= org.apache.log4j.Logger.getLogger(ColumnConfigurationScreen.class);
		private static Activities				activities			= Activities.getInstance();
		final static Screen						SCREEN				= Screen.getInstance();
		private static final long				serialVersionUID	= 1L;
		private static NumberFormatter			numberFormatter		= null;
private void routineList()
								dataList.add(routineName);
							}
					}
				dataList.sort(new Comparator<String>()
					{
						@Override
public void valueChanged(ListSelectionEvent event)
				panel.add(scrollPane);
				JButton submit = new JButton("Submit");
				submit.setBounds(X1 + 180, 410, 150, 25);
				submit.addActionListener(onSubmit ->
					{
						JOptionPane optionPane = null;
						if (selectedRoutine != null)
							{
public void valueChanged(ListSelectionEvent event)
									}
								columnScreen.setRoutine(selectedRoutine);
								optionPane = new JOptionPane("Routine Selected Successfully", JOptionPane.INFORMATION_MESSAGE);
							}
						else
							{
								optionPane = new JOptionPane("Error While Selecting Routine", JOptionPane.INFORMATION_MESSAGE);
							}
						JDialog dialog = optionPane.createDialog(null, "Select Routine");
						dialog.setModal(false);
						dialog.setVisible(true);
						// http://docs.oracle.com/javase/tutorial/uiswing/components/dialog.html#stayup
						Timer timer = new Timer(600, timerEvent ->
							{
								dialog.setVisible(false);
								dialog.dispose();
								columnScreen.apply();
							});
						timer.start();
						dispose();
					});
				JButton cancel = new JButton("Canel");
				cancel.setBounds(X1 + 350, 410, 150, 25);
else if (columnScreen.getTemp().equals(CoilType.OUTPUT))
						// flag.setSelected(true);
						flag.setBounds(X2, Y * 2, RADIO_WIDTH, HEIGHT);
						output.setBounds(X2 + (RADIO_WIDTH * 1), Y * 2, RADIO_WIDTH, HEIGHT);
						// separator.setBounds(X1, Y * 3 + (20),
						// CustomDimension.CONFIGURATION_SCREEN.width - (X1 *
						// 4), 10);
else if (isLoadCoil() || coilType.equals(CoilType.OUTPUT))
										if (!isRoutine)
											{
												setInputTagAndValue(columnScreen);
												SearchEngine.index(columnScreen);
											}
										dispose();
										columnScreen.repaint();
else if (NC.isSelected())
					{
						nonc = NoNc.NC;
					}
				else if (SET.isSelected())
					{
						nonc = NoNc.SET;
					}
				else if (RESET.isSelected())
					{
						nonc = NoNc.RESET;
					}
private boolean isLoadCoil()
				CoilType coilType = columnScreen.getTemp();
				return (coilType.equals(CoilType.LOAD) || coilType.equals(CoilType.PARALLEL) || coilType.equals(CoilType.LEFT_LINK) || coilType.equals(CoilType.RIGHT_LINK));
			}
	}
import org.grandviewtech.entity.enums.Edge;
import org.grandviewtech.entity.enums.InputType;
import org.grandviewtech.entity.enums.NoNc;
import org.grandviewtech.service.validation.RowValidation;
import org.grandviewtech.service.validation.ValidateDragOption;
import org.grandviewtech.userinterface.coils.PaintCoilsOnScreen;
public void apply()
					}
				setBlank(false);
				setCoilType(temp);
				RowValidation.validate(this);
				repaint();
			}
			
public void setInputType(InputType inputType)
			
		public NoNc getNonc()
			{
				return nonc;
			}
			
public void setNonc(NoNc nonc)
			
		public Edge getEdge()
			{
				return edge;
			}
			
private void init()
				addMouseListener(columnScreenListener);
				addKeyListener(columnScreenListener);
				addFocusListener(columnScreenListener);
				setToolTipText("Row : " + getRowNumber() + " |  Column : " + getColumnNumber());
				repaint();
				revalidate();
			}
public boolean equals(Object object)
					}
				return false;
			}
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public Hop getNextHop(Request request) throws SipException {
         *
         * Subsequently, the request URI will be used as next hop target
         */

        if (routes != null) {

            // to send the request through a specified hop the application is
            // supposed to prepend the appropriate Route header which.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public boolean isSubclass(String parent, String child) {
        String k = parent + "@" + child;
        if (!isSubclassCache.containsKey(k)) {
            child = getSuperClass(child);

            isSubclassCache.put(k, child != null && isSubclass(parent, child));
        }
        return isSubclassCache.get(k);
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void actionPerformed(ActionEvent arg0) {
			JOptionPane.showConfirmDialog(null, "Please select a directory to put your new directory in first", "No selected directory", JOptionPane.DEFAULT_OPTION, JOptionPane.ERROR_MESSAGE);
			return;
		    }
		    String name = JOptionPane.showInputDialog(null, "What is the name of your new directory?", "Name", JOptionPane.QUESTION_MESSAGE).trim();
		    while (CreateAccountPane.stringContains(name, CreateAccountPane.INVALID_CHARS) || name.length() < 1) {
			name = JOptionPane.showInputDialog(null, "That name is invalid.\nPlease enter an appropriate new name for this directory.\nNo characters such as: \\ / ? %!(BADWIDTH)%! (MISSING): | " + "\" < > . # & { } $ @ = ` + ", "Invalid name", JOptionPane.ERROR_MESSAGE).trim();
		    }
private CreateFileOnFolderButton() {
		@Override
		public void actionPerformed(ActionEvent arg0) {
		    DirectoryNode selectedDir = (DirectoryNode) getSelectionPath().getLastPathComponent();
		    String name = JOptionPane.showInputDialog(null, "What is the name of your new  file?\nInclude extensions such as .java", "Name", JOptionPane.QUESTION_MESSAGE).trim();
		    while (CreateAccountPane.stringContains(name, CreateAccountPane.INVALID_CHARS) || name.length() < 1) {
			name = JOptionPane.showInputDialog(null, "That name is invalid.\nPlease enter an appropriate new name for this directory.\nNo characters such as: \\ / ? %!(BADWIDTH)%! (MISSING): | " + "\" < > . # & { } $ @ = ` + ", "Invalid name", JOptionPane.ERROR_MESSAGE).trim();
		    }
		    Data createFileRequest = new Data("new_text_file");
		    UUID projectUUID = ((ProjectNode) selectedDir.getPath()[1]).getProjectUUID();
		    createFileRequest.put("project_uuid", projectUUID);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private static PointSymbolizer createArrow(FunctionName angleFunction,
        // Arrow rotation
        List<Expression> rotationArgumentList = new ArrayList<Expression>();

        DataSourceInterface dsInfo = DataSourceFactory.getDataSource();
        String geometryFieldName = dsInfo.getGeometryFieldName();
        rotationArgumentList.add(ff.property(geometryFieldName));

        Expression rotation = FunctionManager.getInstance().createExpression(angleFunction, rotationArgumentList);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public AckMessage getAcknowledge () throws
     * @param remaining - Number of retry attempts remaining
     */
    public void handleTimeout (int remaining) {
        super.handleTimeout(remaining);
        try {
            this.sendDataMessage(this.currentMessage);
        } catch (IOException e){
            e.printStackTrace();
            System.exit(0);
        }
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import mage.MageInt;
import mage.abilities.Ability;
import mage.abilities.common.BeginningOfUpkeepTriggeredAbility;
import mage.abilities.effects.OneShotEffect;
import mage.cards.CardImpl;
import mage.constants.CardType;
import mage.constants.Outcome;
import mage.constants.Rarity;
import mage.constants.TargetController;
import mage.game.Game;
import mage.players.Player;
import mage.game.permanent.Permanent;

/**
 *
 * @author MarcoMarin, Watch out! This one I actually made from scratch!(1st time \o/) Not even checked similars :) beware!
 */
public class GhazbanOgre extends CardImpl {

public GhazbanOgre(UUID ownerId) {
        this.power = new MageInt(2);
        this.toughness = new MageInt(2);

        // At the beginning of your upkeep, if a player has more life than each other player, the player with the most life gains control of Ghazb&aacute;n Ogre.
        this.addAbility(new BeginningOfUpkeepTriggeredAbility(new GhazbanOgreEffect(), TargetController.YOU, false));
        
    }

    public GhazbanOgre(final GhazbanOgre card) {
public GhazbanOgre copy() {
        return new GhazbanOgre(this);
    }
}
class GhazbanOgreEffect extends OneShotEffect {
    
    public GhazbanOgreEffect() {
        super(Outcome.GainControl);
        this.staticText = "the player with the most life gains control of Ghazban Ogre";
    }
    
    public GhazbanOgreEffect(final GhazbanOgreEffect effect) {
        super(effect);
    }
    
    @Override
    public GhazbanOgreEffect copy() {
        return new GhazbanOgreEffect(this);
    }
    
    @Override
    public boolean apply(Game game, Ability source) {
        Player newOwner = null;
        int lowLife = Integer.MIN_VALUE;
        boolean tie = false;
        for (UUID playerID : game.getPlayerList()){
            Player player = game.getPlayer(playerID);        
            if (player.getLife() > lowLife){
                lowLife = player.getLife();
                newOwner = player;
                tie = false;
            }else if (player.getLife() == lowLife){ 
                tie = true;
            }        
        }
        if (!tie){
           game.getPermanent(source.getId()).changeControllerId(newOwner.getId(), game);
        }
        
        return true;
                        
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void flowCompletedWithErrors(Throwable myError) {
        } else if (ACTION_DELETE.equals(actionOnError)) {
            deleteFiles();
        }
        directory.close(false);
        directory = null;
    }

    @Override
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.repository.query.Param;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.concurrent.SynchronousQueue;
import java.util.zip.ZipFile;

/**
 * Created by Arne on 15.05.2016.
    @Autowired
    Crawler crawler;
    private final Logger LOG = LoggerFactory.getLogger(CrawlerController.class);

    @RequestMapping(value = "/crawlIntoBackend", method = RequestMethod.GET)
    public void crawlIntoBackend(@Param("year") String year, @Param("month") String month) throws Exception {
public void crawlIntoBackend(@Param("year") String year, @Param("month") String
        } catch (NumberFormatException nfe) {
            throw new IllegalArgumentException("year/month must be a numerical value");
        }
        if (startMonth == 1) {
            crawler.getAirlines("http://transtats.bts.gov/Download_Lookup.asp?Lookup=L_AIRLINE_ID");
            crawler.getMarkets("http://www.transtats.bts.gov/Download_Lookup.asp?Lookup=L_CITY_MARKET_ID");
            crawler.getRoutes("http://transtats.bts.gov/DownLoad_Table.asp?Table_ID=311&Has_Group=3&Is_Zipped=0", usedYear);
            crawler.sendDataToBackend();
        }
        //FlightPipe:
        Pump<String>[] pumps = new Pump[12];
        Sink<List<Route>>[] sinks = new Sink[12];
        for (int i = startMonth; i <= endMonth; i++) {
            pumps[i - 1] = new Pump<>();
            sinks[i - 1] = new Sink<>();
            String filename = "flights-" + usedYear + "-" + i + ".zip";
            String downloadfileType = "zip";
            Downloader<ZipFile> flightDownloader = new Downloader<>("http://transtats.bts.gov/DownLoad_Table.asp?Table_ID=236&Has_Group=3&Is_Zipped=0", usedYear, i, downloadfileType, filename);
            ResourceBuilder<String, Route> rbsf = new ResourceBuilder<>("", new Route(), true);
            pumps[i - 1].use(new Unzipper<>(downloadfileType, filename, ""))
                    .connect(new Pipe<>())
                    .connect(rbsf)
                    .connect(new SynchronizedQueue<>())
                    .connect(new Collector<>())
                    .connect(new Pipe<>())
                    .connect(sinks[i - 1].use(flightSender));
            pumps[i - 1].interrupt();
            sinks[i - 1].interrupt();
            LOG.info("Started FlightCrawlThread#" + i);
        }
        for (int i = 0; i < sinks.length; i++) {
            sinks[i].join();
            LOG.info("Sink " + i + " beendet");
        }
        LOG.info("Crawling of " + year + " done");
    }
}
import de.orfap.fap.crawler.domain.Market;
import de.orfap.fap.crawler.domain.Route;
import edu.hm.obreitwi.arch.lab08.BaseFilter;
import org.springframework.beans.factory.annotation.Value;

import java.util.GregorianCalendar;

    private Object object;
    private String s;
    private boolean listable;
    @Value("${fap.backend.basePath}")
    private String basepath;

    public ResourceBuilder(final String s, final Object object, boolean listable) {
        this.s = s;
        this.object = object;
        this.listable=listable;
    }

    @Override
public U transform(T data) {
                    output.setDestination(columns[4]);
                }
                else{
                    output.setAirline(basepath + "airlines/" + columns[2]);
                    output.setSource(basepath + "markets/" + columns[3]);
                    output.setDestination(basepath + "markets/" + columns[4]);
                }
                return (U) output;
            }
public void accept(T data) {
        } else if (data instanceof List){
            routeClient.create((List)data);
        }
        numberSendOperations++;
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
else if(resultCode == RESULT_OK) {
     * Triggers form submission cycle, cleans up some session state.
     *
     * @param resultCode exit code of form entry activity
     * @param intent The intent of the returning activity, with the
     * saved form provided as the intent URI data
     * @return Flag signifying that caller should fetch the next activity in
     * the session to launch. If false then caller should exit or spawn home
     * activity.
private boolean processReturnFromFormEntry(int resultCode, Intent intent) {
        }

        // TODO: This should be the default unless we're in some "Uninit" or "incomplete" state
        if (intent.getBooleanExtra(FormEntryActivity.IS_ARCHIVED_FORM, false) ||
                FormRecord.STATUS_COMPLETE.equals(current.getStatus()) ||
                FormRecord.STATUS_SAVED.equals(current.getStatus())) {
            // Viewing an old form, so don't change the historical record
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
protected void parseCreateField(ParseContext context, List<IndexableField> field
            value = context.parser().textOrNull();
        }

        final int tokenCount;
        if (value == null) {
            tokenCount = (Integer) fieldType().nullValue();
import org.apache.lucene.analysis.MockTokenizer;
import org.apache.lucene.analysis.Token;
import org.apache.lucene.analysis.TokenStream;
import org.elasticsearch.common.compress.CompressedXContent;
import org.elasticsearch.common.xcontent.XContentFactory;
import org.elasticsearch.index.IndexService;
import org.elasticsearch.plugins.Plugin;
import org.elasticsearch.test.ESSingleNodeTestCase;
public void testEmptyName() throws IOException {
        );
        assertThat(e.getMessage(), containsString("name cannot be empty string"));
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
package com.jpii.navalbattle;

import com.jpii.roketgamer.RoketGamer;
import com.jpii.navalbattle.data.Constants;
import com.jpii.navalbattle.data.GameState;
import com.jpii.navalbattle.debug.CommandHandler;
import com.jpii.navalbattle.debug.DebugWindow;
	
	public static void main(String[] args) {
		
		
		roketGamer = new RoketGamer();
		debugWindow = new DebugWindow();
		gameState = new GameState();
		commandHandler = new CommandHandler(Constants.COMMANDS);
		
		debugWindow.printInfo("NavalBattle initialized.");
		new LoginWindow();

package com.jpii.navalbattle.data;

import java.util.ArrayList;

import com.jpii.navalbattle.NavalBattle;
import com.jpii.navalbattle.debug.Command;
import com.jpii.navalbattle.debug.CommandAction;

public class Constants {
	
	/*
	public static final String NAVALBATTLE_VERSION = "0.1a";
	public static final String NAVALBATTLE_CODENAME = "Pioneer";
	public static final String NAVALBATTLE_VERSION_TITLE = "NavalBattle " + NAVALBATTLE_VERSION + " (" + NAVALBATTLE_CODENAME + ")";
	public static final String NEWSFEED_URL = "https://dl.dropbox.com/u/4847494/navalbattle/news.html";
	public static final boolean DEBUG_MODE = true;
	
	/*
	 * RoketGamer
	 */
	public static final boolean ENABLE_ROKETGAMER = true;
	public static final boolean FORCE_LOGIN = true;
	public static final String API_KEY = "API_KEY";
	public static final String SERVER_LOCATION = "http://www.roketgamer.co.cc";
	
	/*
	 * Commands
	 */
	@SuppressWarnings("serial")
	public static final ArrayList<Command> COMMANDS = new ArrayList<Command>() {{
	    add(new Command("help", "", "View all commands", new CommandAction() { 
	    	public void onRun(Command c, String enteredCommand) {
	    		NavalBattle.getDebugWindow().println("----------------- NavalBattle Debug Help -----------------");
	    		for(Command cmd : NavalBattle.getCommandHandler().getCommands()) {
	    			NavalBattle.getDebugWindow().println(cmd.getCommand() + cmd.getArgs() + " - " + cmd.getDescription());
	    		}
	    	}}
	    ));
	    
	    add(new Command("quit", "", "Quit game", new CommandAction() { 
	    	public void onRun(Command c, String enteredCommand) {
	    		System.exit(0);
	    	}}
	    ));
	    
	    add(new Command("version", "", "View version info", new CommandAction() { 
	    	public void onRun(Command c, String enteredCommand) {
	    		NavalBattle.getDebugWindow().println(NAVALBATTLE_VERSION_TITLE + " (" + NAVALBATTLE_CODENAME + ")");
	    	}}
	    ));
	    
	    add(new Command("echo", "<message>", "Print specified message", new CommandAction() { 
	    	public void onRun(Command c, String enteredCommand) {
	    		String[] s = enteredCommand.split(" ", 2);
	    		NavalBattle.getDebugWindow().println(s[1]);
	    	}}
	    ));
	    
	    add(new Command("credits", "", "NavalBattle credits", new CommandAction() { 
	    	public void onRun(Command c, String enteredCommand) {
	    		NavalBattle.getDebugWindow().println("----------------- NavalBattle Credits -----------------");
	    		NavalBattle.getDebugWindow().println("Anthony \"abauer\" Bauer - game design lead");
	    		NavalBattle.getDebugWindow().println("Thomas \"TexasGamer\" Gaubert - SCM manager; RoketGamer lead");
	    		NavalBattle.getDebugWindow().println("Max \"maximusvladimir\" Kirkby - TBD");
	    		NavalBattle.getDebugWindow().println("JR \"DarkWarHero\" Vetus - TBD");
	    		NavalBattle.getDebugWindow().println("Matt \"Matthis5point0\" Waller - TBD");
	    		NavalBattle.getDebugWindow().println("Zach \"smeagle42\" Mathewson - SCM manager; RoketGamer lead");
	    		NavalBattle.getDebugWindow().println("");
	    		NavalBattle.getDebugWindow().println("GitHub - source code hosting");
	    		NavalBattle.getDebugWindow().println("RoketGamer - online social gaming");
	    	}}
	    ));
	    
	    add(new Command("setscore", "<score>", "Set game score", new CommandAction() { 
	    	public void onRun(Command c, String enteredCommand) {
	    		String[] s = enteredCommand.split(" ", 2);
	    		try {
	    			NavalBattle.getGameState().setScore(Integer.parseInt(s[1]));
		    		NavalBattle.getDebugWindow().printInfo("Game score set to " + NavalBattle.getGameState().getScore());
	    		} catch (Exception ex) {
	    			NavalBattle.getDebugWindow().printError("Missing or invalid arg: score");
	    		}
	    	}}
	    ));
	    
	    add(new Command("addscore", "<score>", "Add to game score", new CommandAction() { 
	    	public void onRun(Command c, String enteredCommand) {
	    		String[] s = enteredCommand.split(" ", 2);
	    		try {
	    			NavalBattle.getGameState().addScore(Integer.parseInt(s[1]));
		    		NavalBattle.getDebugWindow().printInfo("Game score set to " + NavalBattle.getGameState().getScore());
	    		} catch (Exception ex) {
	    			NavalBattle.getDebugWindow().printError("Missing or invalid arg: score");
	    		}
	    	}}
	    ));
	    
	    add(new Command("removescore", "<score>", "Subtract from game score", new CommandAction() { 
	    	public void onRun(Command c, String enteredCommand) {
	    		String[] s = enteredCommand.split(" ", 2);
	    		try {
	    			NavalBattle.getGameState().subtractScore(Integer.parseInt(s[1]));
		    		NavalBattle.getDebugWindow().printInfo("Game score set to " + NavalBattle.getGameState().getScore());
	    		} catch (Exception ex) {
	    			NavalBattle.getDebugWindow().printError("Missing or invalid arg: score");
	    		}
	    	}}
	    ));
	    
	    add(new Command("getscore", "", "Get game score", new CommandAction() { 
	    	public void onRun(Command c, String enteredCommand) {
		    	NavalBattle.getDebugWindow().printInfo("Game score: " + NavalBattle.getGameState().getScore());
	    	}}
	    ));
	    
	    add(new Command("resetscore", "", "Set game score to 0", new CommandAction() { 
	    	public void onRun(Command c, String enteredCommand) {
	    		NavalBattle.getGameState().resetScore();
		    	NavalBattle.getDebugWindow().printInfo("Game score reset");
	    	}}
	    ));
	    
	    add(new Command("clear", "", "Clear debug window", new CommandAction() { 
	    	public void onRun(Command c, String enteredCommand) {
	    			NavalBattle.getDebugWindow().printNew("");
	    	}}
	    
	    ));
	    
	    add(new Command("cls", "", "Clear debug window", new CommandAction() { 
	    	public void onRun(Command c, String enteredCommand) {
	    			NavalBattle.getDebugWindow().printNew("");
	    	}}
	    
	    ));
	}};
	
}
public LoginWindow() {
		f.getContentPane().setLayout(null);
		usernameLabel = new JLabel();
		usernameLabel.setText("Username");
		usernameLabel.setBounds(311,285,100,20);
		usernameField = new JTextField(25);
		usernameField.setBounds(365,285,100,20);
		passwordLabel = new JLabel();
		passwordLabel.setText("Password");
		passwordLabel.setBounds(311,316,100,20);
		passwordField = new JPasswordField(25);
		passwordField.setBounds(365,316,100,20);
		loginButton=new JButton("Login");
		loginButton.setBounds(389,347,78,22);
		
		JTextPane txtpntest = new JTextPane();
		JScrollPane scrollableList = new JScrollPane(txtpntest);
		scrollableList.setLocation(10, 11);
		scrollableList.setSize(455, 263);

		try {
			txtpntest.setPage("https://dl.dropbox.com/u/4847494/navalbattle/news.html");
		} catch (Exception e) { NavalBattle.getDebugWindow().printError("Exception while loading news feed!"); }

		txtpntest.setEditable(false);
		txtpntest.setFocusable(false);
		txtpntest.setContentType("text/html");
		txtpntest.setBounds(10, 11, 455, 263);

		f.getContentPane().add(scrollableList);
		f.getContentPane().add(usernameLabel);
		f.getContentPane().add(usernameField);
		f.getContentPane().add(passwordLabel);
public LoginWindow() {
		usernameField.addKeyListener(new KeyboardListener(this));		
		
		JLabel lblVersion = new JLabel(Constants.NAVALBATTLE_VERSION_TITLE);
		lblVersion.setBounds(10, 355, 164, 14);
		f.getContentPane().add(lblVersion);

		JButton registerButton = new JButton("Register");
		registerButton.setBounds(301, 347, 78, 22);
		f.getContentPane().add(registerButton);
		
		JButton btnOffline = new JButton("Offline");
		btnOffline.setBounds(213, 347, 78, 22);
		f.getContentPane().add(btnOffline);

		f.setSize(491,418);
		f.setVisible(true);
		f.setLocation(500,300);

public void login() {
		}
		// Authenticate Login
		else if (false) {
			NavalBattle.getDebugWindow().printWarning("User authenticated!");
			NavalBattle.getDebugWindow().printInfo("Disposing LoginWindow");
			f.dispose();
			NavalBattle.getDebugWindow().printInfo("Opening MainMenuWindow");
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.util.regex.Matcher;
import java.util.regex.Pattern;


import org.apache.commons.lang.StringUtils;
import org.openhab.binding.tcp.Direction;
import org.openhab.binding.tcp.protocol.ProtocolBindingProvider;
    private static final Pattern ACTION_CONFIG_PATTERN = Pattern
            .compile("(<|>)\\[(.*?):(.*?):(.*?):(?:'(.*)'|(.*))\\]");
    private static final Pattern STATUS_CONFIG_PATTERN = Pattern.compile("(<|>)\\[(.*?):(.*?):(?:'(.*)'|(.*))\\]");
    
    private static final Command WILDCARD_COMMAND_KEY = StringType.valueOf("*");
    
    static int counter = 0;

    @Override
public String getProtocolCommand(String itemName, Command command) {
     * {@link ProtocolBindingConfigElement }. There will be map like
     * <code>ON->ProtocolBindingConfigElement</code>
     */
    static class ProtocolBindingConfig extends HashMap<Command, ProtocolBindingConfigElement>implements BindingConfig {

        private static final long serialVersionUID = 6363085986521089771L;

/**
 * Copyright (c) 2010-2016 by the respective copyright holders.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
import java.nio.channels.DatagramChannel;
import java.util.Dictionary;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.slf4j.LoggerFactory;

/**
 * UDPBinding is most "simple" implementation of a UDP based ASCII protocol. It sends and received
 * data as ASCII strings. Data sent out is padded with a CR/LF. This should be sufficient for a lot
 * of home automation devices that take simple ASCII based control commands, or that send back
 * text based status messages
 *
 *
 * @author Karel Goderis
 * @since 1.1.0
 *
 */
public class UDPBinding extends AbstractDatagramChannelBinding<UDPBindingProvider> implements ManagedService {

protected boolean internalReceiveChanneledCommand(String itemName, Command comma

        ProtocolBindingProvider provider = findFirstMatchingBindingProvider(itemName);

        if (command != null) {

            String transformedMessage = transformResponse(provider.getProtocolCommand(itemName, command),
                    commandAsString);
            String UDPCommandName = preAmble + transformedMessage + postAmble;

            ByteBuffer outputBuffer = null;
            try {
                outputBuffer = ByteBuffer.allocate(UDPCommandName.getBytes(charset).length);
                outputBuffer.put(UDPCommandName.getBytes(charset));
            } catch (UnsupportedEncodingException e) {
                logger.warn("Exception while attempting an unsupported encoding scheme");
            }

            // send the buffer in an asynchronous way
            ByteBuffer result = null;
            try {
                result = writeBuffer(outputBuffer, sChannel, blocking, timeOut);
            } catch (Exception e) {
                logger.error("An exception occurred while writing a buffer to a channel: {}", e.getMessage());
            }

            if (result != null && blocking) {
                String resultString = "";
                try {
                    resultString = new String(result.array(), charset);
                } catch (UnsupportedEncodingException e) {
                    logger.warn("Exception while attempting an unsupported encoding scheme");
                }

                logger.info("Received {} from the remote end {}", resultString, sChannel.toString());
                String transformedResponse = transformResponse(provider.getProtocolCommand(itemName, command),
                        resultString);

                // if the remote-end does not send a reply in response to the string we just sent, then the abstract
                // superclass will update
                // the openhab status of the item for us. If it does reply, then an additional update is done via
                // parseBuffer.
                // since this TCP binding does not know about the specific protocol, there might be two state updates
                // (the command, and if
                // the case, the reply from the remote-end)

                if (updateWithResponse) {

                    List<Class<? extends State>> stateTypeList = provider.getAcceptedDataTypes(itemName, command);
                    State newState = createStateFromString(stateTypeList, transformedResponse);

                    if (newState != null) {
                        eventPublisher.postUpdate(itemName, newState);
                    } else {
                        logger.warn("Can not parse transformed input " + transformedResponse
                                + " to match command {} on item {}  ", command, itemName);
                    }

                    return false;
                } else {
                    return true;
                }
            } else {
                return true;
            }
        }
        return false;
    }

    /**
protected void parseBuffer(String itemName, Command aCommand, Direction theDirec
        String theUpdate = "";
        try {
            theUpdate = new String(byteBuffer.array(), charset);
        } catch (UnsupportedEncodingException e) {
            logger.warn("Exception while attempting an unsupported encoding scheme");
        }

        ProtocolBindingProvider provider = findFirstMatchingBindingProvider(itemName);

        List<Class<? extends State>> stateTypeList = provider.getAcceptedDataTypes(itemName, aCommand);

protected void parseBuffer(String itemName, Command aCommand, Direction theDirec
        if (newState != null) {
            eventPublisher.postUpdate(itemName, newState);
        } else {
            logger.warn("Can not parse input " + theUpdate + " to match command {} on item {}  ", aCommand, itemName);
        }
    }

public void updated(Dictionary config) throws ConfigurationException {

        super.updated(config);

        if (config != null) {

            String timeOutString = (String) config.get("buffersize");
            if (isNotBlank(timeOutString)) {
                timeOut = Integer.parseInt((timeOutString));
            } else {
                logger.info("The maximum time out for blocking write operations will be set to the default value of {}",
                        timeOut);
            }

            String blockingString = (String) config.get("retryinterval");
            if (isNotBlank(blockingString)) {
                blocking = Boolean.parseBoolean((blockingString));
            } else {
                logger.info("The blocking nature of read/write operations will be set to the default value of {}",
                        blocking);
            }

            String preambleString = (String) config.get("preamble");
            if (isNotBlank(preambleString)) {
                try {
                    preAmble = preambleString.replaceAll("\\\\", "\\");
                } catch (Exception e) {
                    preAmble = preambleString;
                }
            } else {
                logger.info("The preamble for all write operations will be set to the default value of {}", preAmble);
            }

            String postambleString = (String) config.get("postamble");
            if (isNotBlank(postambleString)) {
                try {
                    postAmble = postambleString.replaceAll("\\\\", "\\");
                } catch (Exception e) {
                    postAmble = postambleString;
                }
            } else {
                logger.info("The postamble for all write operations will be set to the default value of {}", postAmble);
            }

            String updatewithresponseString = (String) config.get("updatewithresponse");
            if (isNotBlank(updatewithresponseString)) {
                updateWithResponse = Boolean.parseBoolean((updatewithresponseString));
            } else {
                logger.info("Updating states with returned values will be set to the default value of {}",
                        updateWithResponse);
            }

            String charsetString = (String) config.get("charset");
            if (isNotBlank(charsetString)) {
                charset = charsetString;
            } else {
                logger.info("The characterset will be set to the default value of {}", charset);
            }

        }

    }

    @Override
protected String transformResponse(String transformation, String response) {
        String transformedResponse;

        if (isEmpty(transformation) || transformation.equalsIgnoreCase("default")) {
            transformedResponse = response;
        } else {
            Matcher matcher = EXTRACT_FUNCTION_PATTERN.matcher(transformation);
            if (matcher.matches()) {
                matcher.reset();
                matcher.find();
                String transformationServiceName = matcher.group(1);
                String transformationServiceParam = matcher.group(2);
                try {
                    TransformationService transformationService = TransformationHelper
                            .getTransformationService(TCPActivator.getContext(), transformationServiceName);
                    if (transformationService != null) {
                        transformedResponse = transformationService.transform(transformationServiceParam, response);
                    } else {
                        transformedResponse = response;
                        logger.warn(
                                "couldn't transform response because transformationService of type '{}' is unavailable",
                                transformationServiceName);
                    }
                } catch (Exception te) {
                    logger.error("transformation throws exception [transformation={}, response={}]", transformation,
                            response, te);

                    // in case of an error we return the response without any
                    // transformation
                    transformedResponse = response;
                }
            } else {
                transformedResponse = transformation;
            }
        }

        logger.debug("transformed response is '{}'", transformedResponse);
protected String transformResponse(String transformation, String response) {
    protected String getName() {
        return "UDP Refresh Service";
    }

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 */
public class WMSClientServlet extends AbstractWxSServlet {

    /** maximum aantal elementen per cache. {@value} */
    private static final int NUMBER_CACHE_ELEMENTS = 1000;

    /** logger. */
    private static final Logger LOGGER = LoggerFactory
            .getLogger(WMSClientServlet.class);

    /**
     * vaste afmeting van de kaart (hoogte en breedte). {@value}
     * 
     * @see #MAP_DIMENSION_MIDDLE
     */
    private static final int MAP_DIMENSION = 440;

    /**
     * helft van de afmeting van de kaart (hoogte en breedte). {@value}
     * 
     * @see #MAP_DIMENSION
     */
    private static final int MAP_DIMENSION_MIDDLE = MAP_DIMENSION / 2;

    /** time-to-live voor cache elementen. {@value} */
    private static final long SECONDS_TO_CACHE_ELEMENTS = 60 * 60/* 1 uur */;

    /** time-to-live voor cache elementen. {@value} */
    private static final long MILLISECONDS_TO_CACHE_ELEMENTS = SECONDS_TO_CACHE_ELEMENTS * 1000;

    /** serialVersionUID. */
    private static final long serialVersionUID = 4958212343847516071L;

    /** De achtergrond kaart WMS. */
    private transient WebMapServer bgWMS = null;

    /** cache voor legenda afbeeldingen. */
    private transient Cache<String, CacheImage, BufferedImage> legendCache = null;

    /** cache voor voorgrond WMS afbeeldingen. */
    private transient Cache<BboxLayerCacheKey, CacheImage, BufferedImage> fgWMSCache = null;

    /** cache voor feature info. */
    private transient Cache<BboxLayerCacheKey, CachableString, String> featInfoCache = null;

    /** verzameling lagen voor de achtergrondkaart. */
    private String[] bgWMSlayers = null;

    /**
     * voorgrond wms request.
     * 
     * @todo refactor naar lokale variabele
     */
    private transient GetMapRequest getMapRequest = null;

    /** layers bean. */
    private final transient AvailableLayersBean layers = new AvailableLayersBean();

    /** cache voor achtergrond kaartjes. */
    private transient WMSCache bgWMSCache = null;
    /** De achtergrond luchtfoto WMS. */
    private transient WebMapServer lufoWMS = null;

    /** cache voor achtergrond kaartjes. */
    private transient WMSCache bgWMSLuFoCache = null;
    /** verzameling lagen voor de achtergrondkaart. */
    private String[] lufoWMSlayers = null;

    /**
     * de verzameling met (voorgrond) WMSsen die we benaderen. Het opstarten van
     * een WMS duurt lang vanwege de capabilities uitvraag en versie
     * onderhandeling.
     */
    private transient Map<String, WebMapServer> wmsServersCache = null;

    /*
     * (non-Javadoc)
     * 
     * @see javax.servlet.GenericServlet#destroy()
     */
    @Override
    public void destroy() {
        this.bgWMSCache.clear();
        this.bgWMS = null;
        this.bgWMSLuFoCache.clear();
        this.lufoWMS = null;
        this.wmsServersCache.clear();
        this.legendCache.clear();
        this.legendCache = null;
        this.fgWMSCache.clear();
        this.fgWMSCache = null;
        this.featInfoCache.clear();
        this.featInfoCache = null;
        this.getMapRequest = null;
        super.destroy();
    }

    /**
     * Achtergrondkaart ophalen en opslaan in de cache.
     * 
     * @param bbox
     *            the bbox
     * @param type
     *            the type
     * @return background/basemap image
     * @throws ServletException
     *             Geeft aan dat er een fout is opgetreden bij het benaderen van
     *             de achtergrondgrond WMS service
     */
    private BufferedImage getBackGroundMap(final BoundingBox bbox,
            final BasemapType type) throws ServletException {

        GetMapRequest map;
        switch (type) {
        case luchtfoto:
            if (this.bgWMSLuFoCache.containsKey(bbox)) {
                // ophalen uit cache
                LOGGER.debug("Achtergrond " + type
                        + " afbeelding uit de cache serveren.");
                return this.bgWMSLuFoCache.getImage(bbox);
            }
            map = this.lufoWMS.createGetMapRequest();
            if (this.lufoWMSlayers != null) {
                for (final String lyr : this.lufoWMSlayers) {
                    // per laag toevoegen met de default style
                    map.addLayer(lyr, "");
                }
            } else {
                // alle lagen toevoegen
                for (final Layer layer : WMSUtils.getNamedLayers(this.lufoWMS
                        .getCapabilities())) {
                    map.addLayer(layer);
                }
            }
            break;
        case topografie:
            // implicit fall thru naar default
        default:
            if (this.bgWMSCache.containsKey(bbox)) {
                // ophalen uit cache
                LOGGER.debug("Achtergrond " + type
                        + " afbeelding uit de cache serveren.");
                return this.bgWMSCache.getImage(bbox);
            }
            map = this.bgWMS.createGetMapRequest();
            if (this.bgWMSlayers != null) {
                for (final String lyr : this.bgWMSlayers) {
                    // per laag toevoegen met de default style
                    map.addLayer(lyr, "");
                }
            } else {
                // alle lagen toevoegen
                for (final Layer layer : WMSUtils.getNamedLayers(this.bgWMS
                        .getCapabilities())) {
                    map.addLayer(layer);
                }
            }
        }

        map.setFormat("image/png");
        map.setDimensions(MAP_DIMENSION, MAP_DIMENSION);
        map.setTransparent(true);
        map.setBGColour("0xffffff");
        map.setExceptions("application/vnd.ogc.se_inimage");
        map.setSRS("EPSG:28992");
        map.setBBox(bbox);

        LOGGER.debug("Achtergrond WMS url is: " + map.getFinalURL());

        try {
            final GetMapResponse response = this.bgWMS.issueRequest(map);
            final BufferedImage image = ImageIO.read(response.getInputStream());
            switch (type) {
            case luchtfoto:
                this.bgWMSLuFoCache.put(bbox, image, SECONDS_TO_CACHE_ELEMENTS);

                break;
            case topografie:
            default:
                this.bgWMSCache.put(bbox, image, SECONDS_TO_CACHE_ELEMENTS);
                break;
            }

            if (LOGGER.isDebugEnabled()) {
                // achtergrond plaatje bewaren in debug modus
                final File temp = File.createTempFile(
                        "bgwms",
                        ".png",
                        new File(this.getServletContext().getRealPath(
                                MAP_CACHE_DIR.code)));
                temp.deleteOnExit();
                ImageIO.write(image, "png", temp);
            }

            return image;
        } catch (ServiceException | IOException e) {
            LOGGER.error(
                    "Er is een fout opgetreden bij het benaderen van de achtergrond WMS service.",
                    e);
            throw new ServletException(e);
        }

    }

    /**
     * zoekt of maakt de gevraagde WebMapServer.
     * 
     * @param lyrDesc
     *            de layerdescriptor met de WMS informatie
     * @return the cached wms
     * @throws ServiceException
     *             the service exception
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    private WebMapServer getCachedWMS(final LayerDescriptor lyrDesc)
            throws ServiceException, IOException {
        if (this.wmsServersCache.containsKey(lyrDesc.getUrl())) {
            LOGGER.debug("WMS gevonden in cache.");
            return this.wmsServersCache.get(lyrDesc.getUrl());
        } else {
            LOGGER.debug("Aanmaken van nieuwe WMS (inclusief versie onderhandeling).");
            final WebMapServer fgWMS = new WebMapServer(new URL(
                    lyrDesc.getUrl()));
            this.wmsServersCache.put(lyrDesc.getUrl(), fgWMS);
            return fgWMS;
        }
    }

    /**
     * Haalt de feature info op.
     * 
     * @param bbox
     *            the bbox
     * @param lyrDesc
     *            de layerdescriptor met de WMS informatie
     * @return Een string met feature info
     * @throws ServiceException
     *             Geeft aan dat er een fout is opgetreden tijden het benaderen
     *             van de WMS
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    private String getFeatureInfo(final BoundingBox bbox,
            final LayerDescriptor lyrDesc) throws ServiceException, IOException {
        final BboxLayerCacheKey key = new BboxLayerCacheKey(bbox, lyrDesc);
        if (this.featInfoCache.containsKey(key)) {
            LOGGER.debug("FeatureInfo uit de cache serveren.");
            // ophalen uit cache
            return this.featInfoCache.get(key).getItem();
        }

        try {
            final GetFeatureInfoRequest getFeatureInfoRequest = this
                    .getCachedWMS(lyrDesc).createGetFeatureInfoRequest(
                            this.getMapRequest);

            final String[] layerNames = lyrDesc.getLayers().split(",\\s*");
            final Set<Layer> queryLayers = new HashSet<Layer>();
            final WMSCapabilities caps = this.getCachedWMS(lyrDesc)
                    .getCapabilities();

            for (final Layer wmsLyr : caps.getLayerList()) {
                if ((wmsLyr.getName() != null)
                        && (wmsLyr.getName().length() != 0)) {
                    for (final String layerName : layerNames) {
                        if (wmsLyr.getName().equalsIgnoreCase(layerName)) {
                            queryLayers.add(wmsLyr);
                        }
                    }
                }
            }
            getFeatureInfoRequest.setQueryLayers(queryLayers);
            getFeatureInfoRequest.setInfoFormat("application/vnd.ogc.gml");
            getFeatureInfoRequest.setFeatureCount(10);
            getFeatureInfoRequest.setQueryPoint(MAP_DIMENSION_MIDDLE,
                    MAP_DIMENSION_MIDDLE);
            LOGGER.debug("WMS feature info request url is: "
                    + getFeatureInfoRequest.getFinalURL());
            final GetFeatureInfoResponse response = this.getCachedWMS(lyrDesc)
                    .issueRequest(getFeatureInfoRequest);

            final String html = FeatureInfoResponseConverter
                    .convertToHTMLTable(response.getInputStream(),
                            FeatureInfoResponseConverter.Type.GMLTYPE, lyrDesc
                                    .getAttributes().split(",\\s*"));
            this.featInfoCache.put(key,
                    new CachableString(html, System.currentTimeMillis()
                            + MILLISECONDS_TO_CACHE_ELEMENTS));
            return html;

        } catch (final UnsupportedOperationException u) {
            LOGGER.warn("De WMS server ("
                    + this.getCachedWMS(lyrDesc).getInfo().getTitle()
                    + ") ondersteund geen GetFeatureInfoRequest.", u);
            return "";
        }
    }

    /**
     * voorgrondkaart ophalen.
     * 
     * @param bbox
     *            the bbox
     * @param lyrDesc
     *            de layerdescriptor met de WMS informatie
     * @return voorgrond afbeelding
     * @throws ServletException
     *             Geeft aan dat er een fout is opgetreden bij het benaderen van
     *             de voorgrond WMS service
     */
    private BufferedImage getForeGroundMap(final BoundingBox bbox,
            final LayerDescriptor lyrDesc) throws ServletException {

        final BboxLayerCacheKey key = new BboxLayerCacheKey(bbox, lyrDesc);
        if (this.fgWMSCache.containsKey(key)) {
            // ophalen uit cache
            LOGGER.debug("Voorgrond afbeelding uit de cache serveren.");
            return this.fgWMSCache.get(key).getImage();
        }

        // wms request doen
        try {
            this.getMapRequest = this.getCachedWMS(lyrDesc)
                    .createGetMapRequest();
            final String[] layerNames = lyrDesc.getLayers().split(",\\s*");
            final String[] styleNames = lyrDesc.getStyles().split(",\\s*");

            for (int l = 0; l < layerNames.length; l++) {
                this.getMapRequest.addLayer(layerNames[l], styleNames[l]);
            }
            this.getMapRequest.setFormat("image/png");
            this.getMapRequest.setDimensions(MAP_DIMENSION, MAP_DIMENSION);
            this.getMapRequest.setTransparent(true);
            this.getMapRequest.setSRS("EPSG:28992");
            this.getMapRequest.setBBox(bbox);
            this.getMapRequest.setExceptions("application/vnd.ogc.se_inimage");
            this.getMapRequest.setBGColour("0xffffff");
            LOGGER.debug("Voorgrond WMS url is: "
                    + this.getMapRequest.getFinalURL());

            // thema/voorgrond ophalen
            final GetMapResponse response = this.getCachedWMS(lyrDesc)
                    .issueRequest(this.getMapRequest);
            final BufferedImage image = ImageIO.read(response.getInputStream());

            this.fgWMSCache.put(key, new CacheImage(image,
                    SECONDS_TO_CACHE_ELEMENTS));

            if (LOGGER.isDebugEnabled()) {
                // voorgrond plaatje bewaren in debug modus
                final File temp = File.createTempFile(
                        "fgwms",
                        ".png",
                        new File(this.getServletContext().getRealPath(
                                MAP_CACHE_DIR.code)));
                temp.deleteOnExit();
                ImageIO.write(image, "png", temp);
            }
            return image;
        } catch (ServiceException | IOException e) {
            LOGGER.error(
                    "Er is een fout opgetreden bij het benaderen van de achtergrond WMS service.",
                    e);
            throw new ServletException(e);
        }
    }

    /**
     * Haalt de legenda op voor de thema laag.
     * 
     * @param lyrDesc
     *            de layerdescriptor met de WMS informatie
     * @return een array met legenda afbeeldings bestanden
     * @throws ServiceException
     *             Geeft aan dat er een fout is opgetreden tijden het benaderen
     *             van de WMS
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    private File[] getLegends(final LayerDescriptor lyrDesc)
            throws ServiceException, IOException {

        final String[] layerNames = lyrDesc.getLayers().split(",\\s*");
        final String[] styleNames = lyrDesc.getStyles().split(",\\s*");

        final File[] legends = new File[layerNames.length];
        try {
            final GetLegendGraphicRequest legend = this.getCachedWMS(lyrDesc)
                    .createGetLegendGraphicRequest();
            BufferedImage image;
            for (int l = 0; l < layerNames.length; l++) {
                final String key = layerNames[l] + "::" + styleNames[l];
                if (this.legendCache.containsKey(key)) {
                    // in de cache kijken of we deze legenda afbeelding al
                    // hebben
                    legends[l] = new File(this.legendCache.get(key).getName());
                    if (!legends[l].exists()) {
                        // (mogelijk) is het bestand gewist..
                        ImageIO.write(this.legendCache.get(key).getImage(),
                                "png", legends[l]);
                    }
                    LOGGER.debug("Legenda bestand uit cache: "
                            + legends[l].getAbsolutePath());
                } else {
                    // legenda opvragen
                    legend.setLayer(layerNames[l]);
                    legend.setStyle(styleNames[l]);
                    legend.setFormat("image/png");
                    legend.setExceptions("application/vnd.ogc.se_inimage");

                    LOGGER.debug("Voorgrond WMS legenda url is: "
                            + legend.getFinalURL());
                    final GetLegendGraphicResponse response = this
                            .getCachedWMS(lyrDesc).issueRequest(legend);
                    image = ImageIO.read(response.getInputStream());
                    legends[l] = File.createTempFile(
                            "legenda",
                            ".png",
                            new File(this.getServletContext().getRealPath(
                                    MAP_CACHE_DIR.code)));
                    legends[l].deleteOnExit();
                    this.legendCache
                            .put(key,
                                    new CacheImage(
                                            image,
                                            legends[l].getAbsolutePath(),
                                            System.currentTimeMillis()
                                                    + (MILLISECONDS_TO_CACHE_ELEMENTS * 24)));
                    LOGGER.debug("Legenda bestand: "
                            + legends[l].getAbsolutePath());
                    ImageIO.write(image, "png", legends[l]);
                }
            }
        } catch (final UnsupportedOperationException u) {
            LOGGER.warn("De WMS server ("
                    + this.getCachedWMS(lyrDesc).getInfo().getTitle()
                    + ") ondersteund geen GetLegendGraphicRequest.", u);
            return null;
        }
        return legends;
    }

    /**
     * kaart maken op basis van de opgehaalde afbeeldingen.
     * 
     * @param imageVoorgrond
     *            de voorgrondkaart
     * @param imageAchtergrond
     *            de achtergrondgrondkaart
     * @return de file met de afbeelding
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    private File getMap(final BufferedImage imageVoorgrond,
            final BufferedImage imageAchtergrond) throws IOException {

        final BufferedImage composite = new BufferedImage(MAP_DIMENSION,
                MAP_DIMENSION, BufferedImage.TYPE_INT_ARGB);
        final Graphics2D g = composite.createGraphics();

        g.drawImage(imageAchtergrond, 0, 0, null);
        if (imageVoorgrond != null) {
            final float[] scales = { 1f, 1f, 1f, 0.8f };
            final RescaleOp rop = new RescaleOp(scales, new float[4], null);
            g.drawImage(imageVoorgrond, rop, 0, 0);
            // zoeklocatie intekenen met plaatje
            final BufferedImage infoImage = ImageIO.read(new File(this
                    .getClass().getClassLoader().getResource("info.png")
                    .getFile()));
            // CHECKSTYLE.OFF: MagicNumber - dit zijn midden en hoogte van het
            // plaatje "info.png"
            g.drawImage(infoImage, MAP_DIMENSION_MIDDLE - 16,
                    MAP_DIMENSION_MIDDLE - 37, null);
            // CHECKSTYLE.ON: MagicNumber
        }
        // opslaan van plaatje zodat de browser het op kan halen
        final File kaartAfbeelding = File.createTempFile(
                "wmscombined",
                ".png",
                new File(this.getServletContext().getRealPath(
                        MAP_CACHE_DIR.code)));
        kaartAfbeelding.deleteOnExit();
        ImageIO.write(composite, "png", kaartAfbeelding);
        g.dispose();
        return kaartAfbeelding;
    }

    /*
     * (non-Javadoc)
     * 
     * @see
     * nl.mineleni.cbsviewer.servlet.AbstractBaseServlet#init(javax.servlet.
     * ServletConfig)
     */
    @Override
    public void init(final ServletConfig config) throws ServletException {
        super.init(config);
        try {
            this.bgWMSCache = new WMSCache(this.getServletContext()
                    .getRealPath(MAP_CACHE_DIR.code), NUMBER_CACHE_ELEMENTS);
        } catch (final IOException e) {
            LOGGER.error(
                    "Inititalisatie fout voor de achtergrond topografie cache.",
                    e);
        }

        try {
            this.bgWMSLuFoCache = new WMSCache(this.getServletContext()
                    .getRealPath(MAP_CACHE_DIR.code), NUMBER_CACHE_ELEMENTS);
        } catch (final IOException e) {
            LOGGER.error(
                    "Inititalisatie fout voor de achtergrond luchtfoto cache.",
                    e);
        }

        this.legendCache = new Cache<String, CacheImage, BufferedImage>(
                NUMBER_CACHE_ELEMENTS);

        this.featInfoCache = new Cache<BboxLayerCacheKey, CachableString, String>(
                NUMBER_CACHE_ELEMENTS);

        this.fgWMSCache = new Cache<BboxLayerCacheKey, CacheImage, BufferedImage>(
                NUMBER_CACHE_ELEMENTS);

        // achtergrond kaart
        final String bgCapabilitiesURL = config
                .getInitParameter("bgCapabilitiesURL");
        LOGGER.debug("WMS capabilities url van achtergrond kaart: "
                + bgCapabilitiesURL);
        try {
            this.bgWMS = new WebMapServer(new URL(bgCapabilitiesURL));
        } catch (final MalformedURLException e) {
            LOGGER.error(
                    "Een url die gebruikt wordt voor de topografie WMS capabilities is misvormd",
                    e);
            throw new ServletException(e);
        } catch (final ServiceException e) {
            LOGGER.error(
                    "Er is een service exception (WMS server fout) opgetreden bij het ophalen van de topografie WMS capabilities",
                    e);
            throw new ServletException(e);
        } catch (final IOException e) {
            LOGGER.error(
                    "Er is een I/O fout opgetreden bij benaderen van de topografie WMS services",
                    e);
            throw new ServletException(e);
        }
        final String bgWMSlyrs = config.getInitParameter("bgWMSlayers");
        LOGGER.debug("Achtergrond kaartlagen topografie: " + bgWMSlyrs);
        if ((bgWMSlyrs != null) && (bgWMSlyrs.length() > 0)) {
            this.bgWMSlayers = bgWMSlyrs.split("[,]\\s*");
        }

        // achtergrond luchtfoto
        final String lufoCapabilitiesURL = config
                .getInitParameter("lufoCapabilitiesURL");
        LOGGER.debug("WMS capabilities url van achtergrond luchtfoto: "
                + lufoCapabilitiesURL);
        try {
            this.lufoWMS = new WebMapServer(new URL(lufoCapabilitiesURL));
        } catch (final MalformedURLException e) {
            LOGGER.error(
                    "De url die gebruikt wordt voor de luchtfoto WMS capabilities is misvormd",
                    e);
            throw new ServletException(e);
        } catch (final ServiceException e) {
            LOGGER.error(
                    "Er is een service exception (WMS server fout) opgetreden bij het ophalen van de luchtfoto WMS capabilities",
                    e);
            throw new ServletException(e);
        } catch (final IOException e) {
            LOGGER.error(
                    "Er is een I/O fout opgetreden bij benaderen van de luchtfoto WMS services",
                    e);
            throw new ServletException(e);
        }
        final String lufoWMSlyrs = config.getInitParameter("lufoWMSlayers");
        LOGGER.debug("Achtergrond kaartlagen luchtfoto: " + lufoWMSlyrs);
        if ((lufoWMSlyrs != null) && (lufoWMSlyrs.length() > 0)) {
            this.lufoWMSlayers = lufoWMSlyrs.split("[,]\\s*");
        }

        // init servers cache
        this.wmsServersCache = new ConcurrentHashMap<String, WebMapServer>();
    }

    /*
     * (non-Javadoc)
     * 
     * @see javax.servlet.http.HttpServlet#service(javax.servlet.ServletRequest,
     * javax.servlet.ServletResponse)
     */
    @Override
    protected void service(final HttpServletRequest request,
            final HttpServletResponse response) throws ServletException,
            IOException {

        final int[] dXcoordYCoordStraal = this.parseLocation(request);
        final int xcoord = dXcoordYCoordStraal[0];
        final int ycoord = dXcoordYCoordStraal[1];
        final int straal = dXcoordYCoordStraal[2];
        final BoundingBox bbox = SpatialUtil.calcRDBBOX(xcoord, ycoord, straal);

        BasemapType basemaptype = BasemapType.topografie;
        final String mType = request.getParameter(REQ_PARAM_BGMAP.code);
        if (this.isNotNullNotEmptyNotWhiteSpaceOnly(mType)) {
            try {
                basemaptype = BasemapType.valueOf(mType);
            } catch (final IllegalArgumentException e) {
                LOGGER.debug("Ongeldige waarde gebruikt voor basemap type, de default wordt gebruikt.");
            }
        }
        final BufferedImage bg = this.getBackGroundMap(bbox, basemaptype);

        BufferedImage fg = null;
        final String mapId = request.getParameter(REQ_PARAM_MAPID.code);
        if (this.isNotNullNotEmptyNotWhiteSpaceOnly(mapId)) {
            final LayerDescriptor layer = this.layers.getLayerByID(mapId);
            request.setAttribute("mapname", layer.getName());
            LOGGER.debug("LayerDescriptor::Name is: " + layer.getName());

            final String fgCapabilitiesURL = layer.getUrl();
            LOGGER.debug("WMS capabilities url van voorgrond kaart: "
                    + fgCapabilitiesURL);
            try {
                fg = this.getForeGroundMap(bbox, layer);
                final File[] legendas = this.getLegends(layer);
                final String fInfo = this.getFeatureInfo(bbox, layer);
                request.setAttribute(REQ_PARAM_MAPID.code, mapId);
                request.setAttribute(REQ_PARAM_LEGENDAS.code, legendas);
                request.setAttribute(REQ_PARAM_FEATUREINFO.code, fInfo);
            } catch (final ServiceException e) {
                LOGGER.error(
                        "Er is een service exception opgetreden bij benaderen van de voorgrond WMS",
                        e);
                throw new ServletException(e);
            } catch (final MalformedURLException e) {
                LOGGER.error(
                        "De url die gebruikt wordt voor de WMS capabilities is misvormd.",
                        e);
                throw new ServletException(e);
            }
        }

        final File kaart = this.getMap(fg, bg);

        request.setAttribute(REQ_PARAM_CACHEDIR.code, MAP_CACHE_DIR.code);
        request.setAttribute(REQ_PARAM_KAART.code, kaart);
        request.setAttribute(REQ_PARAM_BGMAP.code, basemaptype);
    }
}
import org.slf4j.LoggerFactory;

/**
 * De Class Cache.
 * 
 * @param <K>
 *            het key type
 * @param <V>
 *            het value type
 * @param <T>
 *            het generic type
 * @author prinsmc
 */
public class Cache<K, V extends Cachable<T>, T> implements Caching<K, V, T> {
public V get(final K key) {

		final long timestamp = entry.getExpireBy();
		if ((timestamp != -1) && (System.currentTimeMillis() > timestamp)) {
			this.remove(key);
			return null;
		}
public void put(final K key, final V cacheValue) {
				this.remove(this.queue.poll());
			}
		}
		this.cache.put(key, cacheValue);
		this.queue.add(key);
	}
public int queueSize() {
	public void remove(final K key) {
		final V entry = this.cache.get(key);
		if (entry != null) {
			this.cacheSize.decrementAndGet();
			this.cache.remove(key);
		}
	 * 
	 * @param bbox
	 *            de sleutel
	 * @return de waarde, of {@code null}
	 */
	V get(K bbox);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
else if (dir.exists() && !dir.canWrite()) {
        // sufficient privileges to write
        try {
            runner = new ReadTransfer(this.getAddress(), filename, path);
            runner.addTransferListener(this);

            if (runner.sendRequest()){
                performTransfer(runner);
            }
        } catch (Exception e){
else if (!file.canRead()) {
        try {
            runner = new WriteTransfer(this.getAddress(), appendPrefix(filename), filename);
            System.out.println("Client Filename: " + appendPrefix(filename));
            runner.addTransferListener(this);

            if (runner.sendRequest()){
                performTransfer(runner);
            }
        } catch (Exception e){
    /**
	 * Timeout time for the socket in ms
	 */
    private static final int TIMEOUT_TIME = 2400;

    /**
     * Default number of attempts to retry sending and receiving after timeouts
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public static ExecutorConfig create(
            @JsonProperty("container_path") String containerPath)
            throws URISyntaxException, UnsupportedEncodingException {

        ExecutorConfig config = create(
                command,
                arguments,
public static ExecutorConfig create(
                URI.create(jreLocation),
                URI.create(executorLocation),
                URI.create(cassandraLocation),
                URI.create(dvdcli),
                volumeDriver,
                volumeName,
                hostPath,
public String getCassandraLocationString() {

    @JsonProperty("dvdcli")
    public String getDvdcliString() {
        return dvdcli.toString();
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void setGesture(final Gesture gesture) {

    @Override
    public boolean equals(final Object obj) {
        Player player = (Player) obj;
        return player.getIsHuman() == getIsHuman()
                && player.getGesture().getName().equals(getGesture().getName());
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
protected void addTreeItemsToRoot(List<RepoFile> repoFiles, TreeItem<RepoFile> r
        // Loop through files at each depth
        for(int i = 0; i < maxDepth + 1; i++) {
            List<RepoFile> filesAtDepth = filesAtDepthMap.get(i);
            for (RepoFile repoFile : filesAtDepth) {
                Path pathToFile = repoFile.getFilePath();

                // Check if there is already a record of this file
                if (itemMap.containsKey(pathToFile)) {
                    TreeItem<RepoFile> oldItem = itemMap.get(pathToFile);

                    if (oldItem.getValue().equals(repoFile)) {
                        // The given file is already present, no additional processing needed
                        itemsToRemove.remove(oldItem);
                    } else {
                        // The file is displayed, but needs its status updated. Replace the old with the new
                        TreeItem<RepoFile> newItem = new TreeItem<>(repoFile, repoFile.diffButton);

                        TreeItem<RepoFile> parent = oldItem.getParent();

                        Platform.runLater(() -> {
                            newItem.setExpanded(oldItem.isExpanded());
                            newItem.getChildren().setAll(oldItem.getChildren());
                            parent.getChildren().set(parent.getChildren().indexOf(oldItem), newItem);
                        });

                        itemsToRemove.remove(oldItem);
                        itemMap.put(pathToFile, newItem);
                    }
                } else {
                    // The given file wasn't present, so need to add it
                    TreeItem<RepoFile> newItem = new TreeItem<>(repoFile, repoFile.diffButton);

                    Path pathToParent = pathToFile.getParent();
                    boolean foundParent = false;
                    // Make sure this new item is properly inserted as a child to its parent
                    while (pathToParent != null && !root.getValue().getFilePath().equals(pathToParent)) {
                        if (itemMap.containsKey(pathToParent)) {
                            TreeItem<RepoFile> parent = itemMap.get(pathToParent);
                            Platform.runLater(() -> parent.getChildren().add(newItem));
                            foundParent = true;
                            break;
                        }
                        pathToParent = pathToParent.getParent();
                    }
                    // If no parent is found, we can assume it belongs to the root
                    if (!foundParent){
                        Platform.runLater(() -> root.getChildren().add(newItem));
                    }
                    itemMap.put(pathToFile, newItem);
                    itemsToRemove.remove(newItem);
                }
            }
        }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void processChooserResponse(Intent intent) {
    public QuestionWidget getPendingWidget() {
        FormIndex pendingIndex = mFormController.getPendingCalloutFormIndex();
        if (pendingIndex == null) {
            return null;
        }
        for (QuestionWidget q : ((ODKView)mCurrentView).getWidgets()) {
            if (q.getFormId().equals(pendingIndex)) {
                return q;
            }
        }
        return null;
    }

import java.io.IOException;

public class ImageCaptureProcessing {
    /**
     * Performs any necessary relocating and scaling of an image coming from either a
     * SignatureWidget or ImageWidget (capture or choose)
public static File moveAndScaleImage(File originalImage, boolean shouldScale,
        // TODO PLM: this scale flag should be decoupled such that getPendingWidget doesn't need to be called
        if (shouldScale) {
            ImageWidget currentWidget = (ImageWidget)formEntryActivity.getPendingWidget();
            int maxDimen = currentWidget.getMaxDimen();
            if (maxDimen != -1) {
                savedScaledImage = FileUtils.scaleAndSaveImage(originalImage, finalFilePath, maxDimen);
            }
        }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public String toString() {
     */
    @Override
    public int hashCode() {
        return Objects.hashCode(id, domain.getId(), description, name, links, parentId, subtree, parents);
    }

    /**
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void mousePressed(MouseEvent e) {

    private void saveCurrentSelectedStack() {
        current_planet_ptr = game.getCurrentPlanetNr();
        selected_point_ptr = new Point(game.getSelectedPoint()); // fix #105
        selected_faction_ptr = new Point(game.getSelectedFaction());
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.util.Objects;
import rhsu.board.Direction;
import rhsu.board.io.BoardIO;
import rhsu.board2.BoardPiece2;
import rhsu.board2.BoardPieceImpl;

public class CompositeBoardImpl<T> implements CompositeBoard<T>
{
		BigDecimal defaultValue)
	{	
		return new BoardBuilder()
			.setDefaulValue(defaultValue)
			.createBoard();
	}
		BigInteger defaultValue)
	{
		return new BoardBuilder()
			.setDefaulValue(defaultValue)
			.createBoard();
	}
		Boolean defaultValue)
	{
		return new BoardBuilder()
			.setDefaulValue(DEFAULT_VALUE)
			.createBoard();
	}
		Double defaultValue)
	{
		return new BoardBuilder()
			.setDefaulValue(defaultValue)
			.createBoard();
	}
		Integer defaultValue)
	{
		return new BoardBuilder()
			.setDefaulValue(defaultValue)
			.createBoard();
	}
		String defaultValue)
	{
		return new BoardBuilder()
			.setDefaulValue(defaultValue)
			.createBoard();
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

### 1.4.4
- Fixed Disk Manipulator crashing due to empty stack (raoulvdberge)

### 1.4.3
- Updated Forge to 2282 (raoulvdberge)
public void detectChanges(INetworkMaster network) {

            // If we exceed the cache size, than that means this items is added
            if (i >= cache.size()) {
                if (actual != null) {
                    network.getItemStorageCache().add(actual, actual.getCount(), false);
                }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
package org.molgenis.data.importer.emx;

import com.google.common.collect.ImmutableCollection;
import com.google.common.collect.Iterables;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.molgenis.data.meta.model.*;
import org.molgenis.data.meta.model.Package;
import org.molgenis.data.support.QueryImpl;
import org.molgenis.data.validation.MolgenisValidationException;
import org.molgenis.security.core.MolgenisPermissionService;
import org.molgenis.security.core.Permission;
import java.util.*;
import java.util.function.Function;

import static com.google.common.collect.Lists.newArrayList;
import static java.lang.String.format;
import static java.util.Collections.emptyList;
import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.toMap;
import static java.util.stream.StreamSupport.stream;
import static org.molgenis.data.EntityManager.CreationMode.POPULATE;
import static org.molgenis.data.i18n.model.I18nStringMetaData.I18N_STRING;
public EntityImportReport doImport(EmxImportJob job)
		{
			importTags(job.parsedMetaData);
			importPackages(job.parsedMetaData);
			addEntityType(job.parsedMetaData, job.report);
		});
		addEntityPermissions(job.metaDataChanges);
		List<EntityType> resolvedEntityTypes = entityTypeDependencyResolver.resolve(job.parsedMetaData.getEntities());
		importData(job.report, resolvedEntityTypes, job.source, job.dbAction, job.defaultPackage);
		importI18nStrings(job.report, job.parsedMetaData.getI18nStrings(), job.dbAction);

		return job.report;
	}

	private void importLanguages(EntityImportReport report, Map<String, Language> languages, DatabaseAction dbAction,
			MetaDataChanges metaDataChanges)
	{
private Entity toEntity(EntityType entityType, Entity emxEntity)
		return entity;
	}

	/**
	 * Gives the user permission to see and edit his imported entities, unless the user is admin since admins can do
	 * that anyways.
	 */
	private void addEntityPermissions(MetaDataChanges metaDataChanges)
	{
		if (!SecurityUtils.currentUserIsSu())
		{
			permissionSystemService
					.giveUserEntityPermissions(SecurityContextHolder.getContext(), metaDataChanges.getAddedEntities());
		}
	}

	/**
	 * Adds the parsed {@link ParsedMetaData}, creating new repositories where necessary.
	 *
	 * @param parsedMetaData meta data from import source
	 * @param report         import report
	 */
	private void addEntityType(ParsedMetaData parsedMetaData, EntityImportReport report)
	{
		Collection<EntityType> entityTypes = parsedMetaData.getEntities();

		// retrieve existing entity types
		Fetch entityTypeFetch = new Fetch().field(EntityTypeMetadata.FULL_NAME).field(EntityTypeMetadata.ATTRIBUTES,
				new Fetch().field(AttributeMetadata.ID).field(AttributeMetadata.NAME));

		Map<String, EntityType> existingEntityTypeMap = dataService
				.findAll(ENTITY_TYPE_META_DATA, entityTypes.stream().map(EntityType::getName), entityTypeFetch,
						EntityType.class).collect(toMap(EntityType::getName, Function.identity()));

		// inject attribute identifiers in entity types to import
		entityTypes.forEach(entityType ->
		{
			EntityType existingEntityType = existingEntityTypeMap.get(entityType.getName());
			if (existingEntityType != null)
			{
				entityType.getOwnAllAttributes().forEach(ownAttr ->
				{
					Attribute existingAttr = existingEntityType.getAttribute(ownAttr.getName());
					if (existingAttr != null)
					{
						ownAttr.setIdentifier(existingAttr.getIdentifier());
					}
				});
			}
		});

		// add or update entity types
		dataService.getMeta().upsertEntityTypes(entityTypes);

		// add new entities to import report
		entityTypes.forEach(entityType ->
		{
			String entityTypeName = entityType.getName();
			if (!existingEntityTypeMap.containsKey(entityTypeName))
			{
				report.addNewEntity(entityTypeName);
			}
		});
	}

	/**
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
android {
        applicationId "org.mythtv.android"
        minSdkVersion 14
        targetSdkVersion 22
        versionCode 12
        versionName "1.1.9"
        archivesBaseName = applicationId + "-" + versionName
    }

protected void onCreate( Bundle savedInstanceState ) {
            URL url = new URL( MainApplication.getInstance().getMasterBackendUrl() + mFileUrl.substring( 1 ) );
            URI uri = new URI( url.getProtocol(), url.getUserInfo(), url.getHost(), url.getPort(), url.getPath(), url.getQuery(), url.getRef() );
            fileUri = Uri.parse( uri.toString() );

        } catch( MalformedURLException | URISyntaxException e ) {
            Log.v( TAG, "onCreate : error parsing mFileUrl=" + mFileUrl );
        }
        Log.v( TAG, "onCreate : fileUrl=" + fileUri.toString() );

        mVideoView =  (VideoView) findViewById( R.id.videoView );
        mVideoView.setVideoURI(fileUri);
protected void onCreate( Bundle savedInstanceState ) {
            URL url = new URL( MainApplication.getInstance().getMasterBackendUrl() + mFileUrl.substring( 1 ) );
            URI uri = new URI( url.getProtocol(), url.getUserInfo(), url.getHost(), url.getPort(), url.getPath(), url.getQuery(), url.getRef() );
            fileUri = Uri.parse(uri.toString());

        } catch( MalformedURLException | URISyntaxException e ) {
            Log.v( TAG, "onCreate : error parsing mFileUrl=" + mFileUrl );
        }
        Log.v( TAG, "onCreate : fileUrl=" + fileUri.toString() );

        mVideoView =  (VideoView) findViewById( R.id.videoView );
        mVideoView.setVideoURI(fileUri);

        MediaController mMediaController = new MediaController( this );
        mMediaController.setAnchorView( mVideoView );
private void startVideoPlayerHls() {
                URL url = new URL( MainApplication.getInstance().getMasterBackendUrl() + mFileUrl.substring( 1 ) );
                URI uri = new URI( url.getProtocol(), url.getUserInfo(), url.getHost(), url.getPort(), url.getPath(), url.getQuery(), url.getRef() );
                fileUri = Uri.parse( uri.toString() );

            } catch( MalformedURLException | URISyntaxException e ) {
                Log.v( TAG, "onCreate : error parsing mFileUrl=" + mFileUrl );
            }
            Log.v(TAG, "startVideoPlayerHls : fileUrl=" + fileUri.toString());

            mVideoView.setVideoURI( fileUri );

            if (mShouldStartPlayback) {
                mPlaybackState = PlaybackState.PLAYING;
private void startVideoPlayerHls() {
                URL url = new URL( MainApplication.getInstance().getMasterBackendUrl() + mFileUrl.substring( 1 ) );
                URI uri = new URI( url.getProtocol(), url.getUserInfo(), url.getHost(), url.getPort(), url.getPath(), url.getQuery(), url.getRef() );
                fileUri = Uri.parse( uri.toString() );

            } catch( MalformedURLException | URISyntaxException e ) {
                Log.v( TAG, "onCreate : error parsing mFileUrl=" + mFileUrl );
            }
            Log.v(TAG, "startVideoPlayerHls : fileUrl=" + fileUri.toString());

            mVideoView.setVideoURI( fileUri );

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private static boolean containsOnlyLegalCharacters(String databaseName) {
     * @exclude
     */
    @InterfaceAudience.Private
    private void upgradeOldDatabaseFiles(File directory) {
        File[] files = directory.listFiles(new FilenameFilter() {
            @Override
            public boolean accept(File file, String name) {
                return name.endsWith(kV1DBExtension);
            }
        });

        for (File file : files) {
            String filename = file.getName();
            String name = nameOfDatabaseAtPath(filename);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public JsonNode getBodyJson() {
                continue;
            ObjectNode seqNode = JsonNodeFactory.instance.objectNode();
            seqNode.set("seq", JsonNodeFactory.instance.numberNode(reqs.size()));
            seqNode.set("op", JsonNodeFactory.instance.textNode(req.getOperation().name().toLowerCase()));
            ObjectNode request = (ObjectNode) req.getBodyJson();
            if (request != null) {
                request.set("entity", JsonNodeFactory.instance.textNode(req.getEntityName()));
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void actionPerformed(ActionEvent event) {
      public void actionPerformed(ActionEvent event) {
        if (acceptingNextCommand) {
          int caretPosition = textField.getCaretPosition();
          textField.setText(textField.getText().substring(caretPosition));
          textField.setCaretPosition(0);
        }
      }
    });
public void actionPerformed(ActionEvent event) {
      public void actionPerformed(ActionEvent event) {
        if (acceptingNextCommand) {
          int caretPosition = textField.getCaretPosition();
          textField.setText(textField.getText().substring(0, caretPosition));
        }
      }
    });
public void actionPerformed(ActionEvent event) {
      public void actionPerformed(ActionEvent event) {
        if (acceptingNextCommand) {
          String text = textField.getText();
          boolean gotToken = false;
          int caretPosition = textField.getCaretPosition();
          for (int i = caretPosition - 1; i >= 0; i--) {
package org.mafagafogigante.dungeon.schema.rules;

import com.eclipsesource.json.JsonValue;

import java.util.HashSet;
import java.util.Set;

  private final Set<String> enumValues = new HashSet<>();

  EnumJsonRule(Class<T> enumClass) {
    for (Enum<T> enumConstant : enumClass.getEnumConstants()) {
      enumValues.add(enumConstant.toString());
    }
  }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void widgetDefaultSelected(SelectionEvent arg0) {

		@Override
		public void widgetSelected(SelectionEvent arg0) {
			browseFonts.open();

			String[] files = browseFonts.getFileNames();

			for (int i = 0; i < files.length; i++) {
				files[i] = browseFonts.getFilterPath() + File.separator + files[i];
			}

			view.appendFonts(files);

		}

public void keyPressed(KeyEvent e) {
			if (e.keyCode == SWT.DEL)
				view.deleteSelectedFonts();

		}

		@Override
else if (!new File(this.sub.getText()).exists()) {
	}

	/**
	 * Deletes all the fonts that are selected in the list
	 */
	public void deleteSelectedFonts() {
public void run() {

						close();
					}
					else {
						message = new MessageBox(getShell(), SWT.ICON_ERROR);
						message.setText("Error");
public void run() {
				if (!CustomWindow.isConnected(true))
					return;

				createJobRunning = true;

				try {
public void run() {
					setChanged();
					notifyObservers("create" + CustomWindow.NOTIFICATION_SEPARATOR + response);

					// after the job is created, start a new search in order to update the job list
					findJobs();

					ActivityLogger.logActivity(this.getClass().getName(), "Create job");

				}
public void run() {
				finally {
					createJobRunning = false;

				}
			}
		}
public void run() {
				if (!CustomWindow.isConnected(true))
					return;

				endJobRunning = true;

				try {
public void run() {
				if (!CustomWindow.isConnected(false))
					return;

				boolean mayRun = !findJobsRunning && !acceptJobRunning && !endJobRunning && !createJobRunning
						&& !cancelJobRunning && !pushJobRunning;

				// wait for other threads to complete
				while (!mayRun) {
					try {
						Thread.sleep(100);
					}
					catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}

				findJobsRunning = true;

				try {

public void run() {
				if (!CustomWindow.isConnected(true))
					return;

				acceptJobRunning = true;

				try {
public void run() {

								job.setBookedBy("Yourself");

								findJobs();
							}

						}
public void run() {
				}
				finally {
					acceptJobRunning = false;

				}
			}
public void run() {
				if (!CustomWindow.isConnected(true))
					return;

				cancelJobRunning = true;
				try {

					boolean response = false;
public void run() {
				if (!CustomWindow.isConnected(true))
					return;

				pushJobRunning = true;

				try {
public void run() {
							job.setType(type);
							job.setNextStaffMember(nextStaff);
							job.setDescription(comments);
							
							if (subFile != null)
								job.setSubFile(subFile);

private Job createJobEntity(String[] data, String dirPath) {
	 */
	private boolean isAccepted(int id) {
		for (Job job : acceptedJobs) {
			if (job.getID() == id)
				return true;
		}

		return false;
	}

	/**
	 * Clears a list of all the Job entiteis that it contains
	 * 
	 * @param list
	 *            The list that needs to be disposed
	 */
	private void clearJobList(List<Job> list) {
		for (Job job : list) {
			job.dispose(false);
		}
		list.clear();
	}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import android.view.MenuItem;

import org.kontalk.R;
import org.kontalk.billing.IBillingService;



    private static final int NUM_ITEMS = 3;

    private AboutPagerAdapter mAdapter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.about_screen);

        setupToolbar(true);

        mAdapter = new AboutPagerAdapter(getSupportFragmentManager());

        ViewPager pager = (ViewPager) findViewById(R.id.pager);
        pager.setAdapter(mAdapter);

        TabLayout tabs = (TabLayout) findViewById(R.id.sliding_tabs);
        tabs.setupWithViewPager(pager);
public boolean onOptionsItemSelected(MenuItem item) {

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        DonationFragment fragment = mAdapter.getDonationFragment();
        IBillingService service = fragment.getBillingService();

        if (service == null || !service.handleActivityResult(requestCode, resultCode, data))
            super.onActivityResult(requestCode, resultCode, data);
    }

    private class AboutPagerAdapter extends FragmentPagerAdapter {

        // this is for IabHelper
        private DonationFragment mDonationFragment;

        public AboutPagerAdapter(FragmentManager fm) {
            super(fm);
        }
public Fragment getItem(int position) {
                    return new AboutFragment();

                case ABOUT_DONATION:
                    mDonationFragment = new DonationFragment();
                    return mDonationFragment;

                case ABOUT_CREDITS:
                    return new CreditsFragment();
public CharSequence getPageTitle(int position) {
            return super.getPageTitle(position);
        }

        public DonationFragment getDonationFragment() {
            return mDonationFragment;
        }

    }

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void setTheme(MessageListItemTheme theme) {

    @Override
    public void onClick(View v) {
        mAudioPlayerControl.buttonClick(new File(mComponent.getLocalUri().getPath()), this, mMessageId);
    }

    @Override
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private TagMap loadData() {
		@Override
		public void onReceive(Context context, Intent intent) {
			if (intent.getAction().equals(TaginService.ACTION_URN_READY)) {
				if (intent.hasExtra(TaginService.EXTRA_QUERY_RESULT)) {
					String urn = intent.getStringExtra(TaginService.EXTRA_QUERY_RESULT);
					mTagAdderDialog.getURNTextView().setText(urn);
					GetLabelsTask<CloudActivity> task = new GetLabelsTask<CloudActivity>(mInstance, urn);
					task.execute();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public Packet getPacket() {
    }

    public Iterable<Packet> getPackets() {
//        return packetsInCell;
        return new HashSet<Packet>(packetsInCell);
    }

    public Iterator<Packet> getPacketIterator() {
        return packetsInCell.iterator();
    }

    public void addPacket(Packet packet) {
import java.util.*;

/**
 * A class to represent the ether, i.e., the cable
 * that hosts on the network are connected to.
 */
public class Ether implements Drawable {
    // TODO: Implement this. Make the color something like black.
    public static Packet JAM_PACKET = null;

    private static enum Direction {
        LEFT,
public void draw() {
        }

        for (int i = 0; i < ether.length; i++) {
//            for (Iterator<Packet> it = ether[i].getPacketIterator(); it.hasNext(); ) {
//                Packet packet = it.next();
            for (Packet packet : ether[i].getPackets()) {
                // TODO: shouldn't have this case
                if (packet == null) {
                    System.out.println("hi");
                    continue;
                }
                if (directions.get(packet) == Direction.BOTH) {
                    Packet leftPacket = new Packet(packet);
                    directions.put(packet, Direction.RIGHT);
public void draw() {
                } else {
                    throw new RuntimeException("Packet did not have associated direction.");
                }
//                ether[i].removePacket(packet);
//                it.remove();
            }
        }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void getPermission(int code) {
    private void fragmentTransact(Fragment fragment) {
        if (fragment != null) {
            final Fragment frag = fragment;
            new Handler().post(new Runnable() {
                @Override
                public void run() {
                    FragmentManager fragmentManager = getSupportFragmentManager();
                    fragmentManager.beginTransaction()
                            .replace(R.id.content_frame, frag)
                            .addToBackStack(null)
                            .setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN)
                            .commit();
                }
            });
        }
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
                    stringBuilder.append(activity.getString(R.string.laundry_notification_snackbar_off))
                            .append(" ").append(machine.machine_type).append(" ")
                            .append(machine.number);
                    Snackbar snackbar = Snackbar.make(buttonView,stringBuilder, Snackbar.LENGTH_SHORT);
                    View subView = snackbar.getView();
                    TextView snackTextView = (TextView) subView.findViewById(android.support.design.R.id.snackbar_text);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
else if(clickedItemStack.equals(setDefaultItem)) {
			}

			clonedRank.setDefault(true);
			generateContent();
		}
		else if(clickedItemStack.equals(cloneItem)) {
public void generateContent() {
	 * @return the guild
	 */
	public NovaGuild getGuild() {
		return rank.getGuild();
	}

	/**
private NovaRank cloneRank() {

		NovaRank clone = new NovaRankImpl(cloneName);
		clone.setClone(rank.isGeneric());
		NovaGuild guild;

		if(rank.isGeneric()) {
			GUIInventory previousGui = getViewer().getGuiInventoryHistory().get(getViewer().getGuiInventoryHistory().size() - 2);
			guild = ((GUIInventoryGuildRankList) previousGui).getGuild();
		}
		else {
			guild = rank.getGuild();
		}

		boolean doubleName;
		int i = 1;
private NovaRank cloneRank() {
		} while(doubleName);

		clone.setPermissions(rank.getPermissions());
		guild.addRank(clone);
		return clone;
	}
import co.marcin.novaguilds.enums.VarKey;
import co.marcin.novaguilds.impl.util.AbstractGUIInventory;
import co.marcin.novaguilds.impl.util.signgui.SignGUIPatternImpl;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.ItemStack;
public void generateContent() {
		if(getViewer().hasPermission(GuildPermission.INVITE)) {
			add(inviteItem);
		}
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public boolean checkInput(String inputString) {

    public void actionPerformed(AnActionEvent e) {
        String inputValue = JOptionPane.showInputDialog("Workspace URL", "https://floobits.com/");
        Flog.info(inputValue);
        FloobitsPlugin.joinWorkspace(inputValue);
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void handle(Job<?, ?> job, PushHook hook, boolean ciSkip, BranchFilter br

    private List<MergeRequest> getOpenMergeRequests(GitLabApi client, String projectId) {
        List<MergeRequest> result = new ArrayList<>();
        Integer page = 0;
        do {
            Response response = null;
            try {
                response = client.getMergeRequests(projectId, State.opened, page, 100);
                result.addAll(response.readEntity(new GenericType<List<MergeRequest>>() {}));
                String nextPage = response.getHeaderString("X-Next-Page");
                page = nextPage.isEmpty() ? null : Integer.valueOf(nextPage);
            } finally {
                if (response != null) {
                    response.close();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public Script getScript(String file) throws RecognitionException, IOException {
		if (parser.hasErrors()) {
			handleErrors(parser.getErrors());
		}
			
		//global is root construction scope.
		Script script = new Script();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
<?xml version="1.0" encoding="UTF-8"?>
<classpath>
	<classpathentry kind="src" path="src"/>
	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
	<classpathentry kind="lib" path="libs/org.eclipse.osgi_3.6.1.R36x_v20100806.jar"/>
	<classpathentry kind="lib" path="libs/org.eclipse.jdt.core_3.6.1.v_A68_R36x.jar"/>
	<classpathentry kind="lib" path="libs/org.eclipse.core.resources_3.6.0.R36x_v20100825-0600.jar"/>
	<classpathentry kind="lib" path="libs/org.eclipse.core.jobs_3.5.1.R36x_v20100824.jar"/>
	<classpathentry kind="lib" path="libs/org.eclipse.core.contenttype_3.4.100.v20100505-1235.jar"/>
	<classpathentry kind="output" path="bin"/>
</classpath>
synchronized public CallGraph next() {
		fCurrentCommit++;
		String commitID = fCommits.get(fCurrentCommit);
		
		// checkout next revision
		fGit.reset(commitID);
		
public void reset(String commitID) {
		String output = fSpawner.spawnProcess(new String[] {"git", "diff", "--name-status", beforeCommitId, afterCommitId});
		
		HashMap<String, List<String>> affectedFiles = new HashMap<String, List<String>>();
		affectedFiles.put(ADD, new ArrayList<String>());
		affectedFiles.put(DELETE, new ArrayList<String>());
		affectedFiles.put(MODIFY, new ArrayList<String>());
		
		String[] lines = output.split(System.getProperty("line.separator"));
		String type = null;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void processChooserResponse(Intent intent) {
    public QuestionWidget getPendingWidget() {
        FormIndex pendingIndex = mFormController.getPendingCalloutFormIndex();
        if (pendingIndex == null) {
            return null;
        }
        for (QuestionWidget q : ((ODKView)mCurrentView).getWidgets()) {
            if (q.getFormId().equals(pendingIndex)) {
                return q;
            }
        }
        return null;
    }

import java.io.IOException;

public class ImageCaptureProcessing {
    /**
     * Performs any necessary relocating and scaling of an image coming from either a
     * SignatureWidget or ImageWidget (capture or choose)
public static File moveAndScaleImage(File originalImage, boolean shouldScale,
        // TODO PLM: this scale flag should be decoupled such that getPendingWidget doesn't need to be called
        if (shouldScale) {
            ImageWidget currentWidget = (ImageWidget)formEntryActivity.getPendingWidget();
            int maxDimen = currentWidget.getMaxDimen();
            if (maxDimen != -1) {
                savedScaledImage = FileUtils.scaleAndSaveImage(originalImage, finalFilePath, maxDimen);
            }
        }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
<idea-plugin version="2">
  <id>uk.co.itmoore.intellisubsteps</id>
  <name>Substeps IntelliJ Plugin</name>
  <version>1.0.0</version>
  <vendor email="ian@itmoore.co.uk" url="n/a">Substeps</vendor>

  <description><![CDATA[


  <change-notes><![CDATA[
    <h3>1.0.0</h3>
    <ul>
        <li>Switched dependency to 1.0.x version of org.substeps fork of Substeps</li>
  </change-notes>

  <!-- please see http://confluence.jetbrains.com/display/IDEADEV/Build+Number+Ranges for description -->
  <idea-version since-build="143.0"/>

  <!-- please see http://confluence.jetbrains.com/display/IDEADEV/Plugin+Compatibility+with+IntelliJ+Platform+Products
       on how to target different products -->





    private static final float DEFAULT_PROPORTION = 0.2f;

    private SubstepsStatusLine myStatusLine;
    private StatisticsPanel myStatisticsPanel;
    private SubstepsTestTreeView myTreeView;
    private TestsOutputConsolePrinter myPrinter;
    private StartingProgress myStartingProgress;
public void initUI() {
        myStartingProgress = new StartingProgress(myTreeView);
    }

    @Override
    protected JComponent createStatisticsPanel() {
        myStatisticsPanel = new StatisticsPanel();
        return myStatisticsPanel;
    }

//    @Override
//    protected ToolbarPanel createToolbarPanel() {
public void setModel(final SubstepsRunningModel model) {



        myStatisticsPanel.attachTo(model);
    }

    private void stopStartingProgress() {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void interact(int cursorX, int cursorY)
			if (!(cursorY >= 0 && cursorY < circuit.grid.length && cursorX >= 0
					&& cursorX < circuit.grid[cursorY].length) || !circuit.grid[cursorY][cursorX].isChangeable)
				return;
			inventory.addComponent(circuit.grid[cursorY][cursorX]);
			circuit.grid[cursorY][cursorX] = CircuitComponent.blank();
		}
		List<CircuitComponent> type = null;
		String componentName = "";
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import java.util.Calendar;

public class EventRecurrenceFormatter
{

    private static int[] mMonthRepeatByDayOfWeekIds;
    private static String[][] mMonthRepeatByDayOfWeekStrs;

    public static String getRepeatString(Context context, Resources r, EventRecurrence recurrence,
            boolean includeEndString) {
        String endString = "";
        if (includeEndString) {
            StringBuilder sb = new StringBuilder();
public static String getRepeatString(Context context, Resources r, EventRecurren

                    if (recurrence.bydayCount > 0) {
                        int count = recurrence.bydayCount - 1;
                        for (int i = 0 ; i < count ; i++) {
                            days.append(dayToString(recurrence.byday[i], dayOfWeekLength));
                            days.append(", ");
                        }
public static String getRepeatString(Context context, Resources r, EventRecurren
            }
            case EventRecurrence.MONTHLY: {
                if (recurrence.bydayCount == 1) {
                    int weekday = recurrence.startDate.weekDay;
                    // Cache this stuff so we won't have to redo work again later.
                    cacheMonthRepeatStrings(r, weekday);
                    int dayNumber = (recurrence.startDate.monthDay - 1) / 7;
private static void cacheMonthRepeatStrings(Resources r, int weekday) {

    /**
     * Converts day of week to a String.
     * @param day a EventRecurrence constant
     * @return day of week as a string
     */
private static String dayToString(int day, int dayOfWeekLength) {

    /**
     * Converts EventRecurrence's day of week to DateUtil's day of week.
     * @param day of week as an EventRecurrence value
     * @return day of week as a DateUtil value.
     */
    private static int dayToUtilDay(int day) {
        switch (day) {
        case EventRecurrence.SU: return Calendar.SUNDAY;
        case EventRecurrence.MO: return Calendar.MONDAY;
        case EventRecurrence.TU: return Calendar.TUESDAY;
        case EventRecurrence.WE: return Calendar.WEDNESDAY;
        case EventRecurrence.TH: return Calendar.THURSDAY;
        case EventRecurrence.FR: return Calendar.FRIDAY;
        case EventRecurrence.SA: return Calendar.SATURDAY;
        default: throw new IllegalArgumentException("bad day argument: " + day);
        }
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public ICarbonLock getTableStatusLock() {
  /**
   * This method will return last modified time of tablestatus file
   */
  public long getTableStatusLastModifiedTime() {
    String tableStatusPath = CarbonStorePath.getCarbonTablePath(
        absoluteTableIdentifier.getStorePath(), absoluteTableIdentifier.getCarbonTableIdentifier())
          .getTableStatusFilePath();
    return FileFactory.getCarbonFile(tableStatusPath, FileFactory.getFileType(tableStatusPath))
      .getLastModifiedTime();
  }

  /**
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
package igwmod;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
public static String getNameFromStack(ItemStack stack){

    public static String getOwningModId(ItemStack stack){
        String modid = "minecraft";
        UniqueIdentifier id = GameRegistry.findUniqueIdentifierFor(stack.getItem());
        if(id != null && id.modId != null) modid = id.modId.toLowerCase();
        return modid;
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// with tail
.tail-loop() { the: end; }
.tail-loop(@head, @tail...) {
  @first: extract(@head, 1);
  @second: extract(@head, 2);

  @{first}: @second;
  tail: @tail;
  .tail-loop(@tail...);
}

.class {
  @values : a A, b B, c C;
  .tail-loop(@values...);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public static String getMacAddress(Context context) {
        WifiManager manager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
        if (manager != null) {
            String mac = manager.getConnectionInfo().getMacAddress();
            Timber.i("MAC address determined to be " + mac);
            return mac;
        } else {
public static String getDeviceId() {
    }

    public static String sha256(String input) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            digest.reset();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void createFrame() {
		pLeft.add(tPlayerList);
		pLeft.add(bPayPrison);
		pLeft.add(bUsePrisonLeave);
		
		pChat.add(bUpdatePlayer);
		pChat.add(bStartGame);
		pChat.add(sP);
		pChat.add(tChatField);
		pChat.add(bEndTurn);

		pCurrentPlayer.add(new JLabel("Spieler"));
		pCurrentPlayer.add(lmP);
public void addStartGameListener(ActionListener al) {
		System.out.println("Spiel gestartet.");
		bStartGame.addActionListener(al);
	}
	
	public void addClearChatListener(ActionListener al) {
		System.out.println("Chat geleert.");
		bClearChat.addActionListener(al);
public void subscribeErr() {
	}

	public void updateMyPlayerText(Player p) {
		if (p.inPrison) {
			lmP.setText(p.getName() + "(Im Gefngnis)");
		} else {
			lmP.setText(p.getName());
		}
		
		lmP.setForeground(p.getColor());
		bUsePrisonLeave.setVisible(p.isInJail());
		bPayPrison.setVisible(p.isInJail());
		lmPMoney.setText("RM " + p.getMoney());
		lmPPlots.setText("Gekaufte Grundstcke: " + p.getPlots());
	}

	public class ChatDisp implements Displayer {
	private Frame f;
	private Converter converter;

	public Gameboard(Frame f) {
		this.f = f;
		converter = new Converter(304, 506);	  // XXX magic: original unresized wfld, hfld
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  <component name="EntryPointsManager">
    <entry_points version="2.0" />
  </component>
  <component name="MavenImportPreferences">
    <option name="generalSettings">
      <MavenGeneralSettings>
        <option name="mavenHome" value="Bundled (Maven 3)" />
      </MavenGeneralSettings>
    </option>
  </component>
  <component name="NullableNotNullManager">
    <option name="myDefaultNullable" value="android.support.annotation.Nullable" />
    <option name="myDefaultNotNull" value="android.support.annotation.NonNull" />
  <component name="ProjectType">
    <option name="id" value="Android" />
  </component>
  <component name="masterDetails">
    <states>
      <state key="ProjectJDKs.UI">
        <settings>
          <last-edited>1.8</last-edited>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
    </states>
  </component>
</project>
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/debug" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dependency-cache" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dex" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.android.support/appcompat-v7/23.0.1/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.android.support/mediarouter-v7/22.2.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.android.support/support-v4/23.0.1/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.google.android.gms/play-services-ads/8.1.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.google.android.gms/play-services-analytics/8.1.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.google.android.gms/play-services-appindexing/8.1.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.google.android.gms/play-services-appinvite/8.1.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.google.android.gms/play-services-appstate/8.1.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.google.android.gms/play-services-base/8.1.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.google.android.gms/play-services-basement/8.1.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.google.android.gms/play-services-cast/8.1.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.google.android.gms/play-services-drive/8.1.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.google.android.gms/play-services-fitness/8.1.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.google.android.gms/play-services-games/8.1.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.google.android.gms/play-services-gcm/8.1.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.google.android.gms/play-services-identity/8.1.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.google.android.gms/play-services-location/8.1.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.google.android.gms/play-services-maps/8.1.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.google.android.gms/play-services-measurement/8.1.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.google.android.gms/play-services-nearby/8.1.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.google.android.gms/play-services-panorama/8.1.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.google.android.gms/play-services-plus/8.1.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.google.android.gms/play-services-safetynet/8.1.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.google.android.gms/play-services-vision/8.1.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.google.android.gms/play-services-wallet/8.1.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.google.android.gms/play-services-wearable/8.1.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.google.android.gms/play-services/8.1.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/incremental" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/manifests" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/pre-dexed" />
    <orderEntry type="jdk" jdkName="Android API 23 Platform" jdkType="Android SDK" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" exported="" name="mediarouter-v7-22.2.0" level="project" />
    <orderEntry type="library" exported="" name="play-services-measurement-8.1.0" level="project" />
    <orderEntry type="library" exported="" name="play-services-appindexing-8.1.0" level="project" />
    <orderEntry type="library" exported="" name="play-services-base-8.1.0" level="project" />
    <orderEntry type="library" exported="" name="play-services-location-8.1.0" level="project" />
    <orderEntry type="library" exported="" name="play-services-identity-8.1.0" level="project" />
    <orderEntry type="library" exported="" name="play-services-vision-8.1.0" level="project" />
    <orderEntry type="library" exported="" name="play-services-drive-8.1.0" level="project" />
    <orderEntry type="library" exported="" name="play-services-analytics-8.1.0" level="project" />
    <orderEntry type="library" exported="" name="play-services-8.1.0" level="project" />
    <orderEntry type="library" exported="" name="support-v4-23.0.1" level="project" />
    <orderEntry type="library" exported="" name="appcompat-v7-23.0.1" level="project" />
    <orderEntry type="library" exported="" name="play-services-cast-8.1.0" level="project" />
    <orderEntry type="library" exported="" name="support-annotations-23.0.1" level="project" />
    <orderEntry type="library" exported="" name="play-services-appinvite-8.1.0" level="project" />
    <orderEntry type="library" exported="" name="play-services-ads-8.1.0" level="project" />
    <orderEntry type="library" exported="" name="play-services-appstate-8.1.0" level="project" />
    <orderEntry type="library" exported="" name="play-services-gcm-8.1.0" level="project" />
    <orderEntry type="library" exported="" name="play-services-safetynet-8.1.0" level="project" />
    <orderEntry type="library" exported="" name="play-services-games-8.1.0" level="project" />
    <orderEntry type="library" exported="" name="play-services-wallet-8.1.0" level="project" />
    <orderEntry type="library" exported="" name="play-services-basement-8.1.0" level="project" />
    <orderEntry type="library" exported="" name="play-services-maps-8.1.0" level="project" />
    <orderEntry type="library" exported="" name="play-services-nearby-8.1.0" level="project" />
    <orderEntry type="library" exported="" name="play-services-panorama-8.1.0" level="project" />
    <orderEntry type="library" exported="" name="play-services-fitness-8.1.0" level="project" />
    <orderEntry type="library" exported="" name="play-services-wearable-8.1.0" level="project" />
    <orderEntry type="library" exported="" name="play-services-plus-8.1.0" level="project" />
  </component>
</module>
android {
dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    testCompile 'junit:junit:4.12'
    compile 'com.android.support:appcompat-v7:23.0.1'
    compile 'com.google.android.gms:play-services:8.1.0'
}
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.mobserv.remoteapp" >

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />

    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/><!--coarse location saves battery-->
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />

    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.FLASHLIGHT" />
    <uses-feature android:name="android.hardware.camera" />
    <uses-feature android:name="android.hardware.camera.autofocus" />
    <uses-permission android:name="android.permission.WAKE_LOCK" />

    <application
        android:allowBackup="true"
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name"
        android:supportsRtl="true"
        android:theme="@style/AppTheme" >
        <activity android:name=".MainActivity" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <activity android:name=".ServerActivity"
                  android:label="Server Activity">
            <intent-filter>
                <action android:name="com.example.mobserv.remoteapp.ServerActivity" />
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity>

        <activity android:name=".ClientActivity"
                  android:label="Client Activity"
            >
            <intent-filter>
                <action android:name="com.example.mobserv.remoteapp.ClientActivity" />
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity>
        <activity android:name=".MapActivity"
            android:label="Map Activity"
            >
            <intent-filter>
                <action  android:name="com.example.mobserv.remoteapp.MapActivity" />
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity>

        <meta-data
            android:name="com.google.android.geo.API_KEY"
            android:value="AIzaSyAFLDYdtQ6nMWjkEUowbywvG2FctN3Xz7E"/>

    </application>

</manifest>
    private boolean mRunning = false;
    private CameraStreamer mCameraStreamer = null;

    CameraPreview(Context context, SurfaceView sv) {
        super(context);
        this.context = context;
        mSurfaceView = sv;
private static String tryGetIpV4Address()
        return null;
    }

    public void releaseMWakeLock(){
        mWakeLock.release();
    }

    private final class LoadPreferencesTask extends AsyncTask<Void, Void, SharedPreferences>
    {
package com.example.mobserv.remoteapp;

import android.app.AlertDialog;
import android.content.Context;
import android.content.pm.PackageManager;
import android.support.v4.app.FragmentManager;
import android.content.DialogInterface;
import android.content.Intent;
import android.graphics.Bitmap;
import android.os.Bundle;
import android.support.v4.app.FragmentActivity;
import android.text.Layout;
import android.text.method.ScrollingMovementMethod;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.SurfaceView;
import android.view.View;
import android.view.ViewGroup;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.Toast;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by pacel_000 on 22/10/2015.
 */
public class ClientActivity extends FragmentActivity implements TaskFragment.TaskCallbacks {

    private static final String TAG = TaskFragment.class.getSimpleName();
    private static final boolean DEBUG = true; // Set this to false to disable logs .

    private static final int serverport = 45678;
    private static final String CLIENTS_LIST = "clientsList";
    private static final String TEXT_SCROLL_X = "tScrollX";
    private static final String TEXT_SCROLL_Y = "tScrollY";

    private String serverip = "another dummy IP";
    private TextView text;
    private EditText et;
    private List<String> clientsList;
    private SurfaceView mSurfaceView;
    private ImageView contactImage;
    private CameraPreview preview;
    private boolean nameTaken;

    private static final String TAG_TASK_FRAGMENT = "task_fragment";
    private TaskFragment mTaskFragment;


    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_client);
        text = (TextView) findViewById(R.id.idClientText);
        text.setMovementMethod(new ScrollingMovementMethod());
        et = (EditText) findViewById(R.id.idClientEditText);
        mSurfaceView = (SurfaceView) findViewById(R.id.surfaceView);
        contactImage = (ImageView) findViewById(R.id.photo);

        preview = new CameraPreview(this, (SurfaceView) findViewById(R.id.surfaceView));
        preview.setKeepScreenOn(true);
        DisplayMetrics metrics = new DisplayMetrics();
        getWindowManager().getDefaultDisplay().getMetrics(metrics);
        mSurfaceView.setX(metrics.widthPixels + 1);

        FragmentManager fm = getSupportFragmentManager();
        mTaskFragment = (TaskFragment) fm.findFragmentByTag(TAG_TASK_FRAGMENT);

        Intent it = getIntent();
        this.serverip = it.getStringExtra("serverip");

        // If the Fragment is non-null, then it is currently being
        // retained across a configuration change,
        // but otherwise we instantiate a NEW ONE
        if (mTaskFragment == null) {
            Bundle bd = new Bundle();
            bd.putString("serverip", serverip);
            mTaskFragment = new TaskFragment();
            mTaskFragment.setArguments(bd);
            fm.beginTransaction().add(mTaskFragment, TAG_TASK_FRAGMENT).commit();
        }


        if(savedInstanceState == null) { // IF first launch of the activity
            et.setFocusable(false);
        }
    }

    public void onClick(View view) {
        String str = et.getText().toString();
        mTaskFragment.sendMsg(str);
        et.setText(null);
    }

    /**
     * Takes the name of the button and concatenates it to
     * the current composing message
     * @param view (the button)
     */
    public void onClickEnterText(View view) {
        String tmp = et.getText().toString();
        tmp += "/" + ((Button) view).getText().toString();
        et.setText(tmp);
        et.setSelection(et.getText().toString().length());
    }

    class updateUIThread implements Runnable {
        private String msg;
        public updateUIThread(String str) { this.msg = str; }
        @Override
        public void run() {
            text.setText(text.getText().toString() + msg + "\n");
            // code below just makes the text scroll on update/receive of messages
            final Layout layout = text.getLayout();
            if(layout != null){
                int scrollDelta = layout.getLineBottom(text.getLineCount() - 1)
                        - text.getScrollY() - text.getHeight();
                if(scrollDelta > 0)
                    text.scrollBy(0, scrollDelta);
            }
        }
    }

    class updateUIImage implements Runnable {
        private Bitmap bitmap;

        public updateUIImage(Bitmap bitmap) {this.bitmap = bitmap; }
        @Override
        public void run() {
            contactImage.setImageBitmap(bitmap);
        }
    }

    class makeToast implements Runnable{
        private String msg;
        public makeToast(String msg){ this.msg = msg; }
        @Override
        public void run() {
            Toast.makeText(getApplicationContext(), msg, Toast.LENGTH_SHORT).show();
        }
    }

public void onClick(DialogInterface arg0, int arg1) {
                }).create().show();
    }

    public void setClientsList(List<String> clientsList){ this.clientsList = clientsList; }

    class updateUIClientsList implements Runnable{
        Integer numOfClients;
        List<String> clientsList;
        public updateUIClientsList(Integer numOfClients, List<String> clientsList) {
            this.clientsList = clientsList;
            this.numOfClients = numOfClients;
        }
        @Override
        public void run() {
            ViewGroup linearLayout = (ViewGroup) findViewById(R.id.clientsLinearLayout);
            linearLayout.removeAllViews();
            for (String clientName : clientsList){
                // let's keep also own name so we can send msgs to ourselves for debugging purposes
                //if ( !clientName.equalsIgnoreCase(myName) ) {
                    Button bt = new Button(getApplicationContext());
                    bt.setText(clientName);
                    bt.setOnClickListener(new View.OnClickListener() {
                        @Override
                        public void onClick(View v) {
                            onClickEnterText(v);
                        }
                    });
                    bt.setLayoutParams(new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT));
                    linearLayout.addView(bt);
                //}
            }
            setClientsList(clientsList);
        }
    }

    public void setNameTaken(boolean val){
        this.nameTaken = val;
    }

    class createNameDialog implements Runnable {
        Boolean alreadyTaken;
        ClientActivity activity;
        public createNameDialog(Boolean alreadyTaken) {
            this.alreadyTaken = alreadyTaken;
            this.activity = ClientActivity.this;
        }

        @Override
        public void run() {
            final EditText name = new EditText(activity);
            name.setHint("Name...");
            if (!alreadyTaken) {
                new AlertDialog.Builder(activity)
                        .setTitle("Please choose a username")
                        .setView(name)
                        .setPositiveButton(android.R.string.yes, new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface arg0, int arg1) {
                                mTaskFragment.sendMsg(name.getText().toString());
                            }
                        }).create().show();
            } else {
                new AlertDialog.Builder(activity)
                        .setTitle("Please choose another username")
                        .setMessage("The name you chose had already been picked")
                        .setView(name)
                        .setPositiveButton(android.R.string.yes, new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface arg0, int arg1) {
                                mTaskFragment.sendMsg(name.getText().toString());
                            }
                        }).create().show();
            }
        }
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        if(clientsList != null)
            outState.putStringArrayList(CLIENTS_LIST, new ArrayList<String>(clientsList));
        outState.putBoolean("nameTaken", nameTaken);
        outState.putInt(TEXT_SCROLL_X, text.getScrollX());
        outState.putInt(TEXT_SCROLL_Y, text.getScrollY());

    }

    @Override
    protected void onRestoreInstanceState(Bundle savedInstanceState) {
        super.onRestoreInstanceState(savedInstanceState);

        // code below just makes the text scroll on update/receive of messages
            /*Layout layout = text.getLayout();
            if(layout != null){
                int scrollDelta = layout.getLineBottom(text.getLineCount() - 1)
                        - text.getScrollY() - text.getHeight();
                if(scrollDelta > 0)
                    text.scrollBy(0, scrollDelta);
                Log.d("onRestore", "delta is "+scrollDelta);
            }*/
        final int x = savedInstanceState.getInt(TEXT_SCROLL_X);
        final int y = savedInstanceState.getInt(TEXT_SCROLL_Y);
        text.post(new Runnable() {
            @Override
            public void run() {
                text.scrollTo(x, y);
            }
        });
        List<String> cl = savedInstanceState.getStringArrayList(CLIENTS_LIST);
        if(cl != null)
            runOnUiThread(new updateUIClientsList(cl.size(), cl));
        nameTaken = savedInstanceState.getBoolean("nameTaken");
        if (!nameTaken)
            runOnUiThread(new createNameDialog(false));
    }

    @Override
    public void onShowToast(String str){
public void onShowToast(String str){

    @Override
    public void onChooseName(Boolean taken) {
        runOnUiThread(new createNameDialog(taken));
    }

    @Override
public void onConnected() {
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                et.setFocusableInTouchMode(true);
            }
        });
        setNameTaken(false);
    }

    @Override
public String onImageRequested() {
            onShowToast("No camera on this device");
        } else {
            try {
                preview.setCamera();
                preview.openSurface();
                result = preview.takePicture();
            } catch (Exception e) {
                Log.d("ERROR", "Failed to config the camera: " + e.getMessage());
            } finally {
                preview.closeSurface();
            }
        }
        return result;
    }

    @Override
    public void onClientListReceived(int numOfClients, List<String> clients) {
        runOnUiThread(new updateUIClientsList(numOfClients, clients));
    }

    @Override
    public void onWelcome(){
        setNameTaken(true);
    }

    /************************/
    /***** LOGS & STUFF *****/
    /************************/

    @Override
    protected void onStart() {
        if (DEBUG) Log.i(TAG, "onStart()");
        super.onStart();
    }

    @Override
    protected void onResume() {
        if (DEBUG) Log.i(TAG, "onResume()");
        super.onResume();
    }

    @Override
    protected void onPause() {
        if (DEBUG) Log.i(TAG, "onPause()");
        super.onPause();
    }

    @Override
    protected void onStop() {
        if (DEBUG) Log.i(TAG, "onStop()");
        super.onStop();
    }

    @Override
    protected void onDestroy() {
        if (DEBUG) Log.i(TAG, "onDestroy()");
        super.onDestroy();
    }


}

    // flag for GPS Status
    boolean isGPSEnabled = false;

    // flag for network status
    boolean isNetworkEnabled = false;

    // flag for GPS Tracking is enabled
    boolean isGPSTrackingEnabled = false;


    // How many Geocoder should return our GPSTracker
    int geocoderMaxResults = 1;

    // The minimum distance to change updates in meters
    private static final long MIN_DISTANCE_CHANGE_FOR_UPDATES = 10; // 10 meters

    // The minimum time between updates in milliseconds
    private static final long MIN_TIME_BW_UPDATES = 1000 * 60 * 1; // 1 minute

    // Declaring a Location Manager
    protected LocationManager locationManager;

    // Store LocationManager.GPS_PROVIDER or LocationManager.NETWORK_PROVIDER information
    private String provider_info;

public void getLocation() {

        try {
            locationManager = (LocationManager) mContext.getSystemService(LOCATION_SERVICE);

            //getting GPS status
            isGPSEnabled = locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER);

            //getting network status
            isNetworkEnabled = locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER);

            // Try to get location if you GPS Service is enabled
            if (isGPSEnabled) {
                this.isGPSTrackingEnabled = true;

                Log.d(TAG, "Application use GPS Service");

                /*
                 * This provider determines location using
                 * satellites. Depending on conditions, this provider may take a while to return
                 * a location fix.
                 */

                provider_info = LocationManager.GPS_PROVIDER;

            } else if (isNetworkEnabled) { // Try to get location if you Network Service is enabled
                this.isGPSTrackingEnabled = true;

                Log.d(TAG, "Application use Network State to get GPS coordinates");

                /*
                 * This provider determines location based on
                 * availability of cell tower and WiFi access points. Results are retrieved
                 * by means of a network lookup.
                 */
                provider_info = LocationManager.NETWORK_PROVIDER;

            }

            // Application can use GPS or Network Provider
public void getLocation() {
     * Update GPSTracker latitude and longitude
     */
    public void updateGPSCoordinates() {
        if (location != null) {
            latitude = location.getLatitude();
            longitude = location.getLongitude();
public String getCountryName(Context context) {

    @Override
    public void onLocationChanged(Location location) {
    }

    @Override
public void onClickClient (View view ){
        startActivity(it); // TODO manifest
    }
}
package com.example.mobserv.remoteapp;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Matrix;
import android.support.v4.app.Fragment;
import android.os.Bundle;
import android.text.TextUtils;
import android.util.Base64;
import android.util.Log;
     * Callback interface through which the fragment will report the
     * task's progress and results back to the Activity.
     */
    interface TaskCallbacks {
        void onConnected();
        void onFragmentCancel();
        void onTextReceived(String str);
        void onShowToast(String str);
        void onChooseName(Boolean taken);
        void onImageReceived(Bitmap decodedByte);
        void onClientListReceived(int numOfClients, List<String> clients);
        void onWelcome();
        String onImageRequested();
    }

     * each configuration change.
     */
    @Override
    public void onAttach(Context context) {
        super.onAttach(context);

        if(context instanceof TaskCallbacks) {
            mCallbacks = (TaskCallbacks) context;
        }
        if (context instanceof Activity){
            attachedActivity = (Activity) context;
        }
    }

    /**
public void run() {
            }

            mCallbacks.onFragmentCancel();
        }

        /**
public void messageIsWrite(String senderName, String[] args) {
                                    break;
                                }
                            }
                            total.append(line).append("\n");
                        }
                        encodedImage = total.toString();
                        byte[] decodedString = Base64.decode(encodedImage, Base64.DEFAULT);
public void messageIsWrite(String senderName, String[] args) {
                        Double lon = Double.parseDouble(args[4]);
                        Double lat = Double.parseDouble(args[5]);
                        Double alt = Double.parseDouble(args[6]);
                        onGpsReceived(lat,lon,senderName);
                        mCallbacks.onShowToast("Received GPS position from " + senderName + ":\n" + TextUtils.join("/", Arrays.asList(args).subList(4, 7)));
                    } catch (ArrayIndexOutOfBoundsException e){
                        Log.d("msgIsWrite", "bad format in msg write gps: "+ TextUtils.join("/", args));
                    }
                    break;
                default:
                    mCallbacks.onShowToast("Unknown WRITE message:\n" + TextUtils.join("/", args));

public void messageIsRead(String senderName, String[] args) {
            String data = null;
            switch (args[3]) {
                case "gps":
                    if (gpsTracker.getIsGPSTrackingEnabled()) {
                        reply.add("write");
                        reply.add("gps");
public void messageIsRead(String senderName, String[] args) {
                    Log.d("msgIsRead", "Parsed list of clients: " + numOfClients + " " + clients.toString());
                    mCallbacks.onClientListReceived(numOfClients, clients);
                    break;
                case "photo":
                    String encodedImage = mCallbacks.onImageRequested();
                    reply.add("write");
                    reply.add("photo");
                    data = encodedImage;
                    break;
                case "nametaken":
                    if (!nameTaken) {
                        mCallbacks.onChooseName(true);
public void closeSocket(){
        }
    }

    /************************/
    /***** LOGS & STUFF *****/
    /************************/
public void onStop() {
        if (DEBUG) Log.i(TAG, "onStop()");
        super.onStop();
    }

    private void onGpsReceived(Double lat, Double lon, String senderName) {
        Intent it = new Intent("com.example.mobserv.remoteapp.MapActivity");
        it.putExtra("latitude", lat);
        it.putExtra("longitude", lon);
        it.putExtra("nametoshow", senderName);
        startActivity(it);
    }

}
import android.view.SurfaceHolder;

import java.io.IOException;
import java.util.List;

/* package */ public final class CameraStreamer extends Object
private void sendPreviewFrame(final byte[] data, final Camera camera, final long
        camera.addCallbackBuffer(data);
   } // sendPreviewFrame(byte[], camera, long)


} // class CameraStreamer


package com.example.mobserv.remoteapp.camera;

import java.io.DataOutputStream;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketTimeoutException;

/* package */ public final class MJpegHttpStreamer
{
        } // if

        mRunning = true;
        mWorker = new Thread(new Runnable()
        {
            @Override
            public void run()
            {
                workerRun();
            } // run()
        });
        mWorker.start();
    } // start()
public void run()
        } // synchronized
    } // streamJpeg(byte[], int, long)

    private void workerRun()
    {
        while (mRunning)
        {
            try
            {
                acceptAndStream();
            } // try
            catch (final IOException exceptionWhileStreaming)
            {
                System.err.println(exceptionWhileStreaming);
            } // catch
        } // while
    } // mainLoop()

    private void acceptAndStream() throws IOException
    {
        ServerSocket serverSocket = null;
        Socket socket = null;
        DataOutputStream stream = null;

        try
        {
            serverSocket = new ServerSocket(mPort);
            serverSocket.setSoTimeout(1000 /* milliseconds */);

            do
            {
                try
                {
                    socket = serverSocket.accept();
                } // try
                catch (final SocketTimeoutException e)
                {
                    if (!mRunning)
                    {
                        return;
                    } // if
                } // catch
            } while (socket == null);

            serverSocket.close();
            serverSocket = null;
            stream = new DataOutputStream(socket.getOutputStream());
            stream.writeBytes(HTTP_HEADER);
            stream.flush();

            while (mRunning)
            {
                final byte[] buffer;
                final int length;
                final long timestamp;

                synchronized (mBufferLock)
                {
                    while (!mNewJpeg)
                    {
                        try
                        {
                            mBufferLock.wait();
                        } // try
                        catch (final InterruptedException stopMayHaveBeenCalled)
                        {
                            // stop() may have been called
                            return;
                        } // catch
                    } // while

                    mStreamingBufferA = !mStreamingBufferA;

                    if (mStreamingBufferA)
                    {
                        buffer = mBufferA;
                        length = mLengthA;
                        timestamp = mTimestampA;
                    } // if
                    else
                    {
                        buffer = mBufferB;
                        length = mLengthB;
                        timestamp = mTimestampB;
                    } // else

                    mNewJpeg = false;
                } // synchronized

                stream.writeBytes(
                    "Content-type: image/jpeg\r\n"
                    + "Content-Length: " + length + "\r\n"
                    + "X-Timestamp:" + timestamp + "\r\n"
                    + "\r\n"
                );
                stream.write(buffer, 0 /* offset */, length);
                stream.writeBytes(BOUNDARY_LINES);
                stream.flush();
            } // while
        } // try
        finally
        {
            if (stream != null)
            {
                try
                {
                    stream.close();
                } // try
                catch (final IOException closingStream)
                {
                    System.err.println(closingStream);
                } // catch
            } //
            if (socket != null)
            {
                try
                {
                    socket.close();
                } // try
                catch (final IOException closingSocket)
                {
                    System.err.println(closingSocket);
                } // catch
            } // socket
            if (serverSocket != null)
            {
                try
                {
                    serverSocket.close();
                } // try
                catch (final IOException closingServerSocket)
                {
                    System.err.println(closingServerSocket);
                } // catch
            } // if
        } // finally
    } // accept()


} // class MJpegHttpStreamer

/* Copyright 2013 Foxdog Studios Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.example.mobserv.remoteapp.camera;

import java.io.IOException;
import java.io.OutputStream;

/* package */ public final class MemoryOutputStream extends OutputStream
{
    private final byte[] mBuffer;
    private int mLength = 0;

    /* package */ MemoryOutputStream(final int size)
    {
        this(new byte[size]);
    } // constructor(int)

    /* package */ MemoryOutputStream(final byte[] buffer)
    {
        super();
        mBuffer = buffer;
    } // constructor(byte[])

    @Override
    public void write(final byte[] buffer, final int offset, final int count)
            throws IOException
    {
        checkSpace(count);
        System.arraycopy(buffer, offset, mBuffer, mLength, count);
        mLength += count;
    } // write(buffer, offset, count)

    @Override
    public void write(final byte[] buffer) throws IOException
    {
        checkSpace(buffer.length);
        System.arraycopy(buffer, 0, mBuffer, mLength, buffer.length);
        mLength += buffer.length;
    } // write(byte[])

    @Override
    public void write(final int oneByte) throws IOException
    {
        checkSpace(1);
        mBuffer[mLength++] = (byte) oneByte;
    } // write(int)

    private void checkSpace(final int length) throws IOException
    {
        if (mLength + length >= mBuffer.length)
        {
            throw new IOException("insufficient space in buffer");
        } // if
    } // checkSpace(int)

    /* package */ void seek(final int index)
    {
        mLength = index;
    } // seek(int)

    /* package */ byte[] getBuffer()
    {
        return mBuffer;
    } // getBuffer()

    /* package */ int getLength()
    {
        return mLength;
    } // getLength()

} // class MemoryOutputStream

/* Copyright 2013 Foxdog Studios Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.example.mobserv.remoteapp.camera;

/* package */ public final class MovingAverage
{
    private final int mNumValues;
    private final long[] mValues;
    private int mEnd = 0;
    private int mLength = 0;
    private long mSum = 0L;

    /* package */ MovingAverage(final int numValues)
    {
        super();
        mNumValues = numValues;
        mValues = new long[numValues];
    } // constructor()

    /* package */ void update(final long value)
    {
        mSum -= mValues[mEnd];
        mValues[mEnd] = value;
        mEnd = (mEnd + 1) %!m(MISSING)NumValues;
        if (mLength < mNumValues)
        {
            mLength++;
        } // if
        mSum += value;
    } // update(long)

    /* package */ double getAverage()
    {
        return mSum / (double) mLength;
    } // getAverage()

} // class MovingAverage

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="vertical"
              android:layout_width="match_parent"
              android:layout_height="match_parent">

    <TextView
        android:hint="Received commands will be shown here\n"
        android:freezesText="true"
        android:layout_width="match_parent"
        android:layout_height="173dp"
        android:id="@+id/idClientText"
        android:scrollbars="vertical"
        />
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        >
        <EditText
            android:hint="Write here"
            android:layout_width="300dp"
            android:layout_height="wrap_content"
            android:id="@+id/idClientEditText"
            />
        <Button
            android:id="@+id/sendButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:onClick="onClick"
            android:text="Send"
            >
        </Button>
    </LinearLayout>

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:text="Predefined commands"
        android:textSize="25dp"
        android:textColor="#000000" />
    <LinearLayout
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        >

        <Button
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="write"
            android:onClick="onClickEnterText"
            />
        <Button
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="read"
            android:onClick="onClickEnterText"
            />
        <!--<Button
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="exec"
            android:onClick="onClickEnterText"
            />-->
        <Button
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="photo"
            android:onClick="onClickEnterText"
            />
        <Button
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="gps"
            android:onClick="onClickEnterText"
            />
    </LinearLayout>

    <LinearLayout
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:layout_gravity="center"
        android:id="@+id/clientsLinearLayout"
        >

    </LinearLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_gravity="center">

        <SurfaceView
            android:layout_width="1dp"
            android:layout_height="1dp"
            android:id="@+id/surfaceView" />

        <ImageView
            android:layout_width="fill_parent"
            android:layout_height="fill_parent"
            android:id="@+id/photo"/>

    </LinearLayout>



</LinearLayout>
    android:paddingTop="@dimen/activity_vertical_margin"
    android:paddingBottom="@dimen/activity_vertical_margin"
    android:orientation="vertical"
    tools:context=".MainActivity">

    <Button
        android:text="Server"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_height="wrap_content"
        android:id="@+id/idIpAddrEditText"
        android:inputType="text"
        android:text="192.168.1.43" />
    <Button
        android:text="Connect as Client"
        android:layout_width="wrap_content"
    <color name="colorPrimary">#3F51B5</color>
    <color name="colorPrimaryDark">#303F9F</color>
    <color name="colorAccent">#FF4081</color>
</resources>
    <!-- Default screen margins, per the Android Design guidelines. -->
    <dimen name="activity_horizontal_margin">16dp</dimen>
    <dimen name="activity_vertical_margin">16dp</dimen>
</resources>
<resources>
    <string name="app_name">RemoteApp</string>
</resources>
<resources>

    <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
        <!-- Customize your theme here. -->
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>
    </style>

</resources>
import socket,os

class Chat(LineReceiver):
    def __init__(self, clients):
        self.clients = clients
        self.name = None
        self.state = "GETNAME"

    def connectionMade(self):
        print "New client connecting..."
        self.sendLine("<server> //read/Hello/whatsyourname")


    def connectionLost(self, reason):
        if self.clients.has_key(self.name):
            left_name = self.name
            del self.clients[self.name]
            print left_name + ' has left'
            #self.broadcast( left_name + ' has left')
            self.send_clients_lists()


    def handle_getname(self, name):
        if self.clients.has_key(name):
def handle_getname(self, name):
        send_msg = "<server> /%!s(MISSING)/read/Welcome!" %!((MISSING)name, )
        self.sendLine(send_msg )
        self.send_clients_lists()

    def dataReceived(self, data):
        if self.state == "READATA":
def send_clients_lists(self):
        for name, protocol in self.clients.iteritems():
            protocol.sendLine(message)

    def handle_Command(self, msg_array, raw_msg):
        print "clients are %!s(MISSING) " %!s(MISSING)elf.clients
        if len(msg_array)>=3 and (msg_array[2] == 'read'or msg_array[2] == 'write'or msg_array[2] == 'exec' or msg_array[2] == 'OK'):
def handle_Command(self, msg_array, raw_msg):
                    self.state = "READATA"
                    self.dest = msg_array[1]
                    self.message(msg_array[1], raw_msg)
                else:
                    self.message(msg_array[1], raw_msg)
            else :
def handle_Command(self, msg_array, raw_msg):
        

class ChatFactory(Factory):

    def __init__(self):
        self.clients = {} # maps user names to Chat instances
    def buildProtocol(self, addr):
        return Chat(self.clients)


ifaceListeningPort = reactor.listenTCP(45678, ChatFactory())
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void stop() {
            return;
        }

        Logger.logInfo("Final score: " + score);
        int place = highScore.isHighScore(score);
        if (place >  0) {
public void stop() {
        spriteStore.removeAllSprites();
        board.resetGrid();

        inProgress = false;
        isStop = true;
        isResume = false;
        
        File boardFile = new File("board.mine");
        File scoreFile = new File("score.mine");
        if (boardFile.exists() || scoreFile.exists()) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void run(Processor p) throws JobExecutionException {
    }

    /**
     * Override this for the concrete download.
     * @throws JobExecutionException Something went wrong during
     * the download.
    private long currentCount;
    private long totalCount;

    private Processor processor;

    public AtomDownloadJob() {
    }

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.logging.Logger;

import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.CloseableHttpClient;
/** FileDownloadJob is a job to download features from a service. */
public class FileDownloadJob extends AbstractDownloadJob {

    private static final Logger log
        = Logger.getLogger(FileDownloadJob.class.getName());

    private String urlString;
    private File file;

    private Processor processor;

    public FileDownloadJob() {
    }

public FileDownloadJob(

    @Override
    public void bytesCounted(long count) {
        String message = I18n.format("file.download.bytes", count);
        processor.broadcastMessage(message);
    }


    @Override
    protected void download() throws JobExecutionException {
        URL url = toURL(this.urlString);;
protected void download() throws JobExecutionException {

        CloseableHttpClient httpclient = getClient(url);

        this.processor.broadcastMessage(I18n.getMsg("file.download.start"));

        try {
            HttpGet httpget = new HttpGet(this.urlString);
protected void download() throws JobExecutionException {
        } finally {
            HTTP.closeGraceful(httpclient);
        }
        this.processor.broadcastMessage(I18n.getMsg("file.download.finished"));
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void annotate(RepositoryAnnotator annotator, Repository<Entity> reposito
					Repository externalRepository = dataService.getMeta().createRepository(targetMetaData);
					permissionSystemService.giveUserEntityPermissions(SecurityContextHolder.getContext(),
							Collections.singletonList(externalRepository.getName()));
					RunAsSystemProxy.runAsSystem(() -> dataService.getMeta().updateEntityType(AnnotatorUtils
							.addAnnotatorMetaDataToRepositories(externalRepository.getEntityType(), attributeFactory,
									annotator)));

					iterateOverEntitiesAndAnnotate(repository, annotator, DatabaseAction.ADD);
				}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void remove(Class<DOC> docType, String key) {
            .values()
            .flatMap(m -> MapStream.of(m).filterKey(nameFilter).values())
            .map(s -> (TranslatorSettings<DOC, ?>) s)
            .map(settings -> settings.createDecorated(document))
            .map(injector::inject);
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void loadFASTA(Map<String, TranscriptModelBuilder> builders, String path
				cdsRegion = new GenomeInterval(txRegion.getGenomeBeginPos(), 0);
			builder.setCDSRegion(cdsRegion);

			if (onlyCurated() && mrnaName.startsWith("X")) {
				LOGGER.debug("Skipping non-curated transcript {}", new Object[] { mrnaName });
				continue; // skip non-curated one
			}
Jannovar will then return the effect and the HGVS annotation for each chromosoma

.. code-block:: console

    # java -jar jannovar-cli-0.16.jar annotate-pos -d data/hg19_ucsc.ser -i 'chr1:12345C>A' 'chr1:12346C>A'
    [...]
    #change     effect  hgvs_annotation
    chr1:12345C>A       CODING_TRANSCRIPT_INTRON_VARIANT        DDX11L1:uc010nxq.1:c.38+118C>A:p.=
For example, for annotating the ``small.vcf`` file in the ``examples`` directory

.. code-block:: console

    # java -jar jannovar-cli-0.16.jar annotate -d data/hg19_ucsc.ser -i examples/small.vcf
    [...]
    # ls examples/small.jv.vcf
    small.jv.vcf
Here is an example of using this command line option:

.. code-block:: console

    # java -jar jannovar-cli-0.16.jar annotate --no-3-prime-shifting \
        -d data/hg19_refseq.ser -i examples/small.vcf

The Show-All Option
You can use the ``--show-all``/``-a`` option to write out all functional annotat

.. code-block:: console

    # java -jar jannovar-cli-0.16.jar annotate --show-all \
        -d data/hg19_refseq.ser -i examples/small.vcf

For example, the first line of ``small.jv.vcf`` will look as follows and contain multiple effects and HGVS annotations.
When saving the above file contents as ``my_ucsc.ini``, you can pass it to the J

.. code-block:: bash

    java -Xms2G -Xmx2G -jar jannovar-cli-0.16.jar download -s my_ucsc.ini -d hg19/ucsc

Your INI file can either add new definitions or override the built-in ones.
In fact, the definition from above is part of the INI file that is contained in the Jannovar JAR file and used by default.
You can view the built-in database names using the ``db-list`` Jannovar command:

.. code-block:: console

    # java -jar jannovar-cli-0.16.jar db-list
    [...]
        hg18/refseq_curated
        hg19/ucsc
Let us now download the RefSeq and UCSC annotations for human release *hg19*:

.. code-block:: console

    # java -jar jannovar-cli-0.16.jar download -d hg19/refseq -d hg19/ucsc


Quickstart

This short How-To guides you from downloading the Jannovar program to annotating a VCF file in 5 steps.

#. Download the current stable release from our `GitHub project <https://github.com/charite/jannovar>`_ by clicking `here <https://github.com/charite/jannovar/releases/download/v0.16/jannovar-0.16.zip>`_.
#. Extract the ZIP archive.

   * you should find file called ``jannovar-cli-0.16.jar`` in the ZIP
   * you should also find a file ``small.vcf`` file in the folder ``examples``

#. Download the `RefSeq <http://www.ncbi.nlm.nih.gov/refseq/>`_ transcript database for the release *hg19/GRCh37*.
This short How-To guides you from downloading the Jannovar program to annotating

   .. code-block:: console

      # java -jar jannovar-cli-0.16.jar download -d hg19/refseq

   This will create the file ``data/hg19_refseq.ser`` which is a self-contained transcript database and can be used for functional annotation.
#. Annotate the file ``small.vcf`` from the ``examples`` directory.

   .. code-block:: console

      # java -jar jannovar-cli-0.16.jar annotate -d data/hg19_refseq.ser -i examples/small.vcf

   Jannovar will now load the transcript database from ``data/hg19_refseq.ser`` and then read ``examples/small.vcf`` file.
   Each contained variant in this file will be annotated with an ``EFFECT`` and an ``HGVS`` field in the ``VCF`` info column.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public GsonResponseConverter(TypeAdapter<T> adapter) {

    @Override
    public T convert(NetworkResponse value) throws IOException {
        if(value.statusCode == 204) {
            return null;
        } else {
            Reader reader = value.getCharStream();
import io.apptik.comm.jus.toolbox.Utils;

public final class JacksonResponseConverter<T> implements Converter<NetworkResponse, T> {
  private final ObjectReader adapter;

  public JacksonResponseConverter(ObjectReader adapter) {
    this.adapter = adapter;
  }

  @Override public T convert(NetworkResponse value) throws IOException {
    Reader reader = value.getCharStream();
    try {
      return adapter.readValue(reader);
    } finally {
      Utils.closeQuietly(reader);
    }
  }
}

public final class JJsonArrayResponseConverter implements Converter<NetworkResponse, JsonArray> {

  public JJsonArrayResponseConverter() {
  }

  @Override public JsonArray convert(NetworkResponse value) throws IOException {
    Reader reader = value.getCharStream();
    try {
      return JsonElement.readFrom(reader).asJsonArray();
    } finally {
      Utils.closeQuietly(reader);
    }
  }
}

public final class JJsonObjectResponseConverter implements Converter<NetworkResponse, JsonObject> {

  public JJsonObjectResponseConverter() {
  }

  @Override public JsonObject convert(NetworkResponse value) throws IOException {
    Reader reader = value.getCharStream();
    try {
      return JsonElement.readFrom(reader).asJsonObject();
    } finally {
      Utils.closeQuietly(reader);
    }
  }
}

public final class JJsonResponseConverter implements Converter<NetworkResponse, JsonElement> {

  public JJsonResponseConverter() {
  }

  @Override public JsonElement convert(NetworkResponse value) throws IOException {
    Reader reader = value.getCharStream();
    try {
      return JsonElement.readFrom(reader);
    } finally {
      Utils.closeQuietly(reader);
    }
  }
}
public MoshiResponseConverter(JsonAdapter<T> adapter) {

    @Override
    public T convert(NetworkResponse value) throws IOException {
        BufferedSource source = value.getBufferedSource();
        try {
            return adapter.fromJson(source);
        } finally {
            Utils.closeQuietly(source);
        }
    }
}
public ProtoResponseConverter(Parser<T> parser) {

    @Override
    public T convert(NetworkResponse value) throws IOException {
        InputStream is = value.getByteStream();
        try {
            return parser.parseFrom(is);
        } catch (InvalidProtocolBufferException e) {
            throw new RuntimeException(e); // Despite extending IOException, this is data mismatch.
        } finally {
            Utils.closeQuietly(is);
        }
    }
}
import io.apptik.comm.jus.NetworkResponse;

public final class SimpleXmlResponseConverter<T> implements Converter<NetworkResponse, T> {
  private final Class<T> cls;
  private final Serializer serializer;
  private final boolean strict;

  public SimpleXmlResponseConverter(Class<T> cls, Serializer serializer, boolean strict) {
    this.cls = cls;
    this.serializer = serializer;
    this.strict = strict;
  }

  @Override public T convert(NetworkResponse value) throws IOException {
    InputStream is = value.getByteStream();
    try {
      T read = serializer.read(cls, is, strict);
      if (read == null) {
        throw new IllegalStateException("Could not deserialize body as " + cls);
      }
      return read;
    } catch (RuntimeException | IOException e) {
      throw e;
    } catch (Exception e) {
      throw new RuntimeException(e);
    } finally {
      try {
        is.close();
      } catch (IOException ignored) {
      }
    }
  }
}
public WireResponseConverter(ProtoAdapter<T> adapter) {

    @Override
    public T convert(NetworkResponse value) throws IOException {
        BufferedSource source = value.getBufferedSource();
        try {
            return adapter.decode(source);
        } finally {
            Utils.closeQuietly(source);
        }
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import org.molgenis.data.AbstractRepositoryDecorator;
import org.molgenis.data.Repository;
import org.molgenis.file.model.FileMeta;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.stream.Stream;

import static java.util.Objects.requireNonNull;

/**
public void delete(FileMeta fileMeta)
	@Override
	public void deleteById(Object id)
	{
		deleteFile(findOneById(id));
		super.deleteById(id);
	}

public void deleteAll(Stream<Object> ids)
	{
		super.deleteAll(ids.filter(id ->
		{
			this.deleteFile(findOneById(id));
			return true;
		}));
	}
private void deleteFile(FileMeta fileMeta)
			LOG.warn("Could not delete file '{}' from file store", fileMeta.getId());
		}
	}
}
import org.mockito.Mock;
import org.molgenis.data.Query;
import org.molgenis.data.Repository;
import org.molgenis.file.model.FileMeta;
import org.molgenis.test.AbstractMockitoTest;
import org.testng.annotations.BeforeMethod;
	@BeforeMethod
	public void setUpBeforeMethod()
	{
		when(fileStore.delete(anyString())).thenReturn(true);
		fileMetaRepositoryDecorator = new FileMetaRepositoryDecorator(fileMetaRepository, fileStore);
	}
public void testDeleteById() throws Exception
		verify(fileStore).delete("id");
	}

	@Test
	public void testDeleteAll() throws Exception
	{
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools"
    package="org.poirsouille.tinc_gui"
    android:versionCode="11"
    android:versionName="0.9.10" >

    <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="19" />
    <uses-permission android:name="android.permission.ACCESS_SUPERUSER" />
private void updateConfig()
    private void addHostsToGroup(File iHostsDir, PreferenceGroup oGroup)
    {
        File[] aChildren = iHostsDir.listFiles();
        for (File aChild : aChildren) 
        {
            // Apply similar check to tinc's check_id to filter only valid hosts configuration files
            if (aChild.getName().matches("[a-zA-Z0-9_]+"))
            {
                addFilePreference(aChild, oGroup, R.drawable.ic_menu_manage);
                // Look for -up/-down scripts for this host
                addUpDown(aChild, oGroup);
            }
        }
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void handleRefCursorOutputParameter(ResultSet rs, ParameterMapping param
      resultSetCount++;
    }

    while (rsw != null && resultSetCount < mappedStatement.getResulSets().length) {
      ResultMapping parentMapping = nextResultMaps.get(mappedStatement.getResulSets()[resultSetCount]);
      if (parentMapping != null) {
        String nestedResultMapId = parentMapping.getNestedResultMapId();
        ResultMap resultMap = configuration.getResultMap(nestedResultMapId);
        handleResultSet(rsw, resultMap, null, parentMapping);
      }
      rsw = getNextResultSet(stmt);
      cleanUpAfterHandlingResultSet();
      resultSetCount++;
    }

    return collapseSingleResultList(multipleResults);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
android:
  components:
    - tools
    - platform-tools
    - build-tools-25.0.3
    - android-25
    - extra-android-support
    - extra-android-m2repository
    - extra-google-m2repository
Add this to your module's `build.gradle` file:
```gradle
dependencies {
    // ... other dependencies
    compile 'com.afollestad:sectioned-recyclerview:0.4.4'
}
```

buildscript {

    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:' + versions.gradlePlugin
buildscript {
allprojects {
    repositories {
        jcenter()
    }
}

ext.versions = [
        minSdk: 14,
        compileSdk: 25,
        buildTools: '25.0.3',
        publishVersion: '0.4.4',
        publishVersionCode: 14,
        gradlePlugin: '2.3.2',
        supportLib: '25.3.1',
        truth: '0.31',
@SuppressWarnings("WeakerAccess")
public class ItemCoord {

  private int section;
  private int relativePos;

  ItemCoord(int section, int relativePos) {
    this.section = section;
  private final ArrayMap<Integer, Integer> headerLocationMap;
  private final ArrayMap<Integer, Boolean> collapsedSectionMap;
  private ItemProvider itemProvider;

  PositionManager() {
    this.headerLocationMap = new ArrayMap<>(0);
    this.collapsedSectionMap = new ArrayMap<>(0);
  }

  int invalidate(ItemProvider itemProvider) {
    this.itemProvider = itemProvider;
    int count = 0;
    headerLocationMap.clear();
void toggleSectionExpanded(int section) {
    }
  }

  boolean isSectionExpanded(int section) {
    if (section < 0 || section > itemProvider.getSectionCount() - 1) {
      throw new IllegalArgumentException("Section " + section + " is out of bounds.");

import java.util.List;

/**
 * @author Aidan Follestad (afollestad)
 */
@SuppressWarnings({"WeakerAccess", "unused"})
public abstract class SectionedRecyclerViewAdapter<VH extends SectionedViewHolder>
    extends RecyclerView.Adapter<VH> implements ItemProvider {

  private static final String TAG = "SectionedRVAdapter";

  protected static final int VIEW_TYPE_HEADER = -2;
  protected static final int VIEW_TYPE_ITEM = -1;

  private PositionManager positionManager;
  private GridLayoutManager layoutManager;
  private boolean showHeadersForEmptySections;

  public SectionedRecyclerViewAdapter() {
    positionManager = new PositionManager();
    positionManager.invalidate(this);
  }

  public void notifySectionChanged(@IntRange(from = 0, to = Integer.MAX_VALUE) int section) {
public void notifySectionChanged(@IntRange(from = 0, to = Integer.MAX_VALUE) int
      Log.d(TAG, "There are no items in section " + section + " to notify.");
      return;
    }
    Log.d(TAG, "Invalidating " + sectionItemCount + " items starting at index " + sectionHeaderIndex);
    notifyItemRangeChanged(sectionHeaderIndex, sectionItemCount);
  }

public void collapseSection(int section) {
  }

  public void expandAllSections() {
    for (int i = 0; i < getSectionCount(); i++) {
      positionManager.expandSection(i);
    }
    notifyDataSetChanged();
  }

  public void collapseAllSections() {
    for (int i = 0; i < getSectionCount(); i++) {
      positionManager.collapseSection(i);
    }
    notifyDataSetChanged();
  }

public void toggleSectionExpanded(int section) {
    notifyDataSetChanged();
  }


  public abstract int getSectionCount();

  public abstract int getItemCount(int section);
protected int getRowSpan(
    return 1;
  }

  /**
   * Converts an absolute position to a relative position and section.
   */
  public ItemCoord getRelativePosition(int absolutePosition) {
    return positionManager.relativePosition(absolutePosition);
  }
import android.support.v7.widget.RecyclerView;
import android.view.View;

public abstract class SectionedViewHolder extends RecyclerView.ViewHolder {

  interface PositionDelegate {
    ItemCoord relativePosition(int absolutePosition);

    boolean isHeader(int absolutePosition);
  }

  private PositionDelegate positionDelegate;

  public SectionedViewHolder(View itemView) {
protected ItemCoord getRelativePosition() {
  protected boolean isHeader() {
    return positionDelegate.isHeader(getAdapterPosition());
  }
}
  @Before
  public void before() {
    positionManager = new PositionManager();
    invalidate();
  }

public void test_collapse_section() {
  }

  @Test
  public void test_expand_section() {
    positionManager.collapseSection(1);
    assertThat(invalidate()).isEqualTo(7);
public void test_expand_section() {
  }

  @Test
  public void test_toggle_expanded() {
    positionManager.collapseSection(1);
    assertThat(invalidate()).isEqualTo(7);
public void test_toggle_expanded() {
  }

  @Test
  public void test_item_coord_toString() {
    assertThat(new ItemCoord(8, 16).toString()).isEqualTo("8:16");
  }
protected void onCreate(@Nullable Bundle savedInstanceState) {
        new GridLayoutManager(this, getResources().getInteger(R.integer.grid_span));
    list.setLayoutManager(manager);
    adapter.setLayoutManager(manager);
    adapter.shouldShowHeadersForEmptySections(false);
    adapter.collapseAllSections();
    list.setAdapter(adapter);
  }

  @Override
  public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.main, menu);
    return super.onCreateOptionsMenu(menu);
  }

public boolean onOptionsItemSelected(MenuItem item) {
      hideEmpty = !hideEmpty;
      adapter.shouldShowHeadersForEmptySections(hideEmpty);
      adapter.notifyDataSetChanged();
      item.setChecked(hideEmpty);
      return true;
    }
    return super.onOptionsItemSelected(item);
public MainVH onCreateViewHolder(ViewGroup parent, int viewType) {

    MainVH(View itemView, MainAdapter adapter) {
      super(itemView);
      this.title = (TextView) itemView.findViewById(R.id.title);
      this.caret = (ImageView) itemView.findViewById(R.id.caret);
      this.adapter = adapter;
      itemView.setOnClickListener(this);
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Include the dependency in your app `build.gradle`:

```groovy
dependencies {
    compile 'com.schibstedspain.android:leku:2.1.0'
}
```

buildscript {
    jcenter()
  }
  dependencies {
    classpath 'com.android.tools.build:gradle:2.1.2'

    classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'
    classpath "org.jfrog.buildinfo:build-info-extractor-gradle:3.1.1"
#Wed Jun 08 15:17:45 CEST 2016
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
apply plugin: 'com.novoda.bintray-release'
apply from: '../quality.gradle'

group = 'com.schibstedspain.android'
version = '2.1.0'

android {
  compileSdkVersion 24
publish {
  userOrg = 'schibstedspain'
  groupId = 'com.schibstedspain.android'
  artifactId = 'leku'
  publishVersion = '2.1.0'
  desc = 'Location picker component for Android. It returns a latitude,longitude and an address based on the location picked in the LocationPickerActivity provided.'
  website = 'https://github.com/SchibstedSpain/leku'
}
public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) {
          adapter.clear();
          adapter.notifyDataSetChanged();
          showLocationInfoLayout();
          clearSearchButton.setVisibility(View.INVISIBLE);
          searchOption.setIcon(R.drawable.ic_mic);
        } else {
          clearSearchButton.setVisibility(View.VISIBLE);
          searchOption.setIcon(R.drawable.ic_search);
        }
      }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void onUnbind(long messageId, AudioContentViewControl view) {
            player.setOnCompletionListener(new MediaPlayer.OnCompletionListener() {
                @Override
                public void onCompletion(MediaPlayer mp) {
                    getAudioFragment().seekPlayerTo(0);
                    setAudioStatus(AudioContentView.STATUS_ENDED);
                }
            });
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void previous() {
	}
	
	public String nameOfPrevious() {
		return getHasPrevious() ? display(current.previous().item().name()) : "";
	}

	public void up() {
public void up() {
	}
	
	public String nameOfUp() {
		return getHasUp() ? display(current.up().item().name()) : "";
	}
	
	public void next() {
public void next() {
	}
	
	public String nameOfNext() {
		return getHasNext() ? display(current.next().item().name()) : "";
	}
	
	public void down() {
public void down() {
	}
	
	public String nameOfDown() {
		return getHasDown() ? display(current.down().item().name()) : "";
	}
	
	private String display(String name) {
		return name.trim();
	}
	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private EntityPortlet controllingPortlet;

    private SelectionListener selectionControllingListener;
    private PanelListener portletDestroyListener;
    private PanelListener panelListener;

    public AbstractTab(final Project project) {
public void setSelection(Collection<EntityData> selection) {
                if (selection == null) {
                    return;
                } // else do nothing here
            } else if (currentSel.equals(selection)) {
                return;
            }
        }
        controllingPortlet.setSelection(selection);
    }

    public int getColumnCount() {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import hudson.tasks.test.AbstractTestResultAction;
import hudson.triggers.SCMTrigger;
import hudson.util.LogTaskListener;
import org.apache.commons.lang.StringUtils;

import java.io.IOException;
String getChanges(AbstractBuild r, boolean includeCustomMessage) {
            Entry entry = (Entry) o;
            logger.info("Entry " + o);
            entries.add(entry);
            files.addAll(entry.getAffectedFiles());
        }
        if (entries.isEmpty()) {
            logger.info("Empty change...");
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static void verifyQuery(QueryBuilder queryBuilder) {
            RangeQueryBuilder rangeQueryBuilder = (RangeQueryBuilder) queryBuilder;
            if (rangeQueryBuilder.from() instanceof String) {
                String from = (String) rangeQueryBuilder.from();
                String to = (String) rangeQueryBuilder.to();
                if (from.contains("now") || to.contains("now")) {
                    throw new IllegalArgumentException("percolator queries containing time range queries based on the " +
                            "current time is unsupported");
                }
            }
        } else if (queryBuilder instanceof HasChildQueryBuilder) {
            throw new IllegalArgumentException("the [has_child] query is unsupported inside a percolator query");
        } else if (queryBuilder instanceof HasParentQueryBuilder) {
public void testRangeQueryWithNowRangeIsForbidden() throws Exception {
                }
        );
        assertThat(e.getCause(), instanceOf(IllegalArgumentException.class));
    }

    public void testUnsupportedQueries() {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
package com.aol.cyclops.lambda.api;

import java.lang.reflect.Field;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import com.aol.cyclops.invokedynamic.ExceptionSoftener;
import com.aol.cyclops.invokedynamic.ReflectionCache;
default Object unwrap(){
	default Map<String,?> toMap(){
		try {
			final Object o = unwrap();
			return ReflectionCache.getFields(o.getClass())
					.stream()
					.collect(Collectors.toMap((Field f)->f.getName(),(Field f) ->{
						try {

							return f.get(o);
						} catch (Exception e) {
							ExceptionSoftener.throwSoftenedException(e);
							return null;
						}
					}));
		} catch (Exception e) {
			ExceptionSoftener
					.throwSoftenedException(e);
			return null;
		}
	}
}
import lombok.Value;

import org.junit.Test;
import static org.hamcrest.Matchers.equalTo;
import com.aol.cyclops.lambda.api.AsMappable;
import static org.junit.Assert.assertThat;

public void testMap(){
		assertThat(map.get("num"),equalTo(10));
		assertThat(map.get("str"),equalTo("hello"));
	}
	@Value static class MyEntity { int num; String str;}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
     * This boolean value tells if the response is from X-Road meta service.
     */
    protected boolean isMetaServiceResponse = false;
    
    private static final Logger logger = LoggerFactory.getLogger(AbstractResponseDeserializer.class);

    /**
protected Object deserializeFaultDetail(final Node detailNode) {
     */
    private boolean deserializeResponseError(final ServiceResponse response, final Node responseNode) throws SOAPException {
        logger.debug("Deserialize a non-technical SOAP error message.");
        if(this.isMetaServiceResponse) {
            logger.debug("Response being processed is from X-Road meta service. Skip.");
            return false;
        }
        String faultCode = null;
        String faultString = null;
        for (int i = 0; i < responseNode.getChildNodes().getLength(); i++) {
            if (responseNode.getChildNodes().item(i).getLocalName().equalsIgnoreCase("faultcode")) {
                logger.trace("FaultCode found.");
                faultCode = responseNode.getChildNodes().item(i).getTextContent();
            } else if (responseNode.getChildNodes().item(i).getLocalName().equalsIgnoreCase("faultstring")) {
                logger.trace("FaultString found.");
                faultString = responseNode.getChildNodes().item(i).getTextContent();
            }
        }
        if (faultCode != null || faultString != null) {
public void test7() throws XRd4JException, SOAPException {
     * @throws SOAPException
     */
    public void test8() throws XRd4JException, SOAPException {
        String soapString = "<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:id=\"http://x-road.eu/xsd/identifiers\" xmlns:xrd=\"http://x-road.eu/xsd/xroad.xsd\"><SOAP-ENV:Header><xrd:client id:objectType=\"SUBSYSTEM\"><id:xRoadInstance>FI</id:xRoadInstance><id:memberClass>GOV</id:memberClass><id:memberCode>MEMBER1</id:memberCode><id:subsystemCode>subsystem</id:subsystemCode></xrd:client><xrd:service id:objectType=\"SERVICE\"><id:xRoadInstance>FI</id:xRoadInstance><id:memberClass>COM</id:memberClass><id:memberCode>MEMBER2</id:memberCode><id:subsystemCode>subsystem</id:subsystemCode><id:serviceCode>getRandom</id:serviceCode><id:serviceVersion>v1</id:serviceVersion></xrd:service><xrd:id>ID-1234567890</xrd:id><xrd:protocolVersion>4.0</xrd:protocolVersion></SOAP-ENV:Header><SOAP-ENV:Body><ns1:getRandomResponse xmlns:ns1=\"http://producer.x-road.ee\"><request><data>1234567890</data></request><response><data>9876543210</data></response></ns1:getRandomResponse></SOAP-ENV:Body></SOAP-ENV:Envelope>";
        SOAPMessage msg = SOAPHelper.toSOAP(soapString);

        ServiceResponseDeserializer deserializer = new TestResponseDeserializer();
public void test8() throws XRd4JException, SOAPException {
     * @throws SOAPException
     */
    public void test9() throws XRd4JException, SOAPException {
        String soapString = "<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:id=\"http://x-road.eu/xsd/identifiers\" xmlns:xrd=\"http://x-road.eu/xsd/xroad.xsd\"><SOAP-ENV:Header><xrd:client id:objectType=\"SUBSYSTEM\"><id:xRoadInstance>FI</id:xRoadInstance><id:memberClass>GOV</id:memberClass><id:memberCode>MEMBER1</id:memberCode><id:subsystemCode>subsystem</id:subsystemCode></xrd:client><xrd:service id:objectType=\"SERVICE\"><id:xRoadInstance>FI</id:xRoadInstance><id:memberClass>COM</id:memberClass><id:memberCode>MEMBER2</id:memberCode><id:subsystemCode>subsystem</id:subsystemCode><id:serviceCode>getRandom</id:serviceCode><id:serviceVersion>v1</id:serviceVersion></xrd:service><xrd:userId>EE1234567890</xrd:userId><xrd:id>ID-1234567890</xrd:id><xrd:protocolVersion>4.0</xrd:protocolVersion><xrd:requestHash algorithmId=\"SHA-512\">ZPbWPAOcJxzE81EmSk//R3DUQtqwMcuMMF9tsccJypdNcukzICQtlhhr3a/bTmexDrn8e/BrBVyl2t0ni/cUvw==</xrd:requestHash></SOAP-ENV:Header><SOAP-ENV:Body><ns1:getRandomResponse xmlns:ns1=\"http://producer.x-road.ee\"><request><data>1234567890</data></request><response><data>9876543210</data></response></ns1:getRandomResponse></SOAP-ENV:Body></SOAP-ENV:Envelope>";
        SOAPMessage msg = SOAPHelper.toSOAP(soapString);

        ServiceResponseDeserializer deserializer = new TestResponseDeserializer();
        ServiceResponse<String, String> response = deserializer.deserialize(msg, "http://producer.x-road.ee");

public void test9() throws XRd4JException, SOAPException {
     * @throws SOAPException
     */
    public void test10() throws XRd4JException, SOAPException {
        String soapString = "<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:id=\"http://x-road.eu/xsd/identifiers\" xmlns:xrd=\"http://x-road.eu/xsd/xroad.xsd\"><SOAP-ENV:Header><xrd:client id:objectType=\"SUBSYSTEM\"><id:xRoadInstance>FI</id:xRoadInstance><id:memberClass>GOV</id:memberClass><id:memberCode>MEMBER1</id:memberCode><id:subsystemCode>subsystem</id:subsystemCode></xrd:client><xrd:service id:objectType=\"SERVICE\"><id:xRoadInstance>FI</id:xRoadInstance><id:memberClass>COM</id:memberClass><id:memberCode>MEMBER2</id:memberCode><id:subsystemCode>subsystem</id:subsystemCode><id:serviceCode>getRandom</id:serviceCode><id:serviceVersion>v1</id:serviceVersion></xrd:service><xrd:userId>EE1234567890</xrd:userId><xrd:id>ID-1234567890</xrd:id><xrd:protocolVersion>4.0</xrd:protocolVersion><xrd:requestHash algorithmId=\"SHA-512\">ZPbWPAOcJxzE81EmSk//R3DUQtqwMcuMMF9tsccJypdNcukzICQtlhhr3a/bTmexDrn8e/BrBVyl2t0ni/cUvw==</xrd:requestHash></SOAP-ENV:Header><SOAP-ENV:Body><ns1:getRandomResponse xmlns:ns1=\"http://producer.x-road.ee\"><request><data>1234567890</data></request><response><data>9876543210</data></response></ns1:getRandomResponse></SOAP-ENV:Body></SOAP-ENV:Envelope>";
        SOAPMessage msg = SOAPHelper.toSOAP(soapString);

        ServiceResponseDeserializer deserializer = new TestResponseDeserializer();
public void test10() throws XRd4JException, SOAPException {
    }

    /**
     * Response to subsystem -> service level service call. Technical error with
     * header.
     *
public void testNonTechError5() throws XRd4JException, SOAPException {

        protected String deserializeRequestData(Node requestNode) throws SOAPException {
            for (int i = 0; i < requestNode.getChildNodes().getLength(); i++) {
                if (requestNode.getChildNodes().item(i).getLocalName().equals("data")) {
                    return requestNode.getChildNodes().item(i).getTextContent();
                }
            }
protected String deserializeRequestData(Node requestNode) throws SOAPException {

        protected String deserializeResponseData(Node responseNode, SOAPMessage message) throws SOAPException {
            for (int i = 0; i < responseNode.getChildNodes().getLength(); i++) {
                if (responseNode.getChildNodes().item(i).getLocalName().equals("data")) {
                    return responseNode.getChildNodes().item(i).getTextContent();
                }
            }
protected Object deserializeFaultDetail(Node detailNode) {
            return SOAPHelper.nodesToMap(detailNode.getChildNodes());
        }
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 */
package org.elasticsearch.hadoop.hive;

import java.util.Map;

import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;
import org.apache.hadoop.hive.serde2.objectinspector.StructField;
import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;
import org.elasticsearch.hadoop.cfg.Settings;
import org.elasticsearch.hadoop.serialization.ConstantFieldExtractor;
import org.elasticsearch.hadoop.util.Assert;

public class HiveFieldExtractor extends ConstantFieldExtractor {

protected String extractField(Object target) {
                        String.format("Field [%!s(MISSING)] needs to be a primitive; found [%!s(MISSING)]", fieldName, foi.getTypeName()));

                // expecting a writeable - simply do a toString
                return soi.getStructFieldData(type.getObject(), field).toString();
            }
        }

public void setSettings(Settings settings) {
        super.setSettings(settings);
        Map<String, String> columnNames = HiveUtils.columnMap(settings);
        // replace column name with _colX (which is what Hive uses during serialization)
        fieldName = columnNames.get(getFieldName().toLowerCase());
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	{
	"name" : "MW",
	"color" : [1.0, 1.0, 1.0, 0.3],
	"size" : 1.6e12,
	"ct" : MilkyWay,
	"transformName" : equatorialToGalactic,

	{
	"name" : "MW",
	"color" : [1.0, 1.0, 1.0, 0.5],
	"size" : 1.6e12,
	"ct" : MilkyWay,
	"transformName" : equatorialToGalactic,

package gaia.cu9.ari.gaiaorbit.android;

import gaia.cu9.ari.gaiaorbit.GaiaSky;
import gaia.cu9.ari.gaiaorbit.android.util.AndroidConfInit;
import gaia.cu9.ari.gaiaorbit.scenegraph.NaturalCamera;
import gaia.cu9.ari.gaiaorbit.util.ConfInit;
import gaia.cu9.ari.gaiaorbit.util.GlobalConf;
import gaia.cu9.ari.gaiaorbit.util.math.MathUtilsd;

import java.io.InputStream;

import android.app.Activity;
import android.content.Context;
import android.hardware.Sensor;
import android.util.Log;
import android.view.View;
import android.view.inputmethod.InputMethodManager;

import com.badlogic.gdx.backends.android.AndroidApplication;
import com.badlogic.gdx.backends.android.AndroidApplicationConfiguration;
import com.badlogic.gdx.math.Matrix4;

public class GaiaSandboxActivity extends AndroidApplication {
    WakeLock mWakeLock;
public void onCreate(Bundle savedInstanceState) {
        sensorAcce = sensorMan.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
        sensorMagn = sensorMan.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);

        initialize(new GaiaSky(), cfg);
    }

import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.utils.Pool;

import gaia.cu9.ari.gaiaorbit.GaiaSky;
import gaia.cu9.ari.gaiaorbit.event.EventManager;
import gaia.cu9.ari.gaiaorbit.scenegraph.Star;
import gaia.cu9.ari.gaiaorbit.util.Constants;
import gaia.cu9.ari.gaiaorbit.util.GlobalConf;
import gaia.cu9.ari.gaiaorbit.util.MyPools;
import gaia.cu9.ari.gaiaorbit.util.comp.ViewAngleComparator;
import gaia.cu9.ari.gaiaorbit.util.math.Vector3d;

 *
 */
public class GaiaInputController extends GestureDetector {
    protected static Pool<Vector3d> v3dpool = MyPools.get(Vector3d.class);
    protected static Pool<Vector3> v3pool = MyPools.get(Vector3.class);

    public KeyBindings mappings;

import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.glutils.FrameBuffer;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.utils.Pool;
import com.badlogic.gdx.utils.viewport.StretchViewport;
import com.badlogic.gdx.utils.viewport.Viewport;
import com.bitfire.postprocessing.effects.Anaglyphic;
import gaia.cu9.ari.gaiaorbit.util.GlobalConf;
import gaia.cu9.ari.gaiaorbit.util.GlobalConf.ProgramConf.StereoProfile;
import gaia.cu9.ari.gaiaorbit.util.GlobalResources;
import gaia.cu9.ari.gaiaorbit.util.MyPools;

/**
 * Renders all the 3D/stereoscopic modes. Renders basically two scenes, one for each eye,

    private Anaglyphic anaglyphic;

    public SGRStereoscopic() {
        super();
        // INIT VIEWPORT
public SGRStereoscopic() {
        // Init anaglyphic effect
        anaglyphic = new Anaglyphic();

        EventManager.instance.subscribe(this, Events.FRAME_SIZE_UDPATE, Events.SCREENSHOT_SIZE_UDPATE);
    }

public void render(SceneGraphRenderer sgr, ICamera camera, float t, int rw, int
        //movecam = false;

        PerspectiveCamera cam = camera.getCamera();
        Pool<Vector3> vectorPool = MyPools.get(Vector3.class);
        // Vector of 1 meter length pointing to the side of the camera
        Vector3 side = vectorPool.obtain().set(cam.direction);
        float separation = (float) Constants.M_TO_U * GlobalConf.program.STEREOSCOPIC_EYE_SEPARATION_M;
        float dirangleDeg = 0;

public void render(SceneGraphRenderer sgr, ICamera camera, float t, int rw, int
        }

        side.crs(cam.up).nor().scl(separation);
        Vector3 backupPos = vectorPool.obtain().set(cam.position);
        Vector3 backupDir = vectorPool.obtain().set(cam.direction);

        if (GlobalConf.program.STEREO_PROFILE == StereoProfile.ANAGLYPHIC) {
            camera.setViewport(extendViewport);
public void render(SceneGraphRenderer sgr, ICamera camera, float t, int rw, int
        /** RESTORE **/
        cam.position.set(backupPos);
        cam.direction.set(backupDir);
        vectorPool.free(side);
        vectorPool.free(backupPos);
        vectorPool.free(backupDir);

    }

public void render(ICamera camera, float t, int rw, int rh, FrameBuffer fb, Post
            initSGR(camera);

        sgr.render(this, camera, t, rw, rh, fb, ppb);

        //        fb.getColorBufferTexture()
        //        if (fb != null) {
        //            int depthId = fb.getDepthBufferHandle();
        //            Gdx.gl.glBindFramebuffer(GL20.GL_FRAMEBUFFER, depthId);
        //            int texid = Gdx.gl.glGenTexture();
        //            Gdx.gl.glBindTexture(GL20.GL_TEXTURE_2D, texid);
        //            Gdx.gl.glTexImage2D(GL20.GL_TEXTURE_2D, 0, GL20.GL_RGB, rw, rh, 0, GL20.GL_RGB, GL20.GL_UNSIGNED_BYTE, null);
        //
        //            // Poor filtering. Needed !
        //            Gdx.gl.glTexParameteri(GL20.GL_TEXTURE_2D, GL20.GL_TEXTURE_MAG_FILTER, GL20.GL_NEAREST);
        //            Gdx.gl.glTexParameteri(GL20.GL_TEXTURE_2D, GL20.GL_TEXTURE_MIN_FILTER, GL20.GL_NEAREST);
        //
        //        }
    }

    /**
public void updateLocal(ITimeFrameProvider time, ICamera camera) {

        this.transform.translate(pos);

        Vector3d aux = v3dpool.obtain();
        this.distToCamera = (float) transform.getTranslation(aux).len();
        v3dpool.free(aux);
        this.viewAngle = (float) Math.atan(size / distToCamera);
        this.viewAngleApparent = this.viewAngle;
        if (!copy) {
public float getDistToCamera() {
    }

    protected void render2DLabel(SpriteBatch batch, ShaderProgram shader, BitmapFont font, ICamera camera, String label, Vector3d pos) {
        Vector3 p = v3fpool.obtain();
        pos.setVector3(p);

        camera.getCamera().project(p);
protected void render2DLabel(SpriteBatch batch, ShaderProgram shader, BitmapFont

        shader.setUniformf("scale", 1f);
        DecalUtils.drawFont2D(font, batch, label, p);
        v3fpool.free(p);
    }

    protected void render3DLabel(SpriteBatch batch, ShaderProgram shader, BitmapFont font, ICamera camera, String label, Vector3d pos, float scale, float size, float[] colour) {
import com.badlogic.gdx.math.Matrix4;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.math.collision.Ray;
import com.badlogic.gdx.utils.Pool;
import com.badlogic.gdx.utils.viewport.Viewport;

import gaia.cu9.ari.gaiaorbit.event.EventManager;
import gaia.cu9.ari.gaiaorbit.util.Constants;
import gaia.cu9.ari.gaiaorbit.util.GlobalConf;
import gaia.cu9.ari.gaiaorbit.util.Logger;
import gaia.cu9.ari.gaiaorbit.util.MyPools;
import gaia.cu9.ari.gaiaorbit.util.TwoWayHashmap;
import gaia.cu9.ari.gaiaorbit.util.coord.AstroUtils;
import gaia.cu9.ari.gaiaorbit.util.coord.Coordinates;
import gaia.cu9.ari.gaiaorbit.util.math.Vector3d;
import gaia.cu9.ari.gaiaorbit.util.time.ITimeFrameProvider;

public class CameraManager implements ICamera, IObserver {
    protected static Pool<Vector3d> v3dpool = MyPools.get(Vector3d.class);
    protected static Pool<Vector3> v3pool = MyPools.get(Vector3.class);

    /**
     * Convenience enum to describe the camera mode
     * @author Toni Sagrista
public boolean isGaiaFov() {
    public FovCamera fovCamera;

    /** Last position, for working out velocity **/
    private Vector3d lastPos;

    /** Are we moving at high speeds? **/
    private boolean supervelocity;
public CameraManager(AssetManager manager, CameraMode mode) {
        fovCamera = new FovCamera(manager, this);
        this.mode = mode;
        lastPos = new Vector3d();
        velocity = new Vector3d();
        supervelocity = true;

public void update(float dt, ITimeFrameProvider time) {
    }

    private void updatePointerRADEC(int screenX, int screenY) {
        Vector3 vec = v3pool.obtain().set(screenX, screenY, 0.5f);
        ICamera camera = current;
        camera.getCamera().unproject(vec);

        Vector3d vecd = v3dpool.obtain().set(vec);
        Vector3d out = v3dpool.obtain();

        Coordinates.cartesianToSpherical(vecd, out);

        double alpha = out.x * AstroUtils.TO_DEG;
        double delta = out.y * AstroUtils.TO_DEG;

        Logger.debug("Alpha/delta: " + alpha + "/" + delta);
        EventManager.instance.post(Events.RA_DEC_UPDATED, alpha, delta, screenX, screenY);

        v3dpool.free(out);
        v3dpool.free(vecd);
        v3pool.free(vec);
    }

    private void updateFocusLatLon(int screenX, int screenY) {
        if (isNatural()) {
            // Hover over planets gets us lat/lon
            if (current.getFocus() != null && current.getFocus() instanceof Planet) {
                Planet p = (Planet) current.getFocus();
                Vector3 pcenter = v3pool.obtain();
                p.transform.getTranslationf(pcenter);
                //pcenter.set((float) p.pos.x, (float) p.pos.y, (float) p.pos.z);
                ICamera camera = current;
                Vector3 v0 = v3pool.obtain().set(screenX, screenY, 0f);
                Vector3 v1 = v3pool.obtain().set(screenX, screenY, 0.5f);
                camera.getCamera().unproject(v0);
                camera.getCamera().unproject(v1);

                Ray ray = new Ray(v0, v1.sub(v0));
                Vector3 intersection = new Vector3();
                boolean inter = Intersector.intersectRaySphere(ray, pcenter, p.getRadius(), intersection);

                if (inter) {
                    // We found an intersection point
private void updateFocusLatLon(int screenX, int screenY) {
                    localTransformInv.inv();
                    intersection.mul(localTransformInv);

                    Vector3d vec = v3dpool.obtain();
                    vec.set(intersection);
                    Vector3d out = v3dpool.obtain();
                    Coordinates.cartesianToSpherical(vec, out);

                    double lon = (Math.toDegrees(out.x) + 90) %!;(MISSING)
                    double lat = Math.toDegrees(out.y);

                    Logger.debug("Lon/lat: " + lon + "/" + lat);
                    EventManager.instance.post(Events.LON_LAT_UPDATED, lon, lat, screenX, screenY);

                    v3dpool.free(vec);
                    v3dpool.free(out);
                }

                v3pool.free(pcenter);
                v3pool.free(v0);
                v3pool.free(v1);

            }

        }
public void render(ShaderProgram shader, float alpha, boolean colorTransit, Mesh

        float size = getFuzzyRenderSize(camera);

        Vector3 aux = v3fpool.obtain();
        shader.setUniformf("u_pos", transform.getTranslationf(aux));
        shader.setUniformf("u_size", size);
        v3fpool.free(aux);

        float[] col = colorTransit ? ccTransit : cc;
        shader.setUniformf("u_color", col[0], col[1], col[2], alpha * opacity);
public void render(SpriteBatch batch, ShaderProgram shader, BitmapFont font3d, B
        } else {
            //render2DLabel(batch, shader, font, camera, text(), transform.position);
            // 3D distance font
            Vector3d pos = v3dpool.obtain();
            textPosition(camera, pos);
            shader.setUniformf("a_viewAngle", (float) viewAngle);
            shader.setUniformf("a_viewAnglePow", getViewAnglePow());
            shader.setUniformf("a_thOverFactor", TH_OVER_FACTOR);
            shader.setUniformf("a_thOverFactorScl", getThOverFactorScl());
            render3DLabel(batch, shader, font3d, camera, text(), pos, textScale(), textSize(), textColour());
            v3dpool.free(pos);
        }

    }
public void textPosition(ICamera cam, Vector3d out) {
        double len = out.len();
        out.clamp(0, len - getRadius()).scl(0.8f);

        Vector3d aux = v3dpool.obtain();
        aux.set(cam.getUp());

        aux.crs(out).nor();
public void textPosition(ICamera cam, Vector3d out) {

        out.add(aux);

        v3dpool.free(aux);

    }

    @Override
public void render(LineRenderSystem renderer, ICamera camera, float alpha) {
        constalpha = alpha;
        alpha *= this.alpha;

        Vector3 campos = v3fpool.obtain();
        Vector3 p1 = v3fpool.obtain();
        Vector3 p2 = v3fpool.obtain();
        camera.getPos().setVector3(campos);
        // Fix, using positions directly
        for (Vector3[] pair : positions) {
public void render(LineRenderSystem renderer, ICamera camera, float alpha) {
            renderer.addLine(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z, cc[0], cc[1], cc[2], alpha);

        }
        v3fpool.free(campos);
        v3fpool.free(p1);
        v3fpool.free(p2);

    }

public void render(LineRenderSystem renderer, ICamera camera, float alpha) {
     */
    @Override
    public void render(SpriteBatch batch, ShaderProgram shader, BitmapFont font3d, BitmapFont font2d, ICamera camera) {
        Vector3d pos = v3dpool.obtain();
        textPosition(camera, pos);
        shader.setUniformf("a_viewAngle", 90f);
        shader.setUniformf("a_thOverFactor", 1f);
        render3DLabel(batch, shader, font3d, camera, text(), pos, textScale(), textSize(), textColour());
        v3dpool.free(pos);
    }

    @Override
import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.utils.Align;
import com.badlogic.gdx.utils.Pool;
import com.badlogic.gdx.utils.Scaling;
import com.badlogic.gdx.utils.viewport.FitViewport;
import com.badlogic.gdx.utils.viewport.ScalingViewport;
import gaia.cu9.ari.gaiaorbit.util.GlobalResources;
import gaia.cu9.ari.gaiaorbit.util.I18n;
import gaia.cu9.ari.gaiaorbit.util.Logger;
import gaia.cu9.ari.gaiaorbit.util.MyPools;
import gaia.cu9.ari.gaiaorbit.util.gaia.GaiaAttitudeServer;
import gaia.cu9.ari.gaiaorbit.util.gaia.Satellite;
import gaia.cu9.ari.gaiaorbit.util.math.Matrix4d;
    private Matrix4d trf;

    public long currentTime, lastTime;
    private Pool<Vector3d> vectorPool;
    private Pool<Matrix4d> matrixPool;

    Viewport viewport, viewport2;

public FovCamera(AssetManager assetManager, CameraManager parent) {

        currentTime = 0l;
        lastTime = 0l;
        vectorPool = MyPools.get(Vector3d.class);
        matrixPool = MyPools.get(Matrix4d.class);
    }

    public void initialize(AssetManager assetManager) {
public void update(float dt, ITimeFrameProvider time) {

        /** ORIENTATION - directions and up **/
        updateDirections(time);
        trf = matrixPool.obtain();
        up.mul(trf).nor();

        // Update cameras
public void update(float dt, ITimeFrameProvider time) {
        updateCamera(directions[1], up, camera2);

        dirMiddle.set(0, 0, 1).mul(trf);
        matrixPool.free(trf);

        // Return to pool
        SceneGraphNode ape = fccopy;
public void update(float dt, ITimeFrameProvider time) {
    public void updateDirections(ITimeFrameProvider time) {
        lastTime = currentTime;
        currentTime = time.getTime().getTime();
        trf = matrixPool.obtain();
        trf.idt();
        Quaterniond quat = GaiaAttitudeServer.instance.getAttitude(time.getTime()).getQuaternion();
        trf.rotate(quat).rotate(0, 0, 1, 180);
        directions[0].set(0, 0, 1).rotate(BAM_2, 0, 1, 0).mul(trf).nor();
        directions[1].set(0, 0, 1).rotate(-BAM_2, 0, 1, 0).mul(trf).nor();
        matrixPool.free(trf);

        /** WORK OUT INTERPOLATED DIRECTIONS IN THE CASE OF FAST SCANNING **/
        for (Vector3d[] directions : interpolatedDirections) {
            vectorPool.free(directions[0]);
            vectorPool.free(directions[1]);
        }
        interpolatedDirections.clear();
        if (GlobalConf.scene.COMPUTE_GAIA_SCAN) {
            if (lastTime != 0 && currentTime - lastTime > MAX_OVERLAP_TIME) {
public void updateDirections(ITimeFrameProvider time) {
    }

    public Vector3d[] getDirections(Date d) {
        trf = matrixPool.obtain();
        trf.idt();
        Quaterniond quat = GaiaAttitudeServer.instance.getAttitude(d).getQuaternion();
        trf.rotate(quat).rotate(0, 0, 1, 180);
        Vector3d dir1 = vectorPool.obtain().set(0, 0, 1).rotate(BAM_2, 0, 1, 0).mul(trf).nor();
        Vector3d dir2 = vectorPool.obtain().set(0, 0, 1).rotate(-BAM_2, 0, 1, 0).mul(trf).nor();
        matrixPool.free(trf);
        return new Vector3d[] { dir1, dir2 };
    }

public void updateLocal(ITimeFrameProvider time, ICamera camera) {

            this.transform.translate(pos);

            Vector3d aux = v3dpool.obtain();
            this.distToCamera = (float) transform.getTranslation(aux).len();
            v3dpool.free(aux);
            this.viewAngle = (float) Math.atan(size / distToCamera) / camera.getFovFactor();
            this.viewAngleApparent = this.viewAngle;
            if (!copy) {
public boolean renderText() {
        if (viewAngle < LOWER_LIMIT || viewAngle > UPPER_LIMIT || !GaiaSky.instance.isOn(ComponentType.Labels)) {
            return false;
        }
        Vector3d aux = v3dpool.obtain();
        transform.getTranslation(aux).scl(-1);

        double cosalpha = aux.add(location3d.x, location3d.y, location3d.z).nor().dot(GaiaSky.instance.cam.getDirection().nor());
        v3dpool.free(aux);
        return cosalpha < -0.2f;
    }

public boolean renderText() {
     */
    @Override
    public void render(SpriteBatch batch, ShaderProgram shader, BitmapFont font3d, BitmapFont font2d, ICamera camera) {
        Vector3d pos = v3dpool.obtain();
        textPosition(camera, pos);
        shader.setUniformf("a_viewAngle", viewAngle * (float) Constants.U_TO_KM);
        shader.setUniformf("a_thOverFactor", 1f);
        render3DLabel(batch, shader, font3d, camera, text(), pos, textScale(), textSize(), textColour());
        v3dpool.free(pos);
    }

    @Override
public void updateLocal(ITimeFrameProvider time, ICamera camera) {
        // Directional light comes from up
        updateLocalTransform();
        if (mc != null) {
            Vector3 d = v3fpool.obtain();
            d.set(0, 1, 0);
            d.mul(coordinateSystem);

            mc.dlight.direction.set(d);
            v3fpool.free(d);
        }

    }
public void render(ModelBatch modelBatch, float alpha, float t) {
     */
    @Override
    public void render(SpriteBatch batch, ShaderProgram shader, BitmapFont font3d, BitmapFont font2d, ICamera camera) {
        Vector3d pos = v3dpool.obtain();
        textPosition(camera, pos);
        shader.setUniformf("a_viewAngle", 90f);
        shader.setUniformf("a_thOverFactor", 1f);
        render3DLabel(batch, shader, font3d, camera, text(), pos, textScale(), textSize(), textColour());
        v3dpool.free(pos);
    }

    @Override
public MilkyWayReal() {
        super();
        localTransform = new Matrix4();
        lowDist = (float) (1e3 * Constants.PC_TO_U);
        highDist = (float) (8e3 * Constants.PC_TO_U);
    }

    public void initialize() {
public void update(ITimeFrameProvider time, final Transform parentTransform, ICa

    @Override
    public void update(ITimeFrameProvider time, Transform parentTransform, ICamera camera) {

    }

    @Override
public void updateLocal(ITimeFrameProvider time, ICamera camera) {
        updateLocalTransform();

        if (mc != null) {
            Vector3 d = v3fpool.obtain();
            d.set(0, 1, 0);
            d.mul(coordinateSystem);

            mc.dlight.direction.set(d);
            v3fpool.free(d);
        }

    }
public void render(Object... params) {
     */
    @Override
    public void render(SpriteBatch batch, ShaderProgram shader, BitmapFont font3d, BitmapFont font2d, ICamera camera) {
        Vector3d pos = v3dpool.obtain();
        textPosition(camera, pos);
        shader.setUniformf("a_viewAngle", 90f);
        shader.setUniformf("a_thOverFactor", 1f);
        render3DLabel(batch, shader, font3d, camera, text(), pos, textScale(), textSize(), textColour());
        v3dpool.free(pos);
    }

    public void setTransformName(String transformName) {
public Object getStars() {
     */
    @Override
    public void render(LineRenderSystem renderer, ICamera camera, float alpha) {
        Vector3 campos = v3fpool.obtain();
        Vector3 p1 = transform.position.setVector3(v3fpool.obtain());
        Vector3 ppm = v3fpool.obtain().set(pm).scl(GlobalConf.scene.PM_LEN_FACTOR);
        Vector3 p2 = v3fpool.obtain().set(p1).add(ppm);
        camera.getPos().setVector3(campos);

        renderer.addLine(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z, 0.65f, 0.65f, 0.0f, alpha);

        v3fpool.free(campos);
        v3fpool.free(p1);
        v3fpool.free(p2);
        v3fpool.free(ppm);
    }

}
public void updateLocalValues(ITimeFrameProvider time, ICamera camera) {

    protected void forceUpdateLocalValues(ITimeFrameProvider time, boolean force) {
        if (time.getDt() != 0 || force) {
            Vector3d aux3 = v3dpool.obtain();
            // Load this planet's spherical ecliptic coordinates into pos
            coordinates.getEquatorialCartesianCoordinates(time.getTime(), pos);

            // Convert to cartesian coordinates and put them in aux3 vector
            Coordinates.cartesianToSpherical(pos, aux3);
            posSph.set((float) (AstroUtils.TO_DEG * aux3.x), (float) (AstroUtils.TO_DEG * aux3.y));
            v3dpool.free(aux3);
            // Update angle
            rc.update(time);
        }
import gaia.cu9.ari.gaiaorbit.render.SceneGraphRenderer;
import gaia.cu9.ari.gaiaorbit.scenegraph.octreewrapper.AbstractOctreeWrapper;
import gaia.cu9.ari.gaiaorbit.util.MyPools;
import gaia.cu9.ari.gaiaorbit.util.concurrent.ThreadIndexer;
import gaia.cu9.ari.gaiaorbit.util.math.Matrix4d;
import gaia.cu9.ari.gaiaorbit.util.math.Vector2d;
import gaia.cu9.ari.gaiaorbit.util.math.Vector3d;
public class SceneGraphNode implements ISceneGraphNode, IPosition {
    public static final String ROOT_NAME = "Universe";

    protected static Pool<Vector3d> v3dpool = MyPools.get(Vector3d.class);
    protected static Pool<Vector3> v3fpool = MyPools.get(Vector3.class);
    protected static Pool<Vector2d> v2dpool = MyPools.get(Vector2d.class);

    /**
     * Describes to which render group this node belongs at a particular time step.
package gaia.cu9.ari.gaiaorbit.scenegraph.octreewrapper;

import gaia.cu9.ari.gaiaorbit.render.system.AbstractRenderSystem;
import gaia.cu9.ari.gaiaorbit.scenegraph.ICamera;
import gaia.cu9.ari.gaiaorbit.scenegraph.SceneGraphNode;
import gaia.cu9.ari.gaiaorbit.scenegraph.Transform;
import gaia.cu9.ari.gaiaorbit.util.GlobalConf;
import gaia.cu9.ari.gaiaorbit.util.time.ITimeFrameProvider;
import gaia.cu9.ari.gaiaorbit.util.tree.OctreeNode;

import java.util.List;

/**
 * Static Octree wrapper that can be inserted into the scene graph. 
 * This implementation is prepared to work with the {@link gaia.cu9.ari.gaiaorbit.desktop.concurrent.SceneGraphConcurrentOctree},
public void update(ITimeFrameProvider time, final Transform parentTransform, ICa
            // Compute observed octants and fill roulette list
            root.update(transform, camera, roulette, 1f);

            if (!GlobalConf.scene.OCTREE_PARTICLE_FADE) {
                if (roulette.size() != lastNumberObjects) {
                    // Need to update the points in renderer
                    AbstractRenderSystem.POINT_UPDATE_FLAG = true;
                    lastNumberObjects = roulette.size();
                }
            } else {
                AbstractRenderSystem.POINT_UPDATE_FLAG = true;
            }

            updateLocal(time, camera);
    static public <T> Pool<T> get(Class<T> type, int max) {
        Pool pool = typePools.get(type.getName());
        if (pool == null) {
            pool = new SimplePool(type, 10, max);
            set(type, pool);
        }

        return pool;
    }

    /** Returns a new or existing pool for the specified type, stored in a Class to {@link Pool} map. The max size of the pool used
     * is 100. */
    static public <T> Pool<T> get(Class<T> type) {
        return get(type, 1000);
    }

    /** Sets an existing pool for the specified type, stored in a Class to {@link Pool} map. */

package gaia.cu9.ari.gaiaorbit.util.scene2d;

import gaia.cu9.ari.gaiaorbit.util.MyPools;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.scenes.scene2d.Actor;
private void setSelectedTab(boolean value) {
    /** Sends a ChangeEvent, with this TabbedPane as the target, to each registered listener. This method is called each time there
     * is a change to the selected index. */
    protected void fireStateChanged() {
        ChangeEvent changeEvent = MyPools.obtain(ChangeEvent.class);
        changeEvent.setBubbles(false);
        fire(changeEvent);
        MyPools.free(changeEvent);
    }

    private static class TabTitleButton extends TextButton {
import gaia.cu9.ari.gaiaorbit.scenegraph.Transform;
import gaia.cu9.ari.gaiaorbit.util.GlobalConf;
import gaia.cu9.ari.gaiaorbit.util.GlobalResources;
import gaia.cu9.ari.gaiaorbit.util.MyPools;
import gaia.cu9.ari.gaiaorbit.util.Pair;
import gaia.cu9.ari.gaiaorbit.util.color.ColourUtils;
import gaia.cu9.ari.gaiaorbit.util.math.BoundingBoxd;

    /**
     * Since OctreeNode is not to be parallelised, these can be static.
     * Otherwise, use ThreadLocal
     **/
    private static BoundingBoxd boxcopy = new BoundingBoxd(new Vector3d(), new Vector3d());
    private static Matrix4d boxtransf = new Matrix4d();
    private static Vector3d auxD1 = new Vector3d(), auxD2 = new Vector3d(), auxD3 = new Vector3d(), auxD4 = new Vector3d();
    private static Vector3 auxF1 = new Vector3(), auxF2 = new Vector3();
    private static Rayd ray = new Rayd(new Vector3d(), new Vector3d());

    /** The load status of this node **/
    private LoadStatus status;
    /** The unique page identifier **/
public OctreeNode(long pageId, double x, double y, double z, double hsx, double
        this.centre = new Vector3d(x, y, z);
        this.size = new Vector3d(hsx * 2, hsy * 2, hsz * 2);
        this.box = new BoundingBoxd(blf, trb);
        this.depth = depth;
        this.transform = new Vector3d();
        this.observed = false;
public void update(Transform parentTransform, ICamera cam, List<T> roulette, flo
            distToCamera = auxD1.set(centre).add(cam.getInversePos()).len();
            viewAngle = (radius / distToCamera) / cam.getFovFactor();

            if (viewAngle < GlobalConf.scene.OCTANT_THRESHOLD_0) {
                // Stay in current level
                addObjectsTo(roulette);
                setChildrenObserved(false);
public void render(LineRenderSystem sr, ICamera camera, float alpha) {
        }

        // Camera correction
        Vector3d loc = MyPools.get(Vector3d.class).obtain();
        loc.set(this.blf).add(transform);

        /*
public void render(LineRenderSystem sr, ICamera camera, float alpha) {
        line(sr, loc.x, loc.y + size.y, loc.z + size.z, loc.x + size.x, loc.y + size.y, loc.z + size.z, this.col);
        line(sr, loc.x + size.x, loc.y + size.y, loc.z, loc.x + size.x, loc.y + size.y, loc.z + size.z, this.col);

        MyPools.get(Vector3d.class).free(loc);
    }

    /** Draws a line **/
import gaia.cu9.ari.gaiaorbit.data.DesktopSceneGraphImplementationProvider;
import gaia.cu9.ari.gaiaorbit.data.SceneGraphImplementationProvider;
import gaia.cu9.ari.gaiaorbit.desktop.concurrent.MultiThreadIndexer;
import gaia.cu9.ari.gaiaorbit.desktop.concurrent.ThreadPoolManager;
import gaia.cu9.ari.gaiaorbit.desktop.format.DesktopDateFormatFactory;
import gaia.cu9.ari.gaiaorbit.desktop.format.DesktopNumberFormatFactory;
import gaia.cu9.ari.gaiaorbit.util.I18n;
import gaia.cu9.ari.gaiaorbit.util.MusicManager;
import gaia.cu9.ari.gaiaorbit.util.concurrent.SingleThreadIndexer;
import gaia.cu9.ari.gaiaorbit.util.concurrent.ThreadIndexer;
import gaia.cu9.ari.gaiaorbit.util.format.DateFormatFactory;
import gaia.cu9.ari.gaiaorbit.util.format.NumberFormatFactory;
import gaia.cu9.ari.gaiaorbit.util.math.MathUtilsd;
public void launchMainApp() {
        if (GlobalConf.performance.MULTITHREADING) {
            ThreadIndexer.initialize(new MultiThreadIndexer());
            ThreadPoolManager.initialize(GlobalConf.performance.NUMBER_THREADS());
        } else {
            ThreadIndexer.initialize(new SingleThreadIndexer());
        }

        // Launch app
        new LwjglApplication(new GaiaSky(), cfg);

import gaia.cu9.ari.gaiaorbit.util.ConfInit;
import gaia.cu9.ari.gaiaorbit.util.GlobalConf;
import gaia.cu9.ari.gaiaorbit.util.concurrent.SingleThreadIndexer;
import gaia.cu9.ari.gaiaorbit.util.concurrent.ThreadIndexer;
import gaia.cu9.ari.gaiaorbit.util.format.DateFormatFactory;
import gaia.cu9.ari.gaiaorbit.util.format.NumberFormatFactory;
import gaia.cu9.ari.gaiaorbit.util.math.MathUtilsd;
public static void main(String[] args) throws Exception {
        ConfInit.initialize(new WebGLConfInitLite());
        PostProcessorFactory.initialize(new WebGLPostProcessorFactory());
        ThreadIndexer.initialize(new SingleThreadIndexer());
        SceneGraphImplementationProvider.initialize(new WebGLSceneGraphImplementationProvider());
        NetworkCheckerManager.initialize(new DesktopNetworkChecker());

public void initialize(List<SceneGraphNode> nodes, ITimeFrameProvider time) {

        pool = ThreadPoolManager.pool;
        tasks = new ArrayList<UpdaterTask<SceneGraphNode>>(pool.getCorePoolSize());
        roulette = new ArrayList<SceneGraphNode>(150000);

        Iterator<SceneGraphNode> it = nodes.iterator();
        while (it.hasNext()) {
public Void call() throws Exception {
        int size = nodes.size();
        for (int i = start; i < size; i += step) {
            SceneGraphNode node = nodes.get(i);
            node.update(time, node.parent.transform, camera);
        }
        return null;
    }
import gaia.cu9.ari.gaiaorbit.util.ConfInit;
import gaia.cu9.ari.gaiaorbit.util.GlobalConf;
import gaia.cu9.ari.gaiaorbit.util.concurrent.SingleThreadIndexer;
import gaia.cu9.ari.gaiaorbit.util.concurrent.ThreadIndexer;
import gaia.cu9.ari.gaiaorbit.util.format.DateFormatFactory;
import gaia.cu9.ari.gaiaorbit.util.format.NumberFormatFactory;

public GwtApplicationConfiguration getConfig() {
        DateFormatFactory.initialize(new GwtDateFormatFactory());
        ScriptingFactory.initialize(new DummyFactory());
        ThreadIndexer.initialize(new SingleThreadIndexer());
        SceneGraphImplementationProvider.initialize(new WebGLSceneGraphImplementationProvider());
        NetworkCheckerManager.initialize(new WebGLNetworkChecker());

public void notify(Events event, Object... data) {
    }

    protected native void reloadIFrame(Element iframeEl) /*-{
		iframeEl.contentWindow.location.reload(false);
    }-*/;

    @Override
    public ApplicationListener createApplicationListener() {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void setName(final String name) {

    @Override
    public boolean equals(final Object obj) {
        if (Gesture.class.equals(obj.getClass())) {
            Gesture gesture = (Gesture) obj;
            return gesture.name.equals(name);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public Return verifyDateTrigger(final Parameter _parameter)
        final Map<?, ?> values = (Map<?, ?>) _parameter.get(ParameterValues.NEW_VALUES);
        Object storage = null;
        Object dateObj = null;
        for (final Entry<?, ?> entry : values.entrySet()) {
            final Attribute attr = (Attribute) entry.getKey();
            if (attr.getName().equals("Storage")) {
                final Object[] objValues = (Object[]) entry.getValue();
                if (objValues != null) {
                    storage = objValues[0];
                }
            }
            if (attr.getName().equals("Date")) {
                final Object[] objValues = (Object[]) entry.getValue();
                if (objValues != null) {
                    dateObj = objValues[0];
                }
            }
        }
        if (storage != null && dateObj != null) {
            Instance storageInst = null;
            DateTime date = null;
            if (storage instanceof Long) {
                final QueryBuilder queryBldr = new QueryBuilder(CIProducts.StorageAbstract);
                queryBldr.addWhereAttrEqValue(CIProducts.StorageAbstract.ID, storage);
                final CachedInstanceQuery query = queryBldr.getCachedQuery(Storage.CACHE_KEY);
                query.executeWithoutAccessCheck();
                query.next();
                storageInst = query.getCurrentValue();
            } else if (storage instanceof Instance) {
                storageInst = (Instance) storage;
            }
            if (dateObj instanceof String) {
                date = new DateTime(dateObj);
            } else if (dateObj instanceof DateTime) {
                date = (DateTime) dateObj;
            }
            if (!Storage.validateClosureDate(_parameter, storageInst, date)) {
                Context.getThreadContext().abort();
                throw new EFapsException(Transaction.class, "InvalidDate");
            }
        }
        return new Return();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
fi
function run_shell()
{
   if [ -f ${CTP_HOME}/conf/shell_template_for_${BUILD_SCENARIOS}.conf ]; then
      shell_config_template= ${CTP_HOME}/conf/shell_template_for_${BUILD_SCENARIOS}.conf
   else if [ -f ${CTP_HOME}/conf/shell_template.conf ]; then
      shell_config_template= ${CTP_HOME}/conf/shell_template.conf
   fi

   cp -f ${shell_config_template} ${shell_fm_test_conf}
function run_shell()
   ini.sh -u "main.coverage.controller.result=$coverage_controller_target_dir" $shell_fm_test_conf 
   ini.sh -u "main.feedback.type=$feedback_type" $shell_fm_test_conf 
   ini.sh -u "main.testbuild.url=$url" $shell_fm_test_conf

   #execute testing
   ctp.sh shell -c $shell_fm_test_conf | tee $tmplog
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void updateAssociation(Cascade mode, E entity, EntityProxy<E> proxy,
                }
                break;
            case MANY_TO_MANY:
                Class referencedClass = attribute.getReferencedClass();
                if (referencedClass == null) {
                    throw new IllegalStateException("Invalid referenced class in " + attribute);
                }
                Type<?> referencedType = model.typeOf(referencedClass);
                QueryAttribute<S, Object> tKey = null;
                QueryAttribute<S, Object> uKey = null;
                for (Attribute a : referencedType.getAttributes()) {
                    if (entityClass.isAssignableFrom(a.getReferencedClass())) {
                        tKey = Attributes.query(a);
                    } else if (attribute.getElementClass().isAssignableFrom(
                            a.getReferencedClass())) {
                        uKey = Attributes.query(a);
                    }
                }
                Objects.requireNotNull(tKey);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	<modelVersion>4.0.0</modelVersion>
	<groupId>org.telegram</groupId>
	<artifactId>taggerbot</artifactId>
	<version>0.2016.531.2006-SNAPSHOT</version>
	<properties>
		<telegrambots.version>dev-SNAPSHOT</telegrambots.version>
	</properties>

	<dependencies>
		<dependency>
			<groupId>com.github.rubenlagus</groupId>
			<artifactId>TelegramBots</artifactId>
			<version>${telegrambots.version}</version>
		</dependency>
		<dependency>
			<groupId>junit</groupId>
						</configuration>
						<executions>
							<execution>
								<id>make-assembly</id> 
								<phase>package</phase>
								<goals>
									<goal>single</goal>
import org.telegram.telegrambots.api.objects.Update;
import org.telegram.telegrambots.bots.TelegramLongPollingBot;
import org.tlg.bot.mem.commands.Command;
import org.tlg.bot.mem.commands.SearchMediaCommand;
import org.tlg.bot.mem.msg.TextMessage;
import org.tlg.bot.mem.proc.CommandProcessor;
import jersey.repackaged.com.google.common.base.Objects;

public class MemBot extends TelegramLongPollingBot {
public MemBot(final String name, final String token) {

    @Override
    public void onUpdateReceived(final Update update) {
        log.debug("update:{}", update);
        // process if this somebody answer
        if (update.hasMessage()) {
            if (update.getMessage().hasText()) {
void resume(final Command command, final Update update) {
     * @param command
     */
    void execute(final Command command) {
        command.execute();
    }

    public void leaveAwaitQueue(final Command command) {
 */
package org.tlg.bot.mem.commands;

import org.telegram.telegrambots.api.objects.Update;

/**
 */
public interface Command {

    void execute();

    void resume(Update update);

/**
 * 
 */
package org.tlg.bot.mem.proc;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.telegram.telegrambots.api.objects.Message;
import org.telegram.telegrambots.api.objects.Update;
import org.tlg.bot.mem.MemBot;
import org.tlg.bot.mem.commands.Command;
import org.tlg.bot.mem.commands.HelpCommand;
import org.tlg.bot.mem.commands.UploadCommand;
import org.tlg.bot.mem.commands.VersionCommand;

/**
 * Process udpate object and return needed command.
public Command command() {
            return new HelpCommand(this.bot, message.getChatId());
        }
        // if this is photo or sticker
        if (message.getSticker() != null || !message.getPhoto().isEmpty()) {
            return new UploadCommand(this.bot, message);
        }

        // if message was not processed
        return new HelpCommand(this.bot, this.update.getMessage().getChatId());

    }

public void execute() {
        try {
            getBot().sendMessage(new VersionMessage(this.chatId));
        } catch (final TelegramApiException e) {
            log.error("Can't send help messagemessage", e);
        }
        
    }
<Configuration status="WARN" monitorInterval="30">
	<Appenders>
		<Console name="Console" target="SYSTEM_OUT">
			<PatternLayout pattern="%!d(MISSING){HH:mm:ss.SSS}{GMT+3} %!l(MISSING)ocation %!l(MISSING)evel %!c(MISSING){1.} - %!m(MISSING)sg%!n(MISSING)" />
		</Console>
		<Async name="AsyncConsole" includeLocation="true">
			<AppenderRef ref="Console"/>
		</Async>
	</Appenders>
	<Loggers>
		<!-- pattern layout actually uses location, so we need to include it -->
		<AsyncLogger name="org.tlg" level="debug" additivity="false" includeLocation="true">
			<AppenderRef ref="AsyncConsole" />
		</AsyncLogger>
		<Root level="error">
			<AppenderRef ref="AsyncConsole" />
package org.tlg.bot.mem;

import static org.junit.Assert.fail;
import java.util.concurrent.atomic.AtomicBoolean;
import org.hamcrest.MatcherAssert;
import org.telegram.telegrambots.api.objects.Update;
import org.tlg.bot.mem.commands.Command;
import org.tlg.bot.mem.commands.HelpCommand;

public class MemBotTest {

void execute(final Command command) {
	        fail("test is not passed");
	    }
	}

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void getPerson(ApiWrapperSingle<ApiPersonDTO> wrapper) {
        if (CollectionUtils.isNotEmpty(results)) {
            ApiPersonDTO person = results.get(0);
            if (options.hasDataItem(DataItem.ARTWORK)) {
                LOG.info("Adding photo for {}", person.getName());
                // Add the artwork
                Set<String> artworkRequired = Collections.singleton(ArtworkType.PHOTO.toString());
                Map<Long, List<ApiArtworkDTO>> artworkList = getArtworkForId(MetaDataType.PERSON, person.getId(), artworkRequired);
                if (artworkList.containsKey(options.getId())) {
                    LOG.info("Found {} artworks", artworkList.get(options.getId()).size());
                    person.setArtwork(artworkList.get(options.getId()));
                } else {
                    LOG.info("No artwork found for Person ID '{}'", options.getId());
                }
            }

public void getPerson(ApiWrapperSingle<ApiPersonDTO> wrapper) {

    public void getPersonListByVideoType(MetaDataType metaDataType, ApiWrapperList<ApiPersonDTO> wrapper) {
        OptionsId options = (OptionsId) wrapper.getOptions();
        LOG.info("Getting person list for {} with ID '{}'", metaDataType, options.getId());

        SqlScalars sqlScalars = generateSqlForVideoPerson(metaDataType, options);
        List<ApiPersonDTO> results = executeQueryWithTransform(ApiPersonDTO.class, sqlScalars, wrapper);
        LOG.info("Found {} results for {} with id '{}'", results.size(), metaDataType, options.getId());

        if (options.hasDataItem(DataItem.ARTWORK) && !results.isEmpty()) {
            LOG.info("Looking for person artwork for {} with id '{}'", metaDataType, options.getId());

            Set<String> artworkRequired = Collections.singleton(ArtworkType.PHOTO.toString());
            Map<Long, List<ApiArtworkDTO>> artworkList = getArtworkForId(MetaDataType.PERSON, generateIdList(results), artworkRequired);
public void getPersonListByVideoType(MetaDataType metaDataType, ApiWrapperList<A
                }
            }
        } else {
            LOG.info("No artwork found/requested for {} with id '{}'", metaDataType, options.getId());
        }

        wrapper.setResults(results);
public void getSingleVideo(ApiWrapperSingle<ApiVideoDTO> wrapper) {
        params.addScalarParameters(sqlScalars);

        List<ApiVideoDTO> queryResults = executeQueryWithTransform(ApiVideoDTO.class, sqlScalars, wrapper);
        LOG.debug("Found {} results for ID '{}'", queryResults.size(), params.getId());
        if (CollectionUtils.isNotEmpty(queryResults)) {
            ApiVideoDTO video = queryResults.get(0);

            if (params.hasDataItem(DataItem.GENRE)) {
                LOG.trace("Adding genres for ID '{}'", options.getId());
                video.setGenres(getGenresForId(type, options.getId()));
            }

            if (params.hasDataItem(DataItem.STUDIO)) {
                LOG.trace("Adding studios for ID '{}'", options.getId());
                video.setStudios(getStudiosForId(type, options.getId()));
            }

            if (params.hasDataItem(DataItem.CERTIFICATION)) {
                LOG.trace("Adding certifications for ID '{}'", options.getId());
                video.setCertifications(getCertificationsForId(type, options.getId()));
            }

            if (params.hasDataItem(DataItem.RATING)) {
                LOG.trace("Adding ratings for ID '{}'", options.getId());
                video.setRatings(getRatingsForId(type, options.getId()));
            }

            if (params.hasDataItem(DataItem.ARTWORK)) {
                LOG.trace("Adding artwork for ID '{}'", options.getId());
                Map<Long, List<ApiArtworkDTO>> artworkList;
                if (CollectionUtils.isNotEmpty(options.getArtworkTypes())) {
                    artworkList = getArtworkForId(type, options.getId(), options.getArtworkTypes());
public void getSingleVideo(ApiWrapperSingle<ApiVideoDTO> wrapper) {
            }

            if (params.hasDataItem(DataItem.FILES)) {
                LOG.trace("Adding files for ID '{}'", options.getId());
                video.setFiles(getFilesForId(type, options.getId()));
            }

            if (MapUtils.isNotEmpty(options.splitJobs())) {
                Set<String> jobs = options.getJobTypesAsSet();
                LOG.trace("Adding jobs for ID '{}': {}", options.getId(), jobs);

                List<ApiPersonDTO> cast = getCastForId(type, options.getId(), options.splitDataItems(), jobs);

public void getSingleVideo(ApiWrapperSingle<ApiVideoDTO> wrapper) {
                    }
                }
            } else if (options.isAllJobTypes()) {
                LOG.debug("Adding all jobs for ID '{}'", options.getId());
                video.setCast(getCastForId(type, options.getId(), params.getDataItems(), null));
            }

public void getSingleVideo(ApiWrapperSingle<ApiVideoDTO> wrapper) {
     * @return
     */
    public Map<Long, List<ApiArtworkDTO>> getArtworkForId(MetaDataType type, Object id, Set<String> artworkRequired) {
        LOG.trace("Artwork required for {} ID '{}' is {}", type, id, artworkRequired);

        StringBuilder sbSQL = new StringBuilder();
        sbSQL.append("SELECT '").append(type.toString()).append("' AS sourceString,");
public void getSingleVideo(ApiWrapperSingle<ApiVideoDTO> wrapper) {
        sqlScalars.addParameters("artworklist", artworkRequired);

        List<ApiArtworkDTO> results = executeQueryWithTransform(ApiArtworkDTO.class, sqlScalars, null);

        Map<Long, List<ApiArtworkDTO>> artworkList = generateIdMapList(results);

        return artworkList;
    }

    public void getSeriesInfo(ApiWrapperList<ApiSeriesInfoDTO> wrapper) {
        OptionsIdArtwork options = (OptionsIdArtwork) wrapper.getOptions();
        Long id = options.getId();
        LOG.info("Getting series information for seriesId '{}'", id);

        SqlScalars sqlScalars = new SqlScalars();
        sqlScalars.addToSql("SELECT s.id AS seriesId, s.title, s.title_original AS originalTitle, s.start_year AS seriesYear, ");
public void getSeriesInfo(ApiWrapperList<ApiSeriesInfoDTO> wrapper) {
        sqlScalars.addScalar(WATCHED, BooleanType.INSTANCE);

        List<ApiSeriesInfoDTO> seriesResults = executeQueryWithTransform(ApiSeriesInfoDTO.class, sqlScalars, wrapper);
        LOG.debug("Found {} series for SeriesId '{}'", seriesResults.size(), id);

        for (ApiSeriesInfoDTO series : seriesResults) {
            if (options.hasDataItem(DataItem.GENRE)) {
public void getSeriesInfo(ApiWrapperList<ApiSeriesInfoDTO> wrapper) {

            if (options.hasDataItem(DataItem.ARTWORK)) {
                Map<Long, List<ApiArtworkDTO>> artworkList = getArtworkForId(MetaDataType.SERIES, id, options.getArtworkTypes());
                for (ApiArtworkDTO artwork : artworkList.get(id)) {
                    series.addArtwork(artwork);
                }
            }
            series.setSeasonList(getSeasonInfo(options));
public void getSeriesInfo(ApiWrapperList<ApiSeriesInfoDTO> wrapper) {
    }

    private List<ApiSeasonInfoDTO> getSeasonInfo(OptionsIdArtwork options) {
        Long seriesId = options.getId();

        LOG.debug("Getting season information for seriesId '{}'", seriesId);
        SqlScalars sqlScalars = new SqlScalars();
        sqlScalars.addToSql("SELECT s.series_id AS seriesId, s.id AS seasonId, s.season, s.title, s.title_original AS originalTitle,");
        if (options.hasDataItem(DataItem.PLOT)) {
public void getSeriesInfo(ApiWrapperList<ApiSeriesInfoDTO> wrapper) {
        sqlScalars.addToSql("FROM season s");
        sqlScalars.addToSql("WHERE series_id=:id");
        sqlScalars.addToSql("ORDER BY series_id, season");
        sqlScalars.addParameters(ID, seriesId);

        sqlScalars.addScalar(SERIES_ID, LongType.INSTANCE);
        sqlScalars.addScalar(SEASON_ID, LongType.INSTANCE);
public void getSeriesInfo(ApiWrapperList<ApiSeriesInfoDTO> wrapper) {
        sqlScalars.addScalar(WATCHED, BooleanType.INSTANCE);

        List<ApiSeasonInfoDTO> seasonResults = executeQueryWithTransform(ApiSeasonInfoDTO.class, sqlScalars, null);
        LOG.debug("Found {} seasons for SeriesId '{}'", seasonResults.size(), seriesId);

        if (options.hasDataItem(DataItem.ARTWORK)) {
            for (ApiSeasonInfoDTO season : seasonResults) {
                Map<Long, List<ApiArtworkDTO>> artworkList = getArtworkForId(MetaDataType.SEASON, season.getSeasonId(), options.getArtworkTypes());
                if (artworkList == null || !artworkList.containsKey(seriesId) || CollectionUtils.isEmpty(artworkList.get(seriesId))) {
                    LOG.debug("No artwork found for seriesId '{}' season {}", seriesId, season.getSeason());
                } else {
                    for (ApiArtworkDTO artwork : artworkList.get(season.getSeasonId())) {
                        season.addArtwork(artwork);
public ApiBoxedSetDTO getBoxedSet(ApiWrapperSingle<ApiBoxedSetDTO> wrapper) {
        }

        if (options.hasDataItem(DataItem.ARTWORK)) {
            LOG.trace("Adding artwork for ID '{}'", options.getId());
            Map<Long, List<ApiArtworkDTO>> artworkList;
            if (CollectionUtils.isNotEmpty(options.getArtworkTypes())) {
                artworkList = getArtworkForId(MetaDataType.BOXSET, options.getId(), options.getArtworkTypes());
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import android.os.Build;
import android.os.Handler;
import android.os.Message;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewTreeObserver;
void add(NiftyNotificationView crouton,boolean repeat ) {

    }
    void addSticky(NiftyNotificationView crouton) {
        if (notifyQueue.size() < 1) {
            notifyQueue.add(crouton);
            displayNotify(true);
        }

    }
    void removeSticky(){

        NiftyNotificationView notify = notifyQueue.poll();
        if(notify!=null) {
            sendMessageDelayed(notify, Messages.REMOVE_NOTIFICATION,
                    0
View getView() {
    }

    private void initializeNotifyView() {

        this.notifyView = initializeCroutonViewGroup();

        RelativeLayout contentView = initializeContentView();
        this.notifyView.addView(contentView);
    }

    private FrameLayout initializeCroutonViewGroup() {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	<groupId>com.bwssystems.HABridge</groupId>
	<artifactId>ha-bridge</artifactId>
	<version>4.3.0</version>
	<packaging>jar</packaging>

	<name>HA Bridge</name>
public String getInternalTestUser() {

	public void setupInternalTestUser() {
		boolean found = false;
		for (String key : whitelist.keySet()) {
			if(key.equals(DEFAULT_INTERNAL_USER))
				found = true;
		}
		
		if(!found) {
			newWhitelistUser(DEFAULT_INTERNAL_USER, DEFAULT_USER_DESCRIPTION);
		}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private boolean nextKeywordParameters() {
	@Override
	public String toString(){
		int n = patternChildren.size();
		if(n == 1){
			return Names.fullName(qName) + "()";
		}
		StringBuilder res = new StringBuilder(qName != null ? Names.fullName(qName) : namePattern.toString());
		res.append("(");
		String sep = "";

		for (IMatchingResult c : patternChildren){
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
protected Boolean doInBackground(Object... params) {
            platform = ApplicationSession.getFermatPlatform();


            StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build();
            StrictMode.setThreadPolicy(policy);


            //set Os Addons in platform
    private SubApp subApp;
    private Activity activity;
    private Map<Fragments, com.bitdubai.fermat_api.layer.dmp_middleware.app_runtime.Fragment> fragments;
    private AppRuntimeManager appRuntimeMiddleware;
    private WalletRuntimeManager walletRuntimeMiddleware;
    private ErrorManager errorManager;

    private CorePlatformContext platformContext;

    private ViewPager pager;
    private ViewPager pagertabs;
    private boolean firstexecute = true;
    private Bundle savedInstanceState;
    private ViewGroup collection;
    private Platform platform;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
protected void onCreate(Bundle savedInstanceState) {


            this.savedInstanceState = savedInstanceState;
            //init runtime app

            platform = ApplicationSession.getFermatPlatform();

            //get platform object
            this.platformContext = platform.getCorePlatformContext();

            //get instances of Runtime Middleware object
            this.appRuntimeMiddleware = (AppRuntimeManager) platformContext.getPlugin(Plugins.BITDUBAI_APP_RUNTIME_MIDDLEWARE);
            this.walletRuntimeMiddleware = (WalletRuntimeManager) platformContext.getPlugin(Plugins.BITDUBAI_WALLET_RUNTIME_MODULE);

            this.errorManager = (ErrorManager) platformContext.getAddon(Addons.ERROR_MANAGER);

            NavigateActivity();
        } catch (Exception e) {
            // TODO: el errorManager no estaria instanciado aca....
            //this.errorManager.reportUnexpectedPlatformException(PlatformComponents.PLATFORM, UnexpectedPlatformExceptionSeverity.DISABLES_ONE_PLUGIN, e);

            Toast.makeText(getApplicationContext(), "Error Load RuntimeApp - " + e.getMessage(), Toast.LENGTH_LONG).show();
        }


private void initialisePaging() {
                    case CWP_SHELL_LOGIN:
                        break;
                    case CWP_WALLET_MANAGER_MAIN:

                        //Matias this flag is because this fragment appair two times and when press the back button in a fragment
                        //the application crash
                      //  if (!flag) {
                            fragments.add(android.support.v4.app.Fragment.instantiate(this, WalletDesktopFragment.class.getName()));
                           // flag = true;
                       // }
                        break;
                    case CWP_WALLET_MANAGER_SHOP:
                         break;
private void initialisePaging() {


        } catch (Exception ex) {
            this.errorManager.reportUnexpectedPlatformException(PlatformComponents.PLATFORM, UnexpectedPlatformExceptionSeverity.DISABLES_ONE_PLUGIN, ex);

            Toast.makeText(getApplicationContext(), "Can't Load tabs: " + ex.getMessage(), Toast.LENGTH_LONG).show();
        }
    }
private void initialisePaging() {
    // to make the NavigationDrawerFragment verified whether the activity has a SideMenu
    private void NavigateActivity() {
        try {
            this.app = appRuntimeMiddleware.getLastApp();
            this.subApp = appRuntimeMiddleware.getLastSubApp();
            this.activity = appRuntimeMiddleware.getLasActivity();

            ApplicationSession.setActivityId(activity.getType().getKey());

private void NavigateActivity() {

            }
        } catch (Exception e) {
            this.errorManager.reportUnexpectedPlatformException(PlatformComponents.PLATFORM, UnexpectedPlatformExceptionSeverity.DISABLES_ONE_PLUGIN, e);

            Toast.makeText(getApplicationContext(), "Error in NavigateActivity " + e.getMessage(), Toast.LENGTH_LONG).show();
        }
private void NavigateActivity() {
    // TODO: En definitiva, tenemos que llegar al punto de que la parametrizacin este en el plugin WalletRuntime y APPRuntime y solo ahi.


    /*@Override
    public boolean onCreateOptionsMenu(Menu menu) {

        try {
public boolean onCreateOptionsMenu(Menu menu) {
        } catch (Exception e) {

            // TODO:  Error manager null
            this.errorManager.reportUnexpectedPlatformException(PlatformComponents.PLATFORM, UnexpectedPlatformExceptionSeverity.DISABLES_ONE_PLUGIN, e);

            Toast.makeText(getApplicationContext(), "Can't CreateoptionMenu: " + e.getMessage(), Toast.LENGTH_LONG).show();
        }
        return super.onCreateOptionsMenu(menu);
    }*/

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
public boolean onOptionsItemSelected(MenuItem item) {

            if (id == R.id.action_wallet_store) {
                ((ApplicationSession) this.getApplication()).setWalletId(0);
                this.appRuntimeMiddleware.getActivity(Activities.CWP_WALLET_RUNTIME_STORE_MAIN);
                NavigateActivity();

                return true;
public boolean onOptionsItemSelected(MenuItem item) {


        } catch (Exception e) {
            this.errorManager.reportUnexpectedPlatformException(PlatformComponents.PLATFORM, UnexpectedPlatformExceptionSeverity.DISABLES_ONE_PLUGIN, e);
            //Matias
            //por ahora lo saco porque no me toma el tag del parametro, vamos a ver como implementarlo
            //Toast.makeText(getApplicationContext(), "Error in OptionsItemSelecte " + e.getMessage(), Toast.LENGTH_LONG).show();
public void onItemSelectedClicked(View v) {
                case CWP_SUP_APP_ALL_DEVELOPER: //Developer manager
                    ((ApplicationSession) this.getApplication()).setWalletId(0);

                    this.activity = this.walletRuntimeMiddleware.getActivity(Activities.CWP_SUP_APP_ALL_DEVELOPER);
                    //execute NavigateWallet to go wallet activity
                    intent = new Intent(this, com.bitdubai.android_core.app.WalletActivity.class);
                    startActivity(intent);
                    break;
                case CWP_WALLET_BASIC_ALL_MAIN: //basic Wallet
                    //go to wallet basic definition
                    ApplicationSession.setWalletId(4);
                    this.walletRuntimeMiddleware.getActivity(Activities.CWP_WALLET_RUNTIME_WALLET_BASIC_WALLET_BITDUBAI_VERSION_1_MAIN);
                    intent = new Intent(this, com.bitdubai.android_core.app.WalletActivity.class);
                    startActivity(intent);
                    break;
                //Bitcoin wallet fragments
                case CWP_WALLET_RUNTIME_BITCOIN_ALL_CONTACTS_SEND:
                    ApplicationSession.setChildId(paramId);
                    this.walletRuntimeMiddleware.getActivity(Activities.CWP_WALLET_RUNTIME_BITCOIN_ALL_CONTACTS_SEND);
                    intent = new Intent(this, com.bitdubai.android_core.app.FragmentActivity.class);

                    startActivity(intent);
public void onItemSelectedClicked(View v) {
                //wallet factory
                case CWP_WALLET_FACTORY_MAIN:

                    this.appRuntimeMiddleware.getActivity(Activities.CWP_WALLET_FACTORY_MAIN);

                    intent = new Intent(this, com.bitdubai.android_core.app.SubAppActivity.class);
                    startActivity(intent);
public void onItemSelectedClicked(View v) {
                //wallet publisher
                case CWP_WALLET_PUBLISHER_MAIN:

                    this.appRuntimeMiddleware.getActivity(Activities.CWP_WALLET_PUBLISHER_MAIN);
                    intent = new Intent(this, com.bitdubai.android_core.app.SubAppActivity.class);
                    startActivity(intent);

                    break;

                case CWP_WALLET_RUNTIME_STORE_MAIN:
                    this.appRuntimeMiddleware.getActivity(Activities.CWP_WALLET_RUNTIME_STORE_MAIN);
                    intent = new Intent(this, com.bitdubai.android_core.app.SubAppActivity.class);
                    startActivity(intent);

                    break;
            }

        } catch (Exception e) {
            this.errorManager.reportUnexpectedPlatformException(PlatformComponents.PLATFORM, UnexpectedPlatformExceptionSeverity.DISABLES_ONE_PLUGIN, e);
            //Esto va a habr que cambiarlo porque no me toma el tag, Matias
            //Toast.makeText(getApplicationContext(), "Error in OptionsItemSelecte " + e.getMessage(), Toast.LENGTH_LONG).show();
        }
public void onBackPressed() {
        ApplicationSession.setActivityId("DesktopActivity");
        ((ApplicationSession) this.getApplication()).setWalletId(0);
        if (activity.getType() != Activities.CWP_WALLET_MANAGER_MAIN) {
            activity = this.appRuntimeMiddleware.getActivity(Activities.CWP_WALLET_MANAGER_MAIN);
            cleanWindows();

            NavigateActivity();
private void cleanWindows() {

            this.PagerAdapter = new PagerAdapter(getSupportFragmentManager(), fragments);
        } catch (Exception e) {
            this.errorManager.reportUnexpectedPlatformException(PlatformComponents.PLATFORM, UnexpectedPlatformExceptionSeverity.DISABLES_ONE_PLUGIN, e);

            Toast.makeText(getApplicationContext(), "Can't Clean Windows: " + e.getMessage(),
                    Toast.LENGTH_LONG).show();
public int getCount() {
                    }

                } catch (Exception ex) {
                    errorManager.reportUnexpectedPlatformException(PlatformComponents.PLATFORM, UnexpectedPlatformExceptionSeverity.DISABLES_ONE_PLUGIN, ex);

                    Toast.makeText(getApplicationContext(), "Error in PagerAdapter GetItem " + ex.getMessage(), Toast.LENGTH_LONG).show();
                }

                return currentFragment;
            } catch (Exception e) {
                errorManager.reportUnexpectedPlatformException(PlatformComponents.PLATFORM, UnexpectedPlatformExceptionSeverity.DISABLES_ONE_PLUGIN, e);

                Toast.makeText(getApplicationContext(), "Can't getItem PageAdpater: " + e.getMessage(), Toast.LENGTH_LONG).show();
                return null;
    private SubApp subApp;
    private Activity activity;
    private Map<Fragments, Fragment> fragments;
    private AppRuntimeManager appRuntimeMiddleware;
    private WalletRuntimeManager walletRuntimeMiddleware;
    private ErrorManager errorManager;


    private CorePlatformContext platformContext;


    private ViewPager pager;
    private TitleBar titleBar; // Comment

    private ViewGroup collection;
    private Platform platform;
    private SearchView mSearchView;


protected void onCreate(Bundle savedInstanceState) {

        try {


            //init runtime app

            //get platform object
            platform = ApplicationSession.getFermatPlatform();
            this.platformContext = platform.getCorePlatformContext();



            Context context = this.getApplicationContext();

            // get instances of Runtime middleware object
            this.appRuntimeMiddleware = ApplicationSession.getAppRuntime();
            this.walletRuntimeMiddleware = ApplicationSession.getwalletRuntime();
            this.errorManager = (ErrorManager) platformContext.getAddon(Addons.ERROR_MANAGER);

            //load wallet UI
            NavigateWallet();

private void NavigateWallet() {
        try
        {
            //get actual activity to execute
            this.activity = walletRuntimeMiddleware.getLasActivity();

            ApplicationSession.setActivityId(activity.getType().getKey());

private void NavigateWallet() {
            }
        }
        catch (Exception e) {
            this.errorManager.reportUnexpectedPlatformException(PlatformComponents.PLATFORM, UnexpectedPlatformExceptionSeverity.DISABLES_ONE_PLUGIN, e);

            Toast.makeText(getApplicationContext(), "Error in NavigateWallet " + e.getMessage(),
                    Toast.LENGTH_LONG).show();
private void initialisePaging() {
        }
        catch (Exception e)
        {
            this.errorManager.reportUnexpectedPlatformException(PlatformComponents.PLATFORM, UnexpectedPlatformExceptionSeverity.DISABLES_ONE_PLUGIN,e);

            Toast.makeText(getApplicationContext(), "Can't Create Tabs: " + e.getMessage(),
                    Toast.LENGTH_LONG).show();
public boolean onCreateOptionsMenu(Menu menu) {
        }
        catch (Exception e) {

            this.errorManager.reportUnexpectedPlatformException(PlatformComponents.PLATFORM, UnexpectedPlatformExceptionSeverity.DISABLES_ONE_PLUGIN,e);

            Toast.makeText(getApplicationContext(), "Error in CleanWindows " + e.getMessage(),
                    Toast.LENGTH_LONG).show();
public boolean onOptionsItemSelected(MenuItem item) {

        }
        catch (Exception e) {
            this.errorManager.reportUnexpectedPlatformException(PlatformComponents.PLATFORM, UnexpectedPlatformExceptionSeverity.DISABLES_ONE_PLUGIN, e);

            Toast.makeText(getApplicationContext(), "Error in OptionsItemSelecte " + e.getMessage(),
                    Toast.LENGTH_LONG).show();
public void onItemSelectedClicked(View v) {

        }
        catch (Exception e) {
            this.errorManager.reportUnexpectedPlatformException(PlatformComponents.PLATFORM, UnexpectedPlatformExceptionSeverity.DISABLES_ONE_PLUGIN, e);


            //Toast.makeText(getApplicationContext(), "Error in OptionsItemSelecte " + e.getMessage(),
protected void onPostResume() {
        if (returningWithResult)
        {
             //Get actual wallet to execute activity result method
            Activity wallet = this.walletRuntimeMiddleware.getLasActivity();

            if (wallet.getType() == Activities.CWP_WALLET_RUNTIME_WALLET_BASIC_WALLET_BITDUBAI_VERSION_1_MAIN)
            {
public void onBackPressed() {
        ApplicationSession.setActivityId("DesktopActivity");
        ((ApplicationSession) this.getApplication()).setWalletId(0);
        if (activity.getType() != Activities.CWP_WALLET_MANAGER_MAIN){
            activity = this.appRuntimeMiddleware.getActivity(Activities.CWP_WALLET_MANAGER_MAIN);
            cleanWindows();

            Intent intent = new Intent(this, SubAppActivity.class);
private void cleanWindows()
        }
        catch (Exception e) {

            this.errorManager.reportUnexpectedPlatformException(PlatformComponents.PLATFORM, UnexpectedPlatformExceptionSeverity.DISABLES_ONE_PLUGIN,e);

            Toast.makeText(getApplicationContext(), "Error in CleanWindows " + e.getMessage(),
                    Toast.LENGTH_LONG).show();
public int getCount() {

                    case CWP_SUB_APP_DEVELOPER_DATABASE_TOOLS:
                        developerPlatform = new com.bitdubai.sub_app.developer.fragment.Platform();
                        developerPlatform.setErrorManager((ErrorManager) platformContext.getAddon(Addons.ERROR_MANAGER));
                        developerPlatform.setToolManager((ToolManager) platformContext.getPlugin(Plugins.BITDUBAI_ACTOR_DEVELOPER));

                        currentFragment = DatabaseToolsFragment.newInstance(position);
                        break;

                    case CWP_SUB_APP_DEVELOPER_LOG_TOOLS:
                        developerPlatform = new com.bitdubai.sub_app.developer.fragment.Platform();
                         developerPlatform.setErrorManager((ErrorManager) platformContext.getAddon(Addons.ERROR_MANAGER));
                        developerPlatform.setToolManager((ToolManager) platformContext.getPlugin(Plugins.BITDUBAI_ACTOR_DEVELOPER));
                        currentFragment = LogToolsFragment.newInstance(0);
                        break;

public int getCount() {

                    case CWP_WALLET_RUNTIME_WALLET_BITCOIN_ALL_BITDUBAI_BALANCE:
                        bitcoinPlatform = new com.bitdubai.reference_niche_wallet.bitcoin_wallet.Platform();
                        bitcoinPlatform.setNicheWalletTypeCryptoWalletManager((CryptoWalletManager) platformContext.getPlugin(Plugins.BITDUBAI_CRYPTO_WALLET_NICHE_WALLET_TYPE));
                        bitcoinPlatform.setErrorManager((ErrorManager)platformContext.getAddon(Addons.ERROR_MANAGER));
                        currentFragment =  BalanceFragment.newInstance(0);
                        break;
                    case CWP_WALLET_RUNTIME_WALLET_BITCOIN_ALL_BITDUBAI_RECEIVE:
                        bitcoinPlatform = new com.bitdubai.reference_niche_wallet.bitcoin_wallet.Platform();
                        bitcoinPlatform.setNicheWalletTypeCryptoWalletManager((CryptoWalletManager) platformContext.getPlugin(Plugins.BITDUBAI_CRYPTO_WALLET_NICHE_WALLET_TYPE));
                        bitcoinPlatform.setErrorManager((ErrorManager) platformContext.getAddon(Addons.ERROR_MANAGER));
                        currentFragment = ReceiveFragment.newInstance(0);
                        break;
                    case CWP_WALLET_RUNTIME_WALLET_BITCOIN_ALL_BITDUBAI_SEND:
                        bitcoinPlatform = new com.bitdubai.reference_niche_wallet.bitcoin_wallet.Platform();
                        bitcoinPlatform.setNicheWalletTypeCryptoWalletManager((CryptoWalletManager) platformContext.getPlugin(Plugins.BITDUBAI_CRYPTO_WALLET_NICHE_WALLET_TYPE));
                        bitcoinPlatform.setErrorManager((ErrorManager) platformContext.getAddon(Addons.ERROR_MANAGER));
                        currentFragment =  SendFragment.newInstance(0);
                        break;

                    case CWP_WALLET_RUNTIME_WALLET_BITCOIN_ALL_BITDUBAI_TRANSACTIONS:
                        bitcoinPlatform = new com.bitdubai.reference_niche_wallet.bitcoin_wallet.Platform();
                        bitcoinPlatform.setNicheWalletTypeCryptoWalletManager((CryptoWalletManager) platformContext.getPlugin(Plugins.BITDUBAI_CRYPTO_WALLET_NICHE_WALLET_TYPE));
                        bitcoinPlatform.setErrorManager((ErrorManager) platformContext.getAddon(Addons.ERROR_MANAGER));
                        currentFragment =  TransactionsFragment.newInstance(0);

                        break;
                    case CWP_WALLET_RUNTIME_WALLET_BITCOIN_ALL_BITDUBAI_CONTACTS:
                        bitcoinPlatform = new com.bitdubai.reference_niche_wallet.bitcoin_wallet.Platform();
                        bitcoinPlatform.setNicheWalletTypeCryptoWalletManager((CryptoWalletManager) platformContext.getPlugin(Plugins.BITDUBAI_CRYPTO_WALLET_NICHE_WALLET_TYPE));
                        bitcoinPlatform.setErrorManager((ErrorManager) platformContext.getAddon(Addons.ERROR_MANAGER));
                        currentFragment =  ContactsFragment.newInstance(0);
                        break;

public int getCount() {
            }
            catch(Exception ex)
            {
                errorManager.reportUnexpectedPlatformException(PlatformComponents.PLATFORM, UnexpectedPlatformExceptionSeverity.DISABLES_ONE_PLUGIN, ex);

                Toast.makeText(getApplicationContext(), "Error in PagerAdapter GetItem " + ex.getMessage(),
                        Toast.LENGTH_LONG).show();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					if (node.getTypedef() == null)
					{
						PDefinition typedef = question.env.findType(node.getTypeName(), node.getLocation().getModule());
						node.setTypedef(typedef.clone());
					}

					if (node.getTypedef() != null)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void update(double dt) {
		if (playingMovementAnimation) {
			movingUnit.getOwner().updateVisibility(map); // TODO move this into unit
			if (!movingUnit.isMoving()) {
				if (movingUnit != selectedUnit) {
					selectUnit(selectedUnit); // reselect the selected unit.
				} else { selectUnit(null); }
				movingUnit = null;
				playingMovementAnimation = false;
				if (postMoveAction != null) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public Result(int caseId, int statusId, String comment, Float elapsed) {
    public String getComment() { return this.comment; }

    public String getElapsedTimeString() {
        return Math.max(1, elapsed.intValue()) + "s";
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public double availability() {
        return (Subscriber<? super Payload> child) -> {
            child.onSubscribe(new Subscription() {

                final AtomicBoolean started = new AtomicBoolean(false);
                volatile StreamInputSubscriber streamInputSubscriber;
                volatile UnicastSubject<Frame> writer;
public double availability() {

                @Override
                public void request(long n) {
                    if(n <= 0) {
                        return;
                    }
public void error(Throwable e) {

                @Override
                public void cancel() {
                    synchronized(Requester.this) {
                        streamInputMap.remove(streamId);
                    }
                    if (!streamInputSubscriber.terminated.get()) {
                        writer.onNext(Frame.Cancel.from(streamId));
                    }
                    streamInputSubscriber.parentSubscription.cancel();
                }

            });
public void cancel() {
        return (Subscriber<? super Payload> child) -> {
            child.onSubscribe(new Subscription() {

                AtomicBoolean started = new AtomicBoolean(false);
                volatile StreamInputSubscriber streamInputSubscriber;
                volatile UnicastSubject<Frame> writer;
public void cancel() {

                @Override
                public void request(long n) {
                    if(n <= 0) {
                        return;
                    }
public void error(Throwable e) {

                @Override
                public void cancel() {
                    synchronized(Requester.this) {
                        streamInputMap.remove(streamId);
                    }
                    if (!streamInputSubscriber.terminated.get()) {
                        writer.onNext(Frame.Cancel.from(streamId));
                    }
                    streamInputSubscriber.parentSubscription.cancel();
                    if (payloadsSubscription != null) {
                        if (!payloadsSubscription.compareAndSet(null, EmptySubscription.INSTANCE)) {
                            // unsubscribe it if it already exists
public void cancel() {
            child.onSubscribe(new Subscription() {

                final AtomicBoolean started = new AtomicBoolean(false);
                volatile StreamInputSubscriber streamInputSubscriber;
                volatile UnicastSubject<Frame> writer;

                @Override
                public void request(long n) {
                    if (n > 0 && started.compareAndSet(false, true)) {
                        // Response frames for this Stream
                        UnicastSubject<Frame> transportInputSubject = UnicastSubject.create();
                        synchronized(Requester.this) {
public void request(long n) {
                            0,
                            null,
                            null,
                            writer,
                            child,
                            this::cancel
                        );
public void error(Throwable e) {

                @Override
                public void cancel() {
                    if (!streamInputSubscriber.terminated.get()) {
                        Frame cancelFrame = Frame.Cancel.from(streamId);
                        connection.addOutput(cancelFrame, new Completable() {
                            @Override
public void error(Throwable e) {
                    synchronized(Requester.this) {
                        streamInputMap.remove(streamId);
                    }
                    streamInputSubscriber.parentSubscription.cancel();
                }
            });
        };

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

import io.reactivesocket.LatchedCompletable;
import io.reactivesocket.Payload;
import io.reactivesocket.TestConnection;
import io.reactivesocket.rx.Completable;
import io.reactivex.subscribers.TestSubscriber;
import io.reactivex.Observable;
import io.reactivex.subjects.ReplaySubject;

public class RequesterTest
{
	final static Consumer<Throwable> ERROR_HANDLER = Throwable::printStackTrace;

	@Test(timeout=2000)
    public void testRequestResponseSuccess() throws InterruptedException {
        TestConnection conn = establishConnection();
        ReplaySubject<Frame> requests = captureRequests(conn);
public void testRequestResponseSuccess() throws InterruptedException {
        assertEquals(0, one.getStreamId());// SETUP always happens on 0
        assertEquals("", byteToString(one.getData()));
        assertEquals(FrameType.SETUP, one.getType());
        
        Frame two = requested.get(1);
        assertEquals(2, two.getStreamId());// need to start at 2, not 0
        assertEquals("hello", byteToString(two.getData()));
        assertEquals(FrameType.REQUEST_RESPONSE, two.getType());
        
        // now emit a response to ensure the Publisher receives and completes
        conn.toInput.send(utf8EncodedResponseFrame(2, FrameType.NEXT_COMPLETE, "world"));

public void testRequestStreamRequestNReplenishing() {

    /* **********************************************************************************************/

	private TestConnection establishConnection() {
		return new TestConnection();
	}

    private ReplaySubject<Frame> captureRequests(TestConnection conn) {
        ReplaySubject<Frame> rs = ReplaySubject.create();
        rs.forEach(i -> System.out.println("capturedRequest => " + i));
        conn.write.add(rs::onNext);
        return rs;
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public String getPrefix() {
	 */
	public void setPrefix(String prefix) {
		this.prefix = prefix;
		if (prefix != null) {
			this.prefixPattern = Pattern.compile(prefix);
		}
	}

	/**
public String getPostfix() {
	 */
	public void setPostfix(String postfix) {
		this.postfix = postfix;
		if (postfix != null) {
			this.postfixPattern = Pattern.compile(postfix);
		}
	}

	/**
public ZestAssignRegexDelimiters deepCopy() {
	 */
	private String getTokenValue(String str) {
		if (str != null) {
			Matcher prefixMatcher = this.prefixPattern.matcher(str);
			if (prefixMatcher.find()) {
				int tokenStart = prefixMatcher.end();
private String getTokenValue(String str) {
		return null;
	}

	
	@Override
	public String assign(ZestResponse response, ZestRuntime runtime) throws ZestAssignFailException {
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import org.junit.Test;
import org.mozilla.zest.core.v1.ZestAssignFailException;
import org.mozilla.zest.core.v1.ZestAssignRegexDelimiters;
import org.mozilla.zest.core.v1.ZestResponse;


/**
public void testExceptions() throws Exception {
		}
		
	}

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public PType caseADefPatternBind(ADefPatternBind node,
			} else
			{
				ASetBind setbind = (ASetBind) node.getBind();
				ASetType settype = question.assistantFactory.createPTypeAssistant().getSet(setbind.getSet().apply(THIS, question));
				if (!question.assistantFactory.getTypeComparator().compatible(type, settype.getSetof()))
				{
					TypeCheckerErrors.report(3199, "Set bind not compatible with expression", node.getBind().getLocation(), node.getBind());
					TypeCheckerErrors.detail2("Bind", settype.getSetof(), "Exp", type);
				}
			}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    android:layout_toRightOf="@+id/recording_coverart"
                    android:layout_toEndOf="@+id/recording_coverart" />

                <TextView
                    android:id="@+id/hls_percent_complete"
                    android:layout_margin="@dimen/margin"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:textColor="@android:color/white"
                    android:layout_alignParentEnd="true"
                    android:layout_alignParentRight="true" />

            </RelativeLayout>

                    android:max="100"
                    android:visibility="gone" />

                <TextView
                    android:id="@+id/hls_percent_complete"
                    android:layout_margin="@dimen/margin"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:textColor="@android:color/white"
                    android:layout_alignParentEnd="true"
                    android:layout_alignParentRight="true" />

            </RelativeLayout>

            <TextView
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public DragonBot() throws Exception {
            }

            executorService.shutdown();

            executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
        }

public void start() throws Exception {

        getLogger().info("Enabling " + this.plugins.size() + " " + (this.plugins.size() == 1 ? "plugin" : "plugins") +"...");

        this.plugins.forEach(plugin -> {
            getLogger().info("Enabling " + plugin.getInfo().getName() + "...");

            plugin.onEnable();

            getLogger().info("Enabled " + plugin.getInfo().getName() + " v" + plugin.getInfo().getVersion() + "!");
        });

        getLogger().info(this.plugins.size() + " plugins enabled!");

        if (!this.name.equals("") && !this.config.getAuth().equals("")) {
public void run() {

                leaveChannel();

                getLogger().info("Disabling plugins...");

                if (plugins != null) {
                    for (BotPlugin plugin : plugins) {
                        if (plugin == null) {
                            continue;
                        }

                        getLogger().info("Disabling " + plugin.getInfo().getName() + " " + plugin.getInfo().getVersion() + "!");
                        plugin.onDisable();
                        getLogger().info(plugin.getInfo().getName() + " " + plugin.getInfo().getVersion() + " disabled!");
                    }
                }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public MethodCoverageData()
      nonShadowedPaths = Collections.emptyList();
      nodesReached = new ThreadLocal<List<Node>>();
      previousNodeIndex = new ThreadLocal<Integer>();
   }

   public void buildPaths(int lastExecutableLine, @Nonnull NodeBuilder nodeBuilder)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void run() {
                                            currentSlot.getDestinationOfMessagesInSlot());
                                } else {
                                    currentSlot.setSlotInActive();
                                    deleteSlot(currentSlot);
                                }
                            }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public CreateContainerCmd withNetworkMode(String networkMode) {
    public CreateContainerCmd withOomKillDisable(Boolean oomKillDisable) {
        checkNotNull(oomKillDisable, "oomKillDisable was not specified");
        this.oomKillDisable = oomKillDisable;
        return null;
    }

    @Override
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import org.apache.flink.api.common.ProgramDescription;
import org.apache.flink.api.java.ExecutionEnvironment;
import org.gradoop.examples.utils.ExampleOutput;
import org.gradoop.flink.algorithms.fsm.ccs.CategoryCharacteristicSubgraphs;
import org.gradoop.flink.algorithms.fsm.common.config.FSMConfig;
import org.gradoop.flink.model.api.functions.VertexAggregateFunction;
import org.gradoop.flink.model.impl.GraphCollection;
import org.gradoop.flink.model.impl.LogicalGraph;
import static org.gradoop.flink.algorithms.btgs.BusinessTransactionGraphs.SUPERCLASS_VALUE_MASTER;
import static org.gradoop.flink.algorithms.btgs.BusinessTransactionGraphs.SUPERCLASS_VALUE_TRANSACTIONAL;
import static org.gradoop.flink.algorithms.btgs.BusinessTransactionGraphs.SUPERTYPE_KEY;
import static org.gradoop.flink.algorithms.fsm.ccs.CategoryCharacteristicSubgraphs.CATEGORY_KEY;

/**
 * Example workflow of paper "Scalable Business Intelligence with Graph
import org.gradoop.common.model.impl.properties.PropertyValueUtils;
import org.gradoop.examples.AbstractRunner;
import org.gradoop.flink.algorithms.btgs.BusinessTransactionGraphs;
import org.gradoop.flink.algorithms.fsm.common.functions.SubgraphDecoder;
import org.gradoop.flink.algorithms.fsm.tfsm.TransactionalFSM;
import org.gradoop.flink.algorithms.fsm.common.config.FSMConfig;
import org.gradoop.flink.io.impl.dot.DOTDataSink;
import org.gradoop.flink.io.impl.json.JSONDataSource;
import org.gradoop.flink.model.api.functions.TransformationFunction;
private static GraphHead addSupportToGraphHead(GraphHead current,
    GraphHead transformed) {

    BigDecimal support = current
      .getPropertyValue(SubgraphDecoder.FREQUENCY_KEY)
      .getBigDecimal().setScale(2, ROUND_HALF_UP);

    String newLabel = current.getLabel() + " (" + support + ")";
public static void main(String[] args) throws Exception {
    FSMConfig fsmConfig = new FSMConfig(0.6f, true);

    GraphCollection frequentSubgraphs = btgs
      .callForCollection(new TransactionalFSM(fsmConfig));

    // (7) Check, if frequent subgraph contains master data

/*
 * This file is part of Gradoop.
 *
 * Gradoop is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Gradoop is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.ccs;

import org.apache.flink.api.java.DataSet;
import org.apache.flink.api.java.operators.FilterOperator;
import org.apache.flink.api.java.operators.IterativeDataSet;
import org.apache.flink.api.java.typeutils.TypeExtractor;
import org.gradoop.flink.algorithms.fsm.ccs.functions.CCSSingleEdgeEmbeddings;
import org.gradoop.flink.algorithms.fsm.ccs.functions.CCSSubgraphDecoder;
import org.gradoop.flink.algorithms.fsm.ccs.functions.CCSSubgraphOnly;
import org.gradoop.flink.algorithms.fsm.ccs.functions.CCSWrapInSubgraphEmbeddings;
import org.gradoop.flink.algorithms.fsm.ccs.functions.CategoryEdgeLabels;
import org.gradoop.flink.algorithms.fsm.ccs.functions.CategoryFrequent;
import org.gradoop.flink.algorithms.fsm.ccs.functions.CategoryFrequentAndInteresting;
import org.gradoop.flink.algorithms.fsm.ccs.functions.CategoryGraphCounts;
import org.gradoop.flink.algorithms.fsm.ccs.functions.CategoryMinFrequencies;
import org.gradoop.flink.algorithms.fsm.ccs.functions.CategoryVertexLabels;
import org.gradoop.flink.algorithms.fsm.ccs.functions.CategoryWithCount;
import org.gradoop.flink.algorithms.fsm.ccs.functions.IsCharacteristic;
import org.gradoop.flink.algorithms.fsm.ccs.functions.LabelOnly;
import org.gradoop.flink.algorithms.fsm.ccs.functions.ToCCSGraph;
import org.gradoop.flink.algorithms.fsm.ccs.pojos.CCSGraph;
import org.gradoop.flink.algorithms.fsm.ccs.tuples.CCSSubgraph;
import org.gradoop.flink.algorithms.fsm.ccs.tuples.CCSSubgraphEmbeddings;
import org.gradoop.flink.algorithms.fsm.common.TransactionalFSMBase;
import org.gradoop.flink.algorithms.fsm.common.config.Constants;
import org.gradoop.flink.algorithms.fsm.common.config.FSMConfig;
import org.gradoop.flink.algorithms.fsm.common.config.IterationStrategy;
import org.gradoop.flink.algorithms.fsm.common.functions.MinEdgeCount;
import org.gradoop.flink.algorithms.fsm.common.functions.WithoutInfrequentEdgeLabels;
import org.gradoop.flink.algorithms.fsm.common.functions.WithoutInfrequentVertexLabels;
import org.gradoop.flink.algorithms.fsm.common.functions.IsResult;
import org.gradoop.flink.model.impl.GraphCollection;
import org.gradoop.flink.model.impl.GraphTransactions;
import org.gradoop.flink.model.impl.functions.utils.First;
import org.gradoop.flink.representation.transactional.GraphTransaction;
import org.gradoop.flink.util.GradoopFlinkConfig;

import java.util.Map;

/**
 * abstract superclass of different implementations of the gSpan frequent
 * subgraph mining algorithm as Gradoop operator
 */
public class CategoryCharacteristicSubgraphs
  extends TransactionalFSMBase<CCSGraph, CCSSubgraph, CCSSubgraphEmbeddings> {

  /**
   * Property key to store a category association.
   */
  public static final String CATEGORY_KEY = "_category";

  /**
   * minimum frequency for subgraphs to be considered to be frequent
   */
  private DataSet<Map<String, Long>> categoryCounts;

  /**
   * minimum frequency for subgraphs to be considered to be frequent
   */
  private DataSet<Map<String, Long>> categoryMinFrequencies;

  /**
   * interstingness threshold
   */
  private final float minInterestingness;

  /**
   * constructor
   * @param fsmConfig frequent subgraph mining configuration
   * @param minInterestingness minInterestingness threshold
   *
   */
  public CategoryCharacteristicSubgraphs(
    FSMConfig fsmConfig, float minInterestingness) {
    super(fsmConfig);
    this.minInterestingness = minInterestingness;
  }

  @Override
  public GraphCollection execute(GraphCollection collection)  {
    GradoopFlinkConfig gradoopFlinkConfig = collection.getConfig();

    // create transactions from graph collection
    GraphTransactions transactions = collection
      .toTransactions();

    transactions = execute(transactions);

    return GraphCollection.fromTransactions(
      new GraphTransactions(
        transactions.getTransactions(), gradoopFlinkConfig));
  }

  /**
   * Encodes the search space before executing FSM.
   *
   * @param transactions search space as Gradoop graph transactions
   *
   * @return frequent subgraphs as Gradoop graph transactions
   */
  public GraphTransactions execute(GraphTransactions transactions) {
    DataSet<CCSGraph> graphs = transactions
      .getTransactions()
      .map(new ToCCSGraph())
      .returns(TypeExtractor.getForClass(CCSGraph.class));

    GradoopFlinkConfig gradoopConfig = transactions.getConfig();

    DataSet<GraphTransaction> dataSet = execute(graphs, gradoopConfig);

    return new GraphTransactions(dataSet, gradoopConfig);
  }

  /**
   * Core mining method.
   *
   * @param graphs search space
   * @param gradoopConfig Gradoop Flink configuration
   *
   * @return frequent subgraphs
   */
  public DataSet<GraphTransaction> execute(
    DataSet<CCSGraph> graphs, GradoopFlinkConfig gradoopConfig) {

    setCategoryCounts(graphs);

    setMinFrequencies();

    if (fsmConfig.isPreprocessingEnabled()) {
      graphs = preProcess(graphs);
    }

    DataSet<CCSSubgraphEmbeddings>
      embeddings = graphs
      .flatMap(new CCSSingleEdgeEmbeddings(fsmConfig));

    DataSet<CCSSubgraph> characteristicSubgraphs;

    if (fsmConfig.getIterationStrategy() == IterationStrategy.LOOP_UNROLLING) {
      characteristicSubgraphs = mineWithLoopUnrolling(graphs, embeddings);
    } else {
      characteristicSubgraphs = mineWithBulkIteration(graphs, embeddings);
    }

    if (fsmConfig.getMinEdgeCount() > 1) {
      characteristicSubgraphs = characteristicSubgraphs
        .filter(new MinEdgeCount<CCSSubgraph>(fsmConfig));
    }

    return characteristicSubgraphs
      .map(new CCSSubgraphDecoder(gradoopConfig));
  }

  /**
   * Determines the graph count for each category.
   *
   * @param graphs search space
   */
  private void setCategoryCounts(DataSet<CCSGraph> graphs) {
    categoryCounts = graphs
      .map(new CategoryWithCount())
      .groupBy(0)
      .sum(1)
      .reduceGroup(new CategoryGraphCounts());
  }

  /**
   * Determines the min frequency per category based on category graph count
   * and support threshold.
   **/
  private void setMinFrequencies() {
    categoryMinFrequencies = categoryCounts
      .map(new CategoryMinFrequencies(fsmConfig));
  }

  /**
   * Removes vertices and edges showing labels that are infrequent in all
   * categories.
   *
   * @param graphs graph collection
   * @return processed graph collection
   */
  private DataSet<CCSGraph> preProcess(DataSet<CCSGraph> graphs) {
    DataSet<String> frequentVertexLabels = graphs
      .flatMap(new CategoryVertexLabels())
      .groupBy(0, 1)
      .sum(2)
      .filter(new CategoryFrequent())
      .withBroadcastSet(categoryMinFrequencies, Constants.MIN_FREQUENCY)
      .map(new LabelOnly())
      .distinct();

    graphs = graphs
      .map(new WithoutInfrequentVertexLabels<CCSGraph>())
      .withBroadcastSet(
        frequentVertexLabels, Constants.FREQUENT_VERTEX_LABELS);

    DataSet<String> frequentEdgeLabels = graphs
      .flatMap(new CategoryEdgeLabels())
      .groupBy(0, 1)
      .sum(2)
      .filter(new CategoryFrequent())
      .withBroadcastSet(categoryMinFrequencies, Constants.MIN_FREQUENCY)
      .map(new LabelOnly())
      .distinct();

    graphs = graphs
      .map(new WithoutInfrequentEdgeLabels<CCSGraph>())
      .withBroadcastSet(frequentEdgeLabels, Constants.FREQUENT_EDGE_LABELS);

    return graphs;
  }

  /**
   * Mining core based on loop unrolling.
   *
   * @param graphs search space
   * @param embeddings 1-edge embeddings
   * @return frequent subgraphs
   */
  private DataSet<CCSSubgraph> mineWithLoopUnrolling(DataSet<CCSGraph> graphs,
    DataSet<CCSSubgraphEmbeddings> embeddings) {

    DataSet<CCSSubgraph> categoryFrequentSubgraphs =
      getCategoryFrequentSubgraphs(embeddings);

    DataSet<CCSSubgraph> characteristicSubgraphs =
      getCharacteristicSubgraphs(categoryFrequentSubgraphs);

    if (fsmConfig.getMaxEdgeCount() > 1) {
      for (int k = fsmConfig.getMinEdgeCount();
           k < fsmConfig.getMaxEdgeCount(); k++) {

        DataSet<CCSSubgraph> frequentSubgraphs = categoryFrequentSubgraphs
          .groupBy(0)
          .reduceGroup(new First<CCSSubgraph>());

        embeddings = growEmbeddingsOfFrequentSubgraphs(
          graphs, embeddings, frequentSubgraphs);

        categoryFrequentSubgraphs = getCategoryFrequentSubgraphs(embeddings);

        characteristicSubgraphs = characteristicSubgraphs
          .union(getCharacteristicSubgraphs(categoryFrequentSubgraphs));
      }

    }
    return characteristicSubgraphs;
  }

  /**
   * Mining core based on bulk iteration.
   *
   * @param graphs search space
   * @param embeddings 1-edge embeddings
   * @return frequent subgraphs
   */
  private DataSet<CCSSubgraph> mineWithBulkIteration(
    DataSet<CCSGraph> graphs, DataSet<CCSSubgraphEmbeddings> embeddings) {

    // ITERATION HEAD
    IterativeDataSet<CCSSubgraphEmbeddings> iterative = embeddings
      .iterate(fsmConfig.getMaxEdgeCount());

    // ITERATION BODY

    // get frequent subgraphs
    DataSet<CCSSubgraphEmbeddings> parentEmbeddings = iterative
      .filter(new IsResult<CCSSubgraphEmbeddings>(false));

    DataSet<CCSSubgraph> categoryFrequentSubgraphs =
      getCategoryFrequentSubgraphs(parentEmbeddings);

    DataSet<CCSSubgraph> frequentSubgraphs = categoryFrequentSubgraphs
      .groupBy(0)
      .reduceGroup(new First<CCSSubgraph>());

    parentEmbeddings =
      filterByFrequentSubgraphs(parentEmbeddings, frequentSubgraphs);

    DataSet<CCSSubgraphEmbeddings> childEmbeddings =
      growEmbeddingsOfFrequentSubgraphs(
        graphs, parentEmbeddings, frequentSubgraphs
      );

    DataSet<CCSSubgraphEmbeddings> resultIncrement =
      getCharacteristicSubgraphs(categoryFrequentSubgraphs)
        .map(new CCSWrapInSubgraphEmbeddings());

    DataSet<CCSSubgraphEmbeddings> resultAndEmbeddings = iterative
      .filter(new IsResult<CCSSubgraphEmbeddings>(true))
      .union(resultIncrement)
      .union(childEmbeddings);

    // ITERATION FOOTER

    return iterative
      .closeWith(resultAndEmbeddings, childEmbeddings)
      .filter(new IsResult<CCSSubgraphEmbeddings>(true))
      .map(new CCSSubgraphOnly());
  }

  /**
   * Returns characteristic from category frequent subgraphs.
   *
   * @param frequentSubgraphs subgraphs, frequent in at least one category
   * @return characteristic subgraphs
   */
  private FilterOperator<CCSSubgraph> getCharacteristicSubgraphs(
    DataSet<CCSSubgraph> frequentSubgraphs) {
    return frequentSubgraphs
      .filter(new IsCharacteristic());
  }

  /**
   * Determines frequent subgraphs in a set of embeddings.
   *
   * @param embeddings set of embeddings
   * @return frequent subgraphs
   */
  private DataSet<CCSSubgraph> getCategoryFrequentSubgraphs(
    DataSet<CCSSubgraphEmbeddings> embeddings) {
    return embeddings
      .map(new CCSSubgraphOnly())
      .groupBy(0, 3)
      .sum(1)
      .groupBy(0)
      .reduceGroup(new CategoryFrequentAndInteresting(minInterestingness))
      .withBroadcastSet(categoryCounts, Constants.GRAPH_COUNT)
      .withBroadcastSet(categoryMinFrequencies, Constants.MIN_FREQUENCY);
  }

  @Override
  public String getName() {
    return this.getClass().getSimpleName();
  }

}
/*
 * This file is part of Gradoop.
 *
 * Gradoop is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Gradoop is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common;

import org.apache.flink.api.java.DataSet;
import org.gradoop.flink.algorithms.fsm.common.config.Constants;
import org.gradoop.flink.algorithms.fsm.common.config.FSMConfig;
import org.gradoop.flink.algorithms.fsm.common.config.FilterStrategy;
import org.gradoop.flink.algorithms.fsm.common.config.GrowthStrategy;
import org.gradoop.flink.algorithms.fsm.common.functions.CanonicalLabelOnly;
import org.gradoop.flink.algorithms.fsm.common.functions.SubgraphIsFrequent;
import org.gradoop.flink.algorithms.fsm.common.pojos.FSMGraph;
import org.gradoop.flink.algorithms.fsm.common.tuples.Subgraph;
import org.gradoop.flink.algorithms.fsm.common.tuples.SubgraphEmbeddings;
import org.gradoop.flink.algorithms.fsm.common.functions.GraphId;
import org.gradoop.flink.algorithms.fsm.common.functions.MergeEmbeddings;
import org.gradoop.flink.algorithms.fsm.common.functions.PatternGrowth;
import org.gradoop.flink.model.api.operators.UnaryCollectionToCollectionOperator;
import org.gradoop.flink.model.impl.functions.utils.LeftSide;


/**
 * Superclass of transactional FSM and derivatives.
 *
 * @param <G> graph type
 * @param <S> subgraph type
 * @param <SE> subgraph embeddings type
 */
public abstract class TransactionalFSMBase
  <G extends FSMGraph, S extends Subgraph, SE extends SubgraphEmbeddings>
  implements UnaryCollectionToCollectionOperator {

  /**
   * frequent subgraph mining configuration
   */
  protected final FSMConfig fsmConfig;

  /**
   * Constructor.
   *
   * @param fsmConfig FSM configuration
   */
  public TransactionalFSMBase(FSMConfig fsmConfig) {
    this.fsmConfig = fsmConfig;
  }

  /**
   * Grows children of embeddings of frequent subgraphs.
   *
   * @param graphs search space
   * @param parents parent embeddings
   * @param frequentSubgraphs frequent subgraphs
   * @return child embeddings
   */
  protected DataSet<SE> growEmbeddingsOfFrequentSubgraphs(
    DataSet<G> graphs, DataSet<SE> parents,
    DataSet<S> frequentSubgraphs) {
    parents = filterByFrequentSubgraphs(parents, frequentSubgraphs);

    parents = parents
      .groupBy(0)
      .reduceGroup(new MergeEmbeddings<SE>());

    if (fsmConfig.getGrowthStrategy() == GrowthStrategy.JOIN) {
      parents = parents
        .join(graphs)
        .where(0).equalTo(new GraphId<G>())
        .with(new PatternGrowth<G, SE>(fsmConfig));
    } else {
      parents = parents
        .flatMap(new PatternGrowth<G, SE>(fsmConfig));
    }

    return parents;
  }

  /**
   * Filter a set of embeddings to such representing a frequent subgraph.
   *
   * @param embeddings set of embeddings
   * @param frequentSubgraphs frequent subgraphs
   *
   * @return embeddings representing frequent subgraphs
   */
  protected DataSet<SE> filterByFrequentSubgraphs(
    DataSet<SE> embeddings,
    DataSet<S> frequentSubgraphs) {

    if (fsmConfig.getFilterStrategy() == FilterStrategy.BROADCAST_FILTER) {
      return embeddings
        .filter(new SubgraphIsFrequent<SE>())
        .withBroadcastSet(
          frequentSubgraphs
            .map(new CanonicalLabelOnly<S>()),
          Constants.FREQUENT_SUBGRAPHS
        );
    } else if (fsmConfig.getFilterStrategy() == FilterStrategy.BROADCAST_JOIN) {
      return embeddings
        .joinWithTiny(frequentSubgraphs)
        .where(2).equalTo(0) // on canonical label
        .with(new LeftSide<SE, S>());
    } else {
      return embeddings
        .join(frequentSubgraphs)
        .where(2).equalTo(0) // on canonical label
        .with(new LeftSide<SE, S>());
    }
  }
}
/*
 * This file is part of Gradoop.
 *
 * Gradoop is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Gradoop is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * classes related canonical adjacency matrix labels
 */

package org.gradoop.flink.algorithms.fsm.common.canonicalization.cam;
/*
 * This file is part of Gradoop.
 *
 * Gradoop is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Gradoop is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.canonicalization.gspan;

/**
 * Extension of an embedding.
 */
public class Extension implements Comparable<Extension> {

  /**
   * separator between vertex time and label
   */
  private static final char TIME_LABEL_SEPARATOR = ':';
  /**
   * outgoing edge start
   */
  private static final char OUTGOING_CHAR = '>';
  /**
   * incoming edge start
   */
  private static final char INCOMING_CHAR = '<';
  /**
   * edge start of undirected and end of all edges
   */
  private static final char EDGE_CHAR = '-';

  /**
   * extension start time
   */
  private final int fromTime;
  /**
   * extension start label
   */
  private final String fromLabel;
  /**
   * outgoing or incoming traversal
   */
  private final boolean outgoing;
  /**
   * edge label
   */
  private final String edgeLabel;
  /**
   * traversal end time
   */
  private final int toTime;
  /**
   * traversal end label
   */
  private final String toLabel;
  /**
   * directed mode
   */
  private final boolean directed;

  /**
   * Constructor
   * @param fromTime    extension start time
   * @param fromLabel   extension start label
   * @param outgoing    outgoing or incoming traversal
   * @param edgeLabel   edge label
   * @param toTime      traversal end time
   * @param toLabel     traversal end label
   * @param directed    directed mode
   */
  public Extension(int fromTime, String fromLabel, boolean outgoing,
    String edgeLabel, int toTime, String toLabel, boolean directed) {
    this.fromTime = fromTime;
    this.fromLabel = fromLabel;
    this.outgoing = outgoing;
    this.edgeLabel = edgeLabel;
    this.toTime = toTime;
    this.toLabel = toLabel;
    this.directed = directed;
  }

  @Override
  public int compareTo(Extension that) {

    int comparison;

    boolean thisBackward = this.toTime <= this.fromTime;
    boolean thisForward = !thisBackward;
    boolean thatBackward = that.toTime <= that.fromTime;
    boolean thatForward = !thatBackward;

    if (thisBackward && thatForward) {
      comparison = -1;
    } else if (thisForward && thatBackward) {
      comparison = 1;
    } else if (thisBackward) {
      // both backward

      if (this.toTime < that.toTime) {
        comparison = -1;
      } else if (this.toTime > that.toTime) {
        comparison = 1;
      } else {
        comparison = compareEdgeDirectionAndLabel(that);
      }

    } else {
      // both forward

      if (this.fromTime > that.fromTime) {
        comparison = -1;
      } else if (this.fromTime < that.fromTime) {
        comparison = 1;
      } else {
        comparison = compareEdgeDirectionAndLabel(that);

        if (comparison == 0) {
          comparison = this.toLabel.compareTo(that.toLabel);
        }
      }
    }

    return comparison;
  }

  /**
   * compares edge direction and label of two extensions
   *
   * @param that other extension
   *
   * @return comparison result
   */
  private int compareEdgeDirectionAndLabel(Extension that) {
    int comparison;

    if (!directed || this.outgoing == that.outgoing) {
      comparison = this.edgeLabel.compareTo(that.edgeLabel);
    } else if (this.outgoing) {
      comparison = -1;
    } else {
      comparison = 1;
    }

    return comparison;
  }

  @Override
  public String toString() {
    return String.valueOf(fromTime) + TIME_LABEL_SEPARATOR + fromLabel +
      (directed ? (outgoing ? OUTGOING_CHAR : INCOMING_CHAR) : EDGE_CHAR) +
      edgeLabel + EDGE_CHAR +
      toTime + TIME_LABEL_SEPARATOR + toLabel;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }

    Extension extension = (Extension) o;

    if (fromTime != extension.fromTime) {
      return false;
    }
    if (outgoing != extension.outgoing) {
      return false;
    }
    if (toTime != extension.toTime) {
      return false;
    }
    if (fromLabel != null ? !fromLabel.equals(extension.fromLabel) :
      extension.fromLabel != null) {
      return false;
    }
    if (edgeLabel != null ? !edgeLabel.equals(extension.edgeLabel) :
      extension.edgeLabel != null) {
      return false;
    }
    return toLabel != null ? toLabel.equals(extension.toLabel) :
      extension.toLabel == null;

  }

  @Override
  public int hashCode() {
    int result = fromTime;
    result = 31 * result + (fromLabel != null ? fromLabel.hashCode() : 0);
    result = 31 * result + (outgoing ? 1 : 0);
    result = 31 * result + (edgeLabel != null ? edgeLabel.hashCode() : 0);
    result = 31 * result + toTime;
    result = 31 * result + (toLabel != null ? toLabel.hashCode() : 0);
    return result;
  }
}
/*
 * This file is part of Gradoop.
 *
 * Gradoop is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Gradoop is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.canonicalization.gspan;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;

import java.util.Collection;
import java.util.List;
import java.util.Map;

/**
 * Mapping between an embedding and a DFS code.
 */
public class Mapping {

  /**
   * Initial vertex discovery times.
   */
  private final Map<Integer, Integer> vertexTimes;
  /**
   * Rightmost path.
   */
  private final List<Integer> rightmostPath;
  /**
   * Included edges.
   */
  private final Collection<Integer> edgeCoverage;

  /**
   * Constructor.
   *
   * @param startVertex first visited vertex
   */
  public Mapping(Integer startVertex) {
    this.vertexTimes = Maps.newHashMap();
    this.vertexTimes.put(startVertex, 0);
    this.rightmostPath = Lists.newArrayList(startVertex);
    this.edgeCoverage = Sets.newHashSet();
  }

  /**
   * Constructor.
   *
   * @param vertexTimes existing vertex times
   * @param rightmostPath existing rightmost path
   * @param edgeCoverage existing edge set
   */
  private Mapping(Map<Integer, Integer> vertexTimes,
    List<Integer> rightmostPath, Collection<Integer> edgeCoverage) {

    this.vertexTimes = vertexTimes;
    this.rightmostPath = rightmostPath;
    this.edgeCoverage = edgeCoverage;
  }

  public int getRightmostVertexId() {
    return rightmostPath.get(rightmostPath.size() - 1);
  }

  /**
   * Convenience method to check edge containment.
   *
   * @param edgeId edge id to check
   *
   * @return true, if contained
   */
  public boolean containsEdge(int edgeId) {
    return edgeCoverage.contains(edgeId);
  }

  /**
   * Determines the role of a vertex in an embedding.
   *
   * @param vertexId vertex to check
   *
   * @return role
   */
  public int getRole(int vertexId) {
    int role;

    if (vertexId == getRightmostVertexId()) {
      role = VertexRole.IS_RIGHTMOST;
    } else if (rightmostPath.contains(vertexId)) {
      role = VertexRole.ON_RIGHTMOST_PATH;
    } else if (vertexTimes.containsKey(vertexId)) {
      role = VertexRole.CONTAINED;
    } else {
      role = VertexRole.NOT_CONTAINED;
    }

    return role;
  }

  public Map<Integer, Integer> getVertexTimes() {
    return vertexTimes;
  }

  /**
   * grow backwards
   *
   * @param edgeId via edge
   * @param toId to vertex
   *
   * @return grown child
   */
  public Mapping growBackwards(Integer edgeId, int toId) {
    // keep vertex mapping
    Map<Integer, Integer> childVertexTimes = Maps.newHashMap(vertexTimes);

    // keep rightmost path until backtrace vertex and add rightmost
    List<Integer> childRightmostPath = Lists.newArrayList();
    for (int vertexId : rightmostPath) {
      childRightmostPath.add(vertexId);
      if (vertexId == toId) {
        break;
      }
    }
    childRightmostPath.add(getRightmostVertexId());

    // add new edge to coverage
    Collection<Integer> childEdgeCoverage = Sets.newHashSet(edgeCoverage);
    childEdgeCoverage.add(edgeId);

    return new Mapping(
      childVertexTimes, childRightmostPath, childEdgeCoverage);
  }

  /**
   * grow forwards
   *
   * @param fromId from vertex
   * @param edgeId via edge
   * @param toId to vertex
   *
   * @return grown child
   */
  public Mapping growForwards(int fromId, int edgeId, int toId) {
    // add new vertex to vertex mapping
    Map<Integer, Integer> childVertexTimes = Maps.newHashMap(vertexTimes);
    childVertexTimes.put(toId, vertexTimes.size());

    // keep rightmost path until start vertex and add new vertex
    List<Integer> childRightmostPath = Lists.newArrayList();
    for (int vertexId : rightmostPath) {
      childRightmostPath.add(vertexId);
      if (vertexId == fromId) {
        break;
      }
    }
    childRightmostPath.add(toId);

    // add new edge to coverage
    Collection<Integer> childEdgeCoverage = Sets.newHashSet(edgeCoverage);
    childEdgeCoverage.add(edgeId);

    return new Mapping(
      childVertexTimes, childRightmostPath, childEdgeCoverage);
  }

  @Override
  public String toString() {
    return vertexTimes + "\n" + rightmostPath + "\n" + edgeCoverage + "\n";
  }
}
/*
 * This file is part of Gradoop.
 *
 * Gradoop is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Gradoop is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.canonicalization.gspan;

import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import org.apache.commons.lang.StringUtils;
import org.gradoop.flink.algorithms.fsm.common.canonicalization.api.CanonicalLabeler;

import org.gradoop.flink.algorithms.fsm.common.pojos.Embedding;
import org.gradoop.flink.algorithms.fsm.common.pojos.FSMEdge;

import java.util.Collection;
import java.util.List;
import java.util.Map;

/**
 * Generates gSpan minimum DFS labels
 */
public class MinDFSLabeler implements CanonicalLabeler {

  /**
   * separator between traversal steps
   */
  private static final char STEP_SEPARATOR = ',';
  /**
   * directed mode
   */
  private final boolean directed;

  /**
   * Constructor.
   *
   * @param directed directed mode
   */
  public MinDFSLabeler(boolean directed) {
    this.directed = directed;
  }

  @Override
  public String label(Embedding graph) {

    String minVertexLabel = null;

    Collection<Mapping> parents = Lists.newArrayListWithCapacity(0);

    for (Map.Entry<Integer, String> vertexEntry :
      graph.getVertices().entrySet()) {

      String vertexLabel = vertexEntry.getValue();
      int minLabelComparison = minVertexLabel == null ? - 1 :
        vertexLabel.compareTo(minVertexLabel);

      if (minLabelComparison < 0) {
        minVertexLabel = vertexLabel;
        parents = Sets.newHashSet(new Mapping(vertexEntry.getKey()));
      } else if (minLabelComparison == 0) {
        parents.add(new Mapping(vertexEntry.getKey()));
      }
    }

    List<String> stepStrings =
      Lists.newArrayListWithCapacity(graph.getEdges().size());

    for (int k = 1; k <= graph.getEdges().size(); k++) {
      Collection<Mapping> children = Lists.newArrayList();

      Extension minExtension = null;

      for (Mapping parent : parents) {
        for (Map.Entry<Integer, FSMEdge> edgeEntry :
          graph.getEdges().entrySet()) {

          int edgeId = edgeEntry.getKey();

          if (!parent.containsEdge(edgeId)) {
            FSMEdge edge = edgeEntry.getValue();

            int sourceId = edge.getSourceId();
            int targetId = edge.getTargetId();
            String edgeLabel = edge.getLabel();

            if (sourceId == targetId) {
              if (sourceId == parent.getRightmostVertexId()) {

                int fromTime = parent.getVertexTimes().get(sourceId);
                String fromLabel = graph.getVertices().get(sourceId);

                Extension extension = new Extension(fromTime, fromLabel,
                  true, edgeLabel, fromTime, fromLabel, directed);

                int minComparison = minExtension == null ? -1 :
                  extension.compareTo(minExtension);

                if (minComparison <= 0) {
                  Mapping child = parent.growBackwards(edgeId, sourceId);

                  if (minComparison < 0) {
                    minExtension = extension;
                    children = Lists.newArrayList(child);
                  } else if (minComparison == 0) {
                    children.add(child);
                  }
                }

              }
            } else {
              int sourceRole = parent.getRole(sourceId);
              int targetRole = parent.getRole(targetId);

              if (sourceRole >= VertexRole.ON_RIGHTMOST_PATH) {

                // backward from source
                if (sourceRole == VertexRole.IS_RIGHTMOST &&
                  targetRole >= VertexRole.CONTAINED) {

                  int fromTime = parent.getVertexTimes().get(sourceId);
                  String fromLabel = graph.getVertices().get(sourceId);
                  int toTime = parent.getVertexTimes().get(targetId);
                  String toLabel = graph.getVertices().get(targetId);

                  Extension extension = new Extension(fromTime, fromLabel,
                    true, edgeLabel, toTime, toLabel, directed);

                  int minComparison = minExtension == null ? -1 :
                    extension.compareTo(minExtension);

                  if (minComparison <= 0) {
                    Mapping child = parent.growBackwards(edgeId, targetId);

                    if (minComparison < 0) {
                      minExtension = extension;
                      children = Lists.newArrayList(child);
                    } else if (minComparison == 0) {
                      children.add(child);
                    }
                  }

                  // forward from source
                } else if (targetRole == VertexRole.NOT_CONTAINED) {

                  int fromTime = parent.getVertexTimes().get(sourceId);
                  int toTime = parent.getVertexTimes().size();

                  String fromLabel = graph.getVertices().get(sourceId);
                  String toLabel = graph.getVertices().get(targetId);

                  Extension extension = new Extension(fromTime, fromLabel,
                    true, edgeLabel, toTime, toLabel, directed);

                  int minComparison = minExtension == null ? -1 :
                    extension.compareTo(minExtension);

                  if (minComparison <= 0) {
                    Mapping child =
                      parent.growForwards(sourceId, edgeId, targetId);

                    if (minComparison < 0) {
                      minExtension = extension;
                      children = Lists.newArrayList(child);
                    } else if (minComparison == 0) {
                      children.add(child);
                    }
                  }
                }
              }

              if (targetRole >= VertexRole.ON_RIGHTMOST_PATH) {

                // backward from target
                if (targetRole == VertexRole.IS_RIGHTMOST &&
                  sourceRole >= VertexRole.CONTAINED) {

                  int fromTime = parent.getVertexTimes().get(targetId);
                  int toTime = parent.getVertexTimes().get(sourceId);


                  String fromLabel = graph.getVertices().get(targetId);
                  String toLabel = graph.getVertices().get(sourceId);

                  Extension extension = new Extension(fromTime, fromLabel,
                    false, edgeLabel, toTime, toLabel, directed);

                  int minComparison = minExtension == null ? -1 :
                    extension.compareTo(minExtension);

                  if (minComparison <= 0) {
                    Mapping child = parent.growBackwards(edgeId, sourceId);

                    if (minComparison < 0) {
                      minExtension = extension;
                      children = Lists.newArrayList(child);
                    } else if (minComparison == 0) {
                      children.add(child);
                    }
                  }

                  // forward from target
                } else if (sourceRole == VertexRole.NOT_CONTAINED) {

                  int fromTime = parent.getVertexTimes().get(targetId);
                  int toTime = parent.getVertexTimes().size();

                  String fromLabel = graph.getVertices().get(targetId);
                  String toLabel = graph.getVertices().get(sourceId);

                  Extension extension = new Extension(fromTime, fromLabel,
                    false, edgeLabel, toTime, toLabel, directed);

                  int minComparison = minExtension == null ? -1 :
                    extension.compareTo(minExtension);

                  if (minComparison <= 0) {
                    Mapping child =
                      parent.growForwards(targetId, edgeId, sourceId);

                    if (minComparison < 0) {
                      minExtension = extension;
                      children = Lists.newArrayList(child);
                    } else if (minComparison == 0) {
                      children.add(child);
                    }
                  }
                }
              }
            }
          }
        }
      }
      stepStrings.add(minExtension.toString());
      parents = children;
    }

    return StringUtils.join(stepStrings, STEP_SEPARATOR);
  }

}
/*
 * This file is part of Gradoop.
 *
 * Gradoop is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Gradoop is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.canonicalization.gspan;

/**
 * Roles of a vertex with regard to an embedding.
 */
public class VertexRole  {
  /**
   * not contained
   */
  public static final int NOT_CONTAINED = 0;
  /**
   * contained
   */
  public static final int CONTAINED = 1;
  /**
   * on rightmost path
   */
  public static final int ON_RIGHTMOST_PATH = 2;
  /**
   * is rightmost
   */
  public static final int IS_RIGHTMOST = 3;
}
/*
 * This file is part of Gradoop.
 *
 * Gradoop is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Gradoop is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * classes related to min DFS canonical labels
 */

package org.gradoop.flink.algorithms.fsm.common.canonicalization.gspan;
/*
 * This file is part of Gradoop.
 *
 * Gradoop is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Gradoop is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.config;

/**
 * FSM canonical labels.
 */
public enum CanonicalLabel {
  /**
   * gSpan minimum DFS code
   */
  MIN_DFS,
  /**
   * canonical adjacency matrix
   */
  ADJACENCY_MATRIX
}
/*
 * This file is part of Gradoop.
 *
 * Gradoop is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Gradoop is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.config;

/**
 * Different strategies to filter embeddings by frequent subgraphs.
 */
public enum FilterStrategy {
  /**
   * embeddings.join(frequentSubgraphs)
   */
  DEFAULT_JOIN,
  /**
   * embeddings.joinWithTiny(frequentSubgraphs)
   */
  BROADCAST_JOIN,
  /**
   * embeddings.filter(..).withBroadcastSet(frequentSubgraphs,..)
   */
  BROADCAST_FILTER
}
/*
 * This file is part of Gradoop.
 *
 * Gradoop is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Gradoop is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.config;

/**
 * FSM pattern growth strategies.
 */
public enum GrowthStrategy {
  /**
   * create k+1 edge embeddings by fusion of multiple k edge embeddings
   */
  FUSION,
  /**
   * create k+1 edge embeddings by joining k edge ones with the search space
   */
  JOIN
}
/*
 * This file is part of Gradoop.
 *
 * Gradoop is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Gradoop is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.config;

/**
 * FSM iteration implementations.
 */
public enum IterationStrategy {
  /**
   * For loop.
   */
  LOOP_UNROLLING,
  /**
   * Flinks' bulk iteration.
   */
  BULK_ITERATION
}
/*
 * This file is part of Gradoop.
 *
 * Gradoop is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Gradoop is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Classes related to the configuration of frequent subgraph mining.
 */

package org.gradoop.flink.algorithms.fsm.common.config;
/*
 * This file is part of Gradoop.
 *
 * Gradoop is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Gradoop is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.functions;

import com.google.common.collect.Sets;
import org.apache.flink.api.common.functions.RichFilterFunction;
import org.apache.flink.configuration.Configuration;
import org.gradoop.flink.algorithms.fsm.common.config.Constants;
import org.gradoop.flink.algorithms.fsm.common.tuples.SubgraphEmbeddings;

import java.util.Collection;

/**
 * Evaluates to true if the subgraph of an embeddings list is frequent.
 *
 * @param <S> subgraph embeddings type
 */
public class SubgraphIsFrequent<S extends SubgraphEmbeddings>
  extends RichFilterFunction<S> {

  /**
   * frequent subgraphs received via broadcast
   */
  private Collection<String> frequentSubgraphs;

  @Override
  public void open(Configuration parameters) throws Exception {
    super.open(parameters);

    this.frequentSubgraphs = getRuntimeContext()
      .getBroadcastVariable(Constants.FREQUENT_SUBGRAPHS);

    this.frequentSubgraphs = Sets.newHashSet(frequentSubgraphs);
  }
  @Override
  public boolean filter(S value) throws Exception {
    return frequentSubgraphs.contains(value.getCanonicalLabel());
  }
}
/*
 * This file is part of Gradoop.
 *
 * Gradoop is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Gradoop is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.tfsm;

import org.apache.flink.api.java.DataSet;
import org.apache.flink.api.java.operators.IterativeDataSet;
import org.apache.flink.api.java.typeutils.TypeExtractor;
import org.gradoop.flink.algorithms.fsm.common.TransactionalFSMBase;
import org.gradoop.flink.algorithms.fsm.common.config.Constants;
import org.gradoop.flink.algorithms.fsm.common.config.FSMConfig;
import org.gradoop.flink.algorithms.fsm.common.config.IterationStrategy;
import org.gradoop.flink.algorithms.fsm.common.functions.EdgeLabels;
import org.gradoop.flink.algorithms.fsm.common.functions.Frequent;
import org.gradoop.flink.algorithms.fsm.common.functions.MinEdgeCount;
import org.gradoop.flink.algorithms.fsm.common.functions.MinFrequency;
import org.gradoop.flink.algorithms.fsm.common.functions.VertexLabels;
import org.gradoop.flink.algorithms.fsm.common.functions.WithoutInfrequentEdgeLabels;
import org.gradoop.flink.algorithms.fsm.common.functions.WithoutInfrequentVertexLabels;
import org.gradoop.flink.algorithms.fsm.common.functions.IsResult;
import org.gradoop.flink.algorithms.fsm.tfsm.functions.TFSMSingleEdgeEmbeddings;
import org.gradoop.flink.algorithms.fsm.tfsm.functions.TFSMSubgraphDecoder;
import org.gradoop.flink.algorithms.fsm.tfsm.functions.TFSMSubgraphOnly;
import org.gradoop.flink.algorithms.fsm.tfsm.functions.ToTFSMGraph;
import org.gradoop.flink.algorithms.fsm.tfsm.functions.TFSMWrapInSubgraphEmbeddings;
import org.gradoop.flink.algorithms.fsm.tfsm.pojos.TFSMGraph;
import org.gradoop.flink.algorithms.fsm.tfsm.tuples.TFSMSubgraph;
import org.gradoop.flink.algorithms.fsm.tfsm.tuples.TFSMSubgraphEmbeddings;
import org.gradoop.flink.model.impl.GraphCollection;
import org.gradoop.flink.model.impl.GraphTransactions;
import org.gradoop.flink.model.impl.functions.tuple.ValueOfWithCount;
import org.gradoop.flink.model.impl.operators.count.Count;
import org.gradoop.flink.representation.transactional.GraphTransaction;
import org.gradoop.flink.model.impl.tuples.WithCount;
import org.gradoop.flink.util.GradoopFlinkConfig;

/**
 * abstract superclass of different implementations of the gSpan frequent
 * subgraph mining algorithm as Gradoop operator
 */
public class TransactionalFSM
  extends TransactionalFSMBase<TFSMGraph, TFSMSubgraph, TFSMSubgraphEmbeddings>
{

  /**
   * minimum frequency for subgraphs to be considered to be frequent
   */
  private DataSet<Long> minFrequency;

  /**
   * constructor
   * @param fsmConfig frequent subgraph mining configuration
   *
   */
  public TransactionalFSM(FSMConfig fsmConfig) {
    super(fsmConfig);
  }

  @Override
  public GraphCollection execute(GraphCollection collection)  {
    GradoopFlinkConfig gradoopFlinkConfig = collection.getConfig();

    // create transactions from graph collection
    GraphTransactions transactions = collection
      .toTransactions();

    transactions = execute(transactions);

    return GraphCollection.fromTransactions(
      new GraphTransactions(
        transactions.getTransactions(), gradoopFlinkConfig));
  }

  /**
   * Encodes the search space before executing FSM.
   *
   * @param transactions search space as Gradoop graph transactions
   *
   * @return frequent subgraphs as Gradoop graph transactions
   */
  public GraphTransactions execute(GraphTransactions transactions) {
    DataSet<TFSMGraph> graphs = transactions
      .getTransactions()
      .map(new ToTFSMGraph())
      .returns(TypeExtractor.getForClass(TFSMGraph.class));

    GradoopFlinkConfig gradoopConfig = transactions.getConfig();

    DataSet<GraphTransaction> dataSet = execute(graphs, gradoopConfig);

    return new GraphTransactions(dataSet, gradoopConfig);
  }

  /**
   * Core mining method.
   *
   * @param graphs search space
   * @param gradoopConfig Gradoop Flink configuration
   *
   * @return frequent subgraphs
   */
  public DataSet<GraphTransaction> execute(
    DataSet<TFSMGraph> graphs, GradoopFlinkConfig gradoopConfig) {

    setMinFrequency(graphs);

    if (fsmConfig.isPreprocessingEnabled()) {
      graphs = preProcess(graphs);
    }

    DataSet<TFSMSubgraph> allFrequentSubgraphs;

    DataSet<TFSMSubgraphEmbeddings> embeddings = graphs
      .flatMap(new TFSMSingleEdgeEmbeddings(fsmConfig));

    if (fsmConfig.getIterationStrategy() == IterationStrategy.LOOP_UNROLLING) {
      allFrequentSubgraphs = mineWithLoopUnrolling(graphs, embeddings);
    } else  {
      allFrequentSubgraphs = mineWithBulkIteration(graphs, embeddings);
    }

    if (fsmConfig.getMinEdgeCount() > 1) {
      allFrequentSubgraphs = allFrequentSubgraphs
        .filter(new MinEdgeCount<TFSMSubgraph>(fsmConfig));
    }

    return allFrequentSubgraphs
      .map(new TFSMSubgraphDecoder(gradoopConfig));
  }

  /**
   * Determines the min frequency based on graph count and support threshold.
   *
   * @param graphs search space
   */
  private void setMinFrequency(DataSet<TFSMGraph> graphs) {
    minFrequency = Count
      .count(graphs)
      .map(new MinFrequency(fsmConfig));
  }

  /**
   * Removes vertices and edges showing infrequent labels.
   *
   * @param graphs search space
   * @return processed search space
   */
  private DataSet<TFSMGraph> preProcess(DataSet<TFSMGraph> graphs) {
    DataSet<String> frequentVertexLabels = graphs
      .flatMap(new VertexLabels<TFSMGraph>())
      .groupBy(0)
      .sum(1)
      .filter(new Frequent<WithCount<String>>())
      .withBroadcastSet(minFrequency, Constants.MIN_FREQUENCY)
      .map(new ValueOfWithCount<String>());

    graphs = graphs
      .map(new WithoutInfrequentVertexLabels<TFSMGraph>())
      .withBroadcastSet(
        frequentVertexLabels, Constants.FREQUENT_VERTEX_LABELS);

    DataSet<String> frequentEdgeLabels = graphs
      .flatMap(new EdgeLabels<TFSMGraph>())
      .groupBy(0)
      .sum(1)
      .filter(new Frequent<WithCount<String>>())
      .withBroadcastSet(minFrequency, Constants.MIN_FREQUENCY)
      .map(new ValueOfWithCount<String>());

    graphs = graphs
      .map(new WithoutInfrequentEdgeLabels<TFSMGraph>())
      .withBroadcastSet(frequentEdgeLabels, Constants.FREQUENT_EDGE_LABELS);
    return graphs;
  }

  /**
   * Mining core based on loop unrolling.
   *
   * @param graphs search space
   * @param embeddings 1-edge embeddings
   * @return frequent subgraphs
   */
  private DataSet<TFSMSubgraph> mineWithLoopUnrolling(
    DataSet<TFSMGraph> graphs, DataSet<TFSMSubgraphEmbeddings> embeddings) {

    DataSet<TFSMSubgraph> frequentSubgraphs = getFrequentSubgraphs(embeddings);
    DataSet<TFSMSubgraph> allFrequentSubgraphs = frequentSubgraphs;

    if (fsmConfig.getMaxEdgeCount() > 1) {
      for (int k = fsmConfig.getMinEdgeCount();
           k < fsmConfig.getMaxEdgeCount(); k++) {

        embeddings = growEmbeddingsOfFrequentSubgraphs(
          graphs, embeddings, frequentSubgraphs);

        frequentSubgraphs = getFrequentSubgraphs(embeddings);
        allFrequentSubgraphs = allFrequentSubgraphs.union(frequentSubgraphs);
      }
    }

    return allFrequentSubgraphs;
  }

  /**
   * Mining core based on bulk iteration.
   *
   * @param graphs search space
   * @param embeddings 1-edge embeddings
   * @return frequent subgraphs
   */
  private DataSet<TFSMSubgraph> mineWithBulkIteration(
    DataSet<TFSMGraph> graphs, DataSet<TFSMSubgraphEmbeddings> embeddings) {

    // ITERATION HEAD
    IterativeDataSet<TFSMSubgraphEmbeddings> iterative = embeddings
      .iterate(fsmConfig.getMaxEdgeCount());

    // ITERATION BODY

    // get frequent subgraphs
    DataSet<TFSMSubgraphEmbeddings> parentEmbeddings = iterative
      .filter(new IsResult<TFSMSubgraphEmbeddings>(false));

    DataSet<TFSMSubgraph> frequentSubgraphs =
      getFrequentSubgraphs(parentEmbeddings);

    parentEmbeddings =
      filterByFrequentSubgraphs(parentEmbeddings, frequentSubgraphs);

    DataSet<TFSMSubgraphEmbeddings> childEmbeddings =
      growEmbeddingsOfFrequentSubgraphs(
        graphs, parentEmbeddings, frequentSubgraphs);

    DataSet<TFSMSubgraphEmbeddings> resultIncrement = frequentSubgraphs
      .map(new TFSMWrapInSubgraphEmbeddings());

    DataSet<TFSMSubgraphEmbeddings> resultAndEmbeddings = iterative
      .filter(new IsResult<TFSMSubgraphEmbeddings>(true))
      .union(resultIncrement)
      .union(childEmbeddings);

    // ITERATION FOOTER

    return iterative
      .closeWith(resultAndEmbeddings, childEmbeddings)
      .filter(new IsResult<TFSMSubgraphEmbeddings>(true))
      .map(new TFSMSubgraphOnly());
  }

  /**
   * Determines frequent subgraphs in a set of embeddings.
   *
   * @param embeddings set of embeddings
   * @return frequent subgraphs
   */
  private DataSet<TFSMSubgraph> getFrequentSubgraphs(
    DataSet<TFSMSubgraphEmbeddings> embeddings) {
    return embeddings
        .map(new TFSMSubgraphOnly())
        .groupBy(0)
        .sum(1)
        .filter(new Frequent<TFSMSubgraph>())
        .withBroadcastSet(minFrequency, Constants.MIN_FREQUENCY);
  }

  @Override
  public String getName() {
    return this.getClass().getSimpleName();
  }

}
/*
 * This file is part of Gradoop.
 *
 * Gradoop is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Gradoop is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Flink functions related to transactional frequent subgraph mining.
 */

package org.gradoop.flink.algorithms.fsm.tfsm.functions;
/*
 * This file is part of Gradoop.
 *
 * Gradoop is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Gradoop is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * classes related to transactional frequent subgraph mining
 */

package org.gradoop.flink.algorithms.fsm.tfsm;
/*
 * This file is part of Gradoop.
 *
 * Gradoop is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Gradoop is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * pojos related to transactional frequent subgraph mining
 */

package org.gradoop.flink.algorithms.fsm.tfsm.pojos;
/*
 * This file is part of Gradoop.
 *
 * Gradoop is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Gradoop is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * tuple-types related to transactional frequent subgraph mining
 */

package org.gradoop.flink.algorithms.fsm.tfsm.tuples;
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.config;

import org.gradoop.flink.algorithms.fsm.common.canonicalization.api.CanonicalLabeler;


import org.gradoop.flink.algorithms.fsm.common.canonicalization.cam.CAMLabeler;
import org.gradoop.flink.algorithms.fsm.common.canonicalization.gspan.MinDFSLabeler;

import java.io.Serializable;

  private final boolean preprocessingEnbabled;

  /**
   * labeler used to generate canonical labels
   */
  private final CanonicalLabel canonicalLabel;

  /**
   * Strategy used to filter embeddings by frequent subgraphs
   */
  private final FilterStrategy filterStrategy;

  /**
   * Strategy used to grow children of frequent subgraphs
   */
  private final GrowthStrategy growthStrategy;

  /**
   * Strategy for distributed iteration
   */
  private final IterationStrategy iterationStrategy;

  /**
   * Constructor.
   *
   * @param minSupport min support
   * @param directed true, for directed mode
   * @param minEdgeCount min number of edges
   * @param maxEdgeCount max number of edges
   * @param preprocessingEnbabled true, to enable preprocessingEnbabled
   * @param canonicalLabel canonical label
   * @param filterStrategy frequent subgraph filter strategy
   * @param growthStrategy children growth strategy
   * @param iterationStrategy iteration strategy
   */
  public FSMConfig(
    float minSupport,
    boolean directed,
    int minEdgeCount,
    int maxEdgeCount,
    boolean preprocessingEnbabled,
    CanonicalLabel canonicalLabel,
    FilterStrategy filterStrategy,
    GrowthStrategy growthStrategy,
    IterationStrategy iterationStrategy
  ) {
    this.minSupport = minSupport;
    this.directed = directed;
    this.minEdgeCount = minEdgeCount;
    this.maxEdgeCount = maxEdgeCount;
    this.preprocessingEnbabled = preprocessingEnbabled;
    this.canonicalLabel = canonicalLabel;
    this.filterStrategy = filterStrategy;
    this.growthStrategy = growthStrategy;
    this.iterationStrategy = iterationStrategy;
  }

  /**
public FSMConfig(
    this.minEdgeCount = minEdgeCount;
    this.maxEdgeCount = maxEdgeCount;
    this.preprocessingEnbabled = true;
    this.canonicalLabel = CanonicalLabel.MIN_DFS;
    this.filterStrategy = FilterStrategy.BROADCAST_JOIN;
    this.growthStrategy = GrowthStrategy.FUSION;
    this.iterationStrategy = IterationStrategy.BULK_ITERATION;
  }

  /**
public FSMConfig(float minSupport, boolean directed) {
    this.minEdgeCount = 1;
    this.maxEdgeCount = 16;
    this.preprocessingEnbabled = true;
    this.canonicalLabel = CanonicalLabel.MIN_DFS;
    this.filterStrategy = FilterStrategy.BROADCAST_JOIN;
    this.growthStrategy = GrowthStrategy.FUSION;
    this.iterationStrategy = IterationStrategy.BULK_ITERATION;
  }

  public float getMinSupport() {
public boolean isPreprocessingEnabled() {
    return preprocessingEnbabled;
  }

  public CanonicalLabeler getCanonicalLabeler() {
    return canonicalLabel == CanonicalLabel.ADJACENCY_MATRIX ?
      new CAMLabeler(directed) : new MinDFSLabeler(directed);
  }

  public FilterStrategy getFilterStrategy() {
    return filterStrategy;
  }

  public GrowthStrategy getGrowthStrategy() {
    return growthStrategy;
  }

  public IterationStrategy getIterationStrategy() {
    return iterationStrategy;
  }

}
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.config;

/**
 * Collection of broadcast dataset names used for frequent subgraph mining.
 */
public class Constants {

  /**
   * Cache counter name for the total number of graphs.
  public static final String MIN_FREQUENCY = "minFrequency";

  /**
   * vertex label dictionary
   */
  public static final String FREQUENT_VERTEX_LABELS = "frequentVertexLabels";

  /**
   * vertex label dictionary
   */
  public static final String FREQUENT_EDGE_LABELS = "frequentEdgeLabels";

  /**
   * set of frequent subgraphs
   */
  public static final String FREQUENT_SUBGRAPHS = "frequentSubgraphs";
}
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.functions;

import com.google.common.collect.Sets;
import org.apache.flink.api.common.functions.FlatMapFunction;
import org.apache.flink.util.Collector;
import org.gradoop.flink.algorithms.fsm.common.pojos.FSMEdge;
import org.gradoop.flink.algorithms.fsm.common.pojos.FSMGraph;
import org.gradoop.flink.model.impl.tuples.WithCount;

import java.util.Set;

/**
 * graph -> (edgeLabel,1L),..
 *
 * @param <G> graph type
 */
public class EdgeLabels<G extends FSMGraph>
  implements FlatMapFunction<G, WithCount<String>> {

  /**
   * reuse tuple to avoid instantiations
   */
  private WithCount<String> reuseTuple = new WithCount<>(null, 1);

  @Override
  public void flatMap(G graph,
    Collector<WithCount<String>> out) throws Exception {

    Set<String> edgeLabels = Sets.newHashSet();

    for (FSMEdge edge : graph.getEdges().values()) {
      edgeLabels.add(edge.getLabel());
    }

 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.functions;

import org.apache.flink.api.common.functions.MapFunction;
import org.gradoop.flink.algorithms.fsm.common.tuples.Subgraph;

/**
 * subgraph => canonicalLabel
 *
 * @param <S> subgraph type
 */
public class CanonicalLabelOnly<S extends Subgraph>
  implements MapFunction<S, String> {

  @Override
  public String map(S value) throws Exception {
    return value.getCanonicalLabel();
  }
}
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.functions;

import com.google.common.collect.Sets;
import org.apache.flink.api.common.functions.FlatMapFunction;
import org.apache.flink.util.Collector;
import org.gradoop.flink.algorithms.fsm.common.pojos.FSMGraph;
import org.gradoop.flink.model.impl.tuples.WithCount;

import java.util.Set;

/**
 * graph -> (vertexLabel,1L),..
 *
 * @param <G> graph type
 */
public class VertexLabels<G extends FSMGraph>
  implements FlatMapFunction<G, WithCount<String>> {

  /**
   * reuse tuple to avoid instantiations
   */
  private WithCount<String> reuseTuple = new WithCount<>(null, 1);

  @Override
  public void flatMap(G graph,
    Collector<WithCount<String>> out) throws Exception {

    Set<String> vertexLabels = Sets.newHashSet(graph.getVertices().values());

    for (String label : vertexLabels) {
      reuseTuple.setObject(label);
 */

/**
 * interfaces related to canonical labels of graphs
 */

package org.gradoop.flink.algorithms.fsm.common.canonicalization.api;
 */

/**
 * tuple-types related to frequent subgraph mining
 */

package org.gradoop.flink.algorithms.fsm.ccs.tuples;
 */

/**
 * classes related to category characteristic subgraph mining
 */

package org.gradoop.flink.algorithms.fsm.ccs;
 */

/**
 * flink functions related to category characteristic subgraph mining
 */

package org.gradoop.flink.algorithms.fsm.ccs.functions;
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.canonicalization.cam;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import org.apache.commons.lang.StringUtils;
import org.gradoop.flink.algorithms.fsm.common.canonicalization.api.CanonicalLabeler;
import org.gradoop.flink.algorithms.fsm.common.pojos.Embedding;
import org.gradoop.flink.algorithms.fsm.common.pojos.FSMEdge;

import java.util.Collections;
import java.util.List;
import java.util.Map;
 * Creates a canonical label for a given graph embedding that represents its
 * adjacency matrix.
 */
public class CAMLabeler implements CanonicalLabeler {

  /**
   * separator among adjacency lists
   *
   * @param directed true for directed mode
   */
  public CAMLabeler(boolean directed) {
    this.directed = directed;
  }

  @Override
  public String label(Embedding embedding) {

    Map<Integer, String> vertices = embedding.getVertices();
 * classes related to canonical labels of graphs
 */

package org.gradoop.flink.algorithms.fsm.common.canonicalization;
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.ccs.functions;

import org.apache.flink.api.common.functions.FlatMapFunction;
import org.apache.flink.util.Collector;
import org.gradoop.flink.algorithms.fsm.ccs.pojos.CCSGraph;
import org.gradoop.flink.algorithms.fsm.ccs.tuples.CCSSubgraphEmbeddings;
import org.gradoop.flink.algorithms.fsm.common.config.FSMConfig;
import org.gradoop.flink.algorithms.fsm.common.functions.SingleEdgeEmbeddings;
import org.gradoop.flink.algorithms.fsm.common.pojos.Embedding;

import java.util.List;
import java.util.Map;
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.ccs.functions;

import org.apache.flink.api.common.functions.MapFunction;
import org.gradoop.flink.algorithms.fsm.ccs.CategoryCharacteristicSubgraphs;
import org.gradoop.flink.algorithms.fsm.ccs.tuples.CCSSubgraph;
import org.gradoop.flink.algorithms.fsm.common.functions.SubgraphDecoder;
import org.gradoop.flink.representation.transactional.GraphTransaction;
import org.gradoop.flink.util.GradoopFlinkConfig;

 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.ccs.functions;

import org.apache.flink.api.common.functions.MapFunction;
import org.gradoop.flink.algorithms.fsm.ccs.tuples.CCSSubgraph;
import org.gradoop.flink.algorithms.fsm.ccs.tuples.CCSSubgraphEmbeddings;

/**
 * (graphId, size, canonicalLabel, embeddings)
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.ccs.functions;

import com.google.common.collect.Lists;
import org.apache.flink.api.common.functions.MapFunction;
import org.gradoop.common.model.impl.id.GradoopId;
import org.gradoop.flink.algorithms.fsm.ccs.tuples.CCSSubgraph;
import org.gradoop.flink.algorithms.fsm.ccs.tuples.CCSSubgraphEmbeddings;

/**
 * subgraphWithSampleEmbedding => subgraphWithEmbeddings
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.ccs.functions;

import com.google.common.collect.Sets;
import org.apache.flink.api.common.functions.FlatMapFunction;
import org.apache.flink.util.Collector;
import org.gradoop.flink.algorithms.fsm.ccs.pojos.CCSGraph;
import org.gradoop.flink.algorithms.fsm.ccs.tuples.CategoryCountableLabel;
import org.gradoop.flink.algorithms.fsm.common.pojos.FSMEdge;

import java.util.Set;

 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.ccs.functions;

import org.apache.flink.api.common.functions.RichFilterFunction;
import org.apache.flink.configuration.Configuration;
import org.gradoop.flink.algorithms.fsm.ccs.tuples.CategoryCountableLabel;
import org.gradoop.flink.algorithms.fsm.common.config.Constants;

import java.util.Map;

public void open(Configuration parameters) throws Exception {
    super.open(parameters);

    this.categoryMinFrequencies = getRuntimeContext()
      .<Map<String, Long>>getBroadcastVariable(Constants.MIN_FREQUENCY).get(0);
  }

  @Override
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.ccs.functions;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import org.apache.flink.api.common.functions.RichGroupReduceFunction;
import org.apache.flink.configuration.Configuration;
import org.apache.flink.util.Collector;
import org.gradoop.flink.algorithms.fsm.ccs.interestingness.Interestingness;
import org.gradoop.flink.algorithms.fsm.ccs.tuples.CCSSubgraph;
import org.gradoop.flink.algorithms.fsm.common.config.Constants;

import java.util.Collection;
import java.util.Map;
public void open(Configuration parameters) throws Exception {
    super.open(parameters);

    this.categoryMinFrequencies = getRuntimeContext()
      .<Map<String, Long>>getBroadcastVariable(Constants.MIN_FREQUENCY).get(0);

    this.categoryCounts = getRuntimeContext()
      .<Map<String, Long>>getBroadcastVariable(Constants.GRAPH_COUNT).get(0);
  }

  @Override
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.ccs.functions;

import org.apache.flink.api.common.functions.GroupReduceFunction;
import org.apache.flink.hadoop.shaded.com.google.common.collect.Maps;
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.ccs.functions;

import org.apache.flink.api.common.functions.MapFunction;
import org.gradoop.flink.algorithms.fsm.common.config.FSMConfig;
import org.gradoop.flink.algorithms.fsm.common.functions.MinFrequency;

import java.util.Map;

 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.ccs.functions;

import com.google.common.collect.Sets;
import org.apache.flink.api.common.functions.FlatMapFunction;
import org.apache.flink.util.Collector;
import org.gradoop.flink.algorithms.fsm.ccs.pojos.CCSGraph;
import org.gradoop.flink.algorithms.fsm.ccs.tuples.CategoryCountableLabel;

import java.util.Set;

 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.ccs.functions;

import org.apache.flink.api.common.functions.MapFunction;
import org.gradoop.flink.algorithms.fsm.ccs.pojos.CCSGraph;
import org.gradoop.flink.model.impl.tuples.WithCount;

/**
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.functions;

import org.apache.flink.api.common.functions.RichFilterFunction;
import org.apache.flink.configuration.Configuration;
import org.gradoop.flink.algorithms.fsm.common.config.Constants;
import org.gradoop.flink.model.api.tuples.Countable;

/**
public void open(Configuration parameters) throws Exception {
    super.open(parameters);

    this.minFrequency = getRuntimeContext()
      .<Long>getBroadcastVariable(Constants.MIN_FREQUENCY).get(0);
  }

  @Override
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.functions;

import org.apache.flink.api.java.functions.KeySelector;
import org.gradoop.common.model.impl.id.GradoopId;
import org.gradoop.flink.algorithms.fsm.common.pojos.FSMGraph;

/**
 * graph => id
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.ccs.functions;

import org.apache.flink.api.common.functions.FilterFunction;
import org.gradoop.flink.algorithms.fsm.ccs.tuples.CCSSubgraph;

/**
 * Filters characteristic subgraphs.
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.functions;

import org.apache.flink.api.common.functions.FilterFunction;
import org.gradoop.common.model.impl.id.GradoopId;
import org.gradoop.flink.algorithms.fsm.common.tuples.SubgraphEmbeddings;

/**
 * Filters embeddings or collected results.
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.functions;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import org.apache.flink.api.common.functions.FlatJoinFunction;
import org.apache.flink.api.common.functions.FlatMapFunction;
import org.apache.flink.util.Collector;
import org.gradoop.flink.algorithms.fsm.common.canonicalization.api.CanonicalLabeler;
import org.gradoop.flink.algorithms.fsm.common.config.FSMConfig;
import org.gradoop.flink.algorithms.fsm.common.pojos.Embedding;
import org.gradoop.flink.algorithms.fsm.common.pojos.FSMEdge;
import org.gradoop.flink.algorithms.fsm.common.pojos.FSMGraph;
import org.gradoop.flink.algorithms.fsm.common.tuples.SubgraphEmbeddings;

import java.util.Collection;
import java.util.List;
 * @param <G> graph type
 * @param <SE> subgraph type
 */
public class PatternGrowth<G extends FSMGraph, SE extends SubgraphEmbeddings>
  implements FlatJoinFunction<SE, G, SE>, FlatMapFunction<SE, SE> {

  /**
   *
   * @param fsmConfig FSM configuration.
   */
  public PatternGrowth(FSMConfig fsmConfig) {
    this.canonicalLabeler = fsmConfig.getCanonicalLabeler();
  }

  @Override
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.ccs.functions;

import org.apache.flink.api.common.functions.MapFunction;
import org.gradoop.flink.algorithms.fsm.ccs.tuples.CategoryCountableLabel;

/**
 * (category, label, frequency) => label
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.functions;

import org.apache.flink.api.common.functions.GroupReduceFunction;
import org.apache.flink.util.Collector;
import org.gradoop.flink.algorithms.fsm.common.tuples.SubgraphEmbeddings;

import java.util.Iterator;

 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.functions;

import org.apache.flink.api.common.functions.FilterFunction;
import org.gradoop.flink.algorithms.fsm.common.config.FSMConfig;
import org.gradoop.flink.algorithms.fsm.common.tuples.Subgraph;

/**
 * Filters a subgraph by minimum edge count.
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.functions;

import org.apache.flink.api.common.functions.MapFunction;
import org.gradoop.flink.algorithms.fsm.common.config.FSMConfig;

/**
 * Calculates the min frequency based on a configured min support.
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.functions;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import org.gradoop.flink.algorithms.fsm.common.canonicalization.api.CanonicalLabeler;
import org.gradoop.flink.algorithms.fsm.common.config.FSMConfig;
import org.gradoop.flink.algorithms.fsm.common.pojos.Embedding;
import org.gradoop.flink.algorithms.fsm.common.pojos.FSMEdge;
import org.gradoop.flink.algorithms.fsm.common.pojos.FSMGraph;

import java.io.Serializable;
import java.util.List;
   * @param fsmConfig FSM configuration
   */
  public SingleEdgeEmbeddings(FSMConfig fsmConfig) {
    canonicalLabeler = fsmConfig.getCanonicalLabeler();
  }

  /**
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.functions;

import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import org.gradoop.common.model.impl.pojo.Vertex;
import org.gradoop.common.model.impl.pojo.VertexFactory;
import org.gradoop.common.model.impl.properties.Properties;
import org.gradoop.flink.algorithms.fsm.common.pojos.FSMEdge;
import org.gradoop.flink.algorithms.fsm.common.tuples.Subgraph;
import org.gradoop.flink.representation.transactional.GraphTransaction;
import org.gradoop.flink.util.GradoopFlinkConfig;

public abstract class SubgraphDecoder implements Serializable {

  /**
   * Property key to store a frequent subgraphs's frequency.
   */
  public static final String FREQUENCY_KEY = "frequency";
  /**
   * Property key to store the canonical label.
   */
  public static final String CANONICAL_LABEL_KEY = "canonicalLabel";
  /**
   * graph Head Factory
   */
  protected final GraphHeadFactory graphHeadFactory;
protected GraphTransaction createTransaction(

    Properties properties = new Properties();

    properties.set(FREQUENCY_KEY, subgraph.getCount());
    properties.set(CANONICAL_LABEL_KEY, subgraph.getCanonicalLabel());

    GraphHead epgmGraphHead = graphHeadFactory
      .createGraphHead(canonicalLabel, properties);
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.tfsm.functions;

import org.apache.flink.api.common.functions.FlatMapFunction;
import org.apache.flink.util.Collector;
import org.gradoop.flink.algorithms.fsm.common.config.FSMConfig;
import org.gradoop.flink.algorithms.fsm.common.functions.SingleEdgeEmbeddings;
import org.gradoop.flink.algorithms.fsm.common.pojos.Embedding;
import org.gradoop.flink.algorithms.fsm.tfsm.pojos.TFSMGraph;
import org.gradoop.flink.algorithms.fsm.tfsm.tuples.TFSMSubgraphEmbeddings;

import java.util.List;
import java.util.Map;
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.tfsm.functions;

import org.apache.flink.api.common.functions.MapFunction;
import org.gradoop.flink.algorithms.fsm.common.functions.SubgraphDecoder;
import org.gradoop.flink.algorithms.fsm.tfsm.tuples.TFSMSubgraph;
import org.gradoop.flink.representation.transactional.GraphTransaction;
import org.gradoop.flink.util.GradoopFlinkConfig;

/**
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.tfsm.functions;

import org.apache.flink.api.common.functions.MapFunction;
import org.gradoop.flink.algorithms.fsm.tfsm.tuples.TFSMSubgraph;
import org.gradoop.flink.algorithms.fsm.tfsm.tuples.TFSMSubgraphEmbeddings;

/**
 * (graphId, size, canonicalLabel, embeddings)
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.tfsm.functions;

import com.google.common.collect.Lists;
import org.apache.flink.api.common.functions.MapFunction;
import org.gradoop.common.model.impl.id.GradoopId;
import org.gradoop.flink.algorithms.fsm.tfsm.tuples.TFSMSubgraph;
import org.gradoop.flink.algorithms.fsm.tfsm.tuples.TFSMSubgraphEmbeddings;

/**
 * subgraphWithSampleEmbedding => subgraphWithEmbeddings
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.ccs.functions;

import com.google.common.collect.Maps;
import org.apache.flink.api.common.functions.MapFunction;
import org.gradoop.common.model.impl.id.GradoopId;
import org.gradoop.flink.algorithms.fsm.ccs.CategoryCharacteristicSubgraphs;
import org.gradoop.flink.algorithms.fsm.ccs.pojos.CCSGraph;
import org.gradoop.flink.algorithms.fsm.common.functions.ToFSMGraph;
import org.gradoop.flink.algorithms.fsm.common.pojos.FSMEdge;
import org.gradoop.flink.representation.transactional.GraphTransaction;

import java.util.Map;

 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.functions;

import com.google.common.collect.Maps;
import org.gradoop.common.model.impl.id.GradoopId;
import org.gradoop.common.model.impl.pojo.Edge;
import org.gradoop.common.model.impl.pojo.Vertex;
import org.gradoop.flink.algorithms.fsm.common.pojos.FSMEdge;
import org.gradoop.flink.representation.transactional.GraphTransaction;

import java.util.Map;
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.tfsm.functions;

import com.google.common.collect.Maps;
import org.apache.flink.api.common.functions.MapFunction;
import org.gradoop.common.model.impl.id.GradoopId;
import org.gradoop.flink.algorithms.fsm.common.functions.ToFSMGraph;
import org.gradoop.flink.algorithms.fsm.common.pojos.FSMEdge;
import org.gradoop.flink.algorithms.fsm.tfsm.pojos.TFSMGraph;
import org.gradoop.flink.representation.transactional.GraphTransaction;

import java.util.Map;

 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.functions;

import com.google.common.collect.Sets;
import org.apache.flink.api.common.functions.RichMapFunction;
import org.apache.flink.configuration.Configuration;
import org.gradoop.flink.algorithms.fsm.common.config.Constants;
import org.gradoop.flink.algorithms.fsm.common.pojos.FSMEdge;
import org.gradoop.flink.algorithms.fsm.common.pojos.FSMGraph;

import java.util.Collection;
import java.util.Iterator;
public void open(Configuration parameters) throws Exception {
    super.open(parameters);

    this.frequentEdgeLabels = getRuntimeContext()
      .getBroadcastVariable(Constants.FREQUENT_EDGE_LABELS);

    this.frequentEdgeLabels = Sets.newHashSet(frequentEdgeLabels);
  }
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.functions;

import com.google.common.collect.Sets;
import org.apache.flink.api.common.functions.RichMapFunction;
import org.apache.flink.configuration.Configuration;
import org.gradoop.flink.algorithms.fsm.common.config.Constants;
import org.gradoop.flink.algorithms.fsm.common.pojos.FSMEdge;
import org.gradoop.flink.algorithms.fsm.common.pojos.FSMGraph;

import java.util.Collection;
import java.util.Iterator;
public void open(Configuration parameters) throws Exception {
    super.open(parameters);

    this.frequentVertexLabels = getRuntimeContext()
      .getBroadcastVariable(Constants.FREQUENT_VERTEX_LABELS);

    this.frequentVertexLabels = Sets.newHashSet(frequentVertexLabels);
  }
 * Flink functions related to frequent subgraph mining.
 */

package org.gradoop.flink.algorithms.fsm.common.functions;
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.ccs.interestingness;

import java.io.Serializable;

 * classes related to characterizing interestingness measures.
 */

package org.gradoop.flink.algorithms.fsm.ccs.interestingness;
 * classes related to frequent subgraph mining
 */

package org.gradoop.flink.algorithms.fsm.common;
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.ccs.pojos;

import org.gradoop.common.model.impl.id.GradoopId;
import org.gradoop.flink.algorithms.fsm.common.pojos.FSMEdge;
import org.gradoop.flink.algorithms.fsm.tfsm.pojos.TFSMGraph;

import java.util.Map;

 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.pojos;

import com.google.common.collect.Maps;

 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.pojos;

/**
 * Represents an edge within Subgraph embeddings.
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.pojos;

import org.gradoop.common.model.impl.id.GradoopId;

 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.tfsm.pojos;

import org.gradoop.common.model.impl.id.GradoopId;
import org.gradoop.flink.algorithms.fsm.common.pojos.Embedding;
import org.gradoop.flink.algorithms.fsm.common.pojos.FSMEdge;
import org.gradoop.flink.algorithms.fsm.common.pojos.FSMGraph;

import java.util.Map;

 * pojos related to frequent subgraph mining
 */

package org.gradoop.flink.algorithms.fsm.common.pojos;
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.ccs.tuples;

import org.apache.flink.api.java.tuple.Tuple5;
import org.gradoop.flink.algorithms.fsm.common.pojos.Embedding;
import org.gradoop.flink.algorithms.fsm.common.tuples.Subgraph;

/**
 * Representation of a subgraph.
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.ccs.tuples;

import org.apache.flink.api.java.tuple.Tuple5;
import org.gradoop.common.model.impl.id.GradoopId;
import org.gradoop.flink.algorithms.fsm.common.pojos.Embedding;
import org.gradoop.flink.algorithms.fsm.common.tuples.SubgraphEmbeddings;

import java.util.List;

 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.ccs.tuples;

/**
 * Describes something categorizable.
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.ccs.tuples;

import org.apache.flink.api.java.tuple.Tuple3;
import org.gradoop.flink.model.api.tuples.Countable;
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.tuples;

import org.gradoop.flink.algorithms.fsm.common.pojos.Embedding;
import org.gradoop.flink.model.api.tuples.Countable;

import java.io.Serializable;
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.common.tuples;

import org.gradoop.common.model.impl.id.GradoopId;
import org.gradoop.flink.algorithms.fsm.common.pojos.Embedding;

import java.util.List;

 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.tfsm.tuples;

import org.apache.flink.api.java.tuple.Tuple3;
import org.gradoop.flink.algorithms.fsm.common.pojos.Embedding;
import org.gradoop.flink.algorithms.fsm.common.tuples.Subgraph;

/**
 * Representation of a subgraph.
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */

package org.gradoop.flink.algorithms.fsm.tfsm.tuples;

import org.apache.flink.api.java.tuple.Tuple4;
import org.gradoop.common.model.impl.id.GradoopId;
import org.gradoop.flink.algorithms.fsm.common.pojos.Embedding;
import org.gradoop.flink.algorithms.fsm.common.tuples.SubgraphEmbeddings;

import java.util.List;

 * tuple-types related to frequent subgraph mining
 */

package org.gradoop.flink.algorithms.fsm.common.tuples;
 * along with Gradoop. If not, see <http://www.gnu.org/licenses/>.
 */


package org.gradoop.flink.algorithms.fsm.common.canonicalization.api;

import org.gradoop.flink.algorithms.fsm.common.pojos.Embedding;

import java.io.Serializable;

/**
 * Represents object that can derive a canonical label from an embedding.
 */
public interface CanonicalLabeler extends Serializable {

  /**
   * Labelling method.
   *
   * @param embedding input embedding
   * @return canonical label
   */
  String label(Embedding embedding);
}
@FunctionAnnotation.ForwardedFields("id->f0;label->f1")
public class ToIdWithLabel<EL extends Element> implements MapFunction<EL, IdWithLabel> {

  /**
   * Reuse tuple
   */
  private final IdWithLabel reuseTuple = new IdWithLabel();

  @Override
  public IdWithLabel map(EL element) {
    reuseTuple.f0 = element.getId();
    reuseTuple.f1 = element.getLabel();
    return reuseTuple;
  }
}
public IdWithLabel() {
  public GradoopId getId() {
    return f0;
  }
}
public AdjacencyList() {
  public AdjacencyList(GraphHead graphHead, Map<ID, L> labels, Map<ID, Properties> properties,
    Map<ID, AdjacencyListRow<ED, VD>> outgoingRows, Map<ID, AdjacencyListRow<ED, VD>> incomingRows)
  {
    this.f0 = graphHead;
    this.f1 = labels;
    this.f2 = properties;
    this.f3 = outgoingRows;
    this.f4 = incomingRows;
  }

  /**
public void setGraphHead(GraphHead graphId) {
  }

  public Map<ID, AdjacencyListRow<ED, VD>> getIncomingRows() {
    return f3;
  }
}
    MapFunction<Vertex, VD> vertexDataFactory
  ) throws Exception {

    GraphHead graphHead = transaction.getGraphHead();
    Set<Vertex> vertices = transaction.getVertices();
    Set<Edge> edges = transaction.getEdges();

    Map<GradoopId, String> labels =
      Maps.newHashMapWithExpectedSize(1 + vertices.size() + edges.size());

    Map<GradoopId, Properties> properties =
      Maps.newHashMap();

    Map<GradoopId, AdjacencyListRow<ED, VD>> outgoingRows =
      Maps.newHashMapWithExpectedSize(vertices.size());

    Map<GradoopId, AdjacencyListRow<ED, VD>> incomingRows =
      Maps.newHashMapWithExpectedSize(vertices.size());

    Map<GradoopId, Vertex> vertexIndex =
      Maps.newHashMapWithExpectedSize(vertices.size());

    // VERTICES
    for (Vertex vertex : vertices) {
      addLabelsAndProperties(vertex, labels, properties);
      vertexIndex.put(vertex.getId(), vertex);
      outgoingRows.put(vertex.getId(), new AdjacencyListRow<>());
      incomingRows.put(vertex.getId(), new AdjacencyListRow<>());
    }

    // EDGES
    for (Edge edge : edges) {
      addLabelsAndProperties(edge, labels, properties);

      Vertex source = vertexIndex.get(edge.getSourceId());
      AdjacencyListRow<ED, VD> sourceRows = outgoingRows.get(source.getId());

      Vertex target = vertexIndex.get(edge.getTargetId());
      AdjacencyListRow<ED, VD> targetRows = incomingRows.get(target.getId());

      sourceRows.getCells().add(new AdjacencyListCell<>(
        edgeDataFactory.map(edge), vertexDataFactory.map(target)));

      targetRows.getCells().add(new AdjacencyListCell<>(
        edgeDataFactory.map(edge), vertexDataFactory.map(source)));
    }

    return new AdjacencyList<>(graphHead, labels, properties, outgoingRows, incomingRows);
  }

  /**
 */

/**
 * pojos related to category characteristic subgraph mining
 */

package org.gradoop.flink.algorithms.fsm.ccs.pojos;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.util.Collector;
import org.gradoop.common.model.impl.pojo.Element;
import org.gradoop.flink.algorithms.fsm.ccs.CategoryCharacteristicSubgraphs;
import org.gradoop.flink.algorithms.fsm.common.config.FSMConfig;
import org.gradoop.flink.datagen.transactions.predictable.PredictableTransactionsGenerator;
import org.gradoop.flink.model.GradoopFlinkTestBase;
import org.gradoop.flink.model.api.functions.TransformationFunction;

import java.util.List;

import static org.gradoop.flink.algorithms.fsm.ccs.CategoryCharacteristicSubgraphs.CATEGORY_KEY;
import static org.junit.Assert.assertEquals;

public class CategoryCharacteristicSubgraphsTest extends GradoopFlinkTestBase {
package org.gradoop.flink.algorithms.fsm;

import com.google.common.collect.Maps;
import org.gradoop.flink.algorithms.fsm.common.canonicalization.api
  .CanonicalLabeler;
import org.gradoop.flink.algorithms.fsm.common.canonicalization.cam.CAMLabeler;
import org.gradoop.flink.algorithms.fsm.common.canonicalization.gspan
  .MinDFSLabeler;
import org.gradoop.flink.algorithms.fsm.common.pojos.Embedding;
import org.gradoop.flink.algorithms.fsm.common.pojos.FSMEdge;
import org.junit.Test;

import java.util.Map;

import static org.junit.Assert.*;

public class MinDFSLabelerTest {

  @Test
  public void testDiamond() throws Exception {

    Map<Integer, String> vertices = Maps.newHashMap();

    vertices.put(0, "A");
    vertices.put(1, "A");
    vertices.put(2, "A");
    vertices.put(3, "A");

    Map<Integer, FSMEdge> edges = Maps.newHashMap();

    edges.put(0, new FSMEdge(0, "a", 1));
    edges.put(1, new FSMEdge(1, "a", 2));
    edges.put(2, new FSMEdge(0, "a", 3));
    edges.put(3, new FSMEdge(3, "a", 2));

    Embedding embedding = new Embedding(vertices, edges);

    CanonicalLabeler labeler = new MinDFSLabeler(true);

    String expectation = "0:A>a-1:A,1:A>a-2:A,2:A<a-3:A,3:A<a-0:A";
    String label = labeler.label(embedding);

    assertEquals(expectation, label);

    labeler = new MinDFSLabeler(false);

    expectation = "0:A-a-1:A,1:A-a-2:A,2:A-a-3:A,3:A-a-0:A";
    label = labeler.label(embedding);

    assertEquals(expectation, label);
  }

  @Test
  public void testMultiEdge() throws Exception {

    Map<Integer, String> vertices = Maps.newHashMap();

    vertices.put(0, "A");
    vertices.put(1, "A");
    vertices.put(2, "A");

    Map<Integer, FSMEdge> edges = Maps.newHashMap();

    edges.put(0, new FSMEdge(0, "a", 1));
    edges.put(1, new FSMEdge(0, "a", 1));
    edges.put(2, new FSMEdge(1, "a", 2));
    edges.put(3, new FSMEdge(1, "a", 2));

    Embedding embedding = new Embedding(vertices, edges);

    CanonicalLabeler labeler = new MinDFSLabeler(true);

    String expectation = "0:A>a-1:A,1:A<a-0:A,1:A>a-2:A,2:A<a-1:A";
    String label = labeler.label(embedding);

    assertEquals(expectation, label);

    labeler = new MinDFSLabeler(false);

    expectation = "0:A-a-1:A,1:A-a-0:A,1:A-a-2:A,2:A-a-1:A";
    label = labeler.label(embedding);

    assertEquals(expectation, label);
  }

  @Test
  public void testLoop() throws Exception {

    Map<Integer, String> vertices = Maps.newHashMap();

    vertices.put(0, "A");
    vertices.put(1, "A");
    vertices.put(2, "A");

    Map<Integer, FSMEdge> edges = Maps.newHashMap();

    edges.put(0, new FSMEdge(0, "a", 0));
    edges.put(1, new FSMEdge(0, "a", 1));
    edges.put(2, new FSMEdge(0, "a", 2));
    edges.put(3, new FSMEdge(1, "a", 2));

    Embedding embedding = new Embedding(vertices, edges);

    CanonicalLabeler labeler = new MinDFSLabeler(true);

    String expectation = "0:A>a-0:A,0:A>a-1:A,1:A>a-2:A,2:A<a-0:A";
    String label = labeler.label(embedding);

    assertEquals(expectation, label);

    labeler = new MinDFSLabeler(false);

    expectation = "0:A-a-0:A,0:A-a-1:A,1:A-a-2:A,2:A-a-0:A";
    label = labeler.label(embedding);

    assertEquals(expectation, label);
  }

  @Test
  public void testCircleWithBranch() throws Exception {

    Map<Integer, String> vertices = Maps.newHashMap();

    vertices.put(0, "A");
    vertices.put(1, "A");
    vertices.put(2, "A");
    vertices.put(3, "B");

    Map<Integer, FSMEdge> edges = Maps.newHashMap();

    edges.put(0, new FSMEdge(0, "a", 1));
    edges.put(1, new FSMEdge(1, "a", 2));
    edges.put(2, new FSMEdge(2, "a", 0));
    edges.put(3, new FSMEdge(2, "b", 3));

    Embedding embedding = new Embedding(vertices, edges);

    CanonicalLabeler labeler = new MinDFSLabeler(true);

    String expectation = "0:A>a-1:A,1:A>a-2:A,2:A>a-0:A,2:A>b-3:B";
    String label = labeler.label(embedding);

    assertEquals(expectation, label);

    labeler = new MinDFSLabeler(false);

    expectation = "0:A-a-1:A,1:A-a-2:A,2:A-a-0:A,2:A-b-3:B";
    label = labeler.label(embedding);

    assertEquals(expectation, label);
  }

  @Test
  public void testDirectedVsUndirected() throws Exception {

    Map<Integer, String> vertices = Maps.newHashMap();

    vertices.put(0, "A");
    vertices.put(1, "B");

    Map<Integer, FSMEdge> edges = Maps.newHashMap();

    edges.put(0, new FSMEdge(0, "b", 1));
    edges.put(1, new FSMEdge(1, "a", 0));


    Embedding embedding = new Embedding(vertices, edges);

    CanonicalLabeler labeler = new MinDFSLabeler(true);

    String expectation = "0:A>b-1:B,1:B>a-0:A";
    String label = labeler.label(embedding);

    assertEquals(expectation, label);

    labeler = new MinDFSLabeler(false);

    expectation = "0:A-a-1:B,1:B-b-0:A";
    label = labeler.label(embedding);

    assertEquals(expectation, label);
  }

  /**
   * Creation of paper examples
   */
//  @Test
//  public void test() {
//    Map<Integer, String> vertices = Maps.newHashMap();
//
//    vertices.put(0, "A");
//    vertices.put(1, "A");
//    vertices.put(2, "A");
//
//    Map<Integer, FSMEdge> edges = Maps.newHashMap();
//
//    edges.put(0, new FSMEdge(0, "a", 1));
//    edges.put(1, new FSMEdge(0, "a", 1));
//    edges.put(2, new FSMEdge(1, "a", 2));
//    edges.put(3, new FSMEdge(1, "a", 2));
//
//    Embedding embedding = new Embedding(vertices, edges);
//
//    System.out.println(new MinDFSLabeler(true).label(embedding));
//    System.out.println(new MinDFSLabeler(false).label(embedding));
//    System.out.println(new CAMLabeler(true).label(embedding));
//    System.out.println(new CAMLabeler(false).label(embedding));
//
//    vertices = Maps.newHashMap();
//
//    vertices.put(0, "A");
//    vertices.put(1, "B");
//
//    edges = Maps.newHashMap();
//
//    edges.put(0, new FSMEdge(0, "b", 1));
//    edges.put(1, new FSMEdge(0, "b", 1));
//    edges.put(2, new FSMEdge(1, "a", 0));
//
//    embedding = new Embedding(vertices, edges);
//
//    System.out.println(new MinDFSLabeler(true).label(embedding));
//    System.out.println(new MinDFSLabeler(false).label(embedding));
//    System.out.println(new CAMLabeler(true).label(embedding));
//    System.out.println(new CAMLabeler(false).label(embedding));
//  }
}
package org.gradoop.flink.algorithms.fsm;

import org.apache.flink.api.java.DataSet;
import org.gradoop.flink.algorithms.fsm.common.config.FSMConfig;
import org.gradoop.flink.algorithms.fsm.tfsm.TransactionalFSM;
import org.gradoop.flink.datagen.transactions.predictable
  .PredictableTransactionsGenerator;
import org.gradoop.flink.model.GradoopFlinkTestBase;
import org.gradoop.flink.model.impl.GraphTransactions;
import org.gradoop.flink.representation.transactional.GraphTransaction;
private void mineDirected(

    FSMConfig fsmConfig = new FSMConfig(threshold, true);

    DataSet<GraphTransaction> frequentSubgraphs =
      new TransactionalFSM(fsmConfig)
        .execute(transactions)
        .getTransactions();

    Assert.assertEquals(
      PredictableTransactionsGenerator
private void mineUndirected(

    FSMConfig fsmConfig = new FSMConfig(threshold, false);

    DataSet<GraphTransaction> frequentSubgraphs =
      new TransactionalFSM(fsmConfig)
        .execute(transactions)
        .getTransactions();

    Assert.assertEquals(
      PredictableTransactionsGenerator
package org.gradoop.flink.algorithms.fsm;

import org.gradoop.flink.algorithms.fsm.common.config.FSMConfig;
import org.gradoop.flink.algorithms.fsm.tfsm.TransactionalFSM;
import org.gradoop.flink.model.GradoopFlinkTestBase;
import org.gradoop.flink.model.api.operators.UnaryCollectionToCollectionOperator;
import org.gradoop.flink.model.impl.GraphCollection;
public void testSingleEdges() throws Exception {
    String[] searchSpaceVariables = {"g1", "g2", "g3", "g4"};
    String[] expectedResultVariables = {"s1"};

    TransactionalFSM transactionalFSM = new TransactionalFSM(
      fsmConfig);

    compareExpectationAndResult(transactionalFSM,
public void testSimpleGraphs() throws Exception {
    String[] searchSpaceVariables = {"g1", "g2", "g3"};
    String[] expectedResultVariables = {"s1", "s2", "s3", "s4", "s5"};

    TransactionalFSM transactionalFSM = new TransactionalFSM(fsmConfig);

    compareExpectationAndResult(transactionalFSM,
      asciiGraphs, searchSpaceVariables, expectedResultVariables);
public void testParallelEdges() throws Exception {
    String[] searchSpaceVariables = {"g1", "g2", "g3"};
    String[] expectedResultVariables = {"s1", "s2"};

    TransactionalFSM transactionalFSM = new TransactionalFSM(
      fsmConfig);

    compareExpectationAndResult(transactionalFSM,
public void testLoop() throws Exception {
    String[] searchSpaceVariables = {"g1", "g2", "g3", "g4"};
    String[] expectedResultVariables = {"s1", "s2", "s3"};

    TransactionalFSM transactionalFSM = new TransactionalFSM(
      fsmConfig);

    compareExpectationAndResult(transactionalFSM,
public void testDiamond() throws Exception {
      {"s1", "s2", "s3", "s4", "s5", "s6", "s7"};


    TransactionalFSM transactionalFSM = new TransactionalFSM(
      fsmConfig);

    compareExpectationAndResult(transactionalFSM,
public void testCircleWithBranch() throws Exception {
    String[] expectedResultVariables =
      {"s11", "s12", "s21", "s22", "s23", "s31", "s32", "s33", "s34", "s41"};

    TransactionalFSM transactionalFSM = new TransactionalFSM(
      fsmConfig);

    compareExpectationAndResult(transactionalFSM,
public static void assertEquals(AdjacencyList<GradoopId, String, GradoopId, Grad

      List<AdjacencyListCell<GradoopId, GradoopId>> aCells =
        Lists.newArrayList(aRows.get(vertexId).getCells());
      
      List<AdjacencyListCell<GradoopId, GradoopId>> bCells =
        Lists.newArrayList(aRows.get(vertexId).getCells());

public static void assertEquals(AdjacencyList<GradoopId, String, GradoopId, Grad
      Properties aProperties = a.getProperties(id);
      Properties bProperties = b.getProperties(id);

      assertTrue(aProperties == null && bProperties == null 
        || aProperties.equals(bProperties));

    }
  }
}
 * Base class for Pattern Matching Tests.
 */
@RunWith(Parameterized.class)
public abstract class PatternMatchingTest extends GradoopFlinkTestBase {

  private final String testName;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void edit(int cursorX, int cursorY)

	private void interact(int cursorX, int cursorY)
	{
		if (Gdx.input.isKeyJustPressed(Keys.SPACE))
		{
			if (!(cursorY >= 0 && cursorY < circuit.grid.length && cursorX >= 0
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public static String toString(final DataFrame<?> df, final int limit) {
        // determine index width
        width.put(INDEX_KEY, 0);
        for (final Object row : df.index()) {
            width.put(INDEX_KEY, clamp(
                    width.get(INDEX_KEY),
                    MAX_COLUMN_WIDTH,
                    fmt(row.getClass(), row).length()));
        }

        // determine column widths
public static String toString(final DataFrame<?> df, final int limit) {
            // output row name
            int w = width.get(INDEX_KEY);
            final Object row = names.hasNext() ? names.next() : r;
            sb.append(truncate(lpad(fmt(row.getClass(), row), w), w));

            // output rows
            for (int c = 0; c < df.size(); c++) {
private static final String truncate(final Object o, final int w) {
    }

    private static final String fmt(final Class<?> cls, final Object o) {
        String s;
        if (o instanceof Number) {
            if (Short.class.equals(cls) || Integer.class.equals(cls) ||
public void testToString() {
                df.toString().split("\n").length
            );
    }

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
INode getReplicatedNode()
		if (!itQuantifiers.hasNext() && firstRun)
		{
			nextNode = factory.getReplicatedNode();
			return new Pair<INode, Context>(nextNode, factory.createReplicationChildContext(nextValue, nextNode, question));
		}
		/*
		 * if no more rep values exists and this is NOT the first run then we created the context for the left side
private void checkResult(ExpectedTestResult testResult,
	@Parameters(name = "{index} : {1}")
	public static Collection<Object[]> getCmlfilePaths()
	{

		final String initialPath = "src/test/resources/standard";
		List<Object[]> paths = findAllCmlFiles(initialPath);

		// List<Object[]> paths = findAllCmlFiles("src/test/resources/action/parallel-composition");
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public Note getNote(int number){
	
	public String toString(){
		String result = "";
		for(Note n: notes){
			result += n.getNoteLetterName() + Integer.toString(n.getOctNameNumeric()) + ";";
		}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public String getAttribute(Attribute attribute) {
        // -->
        if (attribute.startsWith("town")) {
            try {
                return new dTown(TownyUniverse.getDataSource().getTown(TownyUniverse.getTownName(location)))
                        .getAttribute(attribute.fulfill(1));
            }
            catch (NotRegisteredException ex) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public ScaleDegree getScDeg() {
	}
	
	public int getSeventhIndex(){
		return getNoteIndexByPosition(ChordPosition.Seventh);
	}
	
	public void bassUp(){
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public int add(DownloadRequest request) {
		}

		request.setContext(context);
		request.setDownloader(downloader.copy());

		/* add download request into download request queue */
		return downloadRequestQueue.add(request) ? request.downloadId() : -1;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    // Mann-Whitney U
    private double mann_whit_pvalue;

    //set of genes in common to both gene sets.
    private Set<Integer> overlapping_genes;

    //if it is zero the similarity applies to both sets.
    private int enrichment_set;
    
    private boolean sensitivity;

    /**
     * Class constructor
public GenesetSimilarity(String geneset1_Name, String geneset2_Name, double simi
        this.hypergeom_pvalue = -1.0;
        this.interaction_type = interaction_type;
        this.enrichment_set = enrichment_set;
        this.setSensitivity(false);
     }


public GenesetSimilarity(String geneset1_Name, String geneset2_Name, double simi
        this.hypergeom_pvalue = -1.0;
        this.interaction_type = interaction_type;
        this.enrichment_set = 0;
        this.setSensitivity(false);
     }

    /**
public GenesetSimilarity(String geneset1_Name, String geneset2_Name, double simi
        this.interaction_type = interaction_type;

        this.enrichment_set = 0;
        this.setSensitivity(false);
    }


public void setMann_Whit_pValue(double mann_whit_pvalue) {
	}


	/**
	 * @return the sensitivity
	 */
	public boolean getSensitivity() {
		return sensitivity;
	}


	/**
	 * @param sensitivity the sensitivity to set
	 */
	public void setSensitivity(boolean sensitivity) {
		this.sensitivity = sensitivity;
	}

}


import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
 * Cytoscape-Task to perform  Disease-Signature Post-Analysis
 */
public class BuildDiseaseSignatureTask extends AbstractTask implements ObservableTask {
	private final CySwingApplication swingApplication;
	private final CyApplicationManager applicationManager;
    private final CyEventHelper eventHelper;
    
public BuildDiseaseSignatureTask(EnrichmentMap map, PostAnalysisParameters paPar
    	this.map = map;
    	this.applicationManager = applicationManager;
    	this.eventHelper = eventHelper;
    	this.swingApplication = swingApplication;

    	HashMap<String, DataSet> data_sets = this.map.getDatasets();
    	DataSet dataset = data_sets.get(paParams.getSignature_dataSet());
else if(EnrichmentMap.DATASET2.equals(paParams.getSignature_dataSet())) {

    

    @SuppressWarnings("incomplete-switch")
	public void buildDiseaseSignature(TaskMonitor taskMonitor) {

        /* **************************************************
private boolean passesCutoff(String edge_name) {
			case HYPERGEOM:
				return similarity.getHypergeom_pvalue() <= filterParams.getValue(FilterType.HYPERGEOM);
			case MANN_WHIT:
				return similarity.getSensitivity() || similarity.getMann_Whit_pValue() <= filterParams.getValue(FilterType.MANN_WHIT);
			case NUMBER:
				return similarity.getSizeOfOverlap() >= filterParams.getValue(FilterType.NUMBER);
			case PERCENT:
private void mannWhitney(Set<Integer> intersection, GenesetSimilarity comparison
		Map<Integer, Double> gene2score = ranks.getGene2Score();
		if (gene2score == null || gene2score.isEmpty()) {
			comparison.setMann_Whit_pValue(1.5);
		} else {
			// Calculate Mann-Whitney U pValue for Overlap
            Integer[] overlap_gene_ids = intersection.toArray(new Integer[intersection.size()]);
            double[] overlap_gene_scores = new double[overlap_gene_ids.length];
            
            // Get the scores for the overlap
            for (int k = 0; k < overlap_gene_ids.length; k++) {
            	overlap_gene_scores[k] = gene2score.get(overlap_gene_ids[k]);
            }
            
            double[] scores = ranks.getScores();
            MannWhitneyUTest mann_whit = new MannWhitneyUTest();
			double mannPval = mann_whit.mannWhitneyUTest(overlap_gene_scores, scores);
    		// Set Mann-Whitney U Parameters
    		comparison.setMann_Whit_pValue(mannPval);
		}
	}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void upgrade() throws Exception {
              for (Map.Entry<Long, byte[]> columnEntry : columnMap.getValue().entrySet()) {
                Long timeStamp = columnEntry.getKey();
                byte[] colVal = columnEntry.getValue();
                String specEntry = Bytes.toString(colVal);
                DatasetSpecification specification = GSON.fromJson(specEntry, DatasetSpecification.class);
                DatasetSpecification updatedSpec = updateTTLInSpecification(specification, null);
public void upgrade() throws Exception {
              }
            }
          }
          specTable.put(put);
        }
      }
    } finally {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import static info.archinnov.achilles.internals.schema.SchemaValidator.validateColumns;
import static info.archinnov.achilles.internals.schema.SchemaValidator.validateDefaultTTL;
import static info.archinnov.achilles.internals.statements.PreparedStatementGenerator.*;
import static java.lang.String.format;
import static java.util.stream.Collectors.toList;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.datastax.driver.core.ConsistencyLevel;
import com.datastax.driver.core.Row;
import com.datastax.driver.core.Session;
import com.datastax.driver.core.TableMetadata;
import com.datastax.driver.core.querybuilder.QueryBuilder;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.collect.BiMap;
public void validateSchema(ConfigurationContext configContext) {
        Validator.validateNotBlank(keyspace,
                "Current keyspace not provided neither in configuration nor on entity '%!s(MISSING)' annotation", entityClass.getCanonicalName());

        final TableMetadata tableMetadata = configContext
                .getSession()
                .getCluster()
                .getMetadata()
                .getKeyspace(keyspace)
                .getTable(getTableName());

        validateDefaultTTL(tableMetadata, staticTTL, entityClass);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import org.hibernate.validator.constraints.Email;
import org.hibernate.validator.constraints.NotBlank;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;

import com.bpjoshi.paharinetwork.validations.PasswordMatcher;
 */
@Entity
@Table(name="end_user")
@PasswordMatcher(message="{register.password.mismatch}")
public class EndUser {
@Id
@GeneratedValue(strategy=GenerationType.AUTO)
@NotBlank(message="{register.email.invalid}")
@Column(name="user_email", unique=true)
private String userEmail;
@Size(min=5, max=15, message="{register.password.invalid}")
@Transient
private String plainPassword;
@Transient
private String repeatPassword;
@Column(name="user_password", length=60)
private String userPassword;
@Column(name="user_role", length=20)
private String userRole;
@Autowired
@Transient
private PasswordEncoder passwordEncoder;

public String getUserRole() {
	return userRole;
public String getPlainPassword() {
}
public void setPlainPassword(String plainPassword) {
	this.plainPassword = plainPassword;
	this.setUserPassword(passwordEncoder.encode(plainPassword));
}
public String getRepeatPassword() {
	return repeatPassword;
}
public void setRepeatPassword(String repeatPassword) {
	this.repeatPassword = repeatPassword;
}
public PasswordEncoder getPasswordEncoder() {
	return passwordEncoder;
}
public void setPasswordEncoder(PasswordEncoder passwordEncoder) {
	this.passwordEncoder = passwordEncoder;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.io.PrintWriter;

public class FunkrufProtocol {
	
	public MessageQueue messageQueue = null;
	public static final int E_SUCCESS = 0, E_ERROR = -1, E_RETRY = 1;

	private Log log = null;
	
	
	private void log(String message, int type) {
		log(message, type, Log.DEBUG_TCP);
	}
private void log(String message, int type, int logLevel) {
	}
	
	public FunkrufProtocol(MessageQueue messageQueue, Log log) {
		
		this.messageQueue = messageQueue;
		this.log = log;
		
	}
	
	public void handle(String msg, PrintWriter pw, TimeSlots timeSlots) {
	
		int errorState = E_SUCCESS;
		
		String [] parts = msg.split(":", 5);
public void handle(String msg, PrintWriter pw, TimeSlots timeSlots) {
		switch(type) {
			case '#':
				// Funkrufe
				
				try {
					int messageID = Integer.parseInt(parts[0].substring(1, 3), 16);
					this.messageQueue.push(new Message(parts));
					
					messageID = (messageID + 1) %!;(MISSING)
					
					send(String.format("#%!x(MISSING) +", messageID), pw);
					
				} catch(NumberFormatException e) {
					log("FunkrufProtocol: handle# (#) NumberFormatException", Log.ERROR);
					errorState = E_ERROR;
					
				}
				
				break;
				
			case '2':

				String ident = parts[1];
				int time = Main.scheduler.getTime();
				
				send(String.format("2:%!s(MISSING):%!x(MISSING)", ident, time), pw);
				ack(errorState, pw);
				
				break;
				
			case '3':
				// correct system time
				
				try {
					int delay;
					
public void handle(String msg, PrintWriter pw, TimeSlots timeSlots) {
						delay = -Integer.parseInt(parts[1], 16);
					}					
					
					
					Main.scheduler.correctTime(delay);
					
				} catch(NumberFormatException e) {
					log("FunkrufProtocol: handle# (3) NumberFormatException", Log.ERROR);
					
					errorState = E_ERROR;
				}
				

				ack(errorState, pw);
				
				break;
				
			case '4':
				// set slots
				timeSlots.setSlots(parts[1]);
public void handle(String msg, PrintWriter pw, TimeSlots timeSlots) {
				ack(errorState, pw);
				
				break;
				
			default:
				log("FunkrufProtocol: handle# unknown type", Log.ERROR);
				errorState = E_ERROR;
public void send(String answer, PrintWriter pw) {
	
		pw.printf("%!s(MISSING)\r\n", answer);
	}
	
}
public static boolean initGpioPortComm() {
			gpioPortComm = new GpioPortComm(Main.config.getGpioPin(), Main.config.getInvert(), log);
			return true;
		}
		return false;
	}

public static void startScheduler(boolean searching) {
			}
			return;
		}

		timer.schedule(scheduler, 100, 100);
	}

public static void startServer(boolean join) {
			server = new ServerThread(config.getPort(), messageQueue, log);
		}

		if (!initSerialPortComm()) {
			stopServer(true);
			return;
		}

		if (!initGpioPortComm()) {
			stopServer(true);
			return;
		}

		// start scheduler (not searching)
		startScheduler(false);

public void halt() {
	// "main"
	@Override
	public void run() {
		
		try {
			// open writer and reader
			this.pw = new PrintWriter(this.socket.getOutputStream(), true);
public void run() {
			
			// if thread is running, wait for input
			while(this.running && (inputBuffer = this.reader.readLine()) != null) {
				
				log("SocketThread: inputBuffer# " + inputBuffer, Log.MS);
				
				// handle received input
				this.protocol.handle(inputBuffer, this.pw, Main.timeSlots);

			}
			
			// close writer, reader and socket
public void run() {
			this.running = false;
			
			log("SocketThread: connection lost", Log.COMMUNICATION);
			
		} catch(IOException e) {
			
			e.printStackTrace();
			
		}
				
		// remove thread from thread list
		Main.removeSocketThread(this);
	}
	
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public TileLayerData mapQuery( LayerQuery query, List<String> headers )

        String tds = coordinateSystems.get( crs );
        if ( tds == null ) {
            LOG.debug( "Tile layer {} does not offer the coordinate system {}.", getMetadata().getName(),
                       crs.getAlias() );
            return null;
        }
        TileDataSet data = tileDataSets.get( tds );

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
protected static boolean isCompatibleClass(Class<?> expected, Class<?> given)
    @Override
	public String toString() {
		return Objects.toStringHelper(this.getClass()).add("propertyMetas", propertyMetas).toString();

	}
}
private Object encodeValueForProperty(String columnName, Object rawValue) {
        return encodedValue;
    }

    private PropertyMeta findPropertyMetaByCQLName(String cqlName) {
        for (PropertyMeta propertyMeta : meta.getAllMetasExceptCounters()) {
            if (propertyMeta.getCQLColumnName().equals(cqlName) ) {
                return propertyMeta;
            }
        }
        throw new AchillesException(String.format("Cannot find matching property meta for the cql field %!s(MISSING)", cqlName));
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class EntityMetaTranscoderTest {

public void should_encode_index_condition_value() throws Exception {
        assertThat(encoded).isEqualTo("DuyHai");
        verify(indexCondition).encodedValue("DuyHai");
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	private boolean is_ime_running;
	private boolean is_ime_showing;
	private boolean is_hud_cancelled;
	//	private boolean is_framework_ready;

	private int mScanDelay;
public boolean isIMEShowing() {
		return is_ime_showing;
	}

	public void setHUDCancelled(boolean bool) {
		is_hud_cancelled = bool;
	}

	public boolean isHUDCancelled() {
		return is_hud_cancelled;
	}

	public boolean isFullscreenEnabled() {
		return shared_prefs.getBoolean(PREF_FULLSCREEN_MODE, false);
	}

	// TODO: This method depends only on full-screen mode now, but will likely depend on other preferences later on
	public boolean shouldShowHUD() {
		return shared_prefs.getBoolean(PREF_FULLSCREEN_MODE, false);
public void onClick(View v) {
		@Override
		public boolean onLongClick(View v) {
			TeclaStatic.logV(CLASS_TAG, "Long clicked.  ");
			TeclaApp.persistence.setHUDCancelled(true);
			TeclaApp.a11yservice.shutdownInfrastructure();
			return true;
		}
	};
public void run() {
	public static boolean hasScrollableParent(AccessibilityNodeInfo node) {
		if(node == null) return false;
		AccessibilityNodeInfo parent = node.getParent();
		if(!parent.isScrollable()) return false;
		return true;
	}

public static boolean isFirstScrollNode(AccessibilityNodeInfo node) {
		if(!hasScrollableParent(node)) return false;
		AccessibilityNodeInfo parent = node.getParent();

		Rect firstScrollNode_rect = null;	
		for(int i=0; i<parent.getChildCount(); ++i) {
			AccessibilityNodeInfo  firstScrollNode = parent.getChild(i);
			if(firstScrollNode.isVisibleToUser() && firstScrollNode.isClickable()) {
				firstScrollNode_rect = new Rect();
				firstScrollNode.getBoundsInScreen(firstScrollNode_rect);
				break;
			}
		}		
		if(firstScrollNode_rect == null) return false;

		Rect node_rect = new Rect(); 
public static boolean isLastScrollNode(AccessibilityNodeInfo node) {
		if(node == null) return false;
		if(!hasScrollableParent(node)) return false;
		AccessibilityNodeInfo parent = node.getParent();

		Rect lastScrollNode_rect = null;	
		for(int i=parent.getChildCount()-1; i>=0; --i) {
			AccessibilityNodeInfo  lastScrollNode = parent.getChild(i);
			if(lastScrollNode.isVisibleToUser() && lastScrollNode.isClickable()) {
				lastScrollNode_rect = new Rect();
				lastScrollNode.getBoundsInScreen(lastScrollNode_rect);
				break;
			}
		}		
		if(lastScrollNode_rect == null) return false;

		Rect node_rect = new Rect(); 
public static boolean isInsideParent(AccessibilityNodeInfo node) {
		return false;
	}

	public static void sendGlobalBackAction() {
		if(sInstance == null) return;
		sInstance.performGlobalAction(AccessibilityService.GLOBAL_ACTION_BACK);
	}

	public static void sendGlobalHomeAction() {
		if(sInstance == null) return;
		sInstance.performGlobalAction(AccessibilityService.GLOBAL_ACTION_HOME);		
	}	

	public static void sendGlobalNotificationAction() {
		if(sInstance == null) return;
		sInstance.performGlobalAction(AccessibilityService.GLOBAL_ACTION_NOTIFICATIONS);		
	}	

private void processFrameworkOptions() {
	}
	
	public void turnFullscreenOn() {
		a11yservice.showHUD();
		TeclaAccessibilityService.sendGlobalHomeAction();
		persistence.setSelfScanningEnabled(true);
		AutomaticScan.startAutoScan();;
		a11yservice.showFullscreenSwitch();
	}
	
	public void answerCall() {
public void onClick(View v) {
		}
	};	

	private View.OnLongClickListener mOverlayLongClickListener =  new View.OnLongClickListener() {

		@Override
		public boolean onLongClick(View v) {
			TeclaStatic.logV(CLASS_TAG, "Long clicked.  ");
			TeclaApp.persistence.setHUDCancelled(true);
			TeclaApp.a11yservice.shutdownInfrastructure();
			return true;
		}
	};

	public static void selectScanHighlighted() {
		TeclaHUDOverlay.sInstance.scanTrigger();
	}
protected void scanTrigger() {
			TeclaAccessibilityService.clickActiveNode();
			break;
		case HUD_BTN_BOTTOMLEFT:
			TeclaAccessibilityService.sendGlobalBackAction();
			/*if(Persistence.isDefaultIME(mContext) && TeclaApp.persistence.isIMERunning()) {
				TeclaStatic.logI(CLASS_TAG, "LatinIME is active");
				TeclaApp.ime.pressBackKey();
			} else TeclaStatic.logW(CLASS_TAG, "LatinIME is not active!");*/
			break;
		case HUD_BTN_TOPLEFT:
			TeclaAccessibilityService.sendGlobalHomeAction();
			/*if(Persistence.isDefaultIME(mContext) && TeclaApp.persistence.isIMERunning()) {
				TeclaStatic.logI(CLASS_TAG, "LatinIME is active");
				TeclaApp.ime.pressHomeKey();
public boolean onPreferenceChange(Preference pref, Object newValue) {
			if (newValue.toString().equals("true")) {
				TeclaApp.getInstance().turnFullscreenOn();
			} else {
				TeclaApp.a11yservice.hideFullscreenSwitch();
				TeclaApp.persistence.setSelfScanningEnabled(false);
				AutomaticScan.stopAutoScan();				
				TeclaApp.a11yservice.hideHUD();
			}
			return true;
		}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Add this to your module's `build.gradle` file:
```gradle
dependencies {
    // ... other dependencies
    compile 'com.afollestad:aesthetic:0.4.0'
}
```

ext.versions = [
        minSdk            : 16,
        compileSdk        : 25,
        buildTools        : '25.0.3',
        publishVersion    : '0.4.1',
        publishVersionCode: 13,
        gradlePlugin      : '2.3.2',

        supportLib        : '25.3.1',
public static void pause(@NonNull AppCompatActivity activity) {
    if (instance.backgroundSubscriptions != null) {
      instance.backgroundSubscriptions.clear();
    }
    if (instance.context != null
        && instance.context.getClass().getName().equals(activity.getClass().getName())) {
      instance.context = null;
    }
    if (activity.isFinishing()) {
      instance.backgroundSubscriberViews.remove(activity);
    }
  }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import com.todoroo.astrid.data.SyncFlags;
import com.todoroo.astrid.data.TagData;
import com.todoroo.astrid.data.Task;
import com.todoroo.astrid.data.TaskAttachment;
import com.todoroo.astrid.files.FileUtilities;
import com.todoroo.astrid.gcal.GCalControlSet;
import com.todoroo.astrid.gcal.GCalHelper;
import com.todoroo.astrid.repeats.RepeatControlSet;
import org.tasks.R;

import java.util.HashSet;
import java.util.concurrent.atomic.AtomicReference;

/**
 * Quick Add Bar lets you add tasks.
    private RepeatControlSet repeatControl;
    private GCalControlSet gcalControl;

    private String currentVoiceFile = null;

    @Autowired ExceptionService exceptionService;
    @Autowired
    private TaskAttachmentDao taskAttachmentDao;
private void resetControlSets() {
        deadlineControl.readFromTask(empty);
    }


    // --- quick add task logic

    /**
public Task quickAddTask(String title, boolean selectNewTask) {
                }
            }

            if (currentVoiceFile != null) {

                AtomicReference<String> nameRef = new AtomicReference<>();
                String path = FileUtilities.getNewAudioAttachmentPath(activity, nameRef);

                voiceRecognizer.convert(path);
                currentVoiceFile = null;

                TaskAttachment attachment = TaskAttachment.createNewAttachment(task.getUuid(), path, nameRef.get(), TaskAttachment.FILE_TYPE_AUDIO + "m4a");
                taskAttachmentDao.createNew(attachment);
            }

            fragment.onTaskCreated(task);

            return task;
public boolean onActivityResult(int requestCode, int resultCode, Intent data) {
            return true;
        }


        return false;
    }


    public VoiceRecognizer getVoiceRecognizer() {
        return voiceRecognizer;
    }
    public void startVoiceRecognition() {
        if (VoiceRecognizer.speechRecordingAvailable(activity) && currentVoiceFile == null) {
            currentVoiceFile = Long.toString(DateUtilities.now());
        }
        voiceRecognizer.startVoiceRecognition(activity, fragment, currentVoiceFile);
    }

    public void setupRecognizerApi() {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import org.molgenis.data.meta.model.EntityType;
import org.molgenis.data.populate.EntityPopulator;
import org.molgenis.data.support.*;
import org.molgenis.util.BatchingIterable;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

else if (isMultipleReferenceType(attr))
							// replace lazy entity with real entity
							Object refEntityId = lazyRefEntity.getIdValue();
							return refEntitiesIdMap.get(refEntityId);
						}).collect(Collectors.toList());
						entity.set(attrName, mrefEntities);
					}
				}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public Object getObjectOfClass(String name)
        {
            Util.userError("Illegal access to class", clname);
        }

        // UNREACHABLE
        throw Util.unreachable();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public boolean onOptionsItemSelected(MenuItem item) {
                finish();
                return true;

            case R.id.home_ab_refresh:
                //TODO Update users
                PangsListFragment pFrag = (PangsListFragment) getFragmentManager().findFragmentByTag("mFragment");
                pFrag.UpdateStatus();
                return true;

            case R.id.home_ab_featReq:
                Intent github = new Intent(Intent.ACTION_VIEW, Uri.parse("https://github.com/reustonium/Lunch-Pals/issues/new"));
                startActivity(github);
    <TextView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:text="@string/hello_blank_fragment" />

</FrameLayout>
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="32dp"
            android:text="Nudges Sent"/>
        <TextView
            android:id="@+id/stats_sent"
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:textSize="32dp"
            android:textStyle="bold"
            android:layout_gravity="right"
            android:gravity="right"
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="32dp"
            android:text="Times Nudged"/>
        <TextView
            android:id="@+id/stats_nudged"
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:textSize="32dp"
            android:textStyle="bold"
            android:layout_gravity="right"
            android:gravity="right"

<menu xmlns:android="http://schemas.android.com/apk/res/android">
    <item
        android:id="@+id/home_ab_refresh"
        android:icon="@android:drawable/ic_popup_sync"
        android:title="Refresh Data"
        android:showAsAction="ifRoom"/>
    <item
        android:id="@+id/home_ab_logout"
        android:icon="@drawable/ic_action_loginout"
        android:title="Logout"
    <string name="app_name">LunchPals</string>
    <string name="error_username_taken">Error - Username already taken</string>
    <string name="frag_home_greeting">Greetings</string>
    <string name="splash_message">Alpha Release v0.2.5</string>
    <string name="title_activity_main">MainActivity</string>
    <string name="title_section1">Pals List</string>
    <string name="title_section2">Locations</string>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import static me.drakeet.transformer.App.calculationExecutor;
import static me.drakeet.transformer.App.networkExecutor;
import static me.drakeet.transformer.Requests.urlToResponse;
import static me.drakeet.transformer.entity.Step.OnConfirm;
import static me.drakeet.transformer.entity.Step.OnWorking;
import static me.drakeet.transformer.request.TranslateRequests.YOU_DAO;
private void handleContent(@NonNull final String content) {
                break;
            case "":
            case "":
                onStopStep();
                break;
            default:
                echoDelegate.handleContent(content);
#Wed Sep 07 22:19:56 CST 2016
AI_VERSION_CODE=432
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;

@Mod(modid=AdditionalPipes.MODID, name=AdditionalPipes.NAME,
dependencies="after:BuildCraft|Transport;after:BuildCraft|Silicon;after:BuildCraft|Transport;after:BuildCraft|Factory",
version=AdditionalPipes.VERSION)
@NetworkMod(channels={AdditionalPipes.CHANNEL, AdditionalPipes.CHANNELNBT},
clientSideRequired=true, serverSideRequired=true, packetHandler=NetworkHandler.class)
public class AdditionalPipes {
	public static final String MODID = "APUnofficial";
	public static final String NAME = "Additional Pipes Unofficial";
	@Instance(MODID)
	public static AdditionalPipes instance;

	@SidedProxy(clientSide = "buildcraft.additionalpipes.MutiPlayerProxyClient",
			serverSide = "buildcraft.additionalpipes.MutiPlayerProxy")
	public static MutiPlayerProxy proxy;

	public File configFile;
	private static @interface CfgId {
		public boolean block() default false;
	}
	@Retention(RetentionPolicy.RUNTIME)
	private static @interface CfgBool {}

	public static final String LOC_PATH = "/buildcraft/additionalpipes";
	//textures
	public static final String BASE_PATH = "/mods/additionalpipes";
	public static final String TEXTURE_PATH = BASE_PATH + "/textures";

	public static final String TEXTURE_GUI_TELEPORT = TEXTURE_PATH + "/gui/blankSmallGui.png";
	public static final String TEXTURE_GUI_ADVANCEDWOOD = TEXTURE_PATH + "/gui/advancedWoodGui.png";
	public static final String TEXTURE_GUI_DISTRIBUTION = TEXTURE_PATH + "/gui/distributionGui.png";

	//chunk load boundaries
	public ChunkLoadViewDataProxy chunkLoadViewer;
	public @CfgBool boolean chunkSight = true;
	public int chunkSightRange = 8; //config option
	public @CfgBool boolean chunkSightAutorefresh = true;

	//teleport scanner TODO
	//public Item teleportScanner;
	//public @CfgId int teleportScannerId = 14061;
	//meter TODO
	//public Item powerMeter;
	//public @CfgId int powerMeterId = 14060;

	//Redstone Liquid
	public Item pipeLiquidsRedstone;
	public @CfgId int pipeLiquidsRedstoneId = 14042;
	//Redstone
	public Item pipeItemsRedStone;
	public @CfgId int pipeItemsRedStoneId = 14043;
	//Advanced Insertion
	public Item pipeItemsAdvancedInsertion;
	public @CfgId int pipeItemsAdvancedInsertionId = 14044;
	//Advanced Wood
	public Item pipeItemsAdvancedWood;
	public @CfgId int pipeItemsAdvancedWoodId = 14045;
	//Distributor
	public Item pipeItemsDistributor;
	public @CfgId int pipeItemsDistributorId = 14046;
	//Item Teleport
	public Item pipeItemsTeleport;
	public @CfgId int pipeItemsTeleportId = 14047;
	//Liquid Teleport
	public Item pipeLiquidsTeleport;
	public @CfgId int pipeLiquidsTeleportId = 14048;
	//Power Teleport
	public Item pipePowerTeleport;
	public @CfgId int pipePowerTeleportId = 14049;
	//Items Closed
	public Item pipeItemsClosed;
	public @CfgId int pipeItemsClosedId = 14050;
	//Switch pipes
	public Item pipePowerSwitch;
	public @CfgId int pipePowerSwitchId = 14051;
	public Item pipeItemsSwitch;
	public @CfgId int pipeItemsSwitchId = 14052;
	public Item pipeLiquidsSwitch;
	public @CfgId int pipeLiquidsSwitchId = 14053;
	//water pump pipe
	public Item pipeLiquidsWaterPump;
	public @CfgId int pipeLiquidsWaterPumpId = 14054;
	//chunk loader
	public Block blockChunkLoader;
	public @CfgId(block=true) int chunkLoaderId = 1890;

	public @CfgBool boolean enableTriggers = true;
	public ITrigger triggerPipeClosed;

	public ITrigger triggerPhasedSignalRed;
	public ITrigger triggerPhasedSignalBlue;
	public ITrigger triggerPhasedSignalGreen;
	public ITrigger triggerPhasedSignalYellow;
	//keybinding
	public int laserKeyCode = 64; //config option (& in options menu)
	//misc
	public @CfgBool boolean allowWRRemove = false;
	public double powerLossCfg = 0.90; //config option

	@PreInit
	public void preInit(FMLPreInitializationEvent event) {
		logger = Logger.getLogger(MODID);
		logger.setParent(FMLLog.getLogger());
		logger.setLevel(Level.WARNING); //DEBUG

		configFile = event.getSuggestedConfigurationFile();
		loadConfigs(false);
public void preInit(FMLPreInitializationEvent event) {
			en_US = new Properties();
			en_US.load(AdditionalPipes.class.getResourceAsStream((LOC_PATH + "/lang/en_US.properties")));
			LanguageRegistry.instance().addStringLocalization(en_US);
		} catch (Exception e) {
			logger.log(Level.SEVERE, "Failed to load default localization.", e);
		}
		MinecraftForge.EVENT_BUS.register(this);
public void preInit(FMLPreInitializationEvent event) {
	@Init
	public void init(FMLInitializationEvent event) {
		NetworkRegistry.instance().registerGuiHandler(this, new GuiHandler());
		ForgeChunkManager.setForcedChunkLoadingCallback(this,  new ChunkLoadingHandler());
		chunkLoadViewer = new ChunkLoadViewDataProxy(chunkSightRange);
		TickRegistry.registerScheduledTickHandler(chunkLoadViewer, Side.CLIENT);
		proxy.registerKeyHandler();
		proxy.registerRendering();

		//powerMeter = new ItemPowerMeter(powerMeterId).setItemName("powerMeter");
		//LanguageRegistry.addName(powerMeter, "Power Meter");
		loadConfigs(true);
		loadPipes();

public void init(FMLInitializationEvent event) {
			ActionManager.registerTriggerProvider(new GateProvider());
		}

		if (allowWRRemove) {
			//Additional Pipes
			GameRegistry.addRecipe(new ItemStack(pipeItemsTeleport), new Object[]{"A", 'A', pipePowerTeleport});
			GameRegistry.addRecipe(new ItemStack(pipeItemsTeleport), new Object[]{"A", 'A', pipeLiquidsTeleport});
			GameRegistry.addRecipe(new ItemStack(pipeItemsRedStone), new Object[]{"A", 'A', pipeLiquidsRedstone});
			//BC Liquid
			GameRegistry.addRecipe(new ItemStack(BuildCraftTransport.pipeItemsCobblestone), new Object[]{"A", 'A', BuildCraftTransport.pipeLiquidsCobblestone});
			GameRegistry.addRecipe(new ItemStack(BuildCraftTransport.pipeItemsGold), new Object[]{"A", 'A', BuildCraftTransport.pipeLiquidsGold});
			GameRegistry.addRecipe(new ItemStack(BuildCraftTransport.pipeItemsIron), new Object[]{"A", 'A', BuildCraftTransport.pipeLiquidsIron});
			GameRegistry.addRecipe(new ItemStack(BuildCraftTransport.pipeItemsStone), new Object[]{"A", 'A', BuildCraftTransport.pipeLiquidsStone});
			GameRegistry.addRecipe(new ItemStack(BuildCraftTransport.pipeItemsWood), new Object[]{"A", 'A', BuildCraftTransport.pipeLiquidsWood});
			//BC Power
			GameRegistry.addRecipe(new ItemStack(BuildCraftTransport.pipeItemsGold), new Object[]{"A", 'A', BuildCraftTransport.pipePowerGold});
			GameRegistry.addRecipe(new ItemStack(BuildCraftTransport.pipeItemsStone), new Object[]{"A", 'A', BuildCraftTransport.pipePowerStone});
			GameRegistry.addRecipe(new ItemStack(BuildCraftTransport.pipeItemsWood), new Object[]{"A", 'A', BuildCraftTransport.pipePowerWood});
		}

		//ChunkLoader
		if(chunkLoaderId != 0) {
			blockChunkLoader = new BlockChunkLoader(chunkLoaderId > 0 ? chunkLoaderId : -chunkLoaderId, 32);
			blockChunkLoader.setUnlocalizedName("TeleportTether");
			GameRegistry.registerBlock(blockChunkLoader, ItemBlock.class, "chunkLoader");
			GameRegistry.registerTileEntity(TileChunkLoader.class, "TeleportTether");
			if (chunkLoaderId > 0) {
				GameRegistry.addRecipe(new ItemStack(blockChunkLoader), new Object[]{"iii", "iLi", "iii", 'i', Item.ingotIron, 'L', new ItemStack(Item.dyePowder, 1, 4)});
			}
		}
	}

	@ServerStarting
	public void onServerStart(FMLServerStartingEvent event) {
		//event.registerServerCommand(new CommandAdditionalPipes());
		TeleportManager.instance.reset();
	}

private void loadConfigs(boolean postInit) {
			config.addCustomCategoryComment(Configuration.CATEGORY_ITEM, "Set id to 0 to disable loading the item, add - in front of id to disable recipe only.");
			config.addCustomCategoryComment(Configuration.CATEGORY_GENERAL, "Disabling items/blocks only disables recipes.");
			Field[] fields = AdditionalPipes.class.getFields();
			for(Field field : fields){
				if(!Modifier.isStatic(field.getModifiers())) {

					CfgId annotation = field.getAnnotation(CfgId.class);
					if(annotation != null) {
						int id = field.getInt(this);
						if(annotation.block()){
							if(config.getCategory(Configuration.CATEGORY_BLOCK).containsKey(field.getName())) {
								id = config.get(Configuration.CATEGORY_BLOCK, field.getName(), id).getInt(id);
								if(id > 0) id = config.getBlock(field.getName(), id).getInt(id);
							} else {
								id = config.getBlock(field.getName(), id).getInt(id);
							}
						}else{
							if(config.getCategory(Configuration.CATEGORY_ITEM).containsKey(field.getName())) {
								id = config.get(Configuration.CATEGORY_ITEM, field.getName(), id).getInt(id);
								if(id > 0) id = config.getItem(field.getName(), id).getInt(id);
							} else {
								id = config.getItem(field.getName(), id).getInt(id);
							}
						}
						field.setInt(this, id);
					} else {
						if(field.isAnnotationPresent(CfgBool.class)){
							boolean bool = field.getBoolean(this);
							bool = config.get(Configuration.CATEGORY_GENERAL,
									field.getName(), bool).getBoolean(bool);
							field.setBoolean(this, bool);
						}
					}

				}
			}

			Property powerLoss = config.get(Configuration.CATEGORY_GENERAL,
					"powerLoss", (int) (powerLossCfg * 100));
			powerLoss.comment = "Percentage of power a power teleport pipe transmits. Between 0 and 100.";
			powerLossCfg = powerLoss.getInt() / 100.0;
			if(powerLossCfg > 1.00) {
private void loadConfigs(boolean postInit) {
				powerLossCfg = 0.0;
			}

			Property chunkLoadSightRange = config.get(Configuration.CATEGORY_GENERAL,
					"chunkSightRange", chunkSightRange);
			chunkLoadSightRange.comment = "Range of chunk load boundaries.";

			Property laserKey = config.get(Configuration.CATEGORY_GENERAL,
					"laserKeyChar", laserKeyCode);
			laserKey.comment = "Default key to toggle chunk load boundaries.";
			laserKeyCode = laserKey.getInt();
		} catch (Exception e) {
			logger.log(Level.SEVERE, "Error loading Additional Pipes configs.", e);
		} finally {
			config.save();
		}
	}

	private void loadPipes(){
		// Item Teleport Pipe
		if(pipeItemsTeleportId != 0) {
			pipeItemsTeleport = createPipeSpecial(pipeItemsTeleportId > 0 ? pipeItemsTeleportId : -pipeItemsTeleportId, PipeItemsTeleport.class);
			if (pipeItemsTeleportId > 0) {
				GameRegistry.addRecipe(new ItemStack(pipeItemsTeleport, 4), new Object[]{"dgd", 'd', BuildCraftCore.diamondGearItem, 'g', Block.glass});
				AssemblyRecipe.assemblyRecipes.add(
						new AssemblyRecipe(new ItemStack[]{
								new ItemStack(BuildCraftSilicon.redstoneChipset, 1 , 4),
								new ItemStack(BuildCraftTransport.pipeItemsDiamond, 8),
								new ItemStack(BuildCraftSilicon.redstoneChipset, 1, 3)},
								1000, new ItemStack(pipeItemsTeleport, 8)));
			}

		}

		// Liquid Teleport Pipe
		if(pipeLiquidsTeleportId != 0) {
			pipeLiquidsTeleport = createPipeSpecial(pipeLiquidsTeleportId > 0 ? pipeLiquidsTeleportId : -pipeLiquidsTeleportId, PipeLiquidsTeleport.class);
			if (pipeItemsTeleport != null && pipeLiquidsTeleportId > 0) {
				GameRegistry.addRecipe(new ItemStack(pipeLiquidsTeleport), new Object[]{"w", "P", 'w', BuildCraftTransport.pipeWaterproof, 'P', pipeItemsTeleport});
			}
		}

		// Power Teleport Pipe
		if(pipePowerTeleportId != 0) {
			pipePowerTeleport = createPipeSpecial(pipePowerTeleportId > 0 ? pipePowerTeleportId : -pipePowerTeleportId, PipePowerTeleport.class);
			if (pipeItemsTeleport != null && pipePowerTeleportId > 0) {
				GameRegistry.addRecipe(new ItemStack(pipePowerTeleport), new Object[]{"r", "P", 'r', Item.redstone, 'P', pipeItemsTeleport});
			}
		}

		// Distributor Pipe
		pipeItemsDistributor = doCreatePipeAndRecipe(pipeItemsDistributorId, PipeItemsDistributor.class,
				new Object[]{" r ", "IgI", 'r', Item.redstone, 'I', Item.ingotIron, 'g', Block.glass});

		// Advanced Wooded Pipe
		pipeItemsAdvancedWood = doCreatePipeAndRecipe(pipeItemsAdvancedWoodId, 8, PipeItemsAdvancedWood.class,
				new Object[]{"WgW", 'W', BuildCraftCore.woodenGearItem, 'g', Block.glass});

		// Advanced Insertion Pipe
		pipeItemsAdvancedInsertion = doCreatePipeAndRecipe(pipeItemsAdvancedInsertionId, 8, PipeItemsAdvancedInsertion.class,
				new Object[]{"IgI", 'I', BuildCraftCore.ironGearItem, 'g', Block.glass});

		// Redstone Pipe
		pipeItemsRedStone = doCreatePipeAndRecipe(pipeItemsRedStoneId, 8, PipeItemsRedstone.class,
				new Object[]{"RgR", 'R', Item.redstone, 'g', Block.glass});
		// Redstone Liquid Pipe
		pipeLiquidsRedstone = doCreatePipeAndRecipe(pipeLiquidsRedstoneId, PipeLiquidsRedstone.class,
				new Object[]{"w", "P", 'w', BuildCraftTransport.pipeWaterproof, 'P', pipeItemsRedStone});

		// Closed Items Pipe
		pipeItemsClosed = doCreatePipeAndRecipe(pipeItemsClosedId, PipeItemsClosed.class,
				new Object[]{"r", "I", 'I', BuildCraftTransport.pipeItemsVoid, 'i', BuildCraftCore.ironGearItem});
		//switch pipes
		pipeItemsSwitch = doCreatePipeAndRecipe(pipeItemsSwitchId, 8, PipeSwitchItems.class,
				new Object[]{"GgG", 'g', Block.glass, 'G', BuildCraftCore.goldGearItem});
		pipePowerSwitch = doCreatePipeAndRecipe(pipePowerSwitchId, PipeSwitchPower.class,
				new Object[]{"r", "I", 'I', pipeItemsSwitch, 'r', Item.redstone});
		pipeLiquidsSwitch = doCreatePipeAndRecipe(pipeLiquidsSwitchId, PipeSwitchLiquids.class,
				new Object[]{"w", "I", 'I', pipeItemsSwitch, 'w', BuildCraftTransport.pipeWaterproof});

		//water pump pipe
		pipeLiquidsWaterPump = doCreatePipeAndRecipe(pipeLiquidsWaterPumpId, PipeLiquidsWaterPump.class,
				new Object[]{" L ", "rPr", " W ",
			'r', Item.redstone,
			'P', BuildCraftCore.ironGearItem,
			'L', BuildCraftTransport.pipeLiquidsGold,
			'w', BuildCraftTransport.pipeWaterproof,
			'W', BuildCraftTransport.pipeLiquidsWood});
	}

	private Item doCreatePipeAndRecipe(int id, Class<? extends Pipe> clas, Object[] recipe) {
		return doCreatePipeAndRecipe(id, 1, clas, recipe);
	}

	private Item doCreatePipeAndRecipe(int id, int output, Class<? extends Pipe> clas, Object[] recipe) {
		if(id == 0) return null;
		Item pipe = createPipe(id > 0 ? id : -id, clas);
		for(Object obj : recipe) {
			if(obj == null) return pipe;
		}
		GameRegistry.addRecipe(new ItemStack(pipe, output), recipe);
		return pipe;
private static Item createPipe(int id, Class<? extends Pipe> clas) {
		return res;
	}

	//special pipe code
	private static class ItemPipeAP extends ItemPipe {
		protected ItemPipeAP(int i) {
			super(i);
		}

		@Override
		@SideOnly(Side.CLIENT)
		public EnumRarity getRarity(ItemStack stack){
			return EnumRarity.rare;
		}
	}
private Item createPipeSpecial(int id, Class<? extends Pipe> clas) {
		return item;
	}

	//legacy method
	public static boolean isPipe(Item item) {
		if (item != null && BlockGenericPipe.pipes.containsKey(item.itemID)) {
			return true;
		}
		return false;
	}
	@ForgeSubscribe
	@SideOnly(Side.CLIENT)
	public void textureHook(TextureStitchEvent.Pre event) throws IOException{
		Textures.registerIcons(event.map);
	}
}
public class ChunkLoadViewDataProxy implements IScheduledTickHandler, Comparator<ChunkCoordIntPair> {
	public static final int MAX_SIGHT_RANGE = 31;

	//used by server
	private int sightRange;

	//used by client
	private List<Box> lasers;
	private ChunkCoordIntPair[] persistentChunks;
	private boolean active = false;
public ChunkLoadViewDataProxy(int chunkSightRange) {
		active = false;
	}

	//laser methods

	@SideOnly(Side.CLIENT)
	public void toggleLasers(){
		if(lasersActive()){
			deactivateLasers();
		} else {
			activateLasers();
		}
	}

	@SideOnly(Side.CLIENT)
	public void activateLasers(){
		deactivateLasers();
		EntityClientPlayerMP player = FMLClientHandler.instance().getClient().thePlayer;
		int playerY = (int) player.posY - 1;
		for (ChunkCoordIntPair coords : persistentChunks) {
			int xCoord = coords.chunkXPos * 16;
			int zCoord = coords.chunkZPos * 16;

public void activateLasers(){
			outsideLaser.createLasers(player.worldObj, LaserKind.Blue);
			lasers.add(outsideLaser);


			Box insideLaser = new Box();
			insideLaser.initialize(xCoord + 7, playerY, zCoord + 7, xCoord + 9, playerY, zCoord + 9);
			insideLaser.createLasers(player.worldObj, LaserKind.Red);
public void activateLasers(){
	}

	@SideOnly(Side.CLIENT)
	public void deactivateLasers(){
		for (Box laser : lasers) {
			laser.deleteLasers();
		}
		lasers.clear();
		active = false;
	}

	@SideOnly(Side.CLIENT)
	public boolean lasersActive(){
		return active;
	}

	//packet methods

	@SideOnly(Side.CLIENT)
	public void requestPersistentChunks() {
public void requestPersistentChunks() {
	@SideOnly(Side.CLIENT)
	public void receivePersistentChunks(ChunkCoordIntPair[] chunks) {
		boolean changed = true;
		//check if arrays have equal contents
		//do this on the client since it's only rendering, and it reduces server load
		if(persistentChunks.length == chunks.length) {
			changed = false;
			Arrays.sort(chunks, this);
public void receivePersistentChunks(ChunkCoordIntPair[] chunks) {
		}
	}

	//sets how far the server will search for chunkloaded chunks
	//when sending data to the player
	public void setSightRange(int range) {
		sightRange = range;
		if(sightRange > MAX_SIGHT_RANGE)
public void setSightRange(int range) {
	}

	public void sendPersistentChunksToPlayer(EntityPlayerMP player) {
		if(!AdditionalPipes.instance.chunkSight) { return;}
		if(sightRange > MAX_SIGHT_RANGE) sightRange = MAX_SIGHT_RANGE;

		SetMultimap<ChunkCoordIntPair, Ticket> persistentChunks =
				ForgeChunkManager.getPersistentChunksFor(player.worldObj);
		List<ChunkCoordIntPair> chunksInRange = new LinkedList<ChunkCoordIntPair>();
		int playerX = (((int) player.posX) >> 4) - sightRange / 2,
				playerZ = (((int) player.posZ) >> 4) - sightRange / 2;

		for(int i = -sightRange; i  <= sightRange; i++) {
			for(int j = -sightRange; j <= sightRange; j++) {
				ChunkCoordIntPair coords = new ChunkCoordIntPair(playerX + i, playerZ + j);
				if(persistentChunks.containsKey(coords)) {
public void sendPersistentChunksToPlayer(EntityPlayerMP player) {
	}

	@Override
	public void tickStart(EnumSet<TickType> type, Object... tickData) {}

	@Override
	@SideOnly(Side.CLIENT)
public int nextTickSpacing() {
		return 20 * 5;
	}

	//Comparator

	//first - other
	//assume non-null
	@Override
	public int compare(ChunkCoordIntPair first, ChunkCoordIntPair other) {
		int dx = first.chunkXPos - other.chunkXPos;
public void processCommand(ICommandSender sender, String[] args) {
				if(args.length == 3) {
					try {
						int index = Integer.parseInt(args[2]);
					} catch(Exception e) {}

				} else if(args.length == 5) {
					try {
public void processCommand(ICommandSender sender, String[] args) {
								sender.sendChatToPlayer(sb.toString());
							}
						}
					} catch(Exception e) {}
				}
			} else {
				StringBuffer sb = new StringBuffer();
import cpw.mods.fml.common.network.IGuiHandler;

public class GuiHandler implements IGuiHandler {
	//Gui IDs
	public static final int PIPE_TP = 1;
	public static final int PIPE_DIST = 2;
	public static final int PIPE_WOODEN_ADV = 3;

	@Override
	public Object getServerGuiElement(int ID, EntityPlayer player, World world,
			int x, int y, int z) {
		TileEntity tile = world.getBlockTileEntity(x, y, z);
		if (tile == null) {
			return null;
		}
		switch(ID) {
public Object getServerGuiElement(int ID, EntityPlayer player, World world,
	}

	@Override
	public Object getClientGuiElement(int ID, EntityPlayer player, World world,
			int x, int y, int z) {
		TileEntity tile = world.getBlockTileEntity(x, y, z);
		if (tile == null) {
			return null;
		}
		switch(ID) {
	public ItemPowerMeter(int id) {
		super(id);
		setMaxStackSize(1);
		//setTextureFile(AdditionalPipes.TEXTURE_MASTER);
		setCreativeTab(CreativeTabs.tabTools);
	}

	@Override
	public boolean onItemUse(ItemStack stack, EntityPlayer player,
			World world, int x, int y, int z, int side,
			float par8, float par9, float par10) {
		TileEntity te = world.getBlockTileEntity(x, y, z);
		boolean isPowerTile = te instanceof IPowerReceptor;
		if(!world.isRemote && isPowerTile) {
public boolean onItemUse(ItemStack stack, EntityPlayer player,
				receptor.getPowerProvider().receiveEnergy(1000, ForgeDirection.VALID_DIRECTIONS[side]);
			}

			player.sendChatToPlayer(String.format("R:%!d(MISSING) L:%!d(MISSING) m:%!d(MISSING) M:%!d(MISSING) A:%!d(MISSING) S:%!d(MISSING)",
					receptor.powerRequest(ForgeDirection.VALID_DIRECTIONS[side]),
					provider.getLatency(),
					provider.getMinEnergyReceived(),
					provider.getMaxEnergyReceived(),
					provider.getMaxEnergyStored(),
					provider.getActivationEnergy(),
					provider.getEnergyStored()));
		}
		return isPowerTile;
	}
public String getLabel() {
	}

	@Override
	public void keyDown(EnumSet<TickType> types, KeyBinding kb,
			boolean tickEnd, boolean isRepeat) {
		if (tickEnd && kb.keyCode == laserKey.keyCode) {
			ChunkLoadViewDataProxy viewer = AdditionalPipes.instance.chunkLoadViewer;
			viewer.toggleLasers();
			if(viewer.lasersActive()) {
public void keyDown(EnumSet<TickType> types, KeyBinding kb,
	}

	@Override
	public void keyUp(EnumSet<TickType> types, KeyBinding kb, boolean tickEnd) {}

	@Override
	public EnumSet<TickType> ticks() {
package buildcraft.additionalpipes;

import buildcraft.transport.ItemPipe;
import buildcraft.transport.Pipe;
import net.minecraft.item.Item;
import net.minecraft.world.World;

public class MutiPlayerProxy {
	public boolean isServer(World world) {
		return !world.isRemote;
	}

	public void registerKeyHandler() {}

	public void registerRendering() {}

	public void registerPipeRendering(Item res) {}

	public void createPipeSpecial(ItemPipe item, int id, Class<? extends Pipe> clas) {}
}

	@Override
	public void registerKeyHandler() {
		KeyHandler.laserKey = new KeyBinding("Toggle chunk loading boundries",
				AdditionalPipes.instance.laserKeyCode);

		KeyBinding[] bindings = new KeyBinding[] { KeyHandler.laserKey };
		boolean[] repeatableBindings = new boolean[] { false };
public void registerKeyHandler() {
	}

	@Override
	public void registerPipeRendering(Item res){
		MinecraftForgeClient.registerItemRenderer(res.itemID, TransportProxyClient.pipeItemRenderer);
	}

	@Override
	public void createPipeSpecial(ItemPipe item, int id, Class<? extends Pipe> clas) {
		try {
			Pipe dummyPipe = clas.getConstructor(int.class).newInstance(id);
			if (dummyPipe != null){
				item.setPipesIcons(dummyPipe.getIconProvider());
				//TODO look around
				item.setPipeIconIndex(dummyPipe.getIconIndex(ForgeDirection.VALID_DIRECTIONS[0]));
				//item.setTextureIndex(dummyPipe.getTextureIndexForItem());
			}
		} catch(Exception e) {}
	}
}

	public BlockChunkLoader(int BlockID, int i) {
		super(BlockID, Material.cloth);
		//setTextureFile(AdditionalPipes.TEXTURE_MASTER);
		setCreativeTab(CreativeTabs.tabRedstone);
	}

	@Override
	public void onBlockAdded(World world, int i, int j, int k) {
		super.onBlockAdded(world, i, j, k);
		//TODO implement?
	}

	@Override
	public void breakBlock(World world, int i, int j, int k, int p1, int p2) {
		super.breakBlock(world, i, j, k, p2, p2);
		//TODO implement?
	}

	@Override
public TileEntity createTileEntity(World world, int meta) {
	public TileEntity createNewTileEntity(World world) {
		return null;
	}
	@Override
	public Icon getIcon(int par1, int par2)
	{
		return Textures.tetherTexture;
	}
	@Override
	public void registerIcons(IconRegister par1IconRegister)
	{
		//let Texutre class do it work
	}
}
	public List<ChunkCoordIntPair> getLoadArea() {
		List<ChunkCoordIntPair> loadArea = new LinkedList<ChunkCoordIntPair>();

		for (int x = -loadDistance; x < loadDistance + 1; x++) {
			for (int z = -loadDistance; z < loadDistance + 1; z++) {
				ChunkCoordIntPair chunkCoords = new ChunkCoordIntPair(
						(xCoord >> 4) + x, (zCoord >> 4) + z);

				loadArea.add(chunkCoords);
			}
	@Override
	public void validate() {
		super.validate();
		if (!worldObj.isRemote && chunkTicket == null) {
			Ticket ticket = ForgeChunkManager.requestTicket(
					AdditionalPipes.instance, worldObj, Type.NORMAL);
			if (ticket != null) {
				forceChunkLoading(ticket);
			}
		}
public void setLoadDistance(int dist) {
	public void forceChunkLoading(Ticket ticket) {
		stopChunkLoading();
		chunkTicket = ticket;
		for (ChunkCoordIntPair coord : getLoadArea()) {
			AdditionalPipes.instance.logger.info(
					String.format("Force loading chunk %!s(MISSING) in %!s(MISSING)",
							coord, worldObj.provider.getClass()));
			ForgeChunkManager.forceChunk(chunkTicket, coord);
		}
	}

	public void unforceChunkLoading() {
		for (Object obj : chunkTicket.getChunkList()) {
			ChunkCoordIntPair coord = (ChunkCoordIntPair) obj;
			ForgeChunkManager.unforceChunk(chunkTicket, coord);
		}
	}

	public void stopChunkLoading() {
		if (chunkTicket != null) {
			ForgeChunkManager.releaseTicket(chunkTicket);
			chunkTicket = null;
		}
import buildcraft.api.gates.TriggerParameter;
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;
public abstract class APTrigger implements ITrigger {

	protected int id;
public int getId() {
		return this.id;
	}

    @Override
    @SideOnly(Side.CLIENT)
    public IIconProvider getIconProvider() {
    	return Textures.actionIconProvider;
    }
    
    @Override
    public abstract int getIconIndex();

	@Override
	public boolean hasParameter() {

	@Override
	public LinkedList<ITrigger> getPipeTriggers(IPipe pipe) {
		LinkedList <ITrigger> list = new LinkedList<ITrigger>();
		if(pipe instanceof PipeItemsClosed) {
			list.add(AdditionalPipes.instance.triggerPipeClosed);
		}
public TriggerPhasedSignal(int id, IPipe.WireColor colour) {

	@Override
	public String getDescription() {
		switch (colour) {
		case Red:
			return "Red Phased Signal";
		case Blue:
public String getDescription() {

	@Override
	public int getIconIndex() {
		switch (colour) {
		case Red:
			return 2;
		case Blue:

	private boolean exclude;

	public ContainerAdvancedWoodPipe (IInventory playerInventory, PipeLogicAdvancedWood filterInventory) {
		super (filterInventory.getSizeInventory());
		logic = filterInventory;
		exclude = !logic.exclude;
		playerIInventory = playerInventory;
public ContainerAdvancedWoodPipe (IInventory playerInventory, PipeLogicAdvancedW
			addSlotToContainer(new Slot(filterInventory, j1 + k * 9, 8 + j1 * 18, 18 + k * 18));
		}


		for(int l = 0; l < 3; l++) {
			for(int k1 = 0; k1 < 9; k1++) {
				addSlotToContainer(new Slot(playerInventory, k1 + l * 9 + 9, 8 + k1 * 18, 76 + l * 18));
public boolean canInteractWith(EntityPlayer entityplayer) {
	@Override
	public void detectAndSendChanges() {
		super.detectAndSendChanges();
		for (Object crafter : crafters) {
			if(exclude != logic.exclude) {
				((ICrafting) crafter).sendProgressBarUpdate(this, 0, logic.exclude ? 1 : 0);
			}
public boolean canInteractWith(EntityPlayer player) {
	@Override
	public void detectAndSendChanges() {
		super.detectAndSendChanges();
		for (Object obj : crafters) {
			ICrafting crafter = (ICrafting) obj;
			for(int i = 0; i < lastDistData.length; i++) {
				if(lastDistData[i] != pipe.logic.distData[i]) {
public ContainerPipeClosed(InventoryPlayer inventory, Pipe pipe) {
		int var3;
		int var4;

		for (var3 = 0; var3 < 3; ++var3) {
			for (var4 = 0; var4 < 3; ++var4) {
				addSlotToContainer(new Slot(this.pipe, var4
						+ var3 * 3, 62 + var4 * 18, 17 + var3 * 18));
			}
		}

		for (var3 = 0; var3 < 3; ++var3) {
			for (var4 = 0; var4 < 9; ++var4) {
				addSlotToContainer(new Slot(inventory, var4 + var3
						* 9 + 9, 8 + var4 * 18, 84 + var3 * 18));
			}
		}

		for (var3 = 0; var3 < 9; ++var3) {
			addSlotToContainer(new Slot(inventory, var3,
					8 + var3 * 18, 142));
		}
	}

public ItemStack transferStackInSlot(EntityPlayer par1EntityPlayer, int par2) {
		ItemStack var3 = null;
		Slot var4 = (Slot) inventorySlots.get(par2);

		if (var4 != null && var4.getHasStack()) {
			ItemStack var5 = var4.getStack();
			var3 = var5.copy();

			if (par2 < 9) {
				if (!mergeItemStack(var5, 9, 45, true)) {
					return null;
				}
			} else if (!mergeItemStack(var5, 0, 9, false)) {
				return null;
			}

			if (var5.stackSize == 0) {
				var4.putStack((ItemStack) null);
			} else {
				var4.onSlotChanged();
			}

			if (var5.stackSize == var3.stackSize) {
				return null;
			}

public boolean canInteractWith(EntityPlayer entityplayer) {
	public void detectAndSendChanges() {
		super.detectAndSendChanges();
		int connectedPipesNew = connectedPipes;
		if(ticks %! (MISSING)== 0) { //reduce lag
			ticks = 0;
			AdditionalPipes.instance.logger.info("Old connected:" + connectedPipesNew);
			connectedPipesNew = TeleportManager.instance.getConnectedPipes(pipe, false).size();
			AdditionalPipes.instance.logger.info("New connected:" + connectedPipesNew);
		}
		ticks++;
		for (Object crafter : crafters) {
			if(freq != pipe.logic.getFrequency()) {
				((ICrafting) crafter).sendProgressBarUpdate(this, 0, pipe.logic.getFrequency());
			}
public GuiAdvancedWoodPipe(IInventory playerInventorys, TileGenericPipe containe
		playerInventory = playerInventorys;
		filterInventory = (PipeLogicAdvancedWood) container.pipe.logic;
		this.container = container;
		//container = theContainer;
		xSize = 175;
		ySize = 156;

public void initGui() {
		super.initGui();
		int guiX = (width - xSize) / 2;
		int guiY = (height - ySize) / 2;
		buttons[0] =  new GuiButton(1, guiX + 8, guiY + 40, 140, 20, "These items are required");
		buttonList.add(buttons[0]);
	}

	@Override
	protected void drawGuiContainerForegroundLayer(int p1, int p2) {
		if (((PipeLogicAdvancedWood)container.pipe.logic).exclude) {
			buttons[0].displayString = "These items are excluded";
		}
		else {
			buttons[0].displayString = "These items are required";
		}

protected void drawGuiContainerForegroundLayer(int p1, int p2) {

	@Override
	protected void actionPerformed(GuiButton guibutton) {
		if (guibutton.id == 1) {
			PacketAdditionalPipes packet = new PacketAdditionalPipes(NetworkHandler.ADV_WOOD_DATA, false);
			packet.writeInt(container.xCoord);
			packet.writeInt(container.yCoord);
protected void actionPerformed(GuiButton guibutton) {

	@Override
	protected void drawGuiContainerBackgroundLayer(float f, int i, int j) {
		
		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
		mc.renderEngine.bindTexture(AdditionalPipes.TEXTURE_GUI_ADVANCEDWOOD);
		int j1 = (width - xSize) / 2;
public GuiDistributionPipe(TileGenericPipe container) {
	@Override
	public void initGui() {
		super.initGui();
		//int bw = this.xSize - 20;
		int guiX = (width - xSize) / 2 + 30;
		int guiY = (height - ySize) / 2 - 10;

		buttonList.add(buttons[0]  =  new GuiButton(1, guiX + 1,       guiY + 24, 20, 17, "-"));
		buttonList.add(buttons[1]  =  new GuiButton(2, guiX + 3 + 20,  guiY + 24, 30, 17, "0"));
		buttonList.add(buttons[2]  =  new GuiButton(3, guiX + 5 + 50,  guiY + 24, 20, 17, "+"));

		buttonList.add(buttons[3]  =  new GuiButton(4, guiX + 1,       guiY + 25 + 17, 20, 17, "-"));
		buttonList.add(buttons[4]  =  new GuiButton(5, guiX + 3 + 20,  guiY + 25 + 17, 30, 17, "0"));
		buttonList.add(buttons[5]  =  new GuiButton(6, guiX + 5 + 50,  guiY + 25 + 17, 20, 17, "+"));

		buttonList.add(buttons[6]  =  new GuiButton(7, guiX + 1,       guiY + 26 + 17 * 2, 20, 17, "-"));
		buttonList.add(buttons[7]  =  new GuiButton(8, guiX + 3 + 20,  guiY + 26 + 17 * 2, 30, 17, "0"));
		buttonList.add(buttons[8]  =  new GuiButton(9, guiX + 5 + 50,  guiY + 26 + 17 * 2, 20, 17, "+"));

		buttonList.add(buttons[9]  =  new GuiButton(10, guiX + 1,      guiY + 27 + 17 * 3, 20, 17, "-"));
		buttonList.add(buttons[10] =  new GuiButton(11, guiX + 3 + 20, guiY + 27 + 17 * 3, 30, 17, "0"));
		buttonList.add(buttons[11] =  new GuiButton(12, guiX + 5 + 50, guiY + 27 + 17 * 3, 20, 17, "+"));

		buttonList.add(buttons[12] =  new GuiButton(13, guiX + 1,      guiY + 28 + 17 * 4, 20, 17, "-"));
		buttonList.add(buttons[13] =  new GuiButton(14, guiX + 3 + 20, guiY + 28 + 17 * 4, 30, 17, "0"));
		buttonList.add(buttons[14] =  new GuiButton(15, guiX + 5 + 50, guiY + 28 + 17 * 4, 20, 17, "+"));

		buttonList.add(buttons[15] =  new GuiButton(16, guiX + 1,      guiY + 29 + 17 * 5, 20, 17, "-"));
		buttonList.add(buttons[16] =  new GuiButton(17, guiX + 3 + 20, guiY + 29 + 17 * 5, 30, 17, "0"));
		buttonList.add(buttons[17] =  new GuiButton(18, guiX + 5 + 50, guiY + 29 + 17 * 5, 20, 17, "+"));

	}
	@Override
	protected void drawGuiContainerForegroundLayer(int p1, int p2) {
		PipeLogicDistributor pipeLogic = pipe.logic;
		buttons[1].displayString  = "" + pipeLogic.distData[0];
		buttons[4].displayString  = "" + pipeLogic.distData[1];
		buttons[7].displayString  = "" + pipeLogic.distData[2];
		buttons[10].displayString = "" + pipeLogic.distData[3];
		buttons[13].displayString = "" + pipeLogic.distData[4];
		buttons[16].displayString = "" + pipeLogic.distData[5];
protected void actionPerformed(GuiButton guibutton) {
		} else {
			newData++;
		}
		/* //Old code
		switch (guibutton.id) {
		case 1:
			index = 0;
			pipeLogic.distData[0] -= 1;
			break;
		case 3:
			index = 0;
			pipeLogic.distData[0] += 1;
			break;
		case 4:
			pipeLogic.distData[1] -= 1;
			break;
		case 6:
			pipeLogic.distData[1] += 1;
			break;
		case 7:
			pipeLogic.distData[2] -= 1;
			break;
		case 9:
			pipeLogic.distData[2] += 1;
			break;
		case 10:
			pipeLogic.distData[3] -= 1;
			break;
		case 12:
			pipeLogic.distData[3] += 1;
			break;
		case 13:
			pipeLogic.distData[4] -= 1;
			break;
		case 15:
			pipeLogic.distData[4] += 1;
			break;
		case 16:
			pipeLogic.distData[5] -= 1;
			break;
		case 18:
			pipeLogic.distData[5] += 1;
			break;
		}
		 */

		if(newData < 0) return;

		PacketAdditionalPipes packet = new PacketAdditionalPipes(NetworkHandler.DIST_PIPE_DATA, true);
		packet.writeInt(pipe.xCoord);
protected void actionPerformed(GuiButton guibutton) {

	@Override
	protected void drawGuiContainerBackgroundLayer(float f, int x, int y) {
		
		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
		mc.renderEngine.bindTexture(AdditionalPipes.TEXTURE_GUI_DISTRIBUTION);
		int j = (width - xSize) / 2;
import cpw.mods.fml.common.network.IGuiHandler;

public class GuiHandler implements IGuiHandler {
	//Gui IDs
	public static final int PIPE_TP = 1;
	public static final int PIPE_DIST = 2;
	public static final int PIPE_WOODEN_ADV = 3;
	public static final int PIPE_CLOSED = 4;

	@Override
	public Object getServerGuiElement(int ID, EntityPlayer player, World world,
			int x, int y, int z) {
		TileEntity tile = world.getBlockTileEntity(x, y, z);
		if (tile == null) {
			return null;
		}
		switch(ID) {
public Object getServerGuiElement(int ID, EntityPlayer player, World world,
	}

	@Override
	public Object getClientGuiElement(int ID, EntityPlayer player, World world,
			int x, int y, int z) {
		TileEntity tile = world.getBlockTileEntity(x, y, z);
		if (tile == null) {
			return null;
		}
		switch(ID) {
public GuiPipeClosed(InventoryPlayer inventory, Pipe pipe) {

	@Override
	protected void drawGuiContainerForegroundLayer(int par1, int par2) {
		fontRenderer.drawString(
				StatCollector.translateToLocal("Closed Pipe"), 60, 6,
				4210752);
		fontRenderer.drawString(
				StatCollector.translateToLocal("container.inventory"), 8,
				ySize - 96 + 2, 4210752);
	}

	/**
	 * Draw the background layer for the GuiContainer (everything behind the
	 * items)
	 */
	@Override
	protected void drawGuiContainerBackgroundLayer(float par1, int par2,
			int par3) {
	
		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
		mc.renderEngine.bindTexture("/gui/trap.png");
		int var5 = (width - xSize) / 2;
public void draw(int x, int y) {
			Minecraft.getMinecraft().renderEngine.bindTexture("/gui/items.png");
			drawIcon(BuildCraftCore.iconProvider.getIcon(CoreIconProvider.ENERGY), x + 3, y + 4);

			if (!isFullyOpened())
				return;

			fontRenderer.drawStringWithShadow("Teleport Pipe", x + 22, y + 8, headerColour);
public void draw(int x, int y) {
			fontRenderer.drawString(String.valueOf(gui.container.connectedPipes), x + 66, y + 45, textColour);
			int[] net = gui.pipe.logic.network;
			if(net.length > 0) {
				fontRenderer.drawString(
					new StringBuilder("(").append(net[0]).append(", ").append(net[1]).append(", ").append(net[2]).append(")").toString(),
					x + 22, y + 56, textColour);
			}
			if(net.length > 3) {
				fontRenderer.drawString(
					new StringBuilder("(").append(net[3]).append(", ").append(net[4]).append(", ").append(net[5]).append(")").toString(),
					x + 22, y + 68, textColour);
			}
			if(net.length > 6) {
				fontRenderer.drawString(
					new StringBuilder("(").append(net[6]).append(", ").append(net[7]).append(", ").append(net[8]).append(")").toString(),
					x + 22, y + 80, textColour);
			}
		}

public void initGui() {
		super.initGui();
		int x = (width - xSize) / 2, y = (height - ySize) / 2 + 16;
		int bw = xSize - 24;
		buttonList.add(buttons[0] = new GuiButton(1, x + 12,              y + 32, bw / 6, 20, "-100"));
		buttonList.add(buttons[1] = new GuiButton(2, x + 12 + bw / 6,     y + 32, bw / 6, 20, "-10"));
		buttonList.add(buttons[2] = new GuiButton(3, x + 12 + bw * 2 / 6, y + 32, bw / 6, 20, "-1"));
		buttonList.add(buttons[3] = new GuiButton(4, x + 12 + bw * 3 / 6, y + 32, bw / 6, 20, "+1"));
		buttonList.add(buttons[4] = new GuiButton(5, x + 12 + bw * 4 / 6, y + 32, bw / 6, 20, "+10"));
		buttonList.add(buttons[5] = new GuiButton(6, x + 12 + bw * 5 / 6, y + 32, bw / 6, 20, "+100"));

		buttonList.add(buttons[6] = new GuiButton(7, x + 12,              y + 10, bw / 2, 20, "Send Only"));
		buttonList.add(buttons[7] = new GuiButton(8, x + 12 + bw * 3 / 6, y + 10, bw / 2, 20, "Private"));
	}

	@Override
	protected void drawGuiContainerForegroundLayer(int p1, int p2) {
		super.drawGuiContainerForegroundLayer(p1, p2);
		fontRenderer.drawString("Frequency: " + pipe.logic.getFrequency(), 16, 12, 0x404040);
		fontRenderer.drawString(
			new StringBuilder("(").append(pipe.xCoord).append(", ").append(pipe.yCoord).append(", ").append(pipe.zCoord).append(")").toString(),
			128, 12, 0x404040);
		switch(pipe.logic.state) {
			case 3:
				buttons[6].displayString = "Send & Receive";
				break;
			case 2:
				buttons[6].displayString = "Receive Only";
				break;
			case 1:
				buttons[6].displayString = "Send Only";
				break;
			default:
				buttons[6].displayString = "Disabled";
				break;
		}
		if(pipe.logic.isPublic) {
			buttons[7].displayString = "Public";
		} else {
			buttons[7].displayString = "Private";
		}
	}
	@Override
	protected void actionPerformed(GuiButton guibutton) {
		int freq = pipe.logic.getFrequency();
protected void actionPerformed(GuiButton guibutton) {
			isPublic = !isPublic;
			break;
		}
		if (freq < 0) {
			freq = 0;
		}

import cpw.mods.fml.common.network.Player;

public class NetworkHandler implements IPacketHandler {
	//server to client
	public static final byte CHUNKLOAD_DATA = 15;
	public static final byte TELE_PIPE_DATA = 16;
	//client to server
	public static final byte ADV_WOOD_DATA = 62;
	public static final byte DIST_PIPE_DATA = 63;
	public static final byte TELE_PIPE_DATA_SET = 64;
	public static final byte CHUNKLOAD_REQUEST = 65;

	@Override
	public void onPacketData(INetworkManager manager,
			Packet250CustomPayload packet, Player player) {
		if(AdditionalPipes.CHANNEL.equals(packet.channel)) {
			DataInputStream data = new DataInputStream(new ByteArrayInputStream(packet.data));
			byte packetID = -1;
public void onPacketData(INetworkManager manager,
					handleChunkLoadData(data);
					break;
				case CHUNKLOAD_REQUEST:
					AdditionalPipes.instance.chunkLoadViewer
					.sendPersistentChunksToPlayer((EntityPlayerMP) player);
					break;
				}
			} catch (IOException e) {
				AdditionalPipes.instance.logger.log(Level.SEVERE, "Error handling packet " + packetID, e);
			}
		} else if(AdditionalPipes.CHANNELNBT.equals(packet.channel)) {
private void handleDistPipeData(Player player, DataInputStream data) {
					logic.distData[index] = newData;
					boolean found = newData > 0;
					if(!found) {
						for (int i = 0; i < logic.distData.length; i++) {
							if (logic.distData[i] > 0) {
								found = true;
							}
						}
					}
					if (!found) {
						for (int i = 0; i < logic.distData.length; i++) {
							logic.distData[i] = 1;
						}
					}

				}
			}
		} catch (IOException e) {
			AdditionalPipes.instance.logger.log(Level.SEVERE, "Error handling distribution pipe packet.", e);
		}
	}
private void handleTelePipeData(Player player, DataInputStream data) {
			TileEntity te = getTileEntity(player, data);
			if(te instanceof TileGenericPipe) {
				PipeTeleport pipe = (PipeTeleport) ((TileGenericPipe) te).pipe;
				//only allow the owner to change pipe state
				EntityPlayerMP entityPlayer = (EntityPlayerMP) player;
				if(!PipeLogicTeleport.canPlayerModifyPipe(entityPlayer, pipe.logic)) {
					entityPlayer.sendChatToPlayer("You may not change pipe state.");
private void handleTelePipeData(Player player, DataInputStream data) {
				pipe.logic.state = (byte) data.read();
				pipe.logic.isPublic = (data.read() == 1);
			}
		} catch (IOException e) {
			AdditionalPipes.instance.logger.log(Level.SEVERE, "Error handling teleport pipe packet.", e);
		}
	}
private void handleChunkLoadData(DataInputStream data) {
				chunks[i] = new ChunkCoordIntPair(data.readInt(), data.readInt());
			}
			AdditionalPipes.instance.chunkLoadViewer.receivePersistentChunks(chunks);
		} catch (IOException e) {
			AdditionalPipes.instance.logger.log(Level.SEVERE, "Error handling chunk load data.", e);
		}
	}
public TileEntity getTileEntity(Player player, DataInputStream data) {
			y = data.readInt();
			z = data.readInt();
			te = ((EntityPlayer) player).worldObj.getBlockTileEntity(x, y, z);
		} catch (IOException e) {
			AdditionalPipes.instance.logger.log(Level.SEVERE, "Error getting tileentity position from packet.", e);
		}
		return te;
	public final Packet250CustomPayload packet;
	public final NBTTagCompound nbt;

	public PacketNBTTagData(String channel, int id, boolean chunkPacket,
			NBTTagCompound nbttagcompound) {
		packet = new Packet250CustomPayload();
		packet.channel = channel;
		packet.isChunkDataPacket = chunkPacket;
public Packet250CustomPayload getPacket() {
			byte[] byteData = CompressedStreamTools.compress(nbt);
			packet.length = byteData.length;
			packet.data = byteData;
		} catch (IOException e) {
			//impossible?
		}
		return packet;
	}
public static NBTTagCompound getNBTFrom(Packet250CustomPayload packet) {
		NBTTagCompound tag = new NBTTagCompound();
		try {
			tag = CompressedStreamTools.decompress(packet.data);
		} catch (IOException e) {
			//severe error reading packet data
		}
		return tag;
	}
package buildcraft.additionalpipes.pipes;

import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;
import net.minecraftforge.common.ForgeDirection;
import buildcraft.additionalpipes.textures.Textures;
import buildcraft.api.core.IIconProvider;
import buildcraft.transport.Pipe;
import buildcraft.transport.PipeTransport;
import buildcraft.transport.pipes.PipeLogic;

public abstract class APPipe extends Pipe {

public APPipe(PipeTransport transport, PipeLogic logic, int itemID) {

	@SideOnly(Side.CLIENT)
	@Override
	public IIconProvider getIconProvider()
	{
		return Textures.pipeIconProvider;
	}

public PipeItemsAdvancedInsertion(int itemID) {
	public LinkedList<ForgeDirection> filterPossibleMovements(LinkedList<ForgeDirection> possibleOrientations, Position pos, IPipedItem item) {
		LinkedList<ForgeDirection> newOris = new LinkedList<ForgeDirection>();

		for (int o = 0; o < 6; ++o) {
			ForgeDirection orientation = ForgeDirection.VALID_DIRECTIONS[o];
			if (orientation != pos.orientation.getOpposite()) {
				TileEntity entity = container.getTile(orientation);
				if (entity instanceof IInventory) {
					if (item.getPosition().orientation == orientation.getOpposite()) {
						//continue;
					}
					ITransactor transactor = Transactor.getTransactorFor(entity);
					if(transactor.add(item.getItemStack(), orientation.getOpposite(), false).stackSize > 0) {
public PipeItemsAdvancedInsertion(int itemID) {

	@Override
	public void readjustSpeed(IPipedItem item) {
		if (item.getSpeed() > Utils.pipeNormalSpeed) {
			item.setSpeed(item.getSpeed() - Utils.pipeNormalSpeed / 2.0F);
		}
		if (item.getSpeed() < Utils.pipeNormalSpeed) {
			item.setSpeed(Utils.pipeNormalSpeed);
		}
	}
public IPowerProvider getPowerProvider() {

	@Override
	public void doWork() {
		if (powerProvider.getEnergyStored() <= 0)
			return;

		World w = worldObj;

		int meta = worldObj.getBlockMetadata(xCoord, yCoord, zCoord);

		if (meta > 5)
			return;

		Position pos = new Position(xCoord, yCoord, zCoord,	ForgeDirection.VALID_DIRECTIONS[meta]);
		pos.moveForwards(1);
		int blockId = w.getBlockId((int) pos.x, (int) pos.y, (int) pos.z);
		TileEntity tile = w.getBlockTileEntity((int) pos.x, (int) pos.y, (int) pos.z);

		if (tile instanceof IInventory) {
			if (!PipeManager.canExtractItems(this, w, (int) pos.x, (int) pos.y, (int) pos.z))
				return;

			IInventory inventory = (IInventory) tile;

			ItemStack extracted = checkExtract(inventory, true,
					pos.orientation.getOpposite());

			if (extracted == null || extracted.stackSize == 0) {
				powerProvider.useEnergy(1, 1, false);
				return;
			}

			Position entityPos = new Position(pos.x + 0.5, pos.y + Utils.getPipeFloorOf(extracted), pos.z + 0.5,
					pos.orientation.getOpposite());
			entityPos.moveForwards(0.5);
			IPipedItem entity = new EntityPassiveItem(w, entityPos.x, entityPos.y, entityPos.z, extracted);
			((PipeTransportItems) transport).entityEntering(entity, entityPos.orientation);
public ItemStack checkExtract(IInventory inventory, boolean doRemove, ForgeDirec
		IInventory inv = Utils.getInventory(inventory);
		int first = 0;
		int last = inv.getSizeInventory() - 1;
		if (inventory instanceof net.minecraftforge.common.ISidedInventory) {
			net.minecraftforge.common.ISidedInventory sidedInv =
				(net.minecraftforge.common.ISidedInventory) inventory;
			first = sidedInv.getStartInventorySide(from);
			last = first + sidedInv.getSizeInventorySide(from) - 1;
		} else if (inventory instanceof ISidedInventory) {
			ISidedInventory sidedInv = (ISidedInventory) inventory;
			int[] accessibleSlots = sidedInv.getAccessibleSlotsFromSide(from.ordinal());
			ItemStack result = checkExtractGeneric(inv, doRemove, from, accessibleSlots);
public ItemStack checkExtract(IInventory inventory, boolean doRemove, ForgeDirec
	}

	public ItemStack checkExtractGeneric(IInventory inventory, boolean doRemove, ForgeDirection from, int start, int stop) {
		for (int k = start; k <= stop; ++k) {
			ItemStack slot = inventory.getStackInSlot(k);

			if (slot != null && slot.stackSize > 0 && canExtract(slot)) {
				if (doRemove) {
					return inventory.decrStackSize(k, (int) powerProvider.useEnergy(1, slot.stackSize, true));
				} else {
					return slot;
public ItemStack checkExtractGeneric(IInventory inventory, boolean doRemove, For
	}

	public ItemStack checkExtractGeneric(IInventory inventory, boolean doRemove, ForgeDirection from, int[] slots) {
		for (int i : slots) {
			ItemStack slot = inventory.getStackInSlot(i);

			if (slot != null && slot.stackSize > 0 && canExtract(slot)) {
				if (doRemove) {
					return inventory.decrStackSize(i, (int) powerProvider.useEnergy(1, slot.stackSize, true));
				} else {
					return slot;
public ItemStack checkExtractGeneric(IInventory inventory, boolean doRemove, For

	public boolean canExtract(ItemStack item) {
		PipeLogicAdvancedWood logic = (PipeLogicAdvancedWood) this.logic;
		for (int i = 0; i < logic.getSizeInventory(); i++) {
			ItemStack stack = logic.getStackInSlot(i);
			if (stack != null && stack.itemID == item.itemID) {
				if ((Item.itemsList[item.itemID].isDamageable())) {
					return !logic.exclude;
				}
				else if (stack.getItemDamage() == item.getItemDamage()) {
					return !logic.exclude;
				}
			}
public void readFromNBT(NBTTagCompound nbttagcompound) {

	@Override
	public int getIconIndex(ForgeDirection direction) {
		if (direction == ForgeDirection.UNKNOWN)
			return 6;
		else {
			int metadata = worldObj.getBlockMetadata(xCoord, yCoord, zCoord);
			if (metadata == direction.ordinal())
				return 7;
			else
				return 6;
public void centerReached(PipeTransportItems pipe, EntityData data) {
	}

	@Override
	public void endReached(PipeTransportItems pipe, EntityData data,
			TileEntity tile) {
	}

	@Override
public void drop(PipeTransportItems pipe, EntityData data) {
		container.scheduleRenderUpdate();
	}


	@Override
	public void writeToNBT(NBTTagCompound nbttagcompound) {
		super.writeToNBT(nbttagcompound);
		NBTTagList list = new NBTTagList();

		for (ItemStack stack : inventory) {
			if(stack != null) {
				NBTTagCompound stackTag = new NBTTagCompound();
				stack.writeToNBT(stackTag);
public void writeToNBT(NBTTagCompound nbttagcompound) {
	public void readFromNBT(NBTTagCompound nbttagcompound) {
		super.readFromNBT(nbttagcompound);
		NBTTagList list = nbttagcompound.getTagList("closedInventory");
		for (int i = 0; i < list.tagCount() && i < inventory.length; i++) {
			NBTTagCompound stackTag = (NBTTagCompound) list.tagAt(i);
			inventory[i] = ItemStack.loadItemStackFromNBT(stackTag);
		}
public ItemStack getStackInSlot(int i) {
	@Override
	public ItemStack decrStackSize(int i, int amt) {
		ItemStack stack = inventory[i].splitStack(amt);
		if (inventory[i].stackSize == 0) {
			inventory[i] = null;
		}
		return stack;
public PipeItemsDistributor(int itemID) {

	@Override
	public int getIconIndex(ForgeDirection connection) {
		switch (connection) {
		case DOWN:    //-y
			return 10;
		case UP:      //+y
			return 11;
		case NORTH:   //-z
			return 12;
		case SOUTH:   //+z
			return 13;
		case WEST:    //-x
			return 14;
		case EAST:    //+x
		default:
			return 9;
		}
public int getIconIndex(ForgeDirection connection) {
	public LinkedList<ForgeDirection> filterPossibleMovements(LinkedList<ForgeDirection> possibleOrientations, Position pos, IPipedItem item) {
		LinkedList<ForgeDirection> result = new LinkedList<ForgeDirection>();

		if (logic.curTick >= logic.distData[logic.distSide]) {
			toNextOpenSide();
		}

public int getIconIndex(ForgeDirection connection) {

	private void toNextOpenSide() {
		logic.curTick = 0;
		for (int o = 0; o < logic.distData.length; ++o) {
			logic.distSide = (logic.distSide + 1) %!l(MISSING)ogic.distData.length;
			if (logic.distData[logic.distSide] > 0 &&
					container.isPipeConnected(ForgeDirection.VALID_DIRECTIONS[logic.distSide])) {
				break;
			}
		}
		//no valid inventories found, do nothing
	}

	@Override

public class PipeItemsRedstone extends APPipe implements IPipeTransportItemsHook {

	public @TileNetworkData boolean isPowering = false;
	public PipeItemsRedstone(int itemID) {
		super(new PipeTransportItems(), new PipeLogicStone(), itemID);
	}

	@Override
	public void readjustSpeed (IPipedItem item) {
		if (item.getSpeed() > Utils.pipeNormalSpeed) {
			item.setSpeed(item.getSpeed() - Utils.pipeNormalSpeed / 2.0F);
		}

		if (item.getSpeed() < Utils.pipeNormalSpeed) {
			item.setSpeed(Utils.pipeNormalSpeed);
		}
	}

	@Override
	public LinkedList<ForgeDirection> filterPossibleMovements(
			LinkedList<ForgeDirection> possibleOrientations, Position pos,
			IPipedItem item) {
		return possibleOrientations;
	}

	@Override
	public void updateEntity() {
		super.updateEntity();

		if ( ((PipeTransportItems)transport).travelingEntities.size() == 0 && isPowering) {
			isPowering = false;
			UpdateTiles(container.xCoord, container.yCoord, container.zCoord);
		}
		else if ( ((PipeTransportItems)transport).travelingEntities.size() > 0 && !isPowering) {
			isPowering = true;
			UpdateTiles(container.xCoord, container.yCoord, container.zCoord);
		}
private void UpdateTiles(int i, int j, int k) {

	@Override
	public int isPoweringTo(int l) {
		//System.out.println("RedStoneIsPoweringTo");
		if (((PipeTransportItems)transport).travelingEntities.size() == 0) {
			isPowering = false;
			return 0;
		}
public int isPoweringTo(int l) {
			return 0;
		}

		return (i1 != 2 || l != 4)?15:0;
	}

	@Override

public class PipeItemsTeleport extends PipeTeleport implements IPipeTransportItemsHook {

	private PipeTransportItems transport;

	public PipeItemsTeleport(int itemID) {
		super(new PipeTransportItems(), new PipeLogicTeleport(), itemID);
public void entityEntered(IPipedItem item, ForgeDirection orientation) {
			return;
		}
		List<PipeTeleport> connectedTeleportPipes = TeleportManager.instance.getConnectedPipes(this, false);
		//no teleport pipes connected, use default
		if (connectedTeleportPipes.size() <= 0 || (logic.state & 0x1) == 0) {
			return;
		}

		//output to random pipe
		LinkedList<ForgeDirection> outputOrientations = new LinkedList<ForgeDirection>();
		PipeTeleport otherPipe = connectedTeleportPipes.get(rand.nextInt(connectedTeleportPipes.size()));

		//find possible output orientations
		for (ForgeDirection o : ForgeDirection.VALID_DIRECTIONS) {
			if (otherPipe.outputOpen(o))
				outputOrientations.add(o);
		}
		//no outputs found, default behaviour
		if (outputOrientations.size() <= 0) {
			return;
		}

		ForgeDirection newOrientation = outputOrientations.get(rand.nextInt(outputOrientations.size()));
		TileGenericPipe destination = (TileGenericPipe) otherPipe.container.getTile(newOrientation);
		//item.setContainer(destination);
		item.setPosition(destination.xCoord + 0.5, destination.yCoord, destination.zCoord + 0.5);
		//transport.scheduleRemoval(item);
		destination.pipe.transport.entityEntering(item, newOrientation);
		AdditionalPipes.instance.logger.info(item + " from " + getPosition() + " to " + otherPipe.getPosition() + " " + newOrientation);
	}
import buildcraft.transport.pipes.PipeLogicGold;

public class PipeLiquidsRedstone extends APPipe {
	public @TileNetworkData boolean isPowering = false;

	public PipeLiquidsRedstone(int itemID) {
		super(new PipeTransportLiquids(), new PipeLogicGold(), itemID);
private void UpdateTiles(int i, int j, int k) {

	@Override
	public int isPoweringTo(int l) {
		//System.out.println("RedStoneIsPoweringTo");
		LiquidStack liquid = ((PipeTransportLiquids) transport)
				.getTanks(ForgeDirection.UNKNOWN)[ForgeDirection.UNKNOWN.ordinal()].getLiquid();
		if (liquid == null || liquid.amount == 0) {
			isPowering = false;
			return 0;
		}
public int isPoweringTo(int l) {
			return 0;
		}

		return (i1 != 2 || l != 4)?15:0;
	}

	@Override
public int isIndirectlyPoweringTo(int l) {
	public void updateEntity() {
		super.updateEntity();

		//System.out.println("Quantity: " + (((PipeTransportLiquids)this.transport).getLiquidQuantity()) + " - Wanted: " + computeMaxLiquid() + " - Qua2: " + computeEnds()[1]);
		//System.out.println("Quantity: " + ((PipeTransportLiquids)this.transport).getCenter());
		LiquidStack liquid = ((PipeTransportLiquids) transport)
				.getTanks(ForgeDirection.UNKNOWN)[ForgeDirection.UNKNOWN.ordinal()].getLiquid();
		if (liquid == null || liquid.amount == 0 && isPowering) {
			isPowering = false;
			UpdateTiles(container.xCoord, container.yCoord, container.zCoord);
		}
		else if (!isPowering) {
			isPowering = true;
			UpdateTiles(container.xCoord, container.yCoord, container.zCoord);
		}
	}

	public boolean canRec(Position p) {
		TileEntity entity = worldObj.getBlockTileEntity((int) p.x, (int) p.y,
				(int) p.z);

		if (!Utils.checkPipesConnections(entity, container)) {
			return false;
		}

		if (entity instanceof IPipeEntry || entity instanceof ITankContainer) {
			return true;
		}

public PipeLiquidsTeleport(int itemID) {
	public int fill(ForgeDirection from, LiquidStack resource, boolean doFill) {
		List<PipeTeleport> pipeList = TeleportManager.instance.getConnectedPipes(this, false);

		if (pipeList.size() == 0 || (logic.state & 0x1) == 0) {
			return 0;
		}

		int i = worldObj.rand.nextInt(pipeList.size());
		List<ITankContainer> possibleMovements = getPossibleLiquidMovements(pipeList.get(i));

		if (possibleMovements.size() <= 0) {
			return 0;
		}

		int used = 0;
		while (possibleMovements.size() > 0 && used <= 0) {
			int a = rand.nextInt(possibleMovements.size());
			used = possibleMovements.get(a).fill(ForgeDirection.UNKNOWN, resource, doFill);
			possibleMovements.remove(a);
public int fill(ForgeDirection from, LiquidStack resource, boolean doFill) {
	private static List<ITankContainer> getPossibleLiquidMovements(PipeTeleport pipe) {
		List<ITankContainer> result = new LinkedList<ITankContainer>();

		for (ForgeDirection o : ForgeDirection.VALID_DIRECTIONS) {
			if (pipe.logic.outputOpen(o)) {
				ITankContainer te = (ITankContainer) pipe.container.getTile(o);
				result.add(te);
			}
public PipeLiquidsWaterPump(int itemID) {
	@Override
	public void updateEntity() {
		super.updateEntity();
		if(AdditionalPipes.proxy.isServer(worldObj) &&
				worldObj.getBlockId(xCoord, yCoord - 1, zCoord) == water.blockID) {
			transport.fill(ForgeDirection.UNKNOWN, new LiquidStack(water, 100), true);
		}
	}
	private static class PowerRequest {
		public final TileGenericPipe tile;
		public final ForgeDirection orientation;
		public PowerRequest(TileGenericPipe te, ForgeDirection o) {
			tile = te;
			orientation = o;
public PipePowerTeleport(int itemID) {

	@Override
	public void requestEnergy(ForgeDirection from, int is) {
		((PipeTransportPower)transport).step();

		if ((logic.state & 0x2) == 0) { //No need to waste CPU
			return;
		}

		List<PipeTeleport> pipeList = TeleportManager.instance.getConnectedPipes(this, true);

		if (pipeList.size() <= 0) {
			return;
		}

		for (PipeTeleport pipe : pipeList) {
			LinkedList<ForgeDirection> possibleMovements = getRealPossibleMovements(pipe);
			for (ForgeDirection orientation : possibleMovements) {
				TileEntity tile = pipe.container.getTile(orientation);
				if (tile instanceof TileGenericPipe) {
					TileGenericPipe adjacentTile = (TileGenericPipe) tile;
					PipeTransportPower nearbyTransport = (PipeTransportPower) adjacentTile.pipe.transport;
					nearbyTransport.requestEnergy(orientation.getOpposite(), is);
public void requestEnergy(ForgeDirection from, int is) {

	@Override
	public void receiveEnergy(ForgeDirection from, double val) {
		((PipeTransportPower)transport).step();
		List<PipeTeleport> connectedPipes = TeleportManager.instance.getConnectedPipes(this, false);
		List<PipeTeleport> sendingToList = new LinkedList<PipeTeleport>();

		//no connected pipes, leave!
		if (connectedPipes.size() <= 0 || (logic.state & 0x1) == 0) {
			return;
		}

		for (PipeTeleport pipe : connectedPipes) {
			if (getPipesNeedsPower(pipe).size() > 0) {
				sendingToList.add(pipe);
			}
		}

		//no pipes need energy, leave!
		if (sendingToList.size() <= 0) {
			return;
		}

		//TODO proportional power relay
		double powerToSend = AdditionalPipes.instance.powerLossCfg * val / sendingToList.size();

		for (PipeTeleport receiver : sendingToList) {
			List<PowerRequest> needsPower = getPipesNeedsPower(receiver);

			if (needsPower.size() <= 0) {
				continue;
			}

			double dividedPowerToSend = powerToSend / needsPower.size();

			for (PowerRequest powerEntry : needsPower) {
				PipeTransportPower nearbyTransport = (PipeTransportPower) powerEntry.tile.pipe.transport;
				nearbyTransport.receiveEnergy(powerEntry.orientation, dividedPowerToSend);
			}

		}
	}


	private List<PowerRequest> getPipesNeedsPower(PipeTeleport pipe) {
		LinkedList<ForgeDirection> possibleMovements = getRealPossibleMovements(pipe);
		List<PowerRequest> needsPower = new LinkedList<PowerRequest>();

		if (possibleMovements.size() > 0) {
			for (ForgeDirection orientation : possibleMovements) {
				TileEntity tile = pipe.container.getTile(orientation);
				if (tile instanceof TileGenericPipe){
					TileGenericPipe adjacentPipe = (TileGenericPipe) tile;
					if(pipeNeedsPower(adjacentPipe)) {
						needsPower.add(new PowerRequest(adjacentPipe, orientation.getOpposite()));
public void receiveEnergy(ForgeDirection from, double val) {
		return needsPower;
	}

	//precondition: power pipe that isn't tp
	private static boolean pipeNeedsPower(TileGenericPipe tile) {
		if (tile instanceof TileGenericPipe) {
			PipeTransportPower ttb = (PipeTransportPower) tile.pipe.transport;
			for (int i = 0; i < ttb.powerQuery.length; i++)
				if (ttb.powerQuery[i] > 0) {
					return true;
				}
		}
		return false;
	}

	//returns all adjacent pipes
	private static LinkedList<ForgeDirection> getRealPossibleMovements(PipeTeleport pipe) {
		LinkedList<ForgeDirection> result = new LinkedList<ForgeDirection>();

		for (ForgeDirection orientation : ForgeDirection.VALID_DIRECTIONS) {
			if (pipe.outputOpen(orientation)) {
				TileEntity te = pipe.container.getTile(orientation);
				if ((te instanceof TileGenericPipe) &&
						Utils.checkPipesConnections(pipe.container, te)) {
					result.add(orientation);
				}
			}
public PipeSwitch(PipeTransport transport, int itemID, int textureIndex) {

	@Override
	public int getIconIndex(ForgeDirection direction) {
		return textureIndex + (logic.canPipeConnect(null, direction)? 0 : 1);
	}

	@Override
	public final Map<Integer, Integer[]> phasedSignals;
	public final Map<Integer, String> frequencyNames;

	private TeleportManager(){
		teleportPipes = new LinkedList<PipeTeleport>();
		phasedSignals = new HashMap<Integer, Integer[]>();
		frequencyNames = new HashMap<Integer, String>();
	}

	public void add(PipeTeleport pipe) {
		if(!AdditionalPipes.proxy.isServer(pipe.worldObj)) return;
		teleportPipes.add(pipe);
		AdditionalPipes.instance.logger.info(
				String.format("[TeleportManager] Pipe added: %!s(MISSING) @ (%!d(MISSING), %!d(MISSING), %!d(MISSING)), %!d(MISSING) pipes in network",
						pipe.getClass().getSimpleName(), pipe.xCoord, pipe.yCoord, pipe.zCoord, teleportPipes.size()));
	}

	public void remove(PipeTeleport pipe){
		if(!AdditionalPipes.proxy.isServer(pipe.worldObj)) return;
		teleportPipes.remove(pipe);
		AdditionalPipes.instance.logger.info(
				String.format("[TeleportManager] Pipe removed: %!s(MISSING) @ (%!d(MISSING), %!d(MISSING), %!d(MISSING)), %!d(MISSING) pipes in network",
						pipe.getClass().getSimpleName(), pipe.xCoord, pipe.yCoord, pipe.zCoord, teleportPipes.size()));
	}

	public void reset() {
public void reset() {
		AdditionalPipes.instance.logger.info("Reset teleport manager.");
	}

	//returns all other teleport pipes of the same type (class) and frequency
	//if forceReceive is true. Otherwise, take away all pipes that aren't receiving
	public List<PipeTeleport> getConnectedPipes(PipeTeleport pipe, boolean forceReceive) {
		List<PipeTeleport> connected = new LinkedList<PipeTeleport>();
		PipeLogicTeleport logic = pipe.logic;

		for (PipeTeleport other : teleportPipes) {
			if (!pipe.getClass().equals(other.getClass()) || other.container.isInvalid()) {
				continue;
			}
			PipeLogicTeleport otherLogic = other.logic;

			//not the same pipe &&
			//same frequency &&
			//pipe is open or forceReceive &&
			//both public or same owner
			if ((pipe.xCoord != other.xCoord || pipe.yCoord != other.yCoord || pipe.zCoord != other.zCoord ) &&
					otherLogic.getFrequency() == logic.getFrequency() &&
					((otherLogic.state & 0x2) > 0 || forceReceive) &&
					(logic.isPublic ? otherLogic.isPublic  : otherLogic.owner.equalsIgnoreCase(logic.owner) )) {
				connected.add(other);
			}
		}
		return connected;
	}

	//FIXME unused
	public List<PipeTeleport> getAllPipesInNetwork(PipeTeleport pipe) {
		List<PipeTeleport> pipes = new LinkedList<PipeTeleport>();
		PipeLogicTeleport logic = pipe.logic;

		for (PipeTeleport other : teleportPipes) {
			if (!pipe.getClass().equals(other.getClass()) || other.container.isInvalid()) {
				continue;
			}
			PipeLogicTeleport otherLogic = other.logic;

			if (otherLogic.getFrequency() == logic.getFrequency() &&
					(logic.isPublic ? otherLogic.isPublic  : otherLogic.owner.equalsIgnoreCase(logic.owner) )) {
				pipes.add(other);
			}
		}
public void reset() {

	public String getFrequencyName(int frequency) {
		String name = frequencyNames.get(frequency);
		return name ==  null ? "" : name;
	}

	public void setFrequencyName(int frequency, String name) {

public class PipeLogicAdvancedWood extends PipeLogic implements IInventory {

	public ItemStack [] items = new ItemStack [9];

	public boolean exclude = false;

	public void switchSource () {
		int meta = worldObj.getBlockMetadata(xCoord, yCoord, zCoord);
		int newMeta = 6;

		for (int i = meta + 1; i <= meta + 6; ++i) {
			ForgeDirection o = ForgeDirection.VALID_DIRECTIONS[i %!](MISSING);
			TileEntity tile = container.getTile(o);
			if (isInput(tile))
				if (PipeManager.canExtractItems(container.getPipe(), tile.worldObj, tile.xCoord, tile.yCoord, tile.zCoord)) {
					newMeta = o.ordinal();
					break;
				}
		}

		if (newMeta != meta) {
			worldObj.setBlockMetadataWithNotify(xCoord, yCoord, zCoord, newMeta, 2);
			container.scheduleRenderUpdate();
			//worldObj.markBlockNeedsUpdate(xCoord, yCoord, zCoord);
		}
	}

	public boolean isInput(TileEntity tile) {
		return !(tile instanceof TileGenericPipe) && tile instanceof IInventory
				&& Utils.checkPipesConnections(container, tile);
	}


	@Override
	public boolean blockActivated(EntityPlayer entityplayer) {
		Item equipped = entityplayer.getCurrentEquippedItem() != null ? entityplayer.getCurrentEquippedItem().getItem() : null;
		if (equipped instanceof IToolWrench
				&& ((IToolWrench) equipped).canWrench(entityplayer, xCoord, yCoord, zCoord)) {
			switchSource();
			((IToolWrench) equipped).wrenchUsed(entityplayer, xCoord, yCoord, zCoord);
			return true;
public boolean blockActivated(EntityPlayer entityplayer) {
			return false;
		}

		entityplayer.openGui(AdditionalPipes.instance, GuiHandler.PIPE_WOODEN_ADV,
				container.worldObj, container.xCoord, container.yCoord, container.zCoord);
		return true;
	}

	@Override
	public boolean canPipeConnect(TileEntity tile, ForgeDirection side) {
		Pipe pipe2 = null;

		if (tile instanceof TileGenericPipe) {
			pipe2 = ((TileGenericPipe) tile).pipe;
		}

		return (pipe2 == null || (!(pipe2.logic instanceof PipeLogicWood) && !(pipe2.logic instanceof PipeLogicAdvancedWood))) && super.canPipeConnect(tile,side);

	}

	@Override
	public void initialize () {
		super.initialize();
		switchSourceIfNeeded();
	}

	private void switchSourceIfNeeded () {
		int meta = worldObj.getBlockMetadata(xCoord, yCoord, zCoord);
		if (meta > 5) switchSource();
		else {
			TileEntity tile = container.getTile(ForgeDirection.VALID_DIRECTIONS[meta]);
			if (!isInput(tile)) switchSource();
		}
	}

public void readFromNBT(NBTTagCompound nbttagcompound) {

		NBTTagList nbttaglist = nbttagcompound.getTagList("items");

		for (int j = 0; j < nbttaglist.tagCount(); ++j) {
			NBTTagCompound nbttagcompound2 = (NBTTagCompound) nbttaglist.tagAt(j);
			int index = nbttagcompound2.getInteger("index");
			items [index] = ItemStack.loadItemStackFromNBT(nbttagcompound2);
		}
	}

public void writeToNBT(NBTTagCompound nbttagcompound) {

		NBTTagList nbttaglist = new NBTTagList();

		for (int j = 0; j < items.length; ++j) {
			if (items [j] != null && items [j].stackSize > 0) {
				NBTTagCompound nbttagcompound2 = new NBTTagCompound ();
				nbttaglist.appendTag(nbttagcompound2);
				nbttagcompound2.setInteger("index", j);
				items [j].writeToNBT(nbttagcompound2);
			}
		}

public ItemStack getStackInSlot(int i) {
	@Override
	public ItemStack decrStackSize(int i, int amt) {
		ItemStack stack = getStackInSlot(i);
		if (stack != null) {
			if (stack.stackSize <= amt) {
				setInventorySlotContents(i, null);
			} else {
				stack = stack.splitStack(amt);
				if (stack.stackSize == 0) {
					setInventorySlotContents(i, null);
				}
			}
public ItemStack decrStackSize(int i, int amt) {
	@Override
	public ItemStack getStackInSlotOnClosing(int i) {
		ItemStack stack = getStackInSlot(i);
		if (stack != null) {
			setInventorySlotContents(i, null);
		}
		return stack;
	@Override
	public boolean blockActivated(EntityPlayer player) {
		ItemStack equippedItem = player.getCurrentEquippedItem();
		if (equippedItem != null && AdditionalPipes.isPipe(equippedItem.getItem()))  {
			return false;
		}
		player.openGui(AdditionalPipes.instance, GuiHandler.PIPE_CLOSED, worldObj, xCoord, yCoord, zCoord);

public class PipeLogicDistributor extends PipeLogic {

	public int distData[] = {1, 1, 1, 1, 1, 1};
	public int distSide = 0;
	public int curTick = 0;

public boolean blockActivated(EntityPlayer player) {
		}

		Item equipped = player.getCurrentEquippedItem() != null ? player.getCurrentEquippedItem().getItem() : null;
		if (equipped != null) {
			if (AdditionalPipes.isPipe(equipped)) {
				return false;
			}
		}

		player.openGui(AdditionalPipes.instance, GuiHandler.PIPE_DIST,
				container.worldObj, container.xCoord, container.yCoord, container.zCoord);

		return true;
	}

	private void sanityCheck() {
		for (int d : distData) {
			if (d > 0) {
				return;
			}
		}
		for (int i = 0; i < distData.length; i++) {
			Arrays.fill(distData, 1);
		}
	}
public void writeToNBT(NBTTagCompound nbt) {

		nbt.setInteger("curTick", curTick);
		nbt.setInteger("distSide", distSide);
		for (int i = 0; i < distData.length; i++) {
			nbt.setInteger("distData" + i, distData[i]);
		}
	}
public void readFromNBT(NBTTagCompound nbt) {

		curTick = nbt.getInteger("curTick");
		distSide = nbt.getInteger("distSide");
		for (int i = 0; i < distData.length; i++) {
			distData[i] = nbt.getInteger("distData" + i);
		}
		sanityCheck();
public void setTile(TileGenericPipe tile) {

	@Override
	public boolean blockActivated(EntityPlayer player) {
		if(!AdditionalPipes.proxy.isServer(player.worldObj)) return true;
		if (owner == null || "".equalsIgnoreCase(owner)) {
			owner = player.username;
		}
		ItemStack equippedItem = player.getCurrentEquippedItem();
		/*if (equippedItem != null && AdditionalPipes.isPipe(equippedItem.getItem()))  {
			return false;
		}*/
		player.openGui(AdditionalPipes.instance, GuiHandler.PIPE_TP, worldObj, xCoord, yCoord, zCoord);
		return true;
	}
public void updatePhasedSignals() {
	@Override
	public boolean canPipeConnect(TileEntity tile, ForgeDirection side) {
		Pipe pipe = null;
		if (tile instanceof TileGenericPipe) {
			pipe = ((TileGenericPipe) tile).pipe;
		}
		if(pipe != null && pipe.logic.getClass() == this.getClass()) return false;
		return pipe != null;
	}

package buildcraft.additionalpipes.textures;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.texture.IconRegister;
import net.minecraft.util.Icon;
import buildcraft.api.core.IIconProvider;
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;

public class APActionTriggerIconProvider implements IIconProvider
{
	public static int actionDisablePipeIconIndex = 0;
	public static int triggerCraftingIconIndex = 1;
	public static int triggerPowerDischargingIconIndex =2;
	public static int triggerPowerNeededIconIndex =3;
	public static int triggerSupplierFailedIconIndex =4;
	public static int triggerHasDestinationIconIndex =5;
	
	private Icon icons[];
	private final int iconCount = 9;
	public APActionTriggerIconProvider()
	{
		icons=new Icon[iconCount];
	}
	@Override
	@SideOnly(Side.CLIENT)
	public Icon getIcon(int iconIndex) {
		if(iconIndex>=iconCount)
			return null;
		return icons[iconIndex];
	}

	@Override
	@SideOnly(Side.CLIENT)
	public void registerIcons(IconRegister iconRegister) {
		if(iconRegister!=Minecraft.getMinecraft().renderEngine.textureMapItems)
			return;
		for(int i=0;i<iconCount;i++)
		{
			icons[i]=iconRegister.registerIcon("additionalpipes:triggers/"+i);
		}
	}
	
}
package buildcraft.additionalpipes.textures;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.texture.IconRegister;
import net.minecraft.util.Icon;
	private Icon icons[];
	private final int iconCount = 25;

	public APPipeIconProvider()	{
		icons=new Icon[iconCount];
	}

	@Override
	@SideOnly(Side.CLIENT)
	public Icon getIcon(int iconIndex) {
		if(iconIndex>=iconCount)
			return null;
		return icons[iconIndex];
	}

	@Override
	@SideOnly(Side.CLIENT)
	public void registerIcons(IconRegister iconRegister) {
		if(iconRegister != Minecraft.getMinecraft().renderEngine.textureMapBlocks) return;
		for(int i = 0; i < iconCount; i++) {
			icons[i]=iconRegister.registerIcon("additionalpipes:pipes/"+i);
		}
	}

import net.minecraft.util.Icon;

public class Textures {
	public static APActionTriggerIconProvider actionIconProvider=new APActionTriggerIconProvider();
	public static APPipeIconProvider pipeIconProvider=new APPipeIconProvider();
	public static Icon tetherTexture;
	public static void registerIcons(IconRegister par1IconRegister)
	{
		actionIconProvider.registerIcons(par1IconRegister);
		pipeIconProvider.registerIcons(par1IconRegister);
		if(par1IconRegister==Minecraft.getMinecraft().renderEngine.textureMapBlocks)
		{
			tetherTexture=par1IconRegister.registerIcon("additionalpipes:tether");
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private static boolean syncConfig() {
		SearchMode[] searchModes = SearchMode.values();

		// set new defaults moving from config version 0.2.0 to 0.3.0
		if (config.getLoadedConfigVersion().equals("0.2.0")) {
			config.setEnum("creativeTabSearchMode", CATEGORY_SEARCH, defaultValues.creativeTabSearchMode, searchModes);
			config.setEnum("oreDictSearchMode", CATEGORY_SEARCH, defaultValues.oreDictSearchMode, searchModes);
		}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void executePost(List<ContextDocIdSet> docSets) throws IOException {
                for (int i = 0; i < docSets.size(); i++) {
                    ContextDocIdSet entry = docSets.get(i);
                    DocIdSet filteredSet = filter.getDocIdSet(entry.context, null);
                    filteredEntries.add(new ContextDocIdSet(
                            entry.context,
                            // TODO: can we be smart here, maybe AndDocIdSet is not always fastest?
                            new AndDocIdSet(new DocIdSet[]{entry.docSet, filteredSet})
                    ));
                }
                post.executePost(filteredEntries);
            }
import static org.elasticsearch.index.query.FilterBuilders.termFilter;
import static org.elasticsearch.index.query.QueryBuilders.*;
import static org.elasticsearch.search.facet.FacetBuilders.*;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;

/**
public void testQueryFacet() throws Exception {
        }
    }

    private long utcTimeInMillis(String time) {
        return timeInMillis(time, DateTimeZone.UTC);
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public UserManager userManager(){
		return userManager;
	}
	
	/*
	@Bean
	public CppClassManager cppClassManager(){
		CppClassManager cppClassManager = new CppClassManager();
		return cppClassManager;
	}*/

	public static void main(String[] args) {
		SpringApplication.run(MyApp.class, args);
public class WebController {
	
	@Autowired private UserManager userManager;

    GoogleOAuth OAuth; // May come up with better method

String getHome(@RequestParam("code") String code) throws IOException{

    //Temporary Usage, Just want to try it out
    @RequestMapping("/getCppSchedule")
    String getCppClassesSchedule(){
        try {
            GetCppClasses cppClsss = new GetCppClasses();
        } catch (IOException e) {
            System.out.println("Error -- getCppClsses");
        }
 * @author nchantarutai
 *
 */
@Document(collection = "classes")
public class CppClassSchedule {

	private String code;
@Configurable
public class CppClassManager {
	
	@Autowired private CppClassRepository classRepo; // Not work need to recheck
	
	public void addNewClassToList(CppClassSchedule newClass){
		classRepo.save(newClass);
	}
	
}
 */
public class GetCppClasses {
		
	@Autowired private CppClassManager classManager;
		
		public GetCppClasses() throws IOException{	
			classManager = new CppClassManager(); //Autowired not work, need to recheck
			parseClasses();
		}
		
		public void parseClasses() throws IOException{
			File codeCsv = new File("src/main/resources/static/data/classCodes.csv");
			BufferedReader br = new BufferedReader(new FileReader(codeCsv));
			String input = br.readLine();
public static Document parseClass(String code) throws IOException{
			return result;
		}
		
		public void insertClassScheduleToDB(Document doc){
			
			TimeObj classTime = new TimeObj();		
			String classCode = "", description = "", time ="", location = "", datePeriod = "", instructor = "", building = "", room = "";
public void insertClassScheduleToDB(Document doc){
				
				CppClassSchedule newClass = new CppClassSchedule(classCode, description, classTime, instructor, building, room);
				
				//Error Null Pointer Exception, need to fix
				//classManager.addNewClassToList(newClass);
			}
			
		}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public int compare(FormIndex arg0, FormIndex arg1) {
                    }
                }
            } else {
                Log.w(t, "Unknown view type rendered while current event was question or group! View type: " + mCurrentView == null ? "null" : mCurrentView.getClass().toString());
            }    
        }
        return success;
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#Build Number for ANT. Do not edit!
#Sun Feb 22 21:25:55 GMT 2015
build.number=173
## By DarthSalamon & Wild1145
##

# Visitor Counter
uniqueplayers: 0
players: 0
public void onEnable()
            logger.warning(DC_Messages.MYSQL_NOT_ENABLED);
        }

        //Lets download the Database and see if this shit actually works...
        plugin.playerSource.downloadDatabase();

        // Start the metrics
        metricsPlotter.start();

        logger.log(Level.INFO, DC_Messages.PLUGIN_ENABLED, new Object[]
        {
            pluginVersion, pluginAuthors
        });
    }


public class PlayerSource extends DarthCraftAddon
{
    
    File databaseFile;
    File dataFolder;
    
    public PlayerSource(DarthCraft plugin)
    {
        super(plugin);
        File database = new File("GeoLite2-City.mmdb");
        
        this.dataFolder = dataFolder;
        
        try
        {
            reader = new DatabaseReader.Builder(database).build();
public PlayerSource(DarthCraft plugin)
            logger.debug("SHIT BROKE!!!! (IP Resolver)");
        }
    }
    
    DatabaseReader reader;

    /**
public String getCountryName(String ip)
        try
        {
            CityResponse response = reader.city(InetAddress.getByName(ip));
            
            Country country = response.getCountry();
            
            return country.getName();
        }
        catch (IOException | GeoIp2Exception ex)
public String getCountryName(String ip)
            return null;
        }
    }
    
    public void onPlayerJoinEvent(PlayerJoinEvent event)
    {
        String country = getCountryName(event.getPlayer().getAddress().getHostName());
        for (Player player : plugin.getServer().getOnlinePlayers())
        {
            if (Permissions.PermissionUtils.hasPermission(player, Permissions.Permission.ADMIN))
            {
                player.sendMessage(event.getPlayer().getName() + "Comes from " + country);
            }
        }
        
    }
    
    public void downloadDatabase()
    {
        if (databaseFile.exists())
        {
            logger.debug("The file exsists... Lets do nothing");
        }
        else
        {
            logger.debug("PANIC!!! The file is missing... Lets see what we can do about that.");
            try
            {
                databaseFile = new File(dataFolder, "GeoLite2-City.mmdb");
                String url = "https://www.superior-networks.com/maxmind/GeoLite2-City.mmdb";
                logger.debug("Something important can be put here... What exactly nobody knows, but oh well.");
                URL downloadUrl = new URL(url);
                URLConnection conn = downloadUrl.openConnection();
                conn.setConnectTimeout(10000);
                conn.connect();
                InputStream input = conn.getInputStream();
                
                input = new GZIPInputStream(input);
                OutputStream output = new FileOutputStream(databaseFile);
                byte[] buffer = new byte[2048];
                int length = input.read(buffer);
                while (length >= 0)
                {
                    output.write(buffer, 0, length);
                    length = input.read(buffer);
                }
                output.close();
                input.close();
            }
            catch (MalformedURLException ex)
            {
                logger.debug("The URL is fucked up... Wild broke something again - Sorry :)");
                return;
            }
            catch (IOException ex)
            {
                logger.debug("Errr... This looks like Ben Broken something with the network I think... As we cannot connect to the URL... Shout at Ben please :)");
            }
        }
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                <CheckBoxPreference
                    android:defaultValue="true"
                    android:enabled="false"
                    android:key="@string/pref_navigation_menu_mapswithme"
                    android:title="@string/cache_menu_mapswithme" />
            </PreferenceScreen>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public DB get(MongoDataStore store) {
                db = dbMap.get(store.getDatabaseName());
                if (db == null) {
                    MongoConfiguration cfg=getConfiguration(store);
                    db = cfg.getDB();
                    dbMap.put(store.getDatabaseName(), db);
                }
public static Object getDBObject(DBObject start, Path p) {
            String segment = p.head(seg);
            if (segment.equals(Path.ANY)) {
                throw Error.get(MongoCrudConstants.ERR_TRANSLATION_ERROR, p.toString());
            } else if (Util.isNumber(segment)) {
                trc = ((List) trc).get(Integer.valueOf(segment));
            } else {
                trc = ((DBObject) trc).get(segment);
            }
            if (trc == null&&seg+1<n) {
public BSONObject convert(EntitySchema schema) {
        Error.push("convert[info|bson]");
        try {
            BSONObject doc = super.convert(schema);
            putValue(doc, "_id", getStringProperty(doc, "name") + DELIMITER_ID + getStringProperty(getObjectProperty(doc, "version"), "value"));

            return doc;
        } catch (Error e) {
import com.mongodb.ReadPreference;
import com.mongodb.WriteConcern;
import com.redhat.lightblue.util.JsonUtils;

public class MongoConfigurationParseTest {

    @Test
    public void testReadPreference() throws IOException {

        JsonNode node = JsonUtils.json(Thread.currentThread().getContextClassLoader().getResourceAsStream("parse-test-datasources.json"));

        MongoConfiguration metadataConfig = new MongoConfiguration();
        metadataConfig.initializeFromJson(node.get("metadata"));

        MongoConfiguration dataConfig = new MongoConfiguration();
        dataConfig.initializeFromJson(node.get("mongodata"));

        assertEquals(ReadPreference.nearest(), metadataConfig.getMongoClientOptions().getReadPreference());
        assertEquals(ReadPreference.secondary(), dataConfig.getMongoClientOptions().getReadPreference());
        assertEquals(WriteConcern.SAFE, metadataConfig.getWriteConcern());
    }

}
package com.redhat.lightblue.mongo.crud;

import com.mongodb.BasicDBObject;
import com.mongodb.DBObject;
import com.mongodb.WriteResult;
import com.redhat.lightblue.crud.CRUDDeleteResponse;
import com.redhat.lightblue.crud.CRUDOperationContext;
import com.redhat.lightblue.mongo.crud.BasicDocDeleter;
import com.redhat.lightblue.crud.CRUDOperation;
import org.junit.Assert;
import org.junit.Test;
public void delete() {
        // check that insert happened
        Assert.assertTrue(wr.getError() == null);

        Assert.assertEquals("count on collection", 1, coll.find(null).count());

        // execute delete
        BasicDocDeleter deleter = new BasicDocDeleter();
import com.github.fge.jsonschema.core.exceptions.ProcessingException;

import com.mongodb.BasicDBObject;
import com.mongodb.DBObject;
import com.mongodb.WriteResult;
import com.redhat.lightblue.crud.CRUDOperation;
import com.redhat.lightblue.metadata.EntityMetadata;
import com.redhat.lightblue.mongo.crud.BasicDocFinder;
import com.redhat.lightblue.mongo.crud.Translator;
import com.redhat.lightblue.util.Path;
import com.redhat.lightblue.util.JsonUtils;

    private Translator translator;

    @Before
    public void setup() throws Exception {
        super.setup();

public void findAll() throws IOException, ProcessingException {
        insert("{\"_id\":\"%!s(MISSING)\",\"objectType\":\"test\"}", id + "2");
        insert("{\"_id\":\"%!s(MISSING)\",\"objectType\":\"test\"}", id + "3");

        Assert.assertEquals("count on collection", 3, coll.find(null).count());

        BasicDocFinder finder = new BasicDocFinder(translator);

public void findOneOfMany() throws IOException, ProcessingException {
        insert("{\"_id\":\"%!s(MISSING)\",\"objectType\":\"test\"}", id + "2");
        insert("{\"_id\":\"%!s(MISSING)\",\"objectType\":\"test\"}", id + "3");

        Assert.assertEquals("count on collection", 3, coll.find(null).count());

        BasicDocFinder finder = new BasicDocFinder(translator);

public void findLimit() throws IOException, ProcessingException {
        insert("{\"_id\":\"%!s(MISSING)\",\"objectType\":\"test\"}", id + "2");
        insert("{\"_id\":\"%!s(MISSING)\",\"objectType\":\"test\"}", id + "3");

        Assert.assertEquals("count on collection", 3, coll.find(null).count());

        BasicDocFinder finder = new BasicDocFinder(translator);

public void findLimit() throws IOException, ProcessingException {
    @Test
    public void testSkipLimit() throws IOException, ProcessingException {
    	String id = "findLimit";
        for(int i=0;i<20;i++)
        {
        insert("{\"_id\":\"%!s(MISSING)\",\"objectType\":\"test\"}", id + i);
        }

        Assert.assertEquals("count on collection", 20, coll.find(null).count());

        BasicDocFinder finder = new BasicDocFinder(translator);

public void testSkipLimit() throws IOException, ProcessingException {
    @Test
    public void testNullLimit() throws IOException, ProcessingException {
        String id = "findLimit";
        for(int i=0;i<20;i++)
        {
        insert("{\"_id\":\"%!s(MISSING)\",\"objectType\":\"test\"}", id + i);
        }
       

        Assert.assertEquals("count on collection", 20, coll.find(null).count());

        BasicDocFinder finder = new BasicDocFinder(translator);

public void testNullLimit() throws IOException, ProcessingException {
    @Test
    public void testZeroLimit() throws IOException, ProcessingException {
        String id = "findLimit";
        for(int i=0;i<20;i++)
        {
        insert("{\"_id\":\"%!s(MISSING)\",\"objectType\":\"test\"}", id + i);
        }
       

        Assert.assertEquals("count on collection", 20, coll.find(null).count());

        BasicDocFinder finder = new BasicDocFinder(translator);

public void testZeroLimit() throws IOException, ProcessingException {
    @Test
    public void testResultSetLimit() throws IOException, ProcessingException {
        String id = "findLimit";
        for(int i=0;i<20;i++)
        {
        insert("{\"_id\":\"%!s(MISSING)\",\"objectType\":\"test\"}", id + i);
        }
       

        Assert.assertEquals("count on collection", 20, coll.find(null).count());

        BasicDocFinder finder = new BasicDocFinder(translator);
        finder.setMaxResultSetSize(10);
public void testResultSetLimit() throws IOException, ProcessingException {
    @Test
    public void testNegativeLimit() throws IOException, ProcessingException {
        String id = "findLimit";
        for(int i=0;i<20;i++)
        {
        insert("{\"_id\":\"%!s(MISSING)\",\"objectType\":\"test\"}", id + i);
        }
       

        Assert.assertEquals("count on collection", 20, coll.find(null).count());

        BasicDocFinder finder = new BasicDocFinder(translator);

public void testNegativeLimit() throws IOException, ProcessingException {
    @Test
    public void testLimitLesserThanSkip() throws IOException, ProcessingException {
        String id = "findLimit";
        for(int i=0;i<20;i++)
        {
        insert("{\"_id\":\"%!s(MISSING)\",\"objectType\":\"test\"}", id + i);
        }
       

        Assert.assertEquals("count on collection", 20, coll.find(null).count());

        BasicDocFinder finder = new BasicDocFinder(translator);

public void findSort() throws IOException, ProcessingException {
        insert("{\"_id\":\"%!s(MISSING)\",\"objectType\":\"test\"}", id + "1");
        insert("{\"_id\":\"%!s(MISSING)\",\"objectType\":\"test\"}", id + "3");

        Assert.assertEquals("count on collection", 3, coll.find(null).count());

        BasicDocFinder finder = new BasicDocFinder(translator);

public void findSortAndLimit() throws IOException, ProcessingException {
        insert("{\"_id\":\"%!s(MISSING)\",\"objectType\":\"test\"}", id + "1");
        insert("{\"_id\":\"%!s(MISSING)\",\"objectType\":\"test\"}", id + "3");

        Assert.assertEquals("count on collection", 3, coll.find(null).count());

        BasicDocFinder finder = new BasicDocFinder(translator);

public void findSkip() throws IOException, ProcessingException {
        insert("{\"_id\":\"%!s(MISSING)\",\"objectType\":\"test\"}", id + "2");
        insert("{\"_id\":\"%!s(MISSING)\",\"objectType\":\"test\"}", id + "3");

        Assert.assertEquals("count on collection", 3, coll.find(null).count());

        BasicDocFinder finder = new BasicDocFinder(translator);

public void findSortAndSkip() throws IOException, ProcessingException {
        insert("{\"_id\":\"%!s(MISSING)\",\"objectType\":\"test\"}", id + "1");
        insert("{\"_id\":\"%!s(MISSING)\",\"objectType\":\"test\"}", id + "3");

        Assert.assertEquals("count on collection", 3, coll.find(null).count());

        BasicDocFinder finder = new BasicDocFinder(translator);

public void findSortSkipAndLimit() throws IOException, ProcessingException {
        insert("{\"_id\":\"%!s(MISSING)\",\"objectType\":\"test\"}", id + "4");
        insert("{\"_id\":\"%!s(MISSING)\",\"objectType\":\"test\"}", id + "3");

        Assert.assertEquals("count on collection", 4, coll.find(null).count());

        BasicDocFinder finder = new BasicDocFinder(translator);

import com.mongodb.BasicDBObject;
import com.mongodb.DB;
import com.mongodb.DBCollection;
import com.mongodb.DBObject;
import com.redhat.lightblue.crud.CRUDDeleteResponse;
import com.redhat.lightblue.crud.CRUDInsertionResponse;
import com.redhat.lightblue.mongo.common.DBResolver;
import com.redhat.lightblue.mongo.common.MongoDataStore;
import com.redhat.lightblue.mongo.config.MongoConfiguration;
import com.redhat.lightblue.mongo.crud.IterateAndUpdate;
import com.redhat.lightblue.mongo.crud.MongoCRUDController;
import com.redhat.lightblue.mongo.crud.MongoCrudConstants;
import com.redhat.lightblue.mongo.crud.Translator;
import com.redhat.lightblue.query.Projection;
import com.redhat.lightblue.query.SortKey;
import com.redhat.lightblue.util.Error;
public void insertTest() throws Exception {
        Assert.assertTrue(ctx.getDataErrors() == null || ctx.getDataErrors().isEmpty());
        Assert.assertEquals(ctx.getDocumentsWithoutErrors().size(), response.getNumInserted());
        String id = ctx.getDocuments().get(0).getOutputDocument().get(new Path("_id")).asText();
        Assert.assertEquals(1, coll.find(new BasicDBObject("_id", Translator.createIdFrom(id))).count());
    }

    @Test
public void insertTest_nullReqField() throws Exception {
        Assert.assertTrue(ctx.getDataErrors() == null || ctx.getDataErrors().isEmpty());
        Assert.assertEquals(ctx.getDocumentsWithoutErrors().size(), response.getNumInserted());
        String id = ctx.getDocuments().get(0).getOutputDocument().get(new Path("_id")).asText();
        Assert.assertEquals(1, coll.find(new BasicDBObject("_id", Translator.createIdFrom(id))).count());
    }


public void saveTestForInvisibleFields() throws Exception {
        String id = ctx.getDocuments().get(0).getOutputDocument().get(new Path("_id")).asText();
        System.out.println("Saved id:" + id);

        coll.find();

        // Read doc using mongo
        DBObject dbdoc = coll.findOne(new BasicDBObject("_id", Translator.createIdFrom(id)));
        Assert.assertNotNull(dbdoc);
public void upsertTest() throws Exception {
        ctx.addDocument(readDoc);
        // This should not insert anything
        CRUDSaveResponse sr = controller.save(ctx, false, projection("{'field':'_id'}"));
        Assert.assertEquals(1, coll.find(null).count());

        ctx = new TestCRUDOperationContext(CRUDOperation.SAVE);
        ctx.add(md);
        ctx.addDocument(readDoc);
        sr = controller.save(ctx, true, projection("{'field':'_id'}"));
        Assert.assertEquals(2, coll.find(null).count());
        Assert.assertEquals(ctx.getDocumentsWithoutErrors().size(), sr.getNumSaved());
    }

public void updateTest() throws Exception {
        }
        ctx.addDocuments(docs);
        CRUDInsertionResponse response = controller.insert(ctx, projection("{'field':'_id'}"));
        Assert.assertEquals(numDocs, coll.find(null).count());
        Assert.assertEquals(ctx.getDocumentsWithoutErrors().size(), response.getNumInserted());

        // Single doc update
public void updateTest() throws Exception {
        Assert.assertEquals(0, upd.getNumFailed());
        //Assert.assertEquals(AtomicIterateUpdate.class, ctx.getProperty(MongoCRUDController.PROP_UPDATER).getClass());
        Assert.assertEquals(IterateAndUpdate.class, ctx.getProperty(MongoCRUDController.PROP_UPDATER).getClass());
        DBObject obj = coll.find(new BasicDBObject("field3", 1000), new BasicDBObject("_id", 1)).next();
        Assert.assertNotNull(obj);
        System.out.println("DBObject:" + obj);
        System.out.println("Output doc:" + ctx.getDocuments().get(0).getOutputDocument());
        Assert.assertEquals(ctx.getDocuments().get(0).getOutputDocument().get(new Path("_id")).asText(),
                obj.get("_id").toString());
        Assert.assertEquals(1, coll.find(new BasicDBObject("field3", 1000)).count());

        // Bulk update
        ctx = new TestCRUDOperationContext(CRUDOperation.UPDATE);
public void updateTest() throws Exception {
        Assert.assertEquals(IterateAndUpdate.class, ctx.getProperty(MongoCRUDController.PROP_UPDATER).getClass());
        Assert.assertEquals(10, upd.getNumUpdated());
        Assert.assertEquals(0, upd.getNumFailed());
        Assert.assertEquals(10, coll.find(new BasicDBObject("field3", new BasicDBObject("$gt", 10))).count());

        // Bulk direct update
        ctx = new TestCRUDOperationContext(CRUDOperation.UPDATE);
public void updateTest() throws Exception {
        Assert.assertEquals(IterateAndUpdate.class, ctx.getProperty(MongoCRUDController.PROP_UPDATER).getClass());
        Assert.assertEquals(10, upd.getNumUpdated());
        Assert.assertEquals(0, upd.getNumFailed());
        Assert.assertEquals(10, coll.find(new BasicDBObject("field3", new BasicDBObject("$gt", 10))).count());

        // Iterate update
        ctx = new TestCRUDOperationContext(CRUDOperation.UPDATE);
public void updateTest() throws Exception {
        Assert.assertEquals(IterateAndUpdate.class, ctx.getProperty(MongoCRUDController.PROP_UPDATER).getClass());
        Assert.assertEquals(10, upd.getNumUpdated());
        Assert.assertEquals(0, upd.getNumFailed());
        Assert.assertEquals(10, coll.find(new BasicDBObject("field7.0.elemf1", "blah")).count());
    }

    @Test
public void updateTest_PartialFailure() throws Exception {
        }
        ctx.addDocuments(docs);
        CRUDInsertionResponse response = controller.insert(ctx, projection("{'field':'_id'}"));
        Assert.assertEquals(numDocs, coll.find(null).count());
        Assert.assertEquals(ctx.getDocumentsWithoutErrors().size(), response.getNumInserted());

        // Add element to array
public void deleteTest() throws Exception {
        }
        ctx.addDocuments(docs);
        controller.insert(ctx, projection("{'field':'_id'}"));
        Assert.assertEquals(numDocs, coll.find(null).count());

        // Single doc delete
        ctx = new TestCRUDOperationContext(CRUDOperation.DELETE);
        ctx.add(md);
        CRUDDeleteResponse del = controller.delete(ctx, query("{'field':'field3','op':'$eq','rvalue':10}"));
        Assert.assertEquals(1, del.getNumDeleted());
        Assert.assertEquals(numDocs - 1, coll.find(null).count());

        // Bulk delete
        ctx = new TestCRUDOperationContext(CRUDOperation.DELETE);
        ctx.add(md);
        del = controller.delete(ctx, query("{'field':'field3','op':'>','rvalue':10}"));
        Assert.assertEquals(9, del.getNumDeleted());
        Assert.assertEquals(10, coll.find(null).count());
    }

    @Test
public void indexFieldValidationTest() throws Exception {
    public void indexFieldsMatch() {
        // order of kesys in an index matters to mongo, this test exists to ensure this is accounted for in the controller

        DBCollection coll = db.getCollection("testIndexFieldMatch");
        {
            BasicDBObject dbIndex = new BasicDBObject();
            dbIndex.append("x", 1);
            dbIndex.append("y", 1);
            coll.createIndex(dbIndex);
        }

        {
public void indexFieldsMatch() {
            ix.setFields(fields);

            boolean verified = false;
            for (DBObject dbi: coll.getIndexInfo()) {
                if (((BasicDBObject)dbi.get("key")).entrySet().iterator().next().getKey().equals("_id")) {
                    continue;
                }
public void indexFieldsMatch() {
            ix.setFields(fields);

            boolean verified = false;
            for (DBObject dbi: coll.getIndexInfo()) {
                if (((BasicDBObject)dbi.get("key")).entrySet().iterator().next().getKey().equals("_id")) {
                    continue;
                }
public void testMigrationUpdate() throws Exception {

    @Test
    public void idIndexRewriteTest() throws Exception {
        DBCollection coll=db.getCollection("data");

        EntityMetadata e = new EntityMetadata("testEntity");
        e.setVersion(new Version("1.0.0", null, "some text blah blah"));
public void idIndexRewriteTest() throws Exception {
        ctx.addDocument(doc);
        CRUDInsertionResponse response = controller.insert(ctx, projection);

       Assert.assertEquals(1,coll.find().count());

       Index ix2=new Index(new SortKey(new Path("field1"),false));
       e.getEntityInfo().getIndexes().add(ix2);
       // At this point, there must be an _id index in the collection
       Assert.assertEquals(1,coll.getIndexInfo().size());
       // Lets overwrite
       controller.afterUpdateEntityInfo(null,e.getEntityInfo(),false);
       // This should not fail
       Assert.assertEquals(2,coll.getIndexInfo().size());
    }

    @Test
    public void doubleidIndexRewriteTest() throws Exception {
        DBCollection coll=db.getCollection("data");

        EntityMetadata e = new EntityMetadata("testEntity");
        e.setVersion(new Version("1.0.0", null, "some text blah blah"));
public void doubleidIndexRewriteTest() throws Exception {
        ctx.addDocument(doc);
        CRUDInsertionResponse response = controller.insert(ctx, projection);

        Assert.assertEquals(1,coll.find().count());

        // At this point, there must be only one _id index in the collection
        Assert.assertEquals(1,coll.getIndexInfo().size());

        // Remove the nonunique index
        List<Index> ilist=new ArrayList<>();
public void doubleidIndexRewriteTest() throws Exception {
        // Lets overwrite
        controller.afterUpdateEntityInfo(null,e.getEntityInfo(),false);
        // This should not fail
        Assert.assertEquals(2,coll.getIndexInfo().size());
    }

    @Test
import com.mongodb.BasicDBObject;
import com.mongodb.DB;
import com.mongodb.DBCollection;
import com.mongodb.DBObject;
import com.redhat.lightblue.mongo.test.EmbeddedMongo;
import com.redhat.lightblue.util.test.AbstractJsonSchemaTest;
public void setup() {
            }
        }

        Assert.assertEquals(count, coll.find().count());
    }

    @After
public void executeOne() {
        Assert.assertNotNull(result);
        Assert.assertNull(result.getError());

        DBCursor cur = coll.find(query, null);

        Assert.assertNotNull(cur);
        Assert.assertEquals(1, cur.size());

        DBObject obj = cur.next();

        Assert.assertNotNull(obj);
        Assert.assertEquals("obj", obj.get("name"));
    }

    @Test
public void executeMany() {
        Assert.assertNotNull(result);
        Assert.assertNull(result.getError());

        DBCursor cur = coll.find(null, null);

        Assert.assertNotNull(cur);
        Assert.assertEquals(3, cur.size());

        // check first object
        DBObject obj = cur.next();

        Assert.assertNotNull(obj);
        Assert.assertEquals("obj1", obj.get("name"));
    }
}
package com.redhat.lightblue.mongo.hystrix;

import com.mongodb.BasicDBObject;
import com.mongodb.DBObject;
import com.mongodb.WriteResult;
import org.junit.Assert;
public void executeWithId() {

    @Test
    public void executeWithoutId() {
        DBObject obj = coll.find(new BasicDBObject(key1, "obj2")).sort(new BasicDBObject("_id", -1)).next();
        Object id = obj.get("_id");

        DBObject save = new BasicDBObject(key1, obj.get(key1));
        save.put("newKey", "key value");

        WriteResult result = new SaveCommand(coll, save).execute();

        Assert.assertNotNull(result);
        Assert.assertNull(result.getError());

        DBObject updated = coll.findOne(new BasicDBObject("newKey", "key value"));

        // verify wrote new object
        Assert.assertNotEquals(id, updated.get("_id"));
        Assert.assertEquals("key value", updated.get("newKey"));
    }
}
public void run() {
    public Statement apply(Statement base, Description description) {
        immsAnnotation = description.getAnnotation(InMemoryMongoServer.class);
        if ((immsAnnotation == null) && description.isTest()) {
            immsAnnotation = description.getTestClass().getAnnotation(InMemoryMongoServer.class);
        }

        return super.apply(base, description);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private SUB_STATE moveToDestination() throws AIException {
    }

    private boolean handlePTS(Hex land) {
        game.startBombardOrPTS(land, true);
        List<Hex> pts_queue = game.getBattle().getPTSQueue();
        System.out.println("PTS queue len = " + pts_queue.size());
        while (!pts_queue.isEmpty() && !Util.getSelectedUnits(game.getSelectedStack()).isEmpty()) {
private boolean handlePTS(Hex land) {
                continue;
            }
            // since we are landing, do not try to bomb landing hex
            game.startBombardOrPTS(pts_hex, false);
            pts_hex.spot(game.getTurn());
            System.out.println("PTS combat (" + pts_hex.getX() + "," + pts_hex.getY() + ") vs (" + land.getX() + "," + land.getY() + ")");
            game.resolveGroundBattleInit(C.PTS_COMBAT, pts_hex.getStack().get(0).owner);
public UnitType(String s, int index, int t_lvl) {
        this.index = index;
        this.t_lvl = t_lvl;
        int stats_end;
        /*
         * accepts alphanum, -, ' and .
         */
        Pattern unit_type = Pattern.compile("\"[0-9a-zA-Z_ ,\\(\\)\\[\\]\\!\\*\\-'\\.\\&]+\"");

        Matcher m = unit_type.matcher(s);

public UnitType(String s, int index, int t_lvl) {
        //skip "stats"
        m.find();
        m.find();

        //last one is a big string of one text and dozens of integer values
        String stats = s.substring(m.start() + 1, m.end() - 1);
        Util.debugPrint("Stats: " + stats);
public static void main(String[] args) {
                            index = Integer.parseInt(s.substring(start + 1, end));
                            Util.debugPrint("index: " + index);
                        } else {
                            Util.logFFErrorAndExit(file_name, line_nr);
                        }
                    }
                }
import java.util.ListIterator;
import java.util.Random;
import java.util.Set;
import util.C;
import util.StackIterator;
import util.Util;
    private static final long serialVersionUID = 1L;
    private List<Unit> combat_stack_a;
    private List<Unit> combat_stack_b;
    private LinkedList<Hex> path;
    private String combat_type;
    private int attacked_faction;
    private Hex ranged_space_target;
    // pts defence fire queue against landing or bombardment
    private List<Hex> pts_queue;

    public Battle() {
        
public void battleInit(Random random, int[][] damage, int[][] target,
    public void perBattleInit(LinkedList<Hex> path, int current_planet) {
        this.path = path;
        this.current_planet = current_planet;
    }

    public List<Unit> getCombatStack(String stack) {
public int getDam(Unit atk, Unit def, int atk_type) {

    /**
     * Handles one round of attacks by an attacker stack against a defender
     * stack.
     *
     * @param attacker the attacking stack
     * @param defender the defending stack
public void doAttack(List<Unit> attacker, List<Unit> defender, int[] damage, int
            return;
        }

        int count = attacker.size(); // > defender.size() ? attacker.size() : defender.size();
//        for (int i = 0; i < count; i++) {
//            damage[i] = 0;
//        }
        ListIterator<Unit> atk_it = attacker.listIterator();
        ListIterator<Unit> def_it = defender.listIterator();
        Unit atk = atk_it.next();
        Unit def = def_it.next();
        int def_indx = 0;
        for (int i = 0; i < count; i++) {

            int to_hit = getAtkAcc(atk_type, atk) - def.type_data.ag;
            if (random.nextInt(20) + to_hit > 9) {
//                damage[def_indx] += getDam(atk, def, atk_type);
                def.health_tmp -= getDam(atk, def, atk_type);
            }
//            if (!atk_it.hasNext()) {
//                atk_it = attacker.listIterator();
//            }
            if (!atk_it.hasNext()) {
                return;
            }
            atk = atk_it.next();
            if (!def_it.hasNext()) {
                def_it = defender.listIterator();
                def_indx = -1;
            }
            def = def_it.next();
            def_indx++;
        }

    }
public void resolveGroundBattleFight() {
        CombatReport report = new CombatReport(combat_stack_a.size(), combat_stack_b.size());
        //record combat report combat preconditions combatReportPre()
        combatReportPre(report);
        spotAllUnits();
        doCombat(combat_stack_a, combat_stack_b);
        assignDamage(combat_stack_a, combat_stack_b);
        //record combat report combat postconditions, send message combatReportPost()
        combatReportPost(report);
public void resolveGroundBattleFinalize() {
                cancelRout(stack_a, stack_b);
                break;
            case C.BOMBARD_COMBAT:
            case C.PTS_COMBAT:
                stack_b = ranged_space_target.getStack();
                cancelRout(stack_a, stack_b);
public void resolveGroundBattleFinalize() {
     */
    public void doCombat(List<Unit> attacker, List<Unit> defender) {

        int[] defender_damage = new int[C.STACK_SIZE];
        List<Unit> defender_defence = new LinkedList<>();
        List<Unit> defender_offence = new LinkedList<>();

        int[] attacker_damage = new int[C.STACK_SIZE];
        List<Unit> attacker_offence = new LinkedList<>();
        List<Unit> attacker_defence = new LinkedList<>();

        int combat_loop_iter = -1;
        int[] combat_phases = null;
public void doCombat(List<Unit> attacker, List<Unit> defender) {

            }
        }

    }

    public String getCombatType() {
public Hex getRangedSpaceTarget() {
     * @param h
     * @param queue_pts
     */
    public void startBombardOrPTS(Hex h, boolean queue_pts) {
        ranged_space_target = h;
        if (!queue_pts) {
            return;
public void startBombardOrPTS(Hex h, boolean queue_pts) {
            if (!stack.isEmpty()) {
                int fac_a = stack.get(0).owner;
                int fac_b = game.getTurn();
                if (fac_a != fac_b && game.getDiplomacy().getDiplomaticState(fac_a, fac_b) == C.DS_WAR) {
                    for (Unit unit : stack) {
                        if (unit.type_data.ranged_sp_str > 0) {
                            pts_queue.add(next);
    private List<Term> terms;
    private boolean resolved;
    private int sender;

    public Contract() {
        terms = new LinkedList<>();
public boolean acceptCheck(Game game) throws AssertionError {
            int recipient = term.getRecipient();
            switch (term.type) {
                case STATE:
                    break;
                case MONEY:
                    if (donor == game.getTurn()
public void acceptDo(Game game) throws AssertionError {
                case MINISTRY:
                    game.getDiplomacy().setMinistryPromise(donor, recipient, term.getAmount());
                    break;
                default:
                    throw new AssertionError();
            }
public void setSender(int sender) {
        this.sender = sender;
    }

//    @Override
//    public String toString() {
//        String s = "";
public void setSender(int sender) {
        MONEY,
        VOTES,
        MINISTRY,
    }

    /**
public Ministry(int ministry) {

    }

//    public static class Resource extends Term {
//        private static final long serialVersionUID = 1L;
//
public Regency getRegency() {
     * @param h
     * @param queue_pts
     */
    public void startBombardOrPTS(Hex h, boolean queue_pts) {
        battle.startBombardOrPTS(h, queue_pts);

    }

public void doResearch() {
        }
    }

    /**
     * Update list of units which can be built in cities.
     *
     *
     */
    private static final long serialVersionUID = 1L;
    // pointer to GUI
    private Gui gui;
    private Game game;
public void drawUnits(Graphics g) {
        int[] skull = Util.loadSquare(FN.S_SKULL_BIN, 0, C.SKULL_SIDE * C.SKULL_SIDE);
        int[] flag = Util.loadSquare(FN.S_FLAG_BIN, 0, C.SKULL_SIDE * C.SKULL_SIDE);
        List<Unit> attacker = game.getCombatStack("a");
        ListIterator<Unit> it = attacker.listIterator();

        BufferedImage bi_att_u = new BufferedImage(ws.unit_icon_size, ws.unit_icon_size, BufferedImage.TYPE_BYTE_INDEXED, Gui.getICM());
public void drawUnits(Graphics g) {
                    break loop_att;
                }
                int color = Util.getOwnerColor(e.owner);

//                System.out.println("color = " + color);
                Util.fillRaster(wr_att_u, color);
                Util.drawUnitIconEdges(wr_att_u, ws);
public void drawUnits(Graphics g) {

        }

        List<Unit> defender = game.getCombatStack("b");
        it = defender.listIterator();

        bi_att = new BufferedImage(ws.combat_window_stack_display_w, ws.combat_window_stack_display_h, BufferedImage.TYPE_BYTE_INDEXED, Gui.getICM());
public void drawUnits(Graphics g) {
                    break loop_def;
                }
                int color = Util.getOwnerColor(e.owner);

//                System.out.println("color = " + color);
                Util.fillRaster(wr_att_u, color);
                Util.drawUnitIconEdges(wr_att_u, ws);

    private static final int MAX_MONEY_DEMAND = 50000;


    public enum IfYouWill {

        PEACE("Sign A Peace Treaty With Us", null, null),
        MONEY("Compensate Us With ", "Firebirds", null),
        VOTES("Give Us all Your votes for the next election", null, null),
        MINISTRY("Give Us ", "If You are Elected", "Ministry");
//        RESOURCES("Compensate Us With ", "Resources"),
//        UNITS("Compensate Us With ", "Units"),
//        CITIES("Compensate Us With ", "Cities");
private IfYouWill(String text, String text2, String text3) {
        PEACE("Sign A Peace Treaty With You", null, null),
        MONEY("Compensate You With ", "Firebirds", null),
        VOTES("Give You all Our votes for the next election", null, null),
        MINISTRY("Give You ", "If We are Elected", "Ministry");
//        RESOURCES("Compensate You With ", "Resources"),
//        UNITS("Compensate You With ", "Units"),
//        CITIES("Compensate You With ", "Cities");
public static DiplomacyWindow getWindow(Gui gui) {
    }

    public void enterWindow(int faction) {
        //System.out.println("enterWindow() start : " + contract);
        if (contract == null) {
            contract = new Contract();
        }
        clear();

        //System.out.println("enterWindow() end : " + contract);
        this.faction = faction;
    }

    public void showIfYouMenu(Point p) {        
public void mouseClicked(MouseEvent e) {
        });
    }

    public void doClick(MouseEvent e) {
        Point p = e.getPoint();
        List<Contract.Term> terms = contract.getTerms();
        if (c.get(G.CDW.GIVE_X) <= p.x && p.x <= c.get(G.CDW.GIVE_X) + c.get(G.CDW.GIVE_W)
                && c.get(G.CDW.GIVE_Y) <= p.y && p.y <= c.get(G.CDW.GIVE_Y) + c.get(G.CDW.GIVE_H)) {
            int term_count = 0;
            for (Contract.Term term : terms) {
                if_you_items[term.getType().ordinal()].setEnabled(false);
                term_count++;
            }
            if (term_count < 3) {
                showIfYouMenu(p);
            }
        } else if (c.get(G.CDW.GIVE_X) <= p.x && p.x <= c.get(G.CDW.GIVE_X) + c.get(G.CDW.GIVE_W)
                && c.get(G.CDW.TAKE_Y) <= p.y && p.y <= c.get(G.CDW.TAKE_Y) + c.get(G.CDW.GIVE_H)) {
            int term_count = 0;
            for (Contract.Term term : terms) {
                then_we_items[term.getType().ordinal()].setEnabled(false);
                term_count++;
            }
            if (term_count < 3) {
                showThenWeMenu(p);
            }
        }
    }

    public void clear() {
        contract.clear();
        for (int i = 0; i < if_you_items.length; i++) {
            if_you_items[i].setEnabled(true);
        }
        for (int i = 0; i < then_we_items.length; i++) {
            then_we_items[i].setEnabled(true);
        }
        if (game.getDiplomacy().getDiplomaticState(game.getTurn(), faction) != C.DS_WAR) {
            if_you_items[IfYouWill.PEACE.ordinal()].setEnabled(false);
            then_we_items[ThenWeWill.PEACE.ordinal()].setEnabled(false);
        }
        non_promised_ministries.clear();
        non_promised_ministries.addAll(all_ministries);

        for (Contract con : game.getDiplomacy().getSentContracts()) {
            for (Term term : con.getTerms()) {
                if (term.getDonor() == game.getTurn()) {
public void clear() {
                        case MINISTRY:
                            non_promised_ministries.remove(new Integer(term.getAmount()));
                            break;

                        default:
                            throw new AssertionError();
                    }
                }
            }
        }
        if (game.getRegency().getVotes()[game.getTurn()][Regency.CANDIDATE_IDX] > -1) {
            then_we_items[ThenWeWill.VOTES.ordinal()].setEnabled(false);
        }

        int[] promises = game.getDiplomacy().getMinistryPromises(game.getTurn());
        for (int i = 0; i < promises.length; i++) {
            if (promises[i] > -1) {
                non_promised_ministries.remove(new Integer(promises[i]));
            }
        }
        if (non_promised_ministries.isEmpty()) {
            then_we_items[ThenWeWill.MINISTRY.ordinal()].setEnabled(false);
        }
    }

public void actionPerformed(ActionEvent e) {
                                
                    }
                    contract.setSender(game.getTurn());
                    Message msg = new Message(null, C.Msg.CONTRACT, game.getYear(), null);
                    msg.setContract(contract);
                    game.getDiplomacy().addSentContract(contract);
private void drawBackground(Graphics g) {
    private void drawDetails(Graphics gg) {
        Graphics2D g = (Graphics2D) gg;
        drawLeader(g);
        drawContract(g, contract, ws, faction);
        drawContractHeaders(g);

    }
private void drawContractHeaders(Graphics2D g) {
        UtilG.drawStringGrad(g, s, ws.font_large, x, +c.get(CDW.GIVE_H_Y) - c.get(CDW.GIVE_Y) + c.get(CDW.TAKE_Y));
    }

    static void drawContract(Graphics2D g, Contract contract, WindowSize ws, int other_party) throws AssertionError {
        Map<Enum, Integer> c = ws.diplomacy_window;
        List<Term> terms = contract.getTerms();
        int count_a = 0;
static void drawContract(Graphics2D g, Contract contract, WindowSize ws, int oth
                    case MINISTRY:
                        s = IfYouWill.MINISTRY.text + Util.getFactionName(term.getAmount()) + " " + IfYouWill.MINISTRY.text2;
                        break;

                    default:
                        throw new AssertionError();
                }
static void drawContract(Graphics2D g, Contract contract, WindowSize ws, int oth
                    case MINISTRY:
                        s = ThenWeWill.MINISTRY.text + Util.getFactionName(term.getAmount()) + " " + ThenWeWill.MINISTRY.text2;
                        break;
                    default:
                        throw new AssertionError();
                }
private void selectIfYou(int selection) {
        switch (IfYouWill.values()[selection]) {
            case PEACE:
                term = new Contract.DiplomaticState(C.DS_PEACE);
                break;
            case MONEY:
                detail_dialog.showDialog(MAX_MONEY_DEMAND);
                int value = detail_dialog.getValue();
                if (value > 0) {
                    term = new Contract.Money(value);
                }
                //System.out.println("I'll forward you to alcoholics anonymous ...");
                break;
            case VOTES:
private void selectIfYou(int selection) {
            case MINISTRY:
                term = new Contract.Ministry(selectMinistry(false));
                break;
//            case RESOURCES:
//                System.out.println("A Hawkwood, a Hazat and a Decados went to a bar ...");
//                break;
private void selectIfYou(int selection) {
        }
    }

    private int selectMinistry(boolean donor) {
        int promised_ministry = -1;
        List<Integer> ministry_list = new LinkedList<>();
        if (donor) {
            ministry_list.addAll(non_promised_ministries);
        } else {
            ministry_list.addAll(all_ministries);
        }
//        ministry_list.add(C.FLEET);
//        ministry_list.add(C.THE_SPY);
//        ministry_list.add(C.STIGMATA);
private void selectThenWe(int selection) {
            case MINISTRY:
                term = new Contract.Ministry(selectMinistry(true));
                break;
//            case RESOURCES:
//                System.out.println("A Hawkwood, a Hazat and a Decados went to a bar ...");
//                break;
public void actionPerformed(ActionEvent e) {

        menu_build_road.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {

                showInfoWindow("Not implemented yet.");
            }
        });

public void hideTechWindow() {
    }

    public void showTechWindow() {
        tech_panel.setTechData();
        tech_panel.setLabsCost();
        tech_panel.setRPAvailable();
        tech_panel.setLabResearches();
public void enableBuildCityMenuItem(boolean enabled) {
        menu_build_city.setEnabled(enabled);
    }

    public void enableRazeCityMenuItem(boolean enabled) {
        menu_raze_city.setEnabled(enabled);
    }
public static ResolveContract getWindow(Gui gui) {
    public void enterDialog(Message msg) {
        message = msg;
        contract = message.getContract();
        if (message.getContract().isResolved()) {

        }
        dialog.setVisible(true);
    }
public void actionPerformed(ActionEvent e) {
                    gui.showInfoWindow("My Lord, we cannot satisfy all the terms of the Contract!");
                    return;
                }
                game.getFaction(contract.getSender()).addMessage(new Message(""
                        + Util.factionNameDisplay(game.getTurn())
                        + " sent Us the following message: \"We accept Your offer.\"", C.Msg.RESPONSE, game.getYear(), null));
                self.setWindowVisiblity(false);
            }
        });
public void actionPerformed(ActionEvent e) {
            @Override
            public void actionPerformed(ActionEvent e) {
                contract.reject();
                game.getFaction(contract.getSender()).addMessage(new Message(""
                        + Util.factionNameDisplay(game.getTurn())
                        + " sent Us the following message: \"We reject Your offer.\"", C.Msg.RESPONSE, game.getYear(), null));
                self.setWindowVisiblity(false);
            }
        });
public void actionPerformed(ActionEvent e) {
    private void renderWindow(Graphics g) {
        drawBackground(g);
        drawDetails(g);
    }

    private void drawDetails(Graphics gg) {
        Graphics2D g = (Graphics2D) gg;
        drawContractHeaders(g);
        DiplomacyWindow.drawContract(g, message.getContract(), ws, game.getTurn());
        drawLeader(g);
    }

    private void drawBackground(Graphics g) {
private void drawContractHeaders(Graphics2D g) {
    }

    private void drawLeader(Graphics2D g) {
        String s = Util.factionNameDisplay(contract.getSender());
        int x = UtilG.center(g, c2.get(G.CH.LEADER_H_X), c2.get(G.CH.LEADER_H_W), ws.font_large, s);
        UtilG.drawStringGrad(g, s, ws.font_large, x, c2.get(G.CH.LEADER_H_Y));
    }
}
    // number of labs, set in setLabsCost()
    private int nr_labs;

    private JButton tech_db;
    private JButton exit;
    private JButton archive;
public void setUpExitButton() {
        exit.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {

                gui.hideTechWindow();
            }
        });
    }

    public void setUpArchiveButton() {
        archive = new JButton("Archive");
        archive.setFont(ws.font_default);
public void actionPerformed(ActionEvent e) {
        });
    }

    public void addTechInfo() {
        tech_info = new JTextArea();
        tech_info.setFont(ws.font_default);
public void mousePressed(MouseEvent e) {

                }
                if (e.getClickCount() == 2) {

                    // if category allready reseached && != "nothing"
                    int cost = ((Integer) tech_table.getValueAt(row, 1)).intValue();
                    if (cost == -1 && row != 0) {
                        return;
                    }

                    // set researched technology && do research
                    int tech_no = ((Integer) tech_table.getValueAt(row, 0)).intValue();
                    game.setResearch(tech_no);
                    game.getFaction(game.getTurn()).getResearch().doResearch();
                    setTechData();
                    setRPAvailable();
                    if (row != 0 && game.getFaction(game.getTurn()).getResearch().techs[tech_no]) {
                        tech_table.setRowSelectionInterval(0, 0);
public void mousePressed(MouseEvent e) {
        });
    }

    public void setTechData() {
        tech_info.setText("");
        Research research = game.getFaction(game.getTurn()).getResearch();
        boolean[] owned_tech = research.techs;
        int researched = research.researched;
        Tech[] techs = game.getGameResources().getTech();
public void setTechData() {
            if (techs[i].stats[C.TECH0] >= 800) {
                continue;
            }
            if (!owned_tech[i] && owned_tech[techs[i].stats[C.TECH0]]
                    && owned_tech[techs[i].stats[C.TECH1]]
                    && owned_tech[techs[i].stats[C.TECH2]]) {
//                category_lists.get(techs[i].stats[C.TECH_VOL] - 1).add(new Integer(i));
                category_lists.get(cat_nr).add(new Integer(i));
            }
        }
public Component getTableCellRendererComponent(
                int row, int column) {
            Color c_b = Color.BLACK;
            Color c_f = C.COLOR_GOLD;
            if (row != 0 && ((Integer) table.getValueAt(row, 1)).intValue() == -1) {
                c_f = Color.BLUE;
            }
            if (game.getFaction(game.getTurn()).getResearch().researched
private void setAttkStat(int field_no, String type, int acc, int str) {
                    attack4_stat.setText("" + acc + "/" + str);
                    break;
                default:
                    throw new AssertionError("Unit with over 4 attack types", null);
            }
        }

public void clickOnPlanetMapButton1(Point p) {
        game.getDiplomacy().setDiplomaticState(faction.x, target_stack.get(0).owner, C.DS_WAR);
        game.subMovePointsSpace(selected);
        target_hex.spot(faction.x);
        game.startBombardOrPTS(target_hex, true);
        game.resolveGroundBattleInit(C.BOMBARD_COMBAT, target_stack.get(0).owner);
        gui.setMouseCursor(C.S_CURSOR_SCEPTOR);
        SU.showCombatWindowBombard();
public void pressBombardAgainButton() {
        Hex target = game.getBattle().getRangedSpaceTarget();
        game.resolveGroundBattleFinalize();
        gui.getCombatWindow().setFightText("Do Combat");
        gui.getCombatWindow().toggleButtons(false, true, false);       
        game.startBombardOrPTS(target, true);
        game.resolveGroundBattleInit(C.BOMBARD_COMBAT, game.getBattle().getRangedSpaceTarget().getStack().get(0).owner);
        gui.setCurrentState(CWB1.get());
        game.subMovePointsSpace(game.getCombatStack("a"));
        SU.showCombatWindowBombard();
static void pressFightButtonProcess() {
        if (!Util.getSelectedUnits(game.getSelectedStack()).isEmpty() && !pts_queue.isEmpty()) {
            Hex pts_hex = pts_queue.remove(0);
            pts_hex.spot(game.getTurn());
            game.startBombardOrPTS(pts_hex, false);
            game.resolveGroundBattleInit(C.PTS_COMBAT, pts_hex.getStack().get(0).owner);
            SU.showCombatWindowPTS();
            return;
public void clickOnPlanetMapButton1(Point p) {
            gui.showInfoWindow("Cannot land on ruins.");
            return;
        }
        if (!target_stack.isEmpty() && target_stack.get(0).owner == faction.x && target_stack.get(0).owner != faction.y) {
            gui.showInfoWindow("Cannot merge loaned stacks.");
            return;
        }
public void clickOnPlanetMapButton1(Point p) {
                
        // start PTS defence fire if any
        if (SU.byzIICombatOK(stack, false)) {
            game.startBombardOrPTS(target_hex, true);
            List<Hex> pts_queue = game.getBattle().getPTSQueue();
            if (!pts_queue.isEmpty()) {
                // save state so we can land in state.CWPTS2 after PTS
                saveMainGameState();
                landing_point = p;
                Hex pts_hex = pts_queue.remove(0);
                // since we are landing, do not try to bomb landing hex
                game.startBombardOrPTS(pts_hex, false);
                pts_hex.spot(game.getTurn());
                game.resolveGroundBattleInit(C.PTS_COMBAT, pts_hex.getStack().get(0).owner);
                gui.setMouseCursor(C.S_CURSOR_SCEPTOR);
public void clickOnWindow(MouseEvent e) {
//                        current_cmbt_report = report;
                        SU.showCombatReplay();
                        break;
                    case CONTRACT:
                        gui.showResolveContractDialog(msg);
                        break;
 */
package state;

import java.awt.Point;
import java.awt.event.MouseEvent;
import static state.SU.setWindow;
public void clickOnPlanetWindow(MouseEvent e) {
        }

    }
}
public static void setStateUpKeep(State s) {
            List<Unit> stack = game.getSelectedStack();
            boolean have_engineer = false;
            boolean have_city = false;
            if (stack != null && !stack.isEmpty()) {
                for (Unit unit1 : Util.xS(stack)) {
                    if (unit1.type == C.ENGINEER_UNIT_TYPE && unit1.selected && !unit1.in_space) {
public static void setStateUpKeep(State s) {
                if (hex.getStructure() != null) {
                    have_city = true;
                }
            }
            gui.enableBuildCityMenuItem(have_engineer);
            gui.enableRazeCityMenuItem(have_engineer && have_city);
        } else {
            gui.enableBuildCityMenuItem(false);
            gui.enableRazeCityMenuItem(false);
        }
    }

public void pressUnloadButton() {

    public void razeCity() {
    }
}
public void pressUnloadButton() {
                    if ((faction.x != -1 && !(c.move_type == C.MoveType.JUMP
                            || c.move_type == C.MoveType.LANDER
                            || c.move_type == C.MoveType.SPACE))
                            || (terrain[C.OCEAN] == true && tile_set != 4)) {
                        continue;
                    }
                    tmp.add(c);
    public static final float LOYALTY_REBEL_HIGH_P = 0.98f;
    public static final String OPT_ENABLE_AI = "enableai";
    public static final String OPT_AI_TEST = "ai_test";




        R_ACCEPT_Y,
        R_ACCEPT_W,
        R_ACCEPT_H,
        R_BUTTON_W, R_WIN_Y, R_WIN_H,
    }

    /**
private void iDiplomacyWindow(boolean is_double) {
        diplomacy_window.put(CDW.R_ACCEPT_W, 95);
        diplomacy_window.put(CDW.R_ACCEPT_H, 16);
        diplomacy_window.put(CDW.R_BUTTON_W, 123);

        if (is_double) {
            diplomacy_window.replaceAll(mul2);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void setGesture(final Gesture gesture) {

    @Override
    public boolean equals(final Object obj) {
        if(obj==null || !obj.getClass().equals(Player.class)) {
            return false;
        }
        Player player = (Player) obj;
public void setResultingAction(final String resultingAction) {

    @Override
    public boolean equals(final Object obj) {
        if (Gesture.class.equals(obj.getClass())) {
            Gesture winningCombinationGesture = (Gesture) obj;
            return winningGesture.getName().equals(
                    winningCombinationGesture.getName());
        }
        return false;
    }

    @Override
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
protected String doExecute(HttpServletRequest request,
			request.setAttribute("messageNumber", MessageNumber.USER_ID_ERROR.getId());
			return PAGES.MESSAGE_PAGE.getValue();
		}
		String pass = request.getParameter("pass");
		String confPass = request.getParameter("confpass");
		if (pass.equals("")) {
			request.setAttribute("error", "Password can not be empty");
			request.setAttribute("userId", userId);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



package tundra;

// -----( IS Java Code Template v1.2
// -----( CREATED: 2014-06-11 16:05:34.466
// -----( ON-HOST: -

import com.wm.data.*;
import com.wm.util.Values;
public static final void benchmark (IData pipeline)
		// [o] field:0:required $duration.stdev
		// [o] field:0:required $message
		IDataCursor cursor = pipeline.getCursor();

		try {
		  String service = IDataUtil.getString(cursor, "$service");
		  IData scope = IDataUtil.getIData(cursor, "$pipeline");
		  int count = Integer.parseInt(IDataUtil.getString(cursor, "$count"));

		  IncrementalNormalDistributionEstimator estimator = benchmark(service, scope == null? pipeline : scope, count);

		  IDataUtil.put(cursor, "$duration.average", tundra.duration.format("" + estimator.mean(), "milliseconds", "xml"));
		  IDataUtil.put(cursor, "$duration.stdev", tundra.duration.format("" + estimator.standardDeviation(), "milliseconds", "xml"));
		  IDataUtil.put(cursor, "$message", service + " benchmark results: " + estimator.toString());
public static final void benchmark (IData pipeline)
		}
		// --- <<IS-END>> ---


	}


public static final void callstack (IData pipeline)
		// [o] field:0:required $callers
		// [o] field:0:required $caller
		IDataCursor cursor = pipeline.getCursor();

		try {
		  String[] stack = callstack();
		  String callers = tundra.list.object.join(stack, " \u2192 ");
public static final void callstack (IData pipeline)
		}
		// --- <<IS-END>> ---


	}


public static final void ensure (IData pipeline)
		// [i] record:0:optional $pipeline
		// [o] record:0:optional $pipeline
		IDataCursor cursor = pipeline.getCursor();

		try {
		  String $service = IDataUtil.getString(cursor, "$service");
		  String $catch = IDataUtil.getString(cursor, "$catch");
		  String $finally = IDataUtil.getString(cursor, "$finally");
		  IData scope = IDataUtil.getIData(cursor, "$pipeline");
		  boolean scoped = scope != null;

		  scope = ensure($service, scoped ? scope : pipeline, $catch, $finally);

		  if (scoped) IDataUtil.put(cursor, "$pipeline", scope);
		} finally {
		  cursor.destroy();
		}
		// --- <<IS-END>> ---


	}


public static final void initiator (IData pipeline)
		// @sigtype java 3.5
		// [o] field:0:required $initiator?
		IDataCursor cursor = pipeline.getCursor();

		try {
		  IDataUtil.put(cursor, "$initiator?", "" + initiator());
		} finally {
		  cursor.destroy();
		}
		// --- <<IS-END>> ---


	}


public static final void invoke (IData pipeline)
		// [o] record:0:optional $pipeline
		// [o] object:0:optional $thread
		IDataCursor cursor = pipeline.getCursor();

		try {
		  String service = IDataUtil.getString(cursor, "$service");
		  IData scope = IDataUtil.getIData(cursor, "$pipeline");
		  String mode = IDataUtil.getString(cursor, "$mode");

		  if (mode == null) mode = "synchronous";
		  boolean scoped = scope != null;

		  Object value = invoke(service, scoped ? scope : pipeline, mode);
		  String key = mode.equals("asynchronous")? "$thread" : "$pipeline";

		  if (scoped || mode.equals("asynchronous")) {
		    IDataUtil.put(cursor, key, value);
		  }
public static final void invoke (IData pipeline)
		}
		// --- <<IS-END>> ---


	}


public static final void join (IData pipeline)
		// [i] object:0:optional $thread
		// [o] record:0:optional $pipeline
		IDataCursor cursor = pipeline.getCursor();

		try {
		  com.wm.app.b2b.server.ServiceThread thread = (com.wm.app.b2b.server.ServiceThread)IDataUtil.get(cursor, "$thread");

		  if (thread != null) IDataUtil.put(cursor, "$pipeline", join(thread));
		} finally {
		  cursor.destroy();
		}
		// --- <<IS-END>> ---


	}


public static final void nothing (IData pipeline)
		// @sigtype java 3.5
		// --- <<IS-END>> ---


	}


public static final void respond (IData pipeline)
		// [i] field:0:optional $content.type
		// [i] field:0:optional $encoding
		IDataCursor cursor = pipeline.getCursor();

		try {
		  int code = Integer.parseInt(IDataUtil.getString(cursor, "$code"));
		  String message = IDataUtil.getString(cursor, "$message");
		  IData headers = IDataUtil.getIData(cursor, "$headers");
		  Object content = IDataUtil.get(cursor, "$content");
		  String contentType = IDataUtil.getString(cursor, "$content.type");
		  String encoding = IDataUtil.getString(cursor, "$encoding");

		  respond(code, message, headers, content, contentType, encoding);
		} finally {
		  cursor.destroy();
		}
		// --- <<IS-END>> ---


	}


public static final void self (IData pipeline)
		// @sigtype java 3.5
		// [o] field:0:optional $self
		IDataCursor cursor = pipeline.getCursor();

		try {
		  IDataUtil.put(cursor, "$self", self());
		} finally {
		  cursor.destroy();
		}
		// --- <<IS-END>> ---


	}


public static final void sleep (IData pipeline)
		// @sigtype java 3.5
		// [i] field:0:required $duration
		IDataCursor cursor = pipeline.getCursor();

		try {
		  String duration = IDataUtil.getString(cursor, "$duration");
		  sleep(duration);
public static final void sleep (IData pipeline)
		}
		// --- <<IS-END>> ---


	}


public static final void validate (IData pipeline)
		// [i] field:0:optional $raise? {&quot;false&quot;,&quot;true&quot;}
		// [o] field:0:required $valid?
		IDataCursor cursor = pipeline.getCursor();

		try {
		  String service = IDataUtil.getString(cursor, "$service");
		  boolean raise = tundra.bool.parse(IDataUtil.getString(cursor, "$raise?"));
public static final void validate (IData pipeline)
		}
		// --- <<IS-END>> ---


	}

	// --- <<IS-START-SHARED>> ---
	// sets the response headers and body for the current service invocation
	public static void respond(int code, String message, IData headers, Object content, String contentType, String encoding) throws ServiceException {
	  try {
	    com.wm.net.HttpHeader response = com.wm.app.b2b.server.Service.getHttpResponseHeader();

	    if (response == null) {
	      // not invoked via HTTP, so throw an exception instead for HTTP statuses >= 400
	      if (code >= 400) tundra.exception.raise(tundra.string.normalize(content, encoding));
	    } else {
	      if (message == null) message = tundra.support.http.status(code);
	      response.setResponse(code, message);

	      if (contentType == null) contentType = "application/octet-stream";
	      if (encoding == null) encoding = tundra.support.constant.DEFAULT_CHARACTER_ENCODING;

	      javax.activation.MimeType mimeType = new javax.activation.MimeType(contentType);
	      mimeType.setParameter("charset", encoding);

	      response.clearField("Content-Type");
	      response.addField("Content-Type", mimeType.toString());

	      if (headers != null) {
	        IDataCursor hc = headers.getCursor();

	        while(hc.next()) {
	          String key = hc.getKey();
	          Object value = hc.getValue();

	          if (key != null && value != null) {
	            response.clearField(key);
	            response.addField(key, value.toString());
public static void respond(int code, String message, IData headers, Object conte
	        hc.destroy();
	      }
	    }

	    if (content == null) content = "";
	    byte[] body = tundra.bytes.normalize(content, encoding);
	    com.wm.app.b2b.server.Service.setResponse(body);
public static void respond(int code, String message, IData headers, Object conte
	    tundra.exception.raise(ex);
	  }
	}

	// returns true if the calling service is the top-level initiating
	// service of the current thread
	public static boolean initiator() {
	  return callstack().length <= 1;
	}

	// returns true if the given string is a service and exists
	public static boolean validate(String service) throws ServiceException {
	  return validate(service, false);
	}

	// returns true if the given string is a service and exists
	public static boolean validate(String service, boolean raise) throws ServiceException {
	  boolean valid = tundra.node.exists(service) && "service".equals(tundra.node.type(service));

	  if (raise && !valid) throw new ServiceException("Service does not exist: " + service);

	  return valid;
	}

	// returns the invocation call stack
	public static String[] callstack() {
	  java.util.Iterator stack = com.wm.app.b2b.server.InvokeState.getCurrentState().getCallStack().iterator();
public static boolean validate(String service, boolean raise) throws ServiceExce
	  if (services.size() > 0) services.remove(services.size() - 1);
	  return (String[])services.toArray(new String[services.size()]);
	}

	// returns the name of the current service
	public static String self() {
	  String self = null;
	  String[] callstack = callstack();
	  if (callstack.length > 0) self = tundra.list.object.get(callstack, -1); // last element in list
	  return self;
	}

	// invokes the given service synchronously
	public static IData invoke(String service, IData pipeline) throws ServiceException {
	  return (IData)invoke(service, pipeline, "synchronous");
	}

	// invokes the given service either synchronously or asynchronously
	public static Object invoke(String service, IData pipeline, String mode) throws ServiceException {
	  Object result = null;
	  if (mode.equals("synchronous")) {
	    result = invoke.synchronous(service, pipeline);
public static Object invoke(String service, IData pipeline, String mode) throws
	  }
	  return result;
	}

	public static class invoke {
	  // invokes a service asynchronously
	  public static com.wm.app.b2b.server.ServiceThread asynchronous(String service, IData pipeline) {
	    if (pipeline == null) pipeline = IDataFactory.create();
	    if (service == null) return null;

	    IData scope = IDataUtil.clone(pipeline);
	    com.wm.lang.ns.NSName name = com.wm.lang.ns.NSName.create(service);
	    com.wm.app.b2b.server.ServiceThread thread = com.wm.app.b2b.server.Service.doThreadInvoke(name, scope);

	    return thread;
	  }

	  // invokes a service synchronously
	  public static IData synchronous(String service, IData pipeline) throws ServiceException {
	    if (pipeline == null) pipeline = IDataFactory.create();
	    if (service == null) return pipeline;

	    IData scope = IDataUtil.clone(pipeline);
	    com.wm.lang.ns.NSName name = com.wm.lang.ns.NSName.create(service);

	    try {
	      scope = com.wm.app.b2b.server.Service.doInvoke(name, scope);
	    } catch (Exception ex) {
	      tundra.exception.raise(ex);
	    }

	    IDataUtil.merge(scope, pipeline);

	    return pipeline;
	  }
	}

	// waits for an asynchronously invoked service to complete
	public static IData join(com.wm.app.b2b.server.ServiceThread thread) throws ServiceException {
	  IData pipeline = IDataFactory.create();

	  if (thread != null) {
	    try {
	      pipeline = thread.getIData();
	    } catch (Exception ex) {
	      tundra.exception.raise(ex);
	    }
	  }

	  return pipeline;
	}

	// sleeps the current thread for the given duration
	public static void sleep(String duration) throws ServiceException {
	  sleep(tundra.duration.parse(duration).getTimeInMillis(new java.util.Date()));
	}

	// sleeps the current thread for the given duration
	public static void sleep(long milliseconds) throws ServiceException {
	  try {
public static void sleep(long milliseconds) throws ServiceException {
	    tundra.exception.raise(ex);
	  }
	}

	// provides a try/catch/finally pattern for flow services
	public static IData ensure(String service, IData pipeline, String catchService, String finallyService) throws ServiceException {
	  try {
public static IData ensure(String service, IData pipeline, String catchService,
	    IDataUtil.put(cursor, "$exception.message", t.getMessage());
	    IDataUtil.put(cursor, "$exception.stack", tundra.exception.stack(t));
	    cursor.destroy();

	    if (catchService == null) {
	      tundra.exception.raise(t);
	    } else {
public static IData ensure(String service, IData pipeline, String catchService,
	  } finally {
	    if (finallyService != null) pipeline = invoke(finallyService, pipeline);
	  }

	  return pipeline;
	}

	// invokes the given service a given number of times, and returns execution duration statistics
	public static IncrementalNormalDistributionEstimator benchmark(String service, IData pipeline, int count) throws ServiceException {
	  IncrementalNormalDistributionEstimator estimator = new IncrementalNormalDistributionEstimator("ms");

	  validate(service, true);

	  try {
	    for (int i = 0; i < count; i++) {
	      long start = System.currentTimeMillis();
	      tundra.service.invoke.synchronous(service, pipeline);
	      long end = System.currentTimeMillis();

	      estimator.append(end - start);
	    }
	  } catch (ServiceException ex) {
	    // ignore exceptions
	  }

	  return estimator;
	}

	// Class for incrementally calculating the mean and standard deviation
	public static class IncrementalNormalDistributionEstimator {

	  protected long count;
	  protected double mean, sq;
	  protected String unit = "";

	  /**
	   * Constructs a new estimator object.
	   */
	  public IncrementalNormalDistributionEstimator() {
	    reset();
	  }

	  /**
	   * Constructs a new estimator object.
	   * @param unit The unit of measurement related to the measured samples.
	   */
	  public IncrementalNormalDistributionEstimator(String unit) {
	    this();
	    this.unit = unit;
	  }

	  /**
	   * Constructs a new estimator object seeded with the given samples.
	   *
public IncrementalNormalDistributionEstimator(double... samples) {
	    this();
	    append(samples);
	  }

	  /**
	   * Constructs a new estimator object seeded with the given samples.
	   *
public IncrementalNormalDistributionEstimator(String unit, double... samples) {
	    this(unit);
	    append(samples);
	  }

	  /**
	   * Constructs a new estimator object seeded with the given collection of
	   * samples.
public IncrementalNormalDistributionEstimator(java.util.Collection<Double> sampl
	    this();
	    append(samples);
	  }

	  /**
	   * Constructs a new estimator object seeded with the given collection of
	   * samples.
public IncrementalNormalDistributionEstimator(String unit, java.util.Collection<
	    this(unit);
	    append(samples);
	  }

	  /**
	   * Appends the given sample to the list of samples in the estimator.
	   *
public final IncrementalNormalDistributionEstimator append(double sample) {
	    double next = mean + (sample - mean) / ++count;
	    sq += (sample - mean) * (sample - next);
	    mean = next;

	    return this;
	  }

	  /**
	   * Adds one or more samples to the estimator.
	   *
public final IncrementalNormalDistributionEstimator append(double... samples) {
	    for (double sample : samples) {
	      append(sample);
	    }

	    return this;
	  }

	  /**
	   * Adds a collection of samples to the estimator.
	   *
public final IncrementalNormalDistributionEstimator append(java.util.Collection<
	    for (double sample : samples) {
	      append(sample);
	    }

	    return this;
	  }

	  /**
	   * Returns the number of samples seen by this estimator.
	   *
public final IncrementalNormalDistributionEstimator append(java.util.Collection<
	  public long count() {
	    return count;
	  }

	  /**
	   * Returns the mean of the samples.
	   *
public long count() {
	  public double mean() {
	    return mean;
	  }

	  /**
	   * Returns the maximum likelihood estimate of the variance of the samples.
	   *
	   * @return Maximum likelihood variance estimate.
	   */
	  public double variance() {
	    return count > 1 ? sq / mean : 0.0;
	  }

	  /**
	   * Returns the maximum likelihood estimate of the standard deviation of the
	   * samples.
public double variance() {
	  public double standardDeviation() {
	    return Math.sqrt(variance());
	  }

	  /**
	   * Returns the unit of measure related to the measured samples.
	   *
public double standardDeviation() {
	  public String unit() {
	    return unit;
	  }

	  /**
	   * Resets the estimator back to zero samples.
	   *
public final IncrementalNormalDistributionEstimator reset() {
	    count = 0;
	    mean = 0.0;
	    sq = 0.0;

	    return this;
	  }

	  /**
	   * Returns a string-based representation of the mean, standard deviation and
	   * number of samples for this estimator.
  <record name="svc_sig" javaclass="com.wm.util.Values">
    <record name="sig_in" javaclass="com.wm.util.Values">
      <value name="node_type">record</value>
      <value name="field_type">record</value>
      <value name="field_dim">0</value>
      <value name="nillable">true</value>
            <value name="field_largerEditor">false</value>
            <value name="field_password">false</value>
          </record>
          <value name="field_name">$service</value>
          <value name="field_type">string</value>
          <value name="field_dim">0</value>
            <value name="field_largerEditor">false</value>
            <value name="field_password">false</value>
          </record>
          <value name="field_name">$pipeline</value>
          <value name="field_type">record</value>
          <value name="field_dim">0</value>
          <value name="is_global">false</value>
          <array name="rec_fields" type="record" depth="1">
          </array>
        </record>
        <record javaclass="com.wm.util.Values">
          <value name="node_type">record</value>
            <value name="field_largerEditor">false</value>
            <value name="field_password">false</value>
          </record>
          <value name="field_name">$count</value>
          <value name="field_type">string</value>
          <value name="field_dim">0</value>
          <value name="is_global">false</value>
        </record>
      </array>
    </record>
    <record name="sig_out" javaclass="com.wm.util.Values">
      <value name="node_type">record</value>
      <value name="field_type">record</value>
      <value name="field_dim">0</value>
      <value name="nillable">true</value>
            <value name="field_largerEditor">false</value>
            <value name="field_password">false</value>
          </record>
          <value name="field_name">$duration.average</value>
          <value name="field_type">string</value>
          <value name="field_dim">0</value>
            <value name="field_largerEditor">false</value>
            <value name="field_password">false</value>
          </record>
          <value name="field_name">$duration.stdev</value>
          <value name="field_type">string</value>
          <value name="field_dim">0</value>
            <value name="field_largerEditor">false</value>
            <value name="field_password">false</value>
          </record>
          <value name="field_name">$message</value>
          <value name="field_type">string</value>
          <value name="field_dim">0</value>
          <value name="is_global">false</value>
        </record>
      </array>
    </record>
  </record>
  <value name="node_comment">Benchmarks the performance of the given service by invoking it the given 
durations.
  <value name="prefetch">no</value>
  <value name="cache_ttl">15</value>
  <value name="prefetch_level">1</value>
  <value name="audit_level">off</value>
  <value name="check_internal_acls">no</value>
  <value name="icontext_policy">$null</value>
durations.
  <value name="svc_in_validator_options">default</value>
  <value name="svc_out_validator_options">default</value>
  <value name="auditoption">0</value>
  <record name="auditsettings" javaclass="com.wm.util.Values">
    <value name="document_data">0</value>
    <value name="startExecution">false</value>
    <value name="stopExecution">false</value>
    <value name="onError">true</value>
  </record>
</Values>
CiAgcHVibGljIGRvdWJsZSBtZWFuKCkgewogICAgcmV0dXJuIG1lYW47CiAgfQoKICAvKioKICAg
KiBSZXR1cm5zIHRoZSBtYXhpbXVtIGxpa2VsaWhvb2QgZXN0aW1hdGUgb2YgdGhlIHZhcmlhbmNl
IG9mIHRoZSBzYW1wbGVzLgogICAqCiAgICogQHJldHVybiBNYXhpbXVtIGxpa2VsaWhvb2QgdmFy
aWFuY2UgZXN0aW1hdGUuCiAgICovCiAgcHVibGljIGRvdWJsZSB2YXJpYW5jZSgpIHsKICAgIHJl
dHVybiBjb3VudCA+IDEgPyBzcSAvIG1lYW4gOiAwLjA7CiAgfQoKICAvKioKICAgKiBSZXR1cm5z
IHRoZSBtYXhpbXVtIGxpa2VsaWhvb2QgZXN0aW1hdGUgb2YgdGhlIHN0YW5kYXJkIGRldmlhdGlv
biBvZiB0aGUKICAgKiBzYW1wbGVzLgogICAqCiAgICogQHJldHVybiBNYXhpbXVtIGxpa2VsaWhv
b2Qgc3RhbmRhcmQgZGV2aWF0aW9uIGVzdGltYXRlLgogICAqLwogIHB1YmxpYyBkb3VibGUgc3Rh
bmRhcmREZXZpYXRpb24oKSB7CiAgICByZXR1cm4gTWF0aC5zcXJ0KHZhcmlhbmNlKCkpOwogIH0K
CiAgLyoqCiAgICogUmV0dXJucyB0aGUgdW5pdCBvZiBtZWFzdXJlIHJlbGF0ZWQgdG8gdGhlIG1l
YXN1cmVkIHNhbXBsZXMuCiAgICoKICAgKiBAcmV0dXJuIE1heGltdW0gbGlrZWxpaG9vZCBzdGFu
ZGFyZCBkZXZpYXRpb24gZXN0aW1hdGUuCiAgICovCiAgcHVibGljIFN0cmluZyB1bml0KCkgewog
ICAgcmV0dXJuIHVuaXQ7CiAgfQoKICAvKioKICAgKiBSZXNldHMgdGhlIGVzdGltYXRvciBiYWNr
IHRvIHplcm8gc2FtcGxlcy4KICAgKgogICAqIEByZXR1cm4gVGhlIEVzdGltYXRvciBvYmplY3Qg
aXRzZWxmLCB0byBzdXBwb3J0IG1ldGhvZCBjaGFpbmluZy4KICAgKi8KICBwdWJsaWMgZmluYWwg
SW5jcmVtZW50YWxOb3JtYWxEaXN0cmlidXRpb25Fc3RpbWF0b3IgcmVzZXQoKSB7CiAgICBjb3Vu
dCA9IDA7CiAgICBtZWFuID0gMC4wOwogICAgc3EgPSAwLjA7CgogICAgcmV0dXJuIHRoaXM7CiAg
fQoKICAvKioKICAgKiBSZXR1cm5zIGEgc3RyaW5nLWJhc2VkIHJlcHJlc2VudGF0aW9uIG9mIHRo
ZSBtZWFuLCBzdGFuZGFyZCBkZXZpYXRpb24gYW5kCiAgICogbnVtYmVyIG9mIHNhbXBsZXMgZm9y
IHRoaXMgZXN0aW1hdG9yLgogICAqCiAgICogQHJldHVybiBTdHJpbmctYmFzZWQgcmVwcmVzZW50
YXRpb24gb2YgdGhpcyBlc3RpbWF0b3IuCiAgICovCiAgQE92ZXJyaWRlCiAgcHVibGljIFN0cmlu
ZyB0b1N0cmluZygpIHsKICAgIHJldHVybiBTdHJpbmcuZm9ybWF0KCLOvCA9ICUuM2YgJXMsIM+D
ID0gJS4zZiAlcywgbiA9ICVkIiwgbWVhbigpLCB1bml0KCksIHN0YW5kYXJkRGV2aWF0aW9uKCks
IHVuaXQoKSwgY291bnQoKSk7CiAgfQp9</value>
  <value name="extends"></value>
  <array name="implements" type="value" depth="1">
  </array>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import android.os.Build;
import android.os.Bundle;
import android.support.v4.app.FragmentActivity;
import android.util.Log;
import android.view.View;
import android.widget.EditText;
import android.widget.ProgressBar;
import com.google.api.client.googleapis.extensions.android.gms.auth.GoogleAccountCredential;
import com.google.api.client.json.jackson2.JacksonFactory;
import comp3111h.anytaxi.customer.LocationUtils.ErrorDialogFragment;

public class RequestActivity extends FragmentActivity implements
LocationListener,
GooglePlayServicesClient.ConnectionCallbacks,
GooglePlayServicesClient.OnConnectionFailedListener{

	/*CUURENT LOCATION INFO VAR START*/
	// A request to connect to Location Services
public void getLocation() {
		}
	}    

	public void Request(View view){

		String des = ((EditText)findViewById(R.id.editText3)).getText().toString();

		showDialog("This will send to sever "+mLocationClient.getLastLocation().toString()+" "+des);




		/* 
		Driver d = new Driver();
		d.setLicense("mylicense");
		GeoPt p = new GeoPt();
public void stopUpdates(View v) {
	public void onConnected(Bundle bundle) {
		mConnectionStatus.setText(R.string.connected);


		startPeriodicUpdates();
		getAddress();
		Location currentLoc = mLocationClient.getLastLocation();
		LatLng locationNew = new LatLng(currentLoc.getLatitude(),currentLoc.getLongitude());
		CameraUpdate cameraup=CameraUpdateFactory.newLatLngZoom(locationNew,15);
		LocationUtils.mMap.animateCamera(cameraup);

	}

protected String doInBackground(Location... params) {
			 */
			Geocoder geocoder = new Geocoder(localContext, Locale.getDefault());

			// Get the current location from the input parameter list
			Location location = params[0];

			// Create a list to contain the result address
			List <Address> addresses = null;
protected String doInBackground(Location... params) {
								address.getAddressLine(0) : "",

								// Locality is usually a city
								address.getLocality(),

								// The country of the address
								address.getCountryName()
protected void onPostExecute(Driver result) {
	}


}
protected void onCreate(Bundle savedInstanceState){
        
		final Handler h = new Handler();
		final int delay = 1000; //milliseconds

		h.postDelayed(new Runnable(){
	        Double latDouble = 22.3367;
	        Double lngDouble = 114.2639;
        
        <meta-data
    		android:name="com.google.android.maps.v2.API_KEY"
    		android:value="AIzaSyD4WooXy2q5Plsh4VCgtwDor5EdcZ77GfM"/>
    </application>
</manifest>
package comp3111h.anytaxi.driver;

import java.io.IOException;
import java.util.List;
import java.util.Locale;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;

import com.appspot.hk_taxi.anyTaxi.AnyTaxi;
import com.google.android.gms.common.ConnectionResult;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class DesugarDesugaredMapProjectionTest extends CypherFunSuite {
  def assertRewrite(originalQuery: String, expectedQuery: String) {
    test(originalQuery + " is rewritten to " + expectedQuery) {
      def rewrite(q: String): Statement = {
        val mkException = new SyntaxExceptionCreator(originalQuery, InputPosition.NONE)
        val sequence: Rewriter = inSequence(normalizeReturnClauses(mkException), normalizeWithClauses(mkException))
        val originalAst = parser.parse(q).endoRewrite(sequence)
        val semanticCheckResult = originalAst.semanticCheck(SemanticState.clean)
object InputPosition {
  implicit val byOffset =
    Ordering.by { (pos: InputPosition) => pos.offset }

  val NONE = null
}
class MatchAcceptanceTest extends ExecutionEngineFunSuite with QueryStatisticsTe
      """
        |MATCH p=(source:Neo)-[rel *0..1]->(dest)
        |WITH nodes(p) as d
        |RETURN DISTINCT d
      """.stripMargin

    val result = executeWithAllPlannersAndCompatibilityMode(query)

    result.toSet should equal(Set(Map("d" -> ArrayBuffer(n1)), Map("d" -> ArrayBuffer(n1, n2))))

  }

  // Not TCK material -- only one integer type
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import android.os.Bundle;
import android.view.View;
import edu.byu.support.fragment.ByuCameraFeedFragment;
import edu.byu.support.client.cameraFeed.model.CameraFeed;

import static edu.byu.support.ByuConstants.CAMERA_BUNDLE_TAG;

import android.os.Bundle;
import android.support.design.widget.TabLayout;
import android.support.v4.view.ViewPager;

import edu.byu.suite.R;
import edu.byu.support.activity.ByuActivity;
import edu.byu.support.adapter.ByuFragmentPagerAdapter;
import edu.byu.support.fragment.ByuFragment;

public class TestingCenterMainActivity extends ByuActivity {

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_view_pager);

		final TestingCenterCameraFeedFragment cameraFeedFragment = TestingCenterCameraFeedFragment.newInstance();
		final ByuFragmentPagerAdapter adapter = new ByuFragmentPagerAdapter(getFragmentManager(), new ByuFragment[]{new ScoresFragment(), cameraFeedFragment, new ScheduleFragment()});
		ViewPager viewPager = (ViewPager) findViewById(R.id.viewPager);
		viewPager.setAdapter(adapter);
		viewPager.setOffscreenPageLimit(2);
		viewPager.addOnPageChangeListener(new ViewPager.SimpleOnPageChangeListener() {
			@Override
			public void onPageSelected(int position) {
				if (position == 1) {
					// Refresh feed and start timer to refresh again in 15 seconds
					cameraFeedFragment.startScheduledThreadPool();
				} else if (cameraFeedFragment.isRunning()) {
					// Stop the feed cus we just left the cameraFeedFragment
					cameraFeedFragment.stopScheduledThreadPool();
				}
			}
		});
		((TabLayout) findViewById(R.id.tabLayout)).setupWithViewPager(viewPager);
	}

}
public String getBaseUrl() {

	@Override
	public Converter.Factory getConverter() {
		return GsonConverterFactory.create(new GsonBuilder().registerTypeAdapter(Date.class, new JsonDateDeserializer(Collections.singletonList(DateUtil.DATE_TIME_TIMEZONE_FORMAT)))
															.create());
	}

	@Override
import android.app.Fragment;
import android.app.FragmentManager;
import android.support.v13.app.FragmentPagerAdapter;
import edu.byu.support.fragment.ByuFragment;

/**
 * Created by cwoodfie on 7/28/16
 */
public class ByuFragmentPagerAdapter extends FragmentPagerAdapter {
	private final ByuFragment[] FRAGMENTS;

	public ByuFragmentPagerAdapter(FragmentManager fm, ByuFragment[] fragments) {
		super(fm);
		FRAGMENTS = fragments;
	}

	@Override
	public Fragment getItem(int position) {
		return FRAGMENTS[position];
	}

	@Override
	public int getCount() {
		return FRAGMENTS.length;
	}

	@Override
	public CharSequence getPageTitle(int position) {
		return FRAGMENTS[position].getTitle();
	}
}
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Bundle;
import android.view.*;
import android.widget.ImageView;
import android.widget.TextView;
 * Created by cwoodfie on 7/29/16
 */
public class ByuCameraFeedFragment extends ByuFragment {
	private static final int MINIMUM_REFRESH_INTERVAL = 15;
	private Call<ResponseBody> cameraFeedRequest;
	private ImageView cameraFeedImageView;
	private TextView refreshText;
	private ScheduledExecutorService scheduledExecutorService;
	private CameraFeed cameraFeed;
	private boolean running = false;
	private final ByuCallback<ResponseBody> callback = new ByuCallback<ResponseBody>(this) {
		@Override
public static ByuCameraFeedFragment newInstance(CameraFeed cameraFeed) {
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setHasOptionsMenu(true);
		cameraFeed = getArguments().getParcelable(CAMERA_BUNDLE_TAG);
		cameraFeedRequest = ((ByuCameraFeedClient.Api) ByuApiGenerator.createApi(getActivity(), new ByuCameraFeedClient())).getCameraFeed(cameraFeed.getLocation());
	}

	@Override
public void onViewCreated(View view, Bundle savedInstanceState) {
		startScheduledThreadPool();
	}

	public synchronized void startScheduledThreadPool() {
		// restart the threads if the user hits refresh
		stopScheduledThreadPool();
		scheduledExecutorService = Executors.newScheduledThreadPool(2);
		// Set image to refresh every refreshInterval
		final ScheduledFuture<?> scheduledUpdateImage = scheduledExecutorService.scheduleWithFixedDelay(new Runnable() {
			@Override
			public void run() {
				loadImage();
			}
		}, 0, Math.max(cameraFeed.getRefreshInterval(), MINIMUM_REFRESH_INTERVAL), TimeUnit.SECONDS);
		// Set countdown to update every second
		scheduledExecutorService.scheduleAtFixedRate(new Runnable() {
			@Override
			public void run() {
				updateText(scheduledUpdateImage.getDelay(TimeUnit.SECONDS));
			}
		}, 0, 1, TimeUnit.SECONDS);
		running = true;
	}

	// Used by testing center to only refresh when the cameraFeedFragment is visible
	public synchronized void stopScheduledThreadPool() {
		if (running) {
			scheduledExecutorService.shutdownNow();
		}
		running = false;
	}

	public synchronized boolean isRunning() {
		return running;
	}

	private void updateText(final long delay) {
		getActivity().runOnUiThread(new Runnable() {
			@Override
			public void run() {
				if (delay <= 0) {
public void run() {
					refreshText.setText(getString(R.string.cameraRefreshTextFormat, delay));
				}
			}
		});
	}

	@Override
protected void loadImage() {
	}

	@Override
	public void onDestroy() {
		super.onDestroy();
		stopScheduledThreadPool();
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
* 380 - generate correct tanking report when there are multiple tournaments in the same database
* 377 - correctly identify Excel files by extension

public void setTeamName(final String teamName) {
  }

  /**
   * @return the teamName
   */
  public String getTeamName() {
    return teamName;
  }

  /**
public void setOrganization(final String organization) {
  }

  /**
   * @return the organization
   */
  public String getOrganization() {
    return organization;
  }

  /**
public void setDivision(final String division) {
  }

  /**
   * @return the division
   */
  public String getDivision() {
    return division;
  }

  /**
public void setJudgingStation(final String judge) {
  }

  /**
   * @return the judging station
   */
  public String getJudgingStation() {
    return judgingStation;
  }

  public int getNumberOfRounds() {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
<idea-plugin version="2">
  <id>com.atsebak.raspberrypi</id>
    <name>Embedded Linux JVM Debugger (Raspberry Pi, Intel x86, ARM processors)</name>
    <version>0.41</version>
  <vendor email="ahmad@atsebak.com" url="http://www.atsebak.com">At Sebak</vendor>

  <description><![CDATA[
    <p>Java Debugger for Embedded Systems that run on Embedded Linux or on the <a href="https://www.yoctoproject.org/">Yocto Project Kernel</a></p>
    ]]></description>

  <change-notes><![CDATA[
        <b>Version 0.41</b>
        <ul>
            <li>
protected void resetEditorFrom(EmbeddedLinuxJVMRunConfiguration configuration) {
        runAsRootCheckBox.setSelected(parameters.isRunAsRoot());
        debugPort.setText(parameters.getPort());
        username.setText(parameters.getUsername());
        password.setText(new String(parameters.getPassword()));
        sshStatus.setVisible(false);
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  <version>1.0-SNAPSHOT</version>
  <packaging>hpi</packaging>

    <repositories>
        <repository>
          <id>repo.jenkins-ci.org</id>
          <url>http://repo.jenkins-ci.org/public/</url>
        </repository>
    </repositories>

    <pluginRepositories>
        <pluginRepository>
          <id>repo.jenkins-ci.org</id>
          <url>http://repo.jenkins-ci.org/public/</url>
        </pluginRepository>
    </pluginRepositories>

    <dependencies>
        <dependency>
            <artifactId>TestParser</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
    </dependencies>
</project>
public boolean containsValue(String property, String value) {
        }
        return values.get(property).containsKey(value);
    }
}
public void setProperties(TcmsProperties properties) {
    }
    
    private static TestRun.link_env_value tcmsLinkValue(TcmsEnvironment env,String property,String value) {
        TestRun.link_env_value c = new TestRun.link_env_value();
        c.run_id = -1;
        Hashtable<String,Value> prop = env.getValues().get(property);
public void doCheckSubmit(StaplerRequest req, StaplerResponse rsp) throws Servle
                String val = prop.getValue();

                String result = "UNKNOWN";

                if (environment.containsProperty(name)) {
                    if (environment.containsValue(name, val)) {
                        result = "CHECKED";
public void doCheckSubmit(StaplerRequest req, StaplerResponse rsp) throws Servle
                    result = "PROPERTY";
                    wrongProperty = true;
                }

                if (env_status.containsKey(name) == false) {
                    env_status.put(name, new Hashtable<String, String>());
<j:jelly xmlns:j="jelly:core" xmlns:st="jelly:stapler" xmlns:d="jelly:define" xmlns:l="/lib/layout"
         xmlns:t="/lib/hudson" xmlns:f="/lib/form">
       
    <table >                       
                        
        <j:forEach var="env" items="${it.env_status.entrySet()}">
            <tr>
                <td colspan="2">
                    <strong>${env.getKey()}</strong>
                </td>
                <td>
                    <j:choose>
                        <j:when test="${env.getValue().values().iterator().next()=='PROPERTY'}">
                            <f:textbox name="property-${env.getKey()}" clazz="required" style="width: 100px" value="${env.getKey()}" /> 
                        </j:when>
                        <j:when test="${it.change_axis}">
                            <f:textbox name="property-${env.getKey()}" clazz="required" style="width: 100px" value="${env.getKey()}" /> 
                        </j:when>
                        <j:otherwise>
                        </j:otherwise>
                    </j:choose>
                </td>
                
                <td>
                    <j:if test="${env.getValue().containsValue('PROPERTY')}">
                        Property is not linked to 
                        <strong>${it.environment.env}</strong>. 
                    </j:if>
                </td>
            </tr>
                    
                    
                    
            <j:forEach var="val" items="${env.getValue().entrySet()}">
                <tr>    
                    <td class="tdSmall"></td>
                    <td>
                        ${val.getKey()}
                    </td>
                    <td>
                        <j:choose>
                            <j:when test="${val.getValue()=='CHECKED'}">
                                <img src="${rootURL}/plugin/NitrateIntegration/images/completed.png"
                                         alt="${%!P(MISSING)roperty checked}" tooltip="${%!P(MISSING)roperty checked}"
                                         style="visibility: visible" width="16" height="16" align="center" />
                                <j:choose>
                                    <j:when test="${it.change_axis}">
                                        <f:textbox name="value-${env.getKey()}=>${val.getKey()}" clazz="required" style="width: 100px" value="${val.getKey()}" /> 
                                    </j:when>
                                </j:choose>
                            </j:when>
                            <j:when test="${val.getValue()=='VALUE'}">
                                <f:textbox name="value-${env.getKey()}=>${val.getKey()}" clazz="required" style="width: 100px" value="${val.getKey()}" /> 
                            </j:when>
                            <j:when test="${val.getValue()=='PROPERTY'}">
                                <f:textbox name="value-${env.getKey()}=>${val.getKey()}" clazz="required" style="width: 100px" value="${val.getKey()}" />                                 
                            </j:when>
                            <j:otherwise>
                                ${val.getValue()}
                            </j:otherwise>
                        </j:choose>

                    </td>
                    <td>
                        <j:if test="${val.getValue()=='VALUE'}">
                            Value is not linked with 
                                <strong> ${env.getKey()}</strong>.
                        </j:if>
                    </td>
                </tr>
            </j:forEach>
            <tr>
                <td>
                    <st:nbsp/>
                </td>
            </tr>
        </j:forEach>
    </table> 
    <br />
    <j:choose>
        <j:when test="${it.existsWrongProperty()}">
            Available properties for group 
            <strong>${it.environment.env}</strong>: 
            <br/>                      
            <j:forEach var="posible_val" items="${it.environment.values.keySet()}">
                ${posible_val},
                <st:nbsp/> 
            </j:forEach>
            <br />
        </j:when>
    </j:choose>

    
    <j:forEach var="prop" items="${it.getPropertyWWrongValue()}">
        <br/>
        Available values for property 
        <strong>${prop}:</strong> 
        <br/>
        <j:forEach var="posible_val" items="${it.environment.values.get(prop).keySet()}">
            ${posible_val},
            <st:nbsp/>
        </j:forEach>
        <br />
    </j:forEach>
    <ul>
        <j:forEach var="val" items="${it.env_check_problems}">
            <li> ${val}</li>
        </j:forEach>             
    </ul>
             
</j:jelly>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import net.fortuna.ical4j.model.PropertyList;
import net.fortuna.ical4j.model.component.CalendarComponent;
import net.fortuna.ical4j.model.component.VEvent;

public class EventReloaderJob implements Job {
    public static final String KEY_CONFIG = "config";
public void loadEvents(String filename, org.joda.time.DateTime lastResourceChang
        org.joda.time.DateTime lastModifedVEventOverAll = null;
        for (CalendarComponent comp : vEventComponents) {
            VEvent vEvent = (VEvent) comp;
            log.trace("loading event: " + vEvent.getUid().getValue() + ":" + vEvent.getSummary().getValue());
            // fallback, because 'LastModified' in VEvent is optional
            org.joda.time.DateTime lastModifedVEvent = lastResourceChangeFS;
            if (vEvent.getLastModified() != null) {
public void loadEvents(String filename, org.joda.time.DateTime lastResourceChang
                                    .isAfter(org.joda.time.DateTime.now().plusMinutes(config.getReloadMinutes()))) {
                        // the event is calculated as long as the next reload
                        // interval can handle this
                        log.trace("skipping resource processing {}, not changed", filename);
                        continue;
                    }

                    if (eventContainer.isHistoricEvent()) {
                        // no more upcoming events, do nothing
                        log.trace("skipping resource processing {}, not changed", filename);
                        continue;
                    }
                }
public void loadEvents(String filename, org.joda.time.DateTime lastResourceChang
            periods = periods.normalise();

            String eventId = vEvent.getUid().getValue();
            final String eventName = vEvent.getSummary().getValue();

            // no more upcoming events
            if (periods.size() > 0) {
                if (vEvent.getConsumedTime(new net.fortuna.ical4j.model.Date(),
                        new net.fortuna.ical4j.model.Date(org.joda.time.DateTime.now().plusYears(10).getMillis()))
                        .size() == 0) {
                    log.trace("event will never be occur (historic): {}", eventName);
                    eventContainer.setHistoricEvent(true);
                }
            }

            // expecting this is for every vEvent inside a calendar equals
            eventContainer.setEventId(eventId);
public void loadEvents(String filename, org.joda.time.DateTime lastResourceChang
                org.joda.time.DateTime start = getDateTime("start", p.getStart(), p.getRangeStart());
                org.joda.time.DateTime end = getDateTime("end", p.getEnd(), p.getRangeEnd());

                CalDavEvent event = new CalDavEvent(eventName, vEvent.getUid().getValue(), config.getKey(), start, end);
                event.setLastChanged(lastModifedVEvent);
                if (vEvent.getLocation() != null) {
public void loadEvents(String filename, org.joda.time.DateTime lastResourceChang
                }
                event.getCategoryList().addAll(readCategory(vEvent));
                event.setFilename(filename);
                log.trace("adding event: " + event.getShortName());
                eventContainer.getEventList().add(event);

            }
        }
        if (lastModifedVEventOverAll != null && !config.isLastModifiedFileTimeStampValid()) {
            eventContainer.setLastChanged(lastModifedVEventOverAll);
            log.debug("changing eventcontainer last modified to {}", lastModifedVEventOverAll);
        }
        // if (!eventContainer.getEventList().isEmpty()) {
        CalDavLoaderImpl.instance.addEventToMap(eventContainer, true);
        if (!readFromFile) {
            Util.storeToDisk(config.getKey(), filename, calendar);
        }
        // }
    }

    /**
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 */
public class VersionHandler implements SOAPHandler<SOAPMessageContext> {

    private static final String VERSION = "ctmg.service.version";
    private static final String PROPERTY_FILE_NAME = "webserviceclient.properties";
    private static final ApiVersionInfo apiVersionInfo = new ApiVersionInfo(
            PROPERTY_FILE_NAME);
public void parseApiVersion_1_8() throws Exception {
        version.add(node);
        Iterator<?> it = version.iterator();
        doReturn(it).when(soapHeader).extractHeaderElements(
                eq("ctmg.service.version"));
        doReturn(soapHeader).when(envelope).getHeader();
        doReturn(envelope).when(part).getEnvelope();
        doReturn(part).when(message).getSOAPPart();
 */
public class SoapRequestParser {

    private static final String VERSION = "ctmg.service.version";

    public static String parseApiVersion(SOAPMessageContext context)
            throws SOAPException {
private void verifyAllAttributesAreSetForInternal(WsProxyInfo result) {
        assertNotNull(result.getWsInfo());
        assertNotNull(result.getUserCredentials());
    }
}
  <classpathentry combineaccessrules="false" kind="src" path="/oscm-webservices-proxy" />
  <classpathentry combineaccessrules="false" kind="src" path="/oscm-apiversioning-client-handler" />
  <classpathentry combineaccessrules="false" kind="src" path="/oscm-common" />
  <classpathentry kind="output" path="bin" />
</classpath>

import java.util.Properties;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

String getAndLogServiceClientProperty(String property) {
     * @return
     */
    String getAndLogTokenHandlerProperty(String property) {
        String value = tokenHandlerProp.getProperty(property).trim();
        return value;
    }

# Copyright FUJITSU LIMITED 2016
ctmg.service.version=1.9
# Copyright FUJITSU LIMITED 2016
ctmg.service.version=1.9
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
apply plugin: 'com.android.library'
apply plugin: 'com.github.dcendents.android-maven'
apply plugin: 'com.jfrog.bintray'

def version = '10.1.1'

install {
    repositories.mavenInstaller {
public void getCurScrollState() {
        if (materialScrollBar.recyclerView.getLayoutManager() instanceof GridLayoutManager) {
            scrollPosState.rowIndex = scrollPosState.rowIndex / ((GridLayoutManager) materialScrollBar.recyclerView.getLayoutManager()).getSpanCount();
        }
        scrollPosState.rowTopOffset = materialScrollBar.recyclerView.getLayoutManager().getDecoratedTop(child);
        scrollPosState.rowHeight = child.getHeight();
    }

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void scanPomFile(File pomFile, CommandResult result){
            VictimsDBInterface db = Environment.getInstance().getDatabase();
            Model model = pomReader.read(new FileReader(pomFile));
            List<Dependency> dependencies = model.getDependencies();
            DependencyManagement dependencyManagement = model.getDependencyManagement();
            if (dependencyManagement != null){
                if (dependencies == null){
                    dependencies = new ArrayList<Dependency>();
                }
                dependencies.addAll(dependencyManagement.getDependencies());
            }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void ApplyMove(Move move){
        Position start = new Position(move.GetStartX(), move.GetStartY());
        Position end = new Position(move.GetEndX(), move.GetEndY());
        Piece temp = m_boardState[start.GetX()][start.GetY()];
        SetPiece(start.GetX(),start.GetY(), null);
        SetPiece(end.GetX(), end.GetY(), temp);
    }
    private void CheckApplyMove(Move move){
        //Used on for CheckUnApplyMove which is private
protected Void call() throws Exception {
                            }
                            try {
                                Packet p = (Packet) in.readObject();
                                processPacket(p);
                            } catch (SocketTimeoutException ex) {
                                //This is okay. Makes it so we don't hang here forever
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public static boolean done() {
	stack = new InputStream[8];
	sp = 0;
	buf = empty;
        OS = Windows;
//        OS = MacOS;
//        OS = Unix;
	if (OS == Windows) eol = (char)13; else eol = (char)10;
}

TMatch scorinate_match(int first, int second, boolean ha )
    ht=lookup(first);
    at=lookup(second);
    first_leg=null;
    if (eliminate&&(home_away||home_adv)&&first<second)
    {
      first_leg=get_first_leg(second, first);
      result.first_leg=first_leg;
TMatch scorinate_match(int first, int second, boolean ha )
    result.h_regtime = home;
    result.a_regtime = away;
    require_ET=false;
    if (first_leg!=null)
    {
      if (result.a_regtime+first_leg.home==result.h_regtime+first_leg.away)
      {
        if (result.a_regtime==first_leg.away)
        {
          require_ET=true;
        }
      }
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#!/bin/bash

VERSION="1.14.7.5"

RELEASE_PATH="../../release/heybot_$VERSION"

    <g fill="#fff" text-anchor="middle" font-family="DejaVu Sans,Verdana,Geneva,sans-serif" font-size="11">
	<text x="25.5" y="15" fill="#010101" fill-opacity=".3">version</text>
	<text x="25.5" y="14">version</text>
	<text x="80.5" y="15" fill="#010101" fill-opacity=".3">1.14.7.5</text>
	<text x="80.5" y="14">1.14.7.5</text>
    </g>
</svg>
public class heybot
{

    private final static String VERSION = "1.14.7.5";
    private static final String NEWLINE = System.getProperty("line.separator");
    private static final SimpleDateFormat DATE_FORMATTER = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

import com.taskadapter.redmineapi.bean.Tracker;
import com.taskadapter.redmineapi.bean.User;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
public void execute(Properties prop) throws Exception
	    System.out.println();
	    groupIssuesBySecondaryAssignee(issues, getParameterString(prop, PARAMETER_SECONDARY_ASSIGNEE, false));
	    System.out.println();
	    java.util.Arrays.sort(issues, (o1, o2) -> o1.getDueDate().compareTo(o2.getDueDate()));
	    listIssues(prop, issues);
	    printIssuesSummary(issues);
	    System.out.println();
else if (rejectedTrunkMergeStatuses.contains(status))

    private void printDueDate(Issue issue, Date today)
    {
	if (issue.getDueDate().compareTo(today) < 0)
	{
	    coloredPrinter.print(format(dateTimeFormatOnlyDate.format(issue.getDueDate()), 12, true), Attribute.NONE, fColorDueDateExpired, bColorDueDateExpired);
	    coloredPrinter.clear();
	    totalDueDateExpired++;
	}
	else
	{
	    System.out.print(format(dateTimeFormatOnlyDate.format(issue.getDueDate()), 12, true));
	}
    }

private UserQueue getUserQueue(HashMap<Integer, UserQueue> userQueues, int userI
	return userQueue;
    }

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
For a complete list of issues completed in this version goto
and click on either open or closed. Be sure to look at the date closed
and download the BETA released after that date.

Version: 1.4_Build_BETA-2017.06.23
    1. Fixed #103 (https://github.com/SIMRacingApps/SIMRacingApps/issues/103)
       Brake Bias .5 Increment on cars that show the actual percentage, not the delta.
       
    2. Fixed #104 (https://github.com/SIMRacingApps/SIMRacingApps/issues/104)
       Standings App not working when out of car

    3. Added a small delay in the Voice Attack Profile in the spotter loops
       to cut down on CPU usage.
       
    4. Implemented a better SOF (Strength of field) calculation posted on the iRacing forums.

    For notes on previous BETA builds, see below.
    
------------------------------------------------------------------------------------------------------
Version: 1.4_Build_BETA-2017.06.23

****************** Previous Versions *************************

For versions prior to 1.4, see the regular release notes.
Version: 1.4_Build_BETA-2017.06.23

    4. Implemented a better SOF (Strength of field) calculation posted on the iRacing forums.

    For notes on previous versions, see below.
       
------------------------------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public class PacketDataSyncReq extends AbstractPacket implements IMessage, IMessageHandler<PacketDataSyncReq, IMessage>
{
	private int entityId;
	
	public PacketDataSyncReq()
	{
	}
public IMessage onMessage(PacketDataSyncReq packet, MessageContext context)
		try
		{
			IWatchable watchable = (IWatchable) context.getServerHandler().playerEntity.worldObj.getEntityByID(packet.entityId);
			DataWatcherEx dataWatcherEx = watchable.getDataWatcherEx();
			
			return new PacketDataSync(packet.entityId, dataWatcherEx);
		}
		
		catch (Throwable e)
		{
			RadixExcept.logErrorCatch(e, "Error sending sync data to client.");
		}
		
		return null;
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public InlineList(
        listOfObjects = new HashSet<InlineListObject>();

        for (Object listObject : listOfListObjects) {
            InterMineObject interMineListObject = (InterMineObject) listObject;

            Object value = null;
            Object id = null;
            try {
                // get field values from the object
                value = interMineListObject.getFieldValue(columnToDisplayBy);
                id = interMineListObject.getFieldValue("id");
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }

            // make our InlineListObject
            InlineListObject inlineListObject =
                new InlineListObject(interMineListObject, value, id);

            listOfObjects.add(inlineListObject);
        }
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
