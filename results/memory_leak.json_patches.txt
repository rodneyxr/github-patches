public String getDescription()
    public String getReleaseVersion() {
        return RELEASED_IN_VERSION;
    }
	
	/**
	 * Resets the Module Context 
	 * 
	 * @param xqueryContext The XQueryContext
	 */
	
	public void reset( XQueryContext xqueryContext )
	{
		super.reset( xqueryContext );
	}
}
public static FTPClient retrieveConnection(XQueryContext context, long connectio
     * @param  xqueryContext  The XQueryContext
     */
    @Override
    public void reset(XQueryContext xqueryContext) {
        // reset the module context
        super.reset(xqueryContext);

        // close any open Connections
        closeAllConnections(xqueryContext);
private static synchronized long getID()
	 * @param xqueryContext		The XQueryContext
	 */
	
	public void reset( XQueryContext xqueryContext ) 
	{
		// reset the module context
		super.reset( xqueryContext );

		// close any open JNDI Contexts
		closeAllJNDIContexts( xqueryContext );
public void modify(Map<Long, Message[]> map) {
     * @param context The XQueryContext
     */
    @Override
    public void reset( XQueryContext context ) {
        // reset the module context
        super.reset(context);

        // close any open MessageLists
        closeAllMessageLists(context);
public static synchronized long storePreparedStatement(XQueryContext context, Pr
     * @param  xqueryContext  The XQueryContext
     */
    @Override
    public void reset(XQueryContext xqueryContext) {
        // reset the module context
        super.reset(xqueryContext);

        // close any open PreparedStatements
        closeAllPreparedStatements(xqueryContext);
public boolean isVarDeclared(QName qname) {
    }

    @Override
    public void reset(XQueryContext xqueryContext) {
        //Nothing to do
    }
}
public int returnsType() {
    }

    @Override
    public void resetState(boolean postOptimization) {
        super.resetState(postOptimization);
    }
}

    private XQueryContext mContext = null;

    public ExternalModuleImpl(String namespaceURI, String prefix) {
        mNamespaceURI = namespaceURI;
        mPrefix = prefix;
public boolean moduleIsValid(DBBroker broker) {
        return mSource != null && mSource.isValid(broker) == Source.VALID;
    }

    public void reset(XQueryContext xqueryContext) {
        mContext.reset();
        mStaticVariables.clear();
    }

    private Expression rootExpression = null;
private void updateFunction() throws XPathException {
	 */
	public void analyze(AnalyzeContextInfo contextInfo) throws XPathException {
		//updateFunction();
		contextInfo.setParent(this);
         final AnalyzeContextInfo newContextInfo = new AnalyzeContextInfo(contextInfo);
         newContextInfo.removeFlag(IN_NODE_CONSTRUCTOR);
         super.analyze(newContextInfo);
		if (context.tailRecursiveCall(functionDef.getSignature())) {
public Sequence evalFunction(Sequence contextSequence, Item contextItem, Sequenc
    @Override
    public void resetState(boolean postOptimization) {
        super.resetState(postOptimization);
        setRecursive(false);
        if(expression.needsReset() || postOptimization) {
            expression.resetState(postOptimization);
        }
 */
package org.exist.xquery;

import java.util.List;

import org.exist.dom.QName;
import org.exist.xquery.util.ExpressionDumper;
	public final static QName INLINE_FUNCTION_QNAME = new QName("", "");
	
	private UserDefinedFunction function;
	
    private AnalyzeContextInfo cachedContextInfo;

public InlineFunction(XQueryContext context, UserDefinedFunction function) {

	@Override
	public void analyze(AnalyzeContextInfo contextInfo) throws XPathException {
        cachedContextInfo = new AnalyzeContextInfo(contextInfo);

        final AnalyzeContextInfo info = new AnalyzeContextInfo(contextInfo);
		info.addFlag(SINGLE_STEP_EXECUTION);
		
		// local variable context is known within inline function:
		final List<Variable> closureVars = context.getLocalStack();
		function.setClosureVariables(closureVars);
		
		function.analyze(info);
	}

	@Override
public void dump(ExpressionDumper dumper) {
	public Sequence eval(Sequence contextSequence, Item contextItem)
			throws XPathException {
		// local variable context is known within inline function
		final List<Variable> closureVars = context.getLocalStack();
		function.setClosureVariables(closureVars);
		
		final FunctionCall call = new FunctionCall(context, function);
		call.setLocation(function.getLine(), function.getColumn());
		function.setCaller(call);
		function.analyze(cachedContextInfo);
		return new FunctionReference(call);
	}

public int returnsType() {
    public void resetState(boolean postOptimization) {
        super.resetState(postOptimization);
        // clear closure variables set on inline function
        function.setClosureVariables(null);
    }
}

	protected LocalVariable before = null;
	protected LocalVariable after = null;
	protected boolean isClosureVar = false;

    public LocalVariable(QName qname) {
        super(qname);
    }

	public LocalVariable(LocalVariable other, boolean isClosureVar) {
		super(other);
        this.isClosureVar = isClosureVar;
	}

	public LocalVariable(LocalVariable other) {
		this(other, false);
	}
	
	public void addAfter(LocalVariable var) {
public void addAfter(LocalVariable var) {
	}

    public boolean isClosureVar() {
        return isClosureVar;
    }
}
     * module implementation (internal modules).
     */
    public Iterator<QName> getGlobalVariables();
    
	/**
	 * Reset the module's internal state for being reused.
	 *
	 */
	public void reset(XQueryContext xqueryContext);

    /**
     * Check if this module has been fully loaded
public Variable resolveVariable(QName qname) throws XPathException {
    	return parentContext.getLocalVariables();
    }

    public List<Variable> getLocalStack() {
    	return parentContext.getLocalStack();
    }
    
    public Map<QName, Variable> getGlobalVariables() {
    	return parentContext.getGlobalVariables();
    }

    public void restoreStack(List<Variable> stack) throws XPathException {
    	parentContext.restoreStack(stack);
    }
    

    private boolean visited = false;

    private List<Variable> closureVariables = null;
    
	public UserDefinedFunction(XQueryContext context, FunctionSignature signature) {
		super(context, signature);
public void analyze(AnalyzeContextInfo contextInfo) throws XPathException {
					var = new LocalVariable(varName);
					context.declareVariableBinding(var);
				}
				
				contextInfo.setParent(this);
				if (!bodyAnalyzed) {
					body.analyze(contextInfo);
					bodyAnalyzed = true;
				}
			} finally {
public void resetState(boolean postOptimization) {
		super.resetState(postOptimization);
        // Question: understand this test. Why not reset even is not in recursion ?
		// Answer: would lead to an infinite loop if the function is recursive.
		if(call != null && !call.isRecursive()) {
            bodyAnalyzed = false;
			body.resetState(postOptimization);
		}
        if (!postOptimization) {
            currentArguments = null;
            contextDocs = null;
        }
    }

	public boolean needsReset() {
		return currentArguments != null;
	}
	
    public void accept(ExpressionVisitor visitor) {
        if (visited)
            {return;}
public void setCaller(FunctionCall call){
    	this.call = call;
    }
    
    public void setClosureVariables(List<Variable> vars) {
    	this.closureVariables = vars;
    }
    
    protected Sequence[] getCurrentArguments() {
        return currentArguments;
    }
import java.net.URISyntaxException;
import java.nio.file.Path;
import java.text.Collator;
import java.util.ArrayList;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Properties;
import java.util.SimpleTimeZone;
import java.util.Stack;
import java.util.TimeZone;
import java.util.TreeMap;

import javax.xml.datatype.DatatypeConfigurationException;
import javax.xml.datatype.DatatypeFactory;
public void reset(final boolean keepGlobals) {
            watchdog.reset();
        }

        for( final Module module : modules.values() ) {
            if (module instanceof ExternalModule && ((ModuleContext)((ExternalModule)module).getContext()).getParentContext() != this) {
                continue;
            }
            module.reset( this );
        }

        if( !keepGlobals ) {
public boolean isVarDeclared( QName qname )
     * 
     * @return currently visible local variables as a stack
     */
    public List<Variable> getLocalStack() {
    	final List<Variable> variables = new ArrayList<Variable>(10);
    	
    	final LocalVariable end = contextStack.isEmpty() ? null : contextStack.peek();

        for ( LocalVariable var = lastVar; var != null; var = var.before ) {
public boolean isVarDeclared( QName qname )
                break;
            }

            variables.add( new LocalVariable(var, true) );
        }

        return ( variables );
    }
    
    public Map<QName, Variable> getGlobalVariables() {
public boolean isVarDeclared( QName qname )
     * @param stack
     * @throws XPathException
     */
    public void restoreStack(List<Variable> stack) throws XPathException {
        for (int i = stack.size() - 1; i > -1; i--) {
            declareVariableBinding((LocalVariable)stack.get(i));
        }
    }
    
import java.util.Map;

import org.exist.dom.QName;
import org.exist.xquery.AbstractInternalModule;
import org.exist.xquery.FunctionDef;
import org.exist.xquery.XPathException;

/**
 * Module function definitions for transform module.
        Arrays.sort(functions, new FunctionComparator());
    }

    public RequestModule(Map<String, List<? extends Object>> parameters) throws XPathException {
        super(functions, parameters, true);
        // predefined module global variables:
        declareVariable(REQUEST_VAR, null);
    }

    /* (non-Javadoc)
public String getDefaultPrefix() {
    public String getReleaseVersion() {
        return RELEASED_IN_VERSION;
    }
}
import java.util.List;
import java.util.Map;
import org.exist.dom.QName;
import org.exist.xquery.AbstractInternalModule;
import org.exist.xquery.FunctionDef;
import org.exist.xquery.XPathException;


/**
        new FunctionDef( GetExists.signature, GetExists.class )
    };

    public ResponseModule(Map<String, List<? extends Object>> parameters) throws XPathException
    {
        super(functions, parameters);

        // predefined module global variables:
        declareVariable( RESPONSE_VAR, null );
    }

    /* (non-Javadoc)
public String getReleaseVersion()
        return( RELEASED_IN_VERSION );
    }

}
		new FunctionDef( SetCurrentUser.signature, SetCurrentUser.class ),
		new FunctionDef( GetExists.signature, GetExists.class )
	};
	
	public SessionModule(Map<String, List<? extends Object>> parameters) throws XPathException
	{
		super(functions,  parameters);
		// predefined module global variables:
		declareVariable( SESSION_VAR, null );
	}

	/* (non-Javadoc)
static JavaObjectValue createSession( XQueryContext context, Function fn ) throw
		return( ret );
	}

}
stringConcatExpr throws XPathException
{ boolean isConcat = false; }
:
	r1:rangeExpr (
		CONCAT^ rangeExpr { isConcat = true; }
	)*
	{
		if (isConcat)
public final void stringConcatExpr() throws RecognitionException, TokenStreamExc
		_loop301:
		do {
			if ((LA(1)==CONCAT)) {
				org.exist.xquery.parser.XQueryAST tmp299_AST = null;
				tmp299_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.makeASTRoot(currentAST, tmp299_AST);
				match(CONCAT);
				rangeExpr();
				astFactory.addASTChild(currentAST, returnAST);

        UnionTest.class,
        TestXPathOpOrSpecialCase.class,
        MemtreeDescendantOrSelfNodeKindTest.class,
        PersistentDescendantOrSelfNodeKindTest.class
})
public class AllXqueryTests {
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import java.util.HashSet;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

    //~ Instance fields --------------------------------------------------------

    volatile javax.swing.SwingWorker<Void, Void> objectRetrievingWorker = null;
    final HashSet<ObjectTreeNode> listOfRetrievingObjectWorkers = new HashSet<ObjectTreeNode>();
    private final ExecutorService objectRetrievalExecutor = Executors.newFixedThreadPool(15);
    private final ImageIcon DELETED_ICON;
    private final ImageIcon CLOSED_ICON;
private Icon generateIconFromState(final ObjectTreeNode node) {
                }
                return result;
            } else {
                if (!listOfRetrievingObjectWorkers.contains(node)) {
                    synchronized (listOfRetrievingObjectWorkers) {
                        if (!listOfRetrievingObjectWorkers.contains(node)) {
                            listOfRetrievingObjectWorkers.add(node);
                            objectRetrievalExecutor.execute(new javax.swing.SwingWorker<Void, Void>() {

                                    @Override
protected Void doInBackground() throws Exception {
                                                node.getMetaObject(true);
                                            }
                                        }
                                        return null;
                                    }

                                    @Override
                                    protected void done() {
                                        try {
                                            synchronized (listOfRetrievingObjectWorkers) {
                                                listOfRetrievingObjectWorkers.remove(node);
                                            }
                                            final Void result = get();
                                            if (node.getPath()[0].equals(
                                                            ComponentRegistry.getRegistry().getSearchResultsTree()
protected void done() {
                                            }
                                        } catch (Exception e) {
                                            log.error("Fehler beim Laden des MetaObjects", e);
                                        }
                                    }
                                });

import java.util.HashSet;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

    //~ Instance fields --------------------------------------------------------

    volatile javax.swing.SwingWorker<Void, Void> objectRetrievingWorker = null;
    final HashSet<ObjectTreeNode> listOfRetrievingObjectWorkers = new HashSet<ObjectTreeNode>();
    private final ExecutorService objectRetrievalExecutor = Executors.newFixedThreadPool(15);
    private final ImageIcon DELETED_ICON;
    private final ImageIcon WARNING_ICON;
private Icon generateIconFromState(final ObjectTreeNode node) {
                }
                return result;
            } else {
                if (!listOfRetrievingObjectWorkers.contains(node)) {
                    synchronized (listOfRetrievingObjectWorkers) {
                        if (!listOfRetrievingObjectWorkers.contains(node)) {
                            listOfRetrievingObjectWorkers.add(node);
                            objectRetrievalExecutor.execute(new javax.swing.SwingWorker<Void, Void>() {

                                    @Override
protected Void doInBackground() throws Exception {
                                    @Override
                                    protected void done() {
                                        try {
                                            synchronized (listOfRetrievingObjectWorkers) {
                                                listOfRetrievingObjectWorkers.remove(node);
                                            }
                                            final Void result = get();
                                            if (node.getPath()[0].equals(
                                                            ComponentRegistry.getRegistry().getSearchResultsTree()
protected void done() {
                                            }
                                        } catch (Exception e) {
                                            log.error("Fehler beim Laden des MetaObjects", e);
                                        }
                                    }
                                });
protected void done() {
                                            final Icon result = get();
                                            setIconToNode(node, result);
                                            final boolean wasChangedBefore = node.isChanged();
                                            node.setMetaObject(null);
                                            node.setChanged(wasChangedBefore);
                                        } catch (Exception e) {
                                            LOG.error("Fehler beim Laden des MetaObjects", e);
                                        } finally {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public static void main(String[] args) throws IOException {
		long startTime = System.currentTimeMillis();

		Files.walk(Paths.get(jsonPath)).forEach(filePath -> {

			if (Files.isRegularFile(filePath)) {

public static void main(String[] args) throws IOException {
				}
			}

		});

		System.out.println("Total files related to corrections: " + filesRelatedToCorrections);
		System.out.println("Total files related to corrections found: " + filesRelatedToCorrectionsFound);
public static void main(String[] args) throws IOException {
			session.close();
		}

		long millis = (System.currentTimeMillis() - startTime);

		String hms = String.format("%!d(MISSING):%!d(MISSING):%!d(MISSING)", TimeUnit.MILLISECONDS.toHours(millis),
private static boolean containsCorrections(Commit commit) {
		String subject = commit.getSubject().toLowerCase();

		for (String keyword : keywords) {
			if (message.contains(keyword) || subject.contains(keyword)	) {
				return true;
			}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      'bk.evaluatePluginManager',
      'bk.controlPanel',
      'bk.mainApp',
      'bk.debug'
    ]);

    // setup routing. the template is going to replace ng-view
      }
    });

    beaker.run(function($location, $route, $document, bkUtils, bkCoreManager, bkDebug) {
      var user;
      var lastAction = new Date();
      var beakerRootOp = {
          $('.dropdown.open .dropdown-toggle').dropdown('toggle');
        }
      });
      window.bkDebug = bkDebug;
    });

    beaker.run(function(bkEvaluatePluginManager) {
    'bk.cellMenuPluginManager',
    "bk.core",
    'bk.sessionManager',
    "bk.helper",
    "bk.outputLog",
    "bk.recentMenu",
    "bk.session",
  ]);
  module.factory("bkDebug", function(
      $injector, angularUtils, bkEvaluateJobManager, bkCellMenuPluginManager, bkSessionManager,
      bkCoreManager, bkHelper, bkOutputLog, bkRecentMenu, bkSession, bkShare,
      bkTrack, bkUtils, cometdUtils, commonUtils, bkMenuPluginManager, bkEvaluatePluginManager,
      bkEvaluatorManager) {
    return {
      bkCellMenuPluginManager: bkCellMenuPluginManager,
      bkSessionManager: bkSessionManager,
      bkCoreManager: bkCoreManager,
      bkHelper: bkHelper,
      bkOutputLog: bkOutputLog,
      bkRecentMenu: bkRecentMenu,
      bkSession: bkSession,
      commonUtils: commonUtils,
      bkMenuPluginManager: bkMenuPluginManager,
      bkEvaluatePluginManager: bkEvaluatePluginManager,
      bkEvaluatorManager: bkEvaluatorManager
    };
  });
})();
 */
(function() {
  'use strict';
  var module = angular.module('bk.helper', ['bk.utils', 'bk.core', 'bk.share']);
  /**
   * bkHelper
   * - should be the only thing plugins depend on to interact with general beaker stuffs (other than
   *   plugins dynamically
   * - it mostly should just be a subset of bkUtil
   */
  module.factory('bkHelper', function(bkUtils, bkCoreManager, bkShare) {
    var getCurrentApp = function() {
      return bkCoreManager.getBkApp();
    };
    };

    var bkHelper = {

      // beaker (root)
      gotoControlPanel: function() {
      // bkShare
      share: bkShare
    };
    window.bkHelper = bkHelper; // TODO, we want to revisit the decision of making this global
    return bkHelper;
  });
})();
      },
      link: function(scope, element, attrs) {
        var div = element.find(".bkcell").first();
        div.click(function(event) {
          //click in the border or padding should trigger menu
          if (bkUtils.getEventOffsetX(div, event) >= div.width()) {
            var menu = div.find('.bkcellmenu').last();
            menu.find('.dropdown-toggle').first().dropdown('toggle');
            event.stopPropagation();
          }
        });
        div.mousemove(function(event) {
          if (bkUtils.getEventOffsetX(div, event) >= div.width()) {
            div.css('cursor', 'pointer');
          } else {
            div.css('cursor', 'default');
          }
        });
      }
    };
            notebookCellOp.reset();
          }
        });
        $scope.$on("$destroy", function() {
          $scope.bkNotebook.unregisterFocusable($scope.cellmodel.id);
          $scope.bkNotebook.unregisterCM($scope.cellmodel.id);
        });
      },
      link: function(scope, element, attrs) {
        scope.showDebug = false;
          }
          cm.refresh();
        }

        CodeMirror.on(window, "resize", function() {
          var showing = document.body.getElementsByClassName("CodeMirror-fullscreen")[0];
          if (!showing)
            return;
          showing.CodeMirror.getWrapperElement().style.height = winHeight() + "px";
        });
        var moveFocusDown = function() {
          // move focus to next code cell
          var thisCellId = scope.cellmodel.id;
          }
        });
        // cellmodel.body <-- CodeMirror
        scope.cm.on("change", function(cm, e) {
          scope.cellmodel.input.body = cm.getValue();
          bkUtils.refreshRootScope();
        });

        var inputMenuDiv = element.find(".bkcell").first();
        scope.popupMenu = function(event) {
          menu.css("left", clicked ? event.clientX - 150 : "");
          menu.find('.dropdown-toggle').first().dropdown('toggle');
        };
        inputMenuDiv.click(function(event) {
          if (bkUtils.getEventOffsetX(inputMenuDiv, event) >= inputMenuDiv.width()) {
            scope.popupMenu(event);
            event.stopPropagation();
          }
        });
        inputMenuDiv.mousemove(function(event) {
          if (bkUtils.getEventOffsetX(inputMenuDiv, event) >= inputMenuDiv.width()) {
            inputMenuDiv.css('cursor', 'pointer');
          } else {
            inputMenuDiv.css('cursor', 'default');
          }
        });

        if (scope.isInitializationCell()) {
          element.closest(".bkcell").addClass("initcell");
          var cells = [scope.cellmodel];
          return bkUtils.generateNotebook([evaluator], cells);
        };
      }
    };
  });
      },
      link: function(scope, element, attrs) {
        var outputMenuDiv = element.parent('.bkcell');
        outputMenuDiv.click(function(event) {
          //click in the border or padding should trigger menu
          if (bkUtils.getEventOffsetX(outputMenuDiv, event) >= outputMenuDiv.width()) {
            var menu = outputMenuDiv.find('.dropdown').last();
            menu.find('.dropdown-toggle').first().dropdown('toggle');
            event.stopPropagation();
          }
        });
        outputMenuDiv.mousemove(function(event) {
          if (bkUtils.getEventOffsetX(outputMenuDiv, event) >= outputMenuDiv.width()) {
            outputMenuDiv.css('cursor', 'pointer');
          } else {
            outputMenuDiv.css('cursor', 'default');
          }
        });
      }
    };
            bkSessionManager.setNotebookModelEdited(true);
          }
        });
      }
    };
  });
          },
          unregisterFocusable: function (cellId) {
            delete this._focusables[cellId];
          },
          getFocusable: function (cellId) {
            return this._focusables[cellId];
          },
          unregisterCM: function (cellId) {
            delete this._codeMirrors[cellId];
          },
          _cmKeyMapMode: "default",
          setCMKeyMapMode: function (keyMapMode) {
          $(".outputlogout").css("width", width);
          $(".outputlogerr").css("width", width);
        };
        $(window).resize(fixOutputLogPosition);
        $(".outputloghandle").drag("start", function () {
          dragHeight = outputLogHeight;
        });
        $(".outputloghandle").drag(function (ev, dd) {
          outputLogHeight = dragHeight - dd.deltaY;
          if (outputLogHeight < 20) outputLogHeight = 20;
          if (outputLogHeight > window.innerHeight - 50) outputLogHeight = window.innerHeight - 50;
          fixOutputLogPosition();
        });
        $scope.showStdOut = true;
        $scope.showStdErr = true;
        bkOutputLog.getLog(function (res) {
          $scope.outputLog = res;
        });
        bkOutputLog.subscribe(function (reply) {
          if (!_impl._viewModel.isShowingOutput()) {
            _impl._viewModel.toggleShowOutput();
          }
            }
          }
        });
      }
    };
  });
            refresh(scope.type);
          }
        });
      }
    };
  });
          stopAutoBackup();
          bkCoreManager.setBkAppImpl(null);
          $(document).unbind('keydown', keydownHandler);
        };

        // TODO, when use setLocation and leave from bkApp (e.g. to control panel),
            window.open("./");
          } else {
            bkSessionManager.backup().then(function() {
              bkCoreManager.gotoControlPanel();
            });
          }
      reset: function(_cells_) {
        if (_cells_) {
          cells = _cells_;
        }
        this.clipboard = null;
        recreateCellMap();
        $.cometd.removeListener(_statusListener);
      },
      addOutputlogUpdateListener: function (cb) {
        $.cometd.subscribe("/outputlog", cb);
      }
    };
  });
            });
      },
      subscribe: function (cb) {
        cometdUtils.addOutputlogUpdateListener(cb);
      }
    };
  });
        return deferred.promise;
      },
      addConnectedStatusListener: function(cb) {
        cometdUtils.addConnectedStatusListener(cb);
      },

      // wrapper around requireJS

    // Sets up the NATIVE fullscreen editor/previewer for WebKit
    if (nativeFsWebkit) {
      document.addEventListener('webkitfullscreenchange', function () {
        if (!document.webkitIsFullScreen && self._eeState.fullscreen) {
          self._exitFullscreen(fsElement);
        }
      }, false);
    }
    else if (nativeFsMoz) {
      document.addEventListener('mozfullscreenchange', function () {
        if (!document.mozFullScreen && self._eeState.fullscreen) {
          self._exitFullscreen(fsElement);
        }
      }, false);
    }
    else if (nativeFsW3C) {
      document.addEventListener('fullscreenchange', function () {
        if (document.fullscreenElement == null && self._eeState.fullscreen) {
          self._exitFullscreen(fsElement);
        }
      }, false);
    }

    // TODO: Move utilBar stuff into a utilBar setup function (_setupUtilBar)
      self._setupTextareaSync();
    }

    window.addEventListener('resize', function () {
      // If NOT webkit, and in fullscreen, we need to account for browser resizing
      // we don't care about webkit because you can't resize in webkit's fullscreen
      if (self.is('fullscreen')) {
        _applyStyles(self.iframeElement, {
          'width': window.outerWidth + 'px'
        , 'height': window.innerHeight + 'px'
        });

        _applyStyles(self.element, {

        _applyStyles(self.previewerIframe, {
          'width': window.outerWidth / 2 + 'px'
        , 'height': window.innerHeight + 'px'
        });

        _applyStyles(self.editorIframe, {
          'width': window.outerWidth / 2 + 'px'
        , 'height': window.innerHeight + 'px'
        });
      }
      // Makes the editor support fluid width when not in fullscreen mode
      else if (!self.is('fullscreen')) {
        self.reflow();
      }
    });

    // Set states before flipping edit and preview modes
    self._eeState.loaded = true;
      window.clearInterval(self._textareaSaveTimer);
    }

    callback.call(this);
    self.emit('unload');
    return self;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
protected Connection(Builder builder) {
    }

    public boolean isConnected() {
        return socket != null && socket.isConnected() && !socket.isClosed();
    }

    public ServerConnectionInfo getRemoteServer() {
public OutputStream getOutputStream() throws IOException {
     */
    public void kill() throws IOException {
        if (isConnected()) {
            socket.close();
        }
    }
package weloveclouds.communication.services;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import weloveclouds.communication.exceptions.UnableToSendContentToServerException;
import weloveclouds.communication.models.Connection;
import weloveclouds.communication.models.ServerConnectionInfo;

/**
 * The communication module implementation which executes the network operations (connect,
 */
public class CommunicationService implements ICommunicationService {

    private static final Logger LOGGER = Logger.getLogger(CommunicationService.class);

    private SocketFactory socketFactory;
public void send(byte[] content) throws IOException, UnableToSendContentToServer

    @Override
    public byte[] receive() throws IOException, ClientNotConnectedException {
        if (connectionToEndpoint.isConnected()) {
            byte[] receivedData = null;

            InputStream socketDataReader = connectionToEndpoint.getInputStream();

            while (receivedData == null) {
                int availableBytes = socketDataReader.available();
                if (availableBytes != 0) {
                    LOGGER.debug(CustomStringJoiner.join(" ", "Receiving",
                            String.valueOf(availableBytes), "from the connection."));
                    receivedData = new byte[availableBytes];
                    socketDataReader.read(receivedData);
                    LOGGER.debug("Data received from the network.");
                }
            }
            return receivedData;
        } else {
            LOGGER.debug("Client is not connected, so message cannot be received.");
            throw new ClientNotConnectedException();
        }
    }
package weloveclouds.communication.services;


import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import weloveclouds.client.utils.CustomStringJoiner;
import weloveclouds.communication.models.Connection;

/**
 * A communication service that can handle multiple connections concurrently.
 */
public class ConcurrentCommunicationService implements IConcurrentCommunicationService {

    private static final Logger LOGGER = Logger.getLogger(ConcurrentCommunicationService.class);

    @Override
public void send(byte[] message, Connection connection) throws IOException {

    @Override
    public byte[] receiveFrom(Connection connection) throws IOException {
        if (connection.isConnected()) {
            byte[] receivedData = null;
            InputStream socketDataReader = connection.getInputStream();

            while (receivedData == null) {
                int availableBytes = socketDataReader.available();
                if (availableBytes != 0) {
                    LOGGER.debug(CustomStringJoiner.join(" ", "Receiving",
                            String.valueOf(availableBytes), "from the connection."));
                    receivedData = new byte[availableBytes];
                    socketDataReader.read(receivedData);
                    LOGGER.debug("Data received from the network.");
                }
            }

            return receivedData;
        } else {
            String errorMessage = "Client is not connected, so message cannot be received.";
            LOGGER.debug(errorMessage);
            throw new IOException(errorMessage);
        }
public void handleConnection() {
    @Override
    public void run() {
        LOGGER.info("Client is connected to server.");

        while (connection.isConnected()) {
            M response = null;

            try {
                M receivedMessage =
                        messageDeserializer.deserialize(communicationApi.receiveFrom(connection));
                LOGGER.debug(CustomStringJoiner.join(" ", "Message received:",
                        receivedMessage.toString()));

                response = requestFactory.createRequestFromReceivedMessage(receivedMessage)
                        .validate().execute();
            } catch (IllegalRequestException ex) {
                try {
                    response = (M) ex.getResponse();
                } catch (ClassCastException e) {
                    LOGGER.error(e);
                }
            } catch (IOException | DeserializationException e) {
                LOGGER.error(e);
            } catch (Throwable e) {
                LOGGER.fatal(e);
            } finally {
                if (response != null) {
                    try {
                        communicationApi.send(messageSerializer.serialize(response).getBytes(),
                                connection);
                        LOGGER.debug(CustomStringJoiner.join(" ", "Sent response:",
                                response.toString()));
                    } catch (IOException e) {
                        LOGGER.error(e);
                    }
                }
            }
        }

        LOGGER.info("Client is disconnected.");
    }

    /**
     * A builder to create a {@link SimpleConnectionHandler} instance.
     * 
     * @author Benoit
import weloveclouds.server.store.exceptions.StorageException;
import weloveclouds.server.store.models.MovableStorageUnit;
import weloveclouds.server.store.models.MovableStorageUnits;

/**
 * A data move request to the {@link IMovableDataAccessService}, which moves a range of the data

    private static final Logger LOGGER = Logger.getLogger(MoveDataToDestination.class);

    // 1 entry (max.): 20 byte key, 120 kbyte value -> 140 kbyte + some java object metadata
    private static final int NUMBER_OF_STORAGE_UNITS_TO_BE_TRANSFERRED_AT_ONCE = 100;

    private IMovableDataAccessService dataAccessService;
    private RingMetadataPart targetServerInfo;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
else if (pref_expand && !pref_share_action && CURRENT_ANDROID_VERSION >= 16) {
                            .build();
                }
                nm.notify(id, n);
                finish();
            }
            // alarm time has past, show toast
public NoteyNote getNotey(int id) {

        //build the object
        NoteyNote notey = new NoteyNote();
        notey.setId(Integer.parseInt(cursor.getString(0)));
        notey.setNote(cursor.getString(1));
        notey.setIcon(cursor.getInt(2));
        notey.setSpinnerLoc(cursor.getInt(3));
        notey.setImgBtnNum(cursor.getInt(4));
        notey.setTitle(cursor.getString(5));
        notey.setIconName(cursor.getString(6));
        notey.setAlarm(cursor.getString(7));

        return notey;
    }
public NoteyNote getNotey(int id) {
                noteyList.add(notey);
            } while (cursor.moveToNext());
        }
        return noteyList;
    }

boolean checkIfExist(int id) {
        } catch (SQLiteException e) {
            e.printStackTrace();
        }
        return cursor.getCount() > 0;

    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
version https://git-lfs.github.com/spec/v1
oid sha256:53aa6c58b89a59035b0cbb3a08ccd5e588b9fad2e94170807fab9163d80e21a4
size 15639888
package io.github.projectchroma.chroma.util;

import java.io.File;

import org.newdawn.slick.Image;
import org.newdawn.slick.SlickException;

public class FileIO{
	public static final File SCREENSHOT_DIR = new File("screenshots");
	public static void init(){
		Settings.SETTINGS_DIR.mkdirs();
		SCREENSHOT_DIR.mkdirs();
	}
	public static File saveScreenshot(Image img) throws SlickException{
		File screenshot;
		
		int i = 0;
		do{
			screenshot = new File(SCREENSHOT_DIR, i++ + ".png");
		}while(screenshot.exists());
		ImageOut.write(img, screenshot.toString());
		return screenshot;
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public static SslProvider getSslProvider() {
        if (OpenSsl.isAvailable()) {
            if (OpenSsl.isAlpnSupported()) {
                log.info("Native SSL provider is available and supports ALPN; will use native provider.");
                sslProvider = SslProvider.OPENSSL_REFCNT;
            } else {
                log.info("Native SSL provider is available, but does not support ALPN; will use JDK SSL provider.");
                sslProvider = SslProvider.JDK;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import javaslang.Tuple3;
import javaslang.collection.IteratorModule.ConcatIterator;
import javaslang.collection.IteratorModule.DistinctIterator;
import javaslang.control.Option;

import java.math.BigDecimal;
import static java.lang.Double.NEGATIVE_INFINITY;
import static java.lang.Double.POSITIVE_INFINITY;
import static java.math.RoundingMode.HALF_UP;
import static javaslang.collection.IteratorModule.BigDecimalHelper.areEqual;
import static javaslang.collection.IteratorModule.BigDecimalHelper.asDecimal;
import static javaslang.collection.IteratorModule.EmptyIterator;
default T get() {

    @Override
    default Iterator<Seq<T>> grouped(int size) {
        return sliding(size, size);
    }

    @Override
    default boolean hasDefiniteSize() {
        return false;
public boolean hasNext() {

    @Override
    default Iterator<Seq<T>> sliding(int size, int step) {
        if (size <= 0 || step <= 0) {
            throw new IllegalArgumentException("size: " + size + " or step: " + step + " not positive");
        }
        if (!hasNext()) {
            return empty();
        } else {
            final Stream<T> source = Stream.ofAll(this);
            return new AbstractIterator<Seq<T>>() {
                private Stream<T> that = source;
                private IndexedSeq<T> next = null;

                @Override
                public boolean hasNext() {
                    while (next == null && !that.isEmpty()) {
                        final Tuple2<Stream<T>, Stream<T>> split = that.splitAt(size);
                        next = split._1.toVector();
                        that = split._2.isEmpty() ? Stream.empty() : that.drop(step);
                    }
                    return next != null;
                }

                @Override
                public IndexedSeq<T> getNext() {
                    final IndexedSeq<T> result = next;
                    next = null;
                    return result;
                }
            };
        }
    }

    @Override
    default Tuple2<Iterator<T>, Iterator<T>> span(Predicate<? super T> predicate) {
        Objects.requireNonNull(predicate, "predicate is null");
public String toString() {
        }
    }

    final class BigDecimalHelper {

        @GwtIncompatible("Math::nextDown is not implemented")

    @Override
    default List<T> drop(int n) {
        List<T> list = this;
        for (long i = n; i > 0 && !list.isEmpty(); i--) {
            list = list.tail();
default String stringPrefix() {

    @Override
    default List<T> take(int n) {
        if (n >= length()) {
            return this;
        }
        if (n <= 0) {
            return empty();
        }
        List<T> result = Nil.instance();
        List<T> list = this;
        for (int i = 0; i < n; i++, list = list.tail()) {
default String stringPrefix() {

    @Override
    default List<T> takeRight(int n) {
        if (n >= length()) {
            return this;
        }
        if (n <= 0) {
            return empty();
        }
        return reverse().take(n).reverse();
    }

public void shouldSlide4ElementsBySize5AndStep3() {
        assertThat(actual).isEqualTo(expected);
    }

    // -- span

    @Test
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void reset(final boolean keepGlobals) {

        clearUpdateListeners();

        cleanupTasks.clear();

        profiler.reset();
        
        analyzed = false;
public void runCleanupTasks() {
                LOG.error("Cleaning up XQueryContext: Ignoring: " + t.getMessage(), t);
            }
        }
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static void  jni_ngx_http_clojure_socket_connect_handler(ngx_http_clojure_socket

static void  jni_ngx_http_clojure_socket_release_handler(ngx_http_clojure_socket_upstream_t *u, ngx_int_t sc) {
	(*jvm_env)->CallVoidMethod(jvm_env, (jobject)u->context, nc_socket_handler_release_mid, (jlong)(uintptr_t)u, (jlong)sc);
	exception_handle(0 == 0, jvm_env, (*jvm_env)->DeleteGlobalRef(jvm_env, (jobject)u->context));
}

static jlong JNICALL jni_ngx_http_clojure_socket_create(JNIEnv *env, jclass cls, jobject handler) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public EMExoPlayer(@Nullable RenderBuilder rendererBuilder) {

    public void replaceRenderBuilder(@Nullable RenderBuilder renderBuilder) {
        this.rendererBuilder = renderBuilder;
        if (rendererBuilder != null && audioCapabilities == null) {
            audioCapabilitiesReceiver = new AudioCapabilitiesReceiver(rendererBuilder.getContext(), this);
            audioCapabilitiesReceiver.register();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
﻿11/8/2014 0.8.0b
  Added Certus Quartz Duplication.
  Added configuration option to disable certus duplication.

10/29/2014 0.7.4b
  Bugfix: Import/Export buses got caught in a loop and imported a full jar amount on neighbor change.
  IO bus redstone pulse mode now works properly
  Bugfix: Export bus would not export into reservoir if aspect to export, and aspect in reservoir did not match.
  Compatibility fix with ExtraCells2: Server crash when exporting essentia gas using the Fluid Formation Plane.
  Notice: Essentia gas will simply disperse if exported using the Fluid Formation Plane.

package thaumicenergistics.blocks;

import net.minecraft.block.Block;
import net.minecraft.block.BlockContainer;
import net.minecraft.block.material.Material;
import net.minecraft.client.renderer.texture.IIconRegister;
import net.minecraft.entity.player.EntityPlayer;
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;

public abstract class BlockGearBoxBase
	extends BlockContainer
{
	/**
	 * Determines if thaumcraft golems are allowed to interact with the gearbox.
	/**
	 * Creates the block.
	 */
	public BlockGearBoxBase()
	{
		// Set material type
		super( Material.ground );
public BlockGearBoxBase()

		// Set sound type
		this.setStepSound( Block.soundTypeStone );
	}

	/**
public final boolean isOpaqueCube()
	 * Is solid.
	 */
	@Override
	public boolean isSideSolid( final IBlockAccess world, final int x, final int y, final int z, final ForgeDirection side )
	{
		// This is a solid cube
		return true;
public boolean isSideSolid( final IBlockAccess world, final int x, final int y,
	 * Determine if the tile should be cranked.
	 */
	@Override
	public boolean onBlockActivated( final World w, final int x, final int y, final int z, final EntityPlayer p, final int side, final float hitX,
										final float hitY, final float hitZ )
	{
		// Fake player?
		if( p instanceof FakePlayer )
		{
			// Are golems allowed to interact?
			if( !this.allowGolemInteraction )
			{
				// Golem interaction not allowed
				return false;
			}

			// Is the fake player a golem?
			if( !p.getGameProfile().getName().equalsIgnoreCase( "FakeThaumcraftGolem" ) )
			{
				// Not a golem
				return false;
			}
		}

		// Get the tile
		TileGearBox gearBox = (TileGearBox)w.getTileEntity( x, y, z );

		// Crank it
		return gearBox.crank();
	}

	/**
package thaumicenergistics.blocks;

import net.minecraft.block.Block;
import net.minecraft.block.BlockContainer;
import net.minecraft.block.material.Material;
import net.minecraft.client.renderer.texture.IIconRegister;
import net.minecraft.entity.EntityLivingBase;
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;

public abstract class BlockProviderBase
	extends BlockContainer
{

	protected BlockProviderBase( final Material material )
	{
		super( material );

public final boolean isOpaqueCube()
	}

	@Override
	public boolean isSideSolid( final IBlockAccess world, final int x, final int y, final int z, final ForgeDirection side )
	{
		// This is a solid cube
		return true;
public final int onBlockPlaced( final World world, final int x, final int y, fin
	}

	@Override
	public void onBlockPlacedBy( final World world, final int x, final int y, final int z, final EntityLivingBase entity, final ItemStack itemstack )
	{
		// Set the owner
		if( entity instanceof EntityPlayer )
 * 
 */
public class BlockEssentiaProvider
	extends BlockProviderBase
{

	public BlockEssentiaProvider()
import thaumicenergistics.texture.BlockTextureManager;

public class BlockGearBox
	extends BlockGearBoxBase
{
	@Override
	public IIcon getIcon( final int side, final int meta )
import thaumicenergistics.texture.BlockTextureManager;

public class BlockGolemGearBox
	extends BlockGearBoxBase
{

	public BlockGolemGearBox()
import cpw.mods.fml.relauncher.SideOnly;

public class BlockInfusionProvider
	extends BlockProviderBase
{

	public BlockInfusionProvider()
public ContainerPartArcaneCraftingTerminal( final AEPartArcaneCraftingTerminal t
		// Set wand slot number
		this.wandSlotNumber = wandSlot.slotNumber;

		// Register the container with terminal
		terminal.registerListener( this );

		// Is this server side?
		if( EffectiveSide.isServerSide() )
		{
			// Get the AE monitor
			this.monitor = terminal.getGridBlock().getItemMonitor();

public ContainerPartArcaneCraftingTerminal( final AEPartArcaneCraftingTerminal t
				this.monitor.addListener( this, null );
			}
		}

	}

	/**
public void onClientRequestExtract( final EntityPlayer player, final IAEItemStac
				else
				{
					// Half amount up to half of maxStackSize
					amountToExtract = (int)Math.min( maxStackSize / 2L, requestedStack.getStackSize() / 2L );
				}
				break;

public void onContainerClosed( final EntityPlayer player )
		// Pass to super
		super.onContainerClosed( player );

		if( this.terminal != null )
		{
			this.terminal.removeListener( this );
		}

		// Is this server side?
		if( EffectiveSide.isServerSide() )
		{
			if( this.monitor != null )
			{
				this.monitor.removeListener( this );
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.inventory.Slot;
import net.minecraft.item.ItemStack;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.StatCollector;
import org.lwjgl.input.Keyboard;
import org.lwjgl.input.Mouse;
import appeng.api.config.ViewItems;
import appeng.api.storage.data.IAEItemStack;
import appeng.api.storage.data.IItemList;
import appeng.client.gui.AEBaseGui;
import appeng.client.gui.widgets.GuiScrollbar;
import appeng.client.gui.widgets.ISortSource;
import appeng.client.me.ItemRepo;
import appeng.client.render.AppEngRenderItem;
	private final ItemRepo repo;

	/**
	 * Scroll bar
	 */
	private final GuiScrollbar scrollBar;

	/**
	 * Serves as a graphics call bridge for the scroll bar.
	 */
	private AEBaseGui aeGuiBridge;

	/**
	 * True if the scroll bar has mouse focus.
	 */
	private boolean isScrollBarHeld = false;

	/**
	 * The last Y position of the mouse when the scroll bar has mouse focus.
	 */
	private int scrollHeldPrevY = 0;

	/**
	 * How the items are sorted.
	 */
	private SortOrder sortingOrder = SortOrder.NAME;

	/**
	 * What direction are the items sorted.
	 */
	private SortDir sortingDirection = SortDir.ASCENDING;

	public GuiArcaneCraftingTerminal( final AEPartArcaneCraftingTerminal part, final EntityPlayer player )
	{
public GuiArcaneCraftingTerminal( final AEPartArcaneCraftingTerminal part, final
			}
		}

		// Create the scrollbar
		this.scrollBar = new GuiScrollbar();

		// Create the repo
		this.repo = new ItemRepo( this.scrollBar, this );

protected void drawGuiContainerBackgroundLayer( final float alpha, final int mou
	@Override
	protected void drawGuiContainerForegroundLayer( final int mouseX, final int mouseY )
	{
		// Draw the title
		this.fontRendererObj.drawString( this.guiTitle, AbstractGuiConstantsACT.TITLE_POS_X, AbstractGuiConstantsACT.TITLE_POS_Y, 0x000000 );

		// Draw the search field.
		this.searchField.drawTextBox();

		// Draw the scroll bar
		this.scrollBar.draw( this.aeGuiBridge );

		// Enable lighting
		GL11.glEnable( GL11.GL_LIGHTING );

protected void drawGuiContainerForegroundLayer( final int mouseX, final int mous
			this.drawCraftingAspects( craftingCost );
		}

		// Do we have a widget under the mouse?
		if( widgetUnderMouse != null )
		{
			// Get the tooltip from the widget
			widgetUnderMouse.getTooltip( this.tooltip );
		}
		else
		{
			// Get the tooltip from the buttons
			this.addTooltipFromButtons( mouseX, mouseY );
		}

		// Draw the tooltip
		this.drawTooltip( mouseX - this.guiLeft, mouseY - this.guiTop );

	}

	/**
	 * Called when the player types a key.
	 */
	@Override
else if( this.searchField.isFocused() )
				this.updateMEWidgets();
			}
		}
		// Home Key
		else if( keyID == Keyboard.KEY_HOME )
		{
			// Move the scroll all the way to home
			this.scrollBar.click( this.aeGuiBridge, AbstractGuiConstantsACT.SCROLLBAR_POS_X + 1, AbstractGuiConstantsACT.SCROLLBAR_POS_Y + 1 );
			this.scrollBar.wheel( 1 );
			this.updateMEWidgets();
		}
		// End Key
		else if( keyID == Keyboard.KEY_END )
		{
			// Move the scroll all the way to end
			this.scrollBar.click( this.aeGuiBridge, AbstractGuiConstantsACT.SCROLLBAR_POS_X + 1, AbstractGuiConstantsACT.SCROLLBAR_VERTICAL_BOUND );
			this.updateMEWidgets();

		}
		// Up Key
		else if( keyID == Keyboard.KEY_UP )
		{
			this.scrollBar.wheel( 1 );
			this.updateMEWidgets();
		}
		// Down Key
		else if( keyID == Keyboard.KEY_DOWN )
		{
			this.scrollBar.wheel( -1 );
			this.updateMEWidgets();
		}
		else
		{
			super.keyTyped( key, keyID );
protected void mouseClicked( final int mouseX, final int mouseY, final int mouse
			}
		}

		// Is the mouse over the scroll bar area?
		if( GuiHelper.instance.isPointInGuiRegion( AbstractGuiConstantsACT.SCROLLBAR_POS_Y, AbstractGuiConstantsACT.SCROLLBAR_POS_X,
			AbstractGuiConstantsACT.SCROLLBAR_HEIGHT, this.scrollBar.getWidth(), mouseX, mouseY, this.guiLeft, this.guiTop ) )
		{
			// The scroll bar now has mouse focus
			this.isScrollBarHeld = true;

			// Mark this Y
			this.scrollHeldPrevY = mouseY;

			// Jump the scroll to the mouse
			this.scrollBar.click( this.aeGuiBridge, mouseX - this.guiLeft, mouseY - this.guiTop );

			// Update the widgets
			this.updateMEWidgets();

			// Do not pass to super
			return;
		}

		// Was the mouse right-clicked over the search field?
		if( ( mouseButton == GuiHelper.MOUSE_BUTTON_RIGHT ) &&
						GuiHelper.instance.isPointInGuiRegion( AbstractGuiConstantsACT.SEARCH_POS_Y, AbstractGuiConstantsACT.SEARCH_POS_X,
protected void mouseClicked( final int mouseX, final int mouseY, final int mouse
		super.mouseClicked( mouseX, mouseY, mouseButton );
	}

	/**
	 * Called when a button is clicked.
	 */
public void actionPerformed( final GuiButton button )
		}
	}

	@Override
	public void drawScreen( final int mouseX, final int mouseY, final float mouseBtn )
	{
		// Call super
		super.drawScreen( mouseX, mouseY, mouseBtn );

		// Is the mouse holding the scroll bar?
		if( this.isScrollBarHeld )
		{
			// Is the mouse button still being held down?
			if( Mouse.isButtonDown( GuiHelper.MOUSE_BUTTON_LEFT ) )
			{
				// Has the Y changed?
				if( mouseY == this.scrollHeldPrevY )
				{
					return;
				}

				boolean correctForZero = false;

				// Mark the Y
				this.scrollHeldPrevY = mouseY;

				// Calculate the Y position for the scroll bar
				int repY = mouseY - this.guiTop;

				// Has the mouse exceeded the 'upper' bound?
				if( repY > AbstractGuiConstantsACT.SCROLLBAR_VERTICAL_BOUND )
				{
					repY = AbstractGuiConstantsACT.SCROLLBAR_VERTICAL_BOUND;
				}
				// Has the mouse exceeded the 'lower' bound?
				else if( repY <= AbstractGuiConstantsACT.SCROLLBAR_POS_Y )
				{
					repY = AbstractGuiConstantsACT.SCROLLBAR_POS_Y;

					// We will have to correct for zero
					correctForZero = true;
				}

				// Update the scroll bar
				this.scrollBar.click( this.aeGuiBridge, AbstractGuiConstantsACT.SCROLLBAR_POS_X + 1, repY );

				// Should we correct for zero?
				if( correctForZero )
				{
					this.scrollBar.wheel( 1 );
				}

				// Update the widgets
				this.updateMEWidgets();
			}
			else
			{
				// The scroll bar no longer has mouse focus
				this.isScrollBarHeld = false;
			}
		}

	}

	/**
	 * Gets the sorting order.
	 */
public void initGui()
		this.buttonList.add( new ButtonClearCraftingGrid( AbstractGuiConstantsACT.BUTTON_CLEAR_GRID_ID, this.guiLeft +
						AbstractGuiConstantsACT.BUTTON_CLEAR_GRID_POS_X, this.guiTop + AbstractGuiConstantsACT.BUTTON_CLEAR_GRID_POS_Y, 8, 8 ) );

		// Create the AE bridge
		this.aeGuiBridge = new AEBaseGui( this.inventorySlots )
		{

			@Override
			public void bindTexture( final String file )
			{
				this.bindTexture( "appliedenergistics2", file );
			}

			@Override
			public void bindTexture( final String base, final String file )
			{
				GuiArcaneCraftingTerminal.this.mc.getTextureManager().bindTexture( new ResourceLocation( base, "textures/" + file ) );
			}

			@Override
			public void drawBG( final int arg0, final int arg1, final int arg2, final int arg3 )
			{
				// Ignored
			}

			@Override
			public void drawFG( final int arg0, final int arg1, final int arg2, final int arg3 )
			{
				// Ignored
			}

			@Override
			public void drawTexturedModalRect( final int posX, final int posY, final int sourceOffsetX, final int sourceOffsetY, final int width,
												final int height )
			{
				GuiArcaneCraftingTerminal.this.drawTexturedModalRect( posX, posY, sourceOffsetX, sourceOffsetY, width, height );
			}
		};

		// Setup the scroll bar
		this.scrollBar.setLeft( AbstractGuiConstantsACT.SCROLLBAR_POS_X ).setTop( AbstractGuiConstantsACT.SCROLLBAR_POS_Y )
						.setHeight( AbstractGuiConstantsACT.SCROLLBAR_HEIGHT );

		// No scrolling until we get items
		this.scrollBar.setRange( 0, 0, 1 );

		// Add sort order button
		this.buttonList.add( new ButtonSortingMode( AbstractGuiConstantsACT.BUTTON_SORT_ORDER_ID, this.guiLeft +
						AbstractGuiConstantsACT.BUTTON_SORT_ORDER_POS_X, this.guiTop + AbstractGuiConstantsACT.BUTTON_SORT_ORDER_POS_Y,
	 * @param z
	 * Z position of the chest.
	 */
	public GuiEssentiaCell( EntityPlayer player, World world, int x, int y, int z )
	{
		super( player, new ContainerEssentiaCell( player, world, x, y, z ) );
	}

	@Override
	protected void sortModeButtonClicked( ComparatorMode modeRequested )
	{
		// Pass to the container
		( (ContainerEssentiaCell)this.inventorySlots ).sendSortModeChangeRequest( modeRequested );
	 * @param player
	 * Player viewing the gui.
	 */
	public GuiEssentiaLevelEmitter( AEPartEssentiaLevelEmitter part, EntityPlayer player )
	{
		// Call super
		super( new ContainerPartEssentiaLevelEmitter( part, player ) );
public GuiEssentiaLevelEmitter( AEPartEssentiaLevelEmitter part, EntityPlayer pl
	 * Draw the gui background
	 */
	@Override
	protected void drawGuiContainerBackgroundLayer( float alpha, int mouseX, int mouseY )
	{
		// Full white
		GL11.glColor4f( 1.0F, 1.0F, 1.0F, 1.0F );
protected void drawGuiContainerBackgroundLayer( float alpha, int mouseX, int mou
	 * Called when the player types a key
	 */
	@Override
	protected void keyTyped( char key, int keyID )
	{
		// Pass to super
		super.keyTyped( key, keyID );
protected void keyTyped( char key, int keyID )
	 * Called when the player clicks a mouse button
	 */
	@Override
	protected void mouseClicked( int mouseX, int mouseY, int mouseBtn )
	{
		// Pass to super
		super.mouseClicked( mouseX, mouseY, mouseBtn );
protected void mouseClicked( int mouseX, int mouseY, int mouseBtn )
	 * Called when a button is clicked.
	 */
	@Override
	public void actionPerformed( GuiButton button )
	{
		// Get the index of the button that was clicked
		int index = button.id;
else if( index == GuiEssentiaLevelEmitter.REDSTONE_MODE_BUTTON_INDEX )
	 * Draw the foreground
	 */
	@Override
	public void drawGuiContainerForegroundLayer( int mouseX, int mouseY )
	{
		// Draw the title
		this.fontRendererObj.drawString( AEPartsEnum.EssentiaLevelEmitter.getStatName(), GuiEssentiaLevelEmitter.TITLE_POS_X,
public void drawGuiContainerForegroundLayer( int mouseX, int mouseY )
		if( this.addTooltipFromButtons( mouseX, mouseY ) )
		{
			// Draw the tooltip
			this.drawTooltip( mouseX - this.guiLeft, mouseY - this.guiTop );
		}
	}

	/**
	 * Draws the screen and all the components in it.
	 */
	@Override
	public void drawScreen( int x, int y, float f )
	{
		// Call super
		super.drawScreen( x, y, f );
public void onGuiClosed()
	 * 
	 * @param mode
	 */
	public void onServerUpdateRedstoneMode( RedstoneMode mode )
	{
		( (ButtonRedstoneModes)this.buttonList.get( GuiEssentiaLevelEmitter.REDSTONE_MODE_BUTTON_INDEX ) ).setRedstoneMode( mode );
	}
public void onServerUpdateRedstoneMode( RedstoneMode mode )
	 * 
	 * @param amount
	 */
	public void onServerUpdateWantedAmount( long amount )
	{
		this.amountField.setText( Long.toString( amount ) );
	}

	public boolean setFilteredAspectFromItemstack( ItemStack itemStack )
	{
		Aspect itemAspect = EssentiaItemContainerHelper.instance.getAspectInContainer( itemStack );

public boolean setFilteredAspectFromItemstack( ItemStack itemStack )
	 * Sets the filtered aspect
	 */
	@Override
	public void updateAspects( List<Aspect> aspectList )
	{
		if( ( aspectList == null ) || ( aspectList.isEmpty() ) )
		{
public void drawGuiContainerForegroundLayer( final int mouseX, final int mouseY
		}

		// Draw the tooltip
		this.drawTooltip( mouseX - this.guiLeft, mouseY - this.guiTop );
	}

	@Override
	 * @param partBus
	 * @param player
	 */
	public GuiEssentiatIO( AEPartEssentiaIO partBus, EntityPlayer player )
	{
		// Call super
		super( new ContainerPartEssentiaIOBus( partBus, player ) );
else if( partBus instanceof AEPartEssentiaExportBus )
	 * Draws the GUI background layer
	 */
	@Override
	protected void drawGuiContainerBackgroundLayer( float alpha, int mouseX, int mouseY )
	{
		// Full white
		GL11.glColor4f( 1.0F, 1.0F, 1.0F, 1.0F );
protected void drawGuiContainerBackgroundLayer( float alpha, int mouseX, int mou
	 * Called when the mouse is clicked.
	 */
	@Override
	protected void mouseClicked( int mouseX, int mouseY, int mouseButton )
	{
		// Call super
		super.mouseClicked( mouseX, mouseY, mouseButton );
protected void mouseClicked( int mouseX, int mouseY, int mouseButton )
	 * Called when a button is pressed
	 */
	@Override
	public void actionPerformed( GuiButton button )
	{
		// Call super
		super.actionPerformed( button );
public void actionPerformed( GuiButton button )
	}

	@Override
	public void drawGuiContainerForegroundLayer( int mouseX, int mouseY )
	{
		// Call super
		super.drawGuiContainerForegroundLayer( mouseX, mouseY );
public void drawGuiContainerForegroundLayer( int mouseX, int mouseY )
		}

		// Draw the tooltip
		this.drawTooltip( mouseX - this.guiLeft, mouseY - this.guiTop );
	}

	@Override
public void initGui()
	 * 
	 * @param filterSize
	 */
	public void onReceiveFilterSize( byte filterSize )
	{
		// Inform our part
		this.part.receiveFilterSize( filterSize );
public void onReceiveFilterSize( byte filterSize )
	 * 
	 * @param newRedstoneControled
	 */
	public void onReceiveRedstoneControlled( boolean newRedstoneControled )
	{
		// Do we differ?
		if( this.redstoneControlled != newRedstoneControled )
public void onReceiveRedstoneControlled( boolean newRedstoneControled )
		}
	}

	public void onReceiveRedstoneMode( RedstoneMode redstoneMode )
	{
		// Are we redstone controlled, and have the redstone mod button
		if( this.redstoneControlled && ( this.buttonList.size() > 0 ) )
public void onReceiveRedstoneMode( RedstoneMode redstoneMode )
	}

	@Override
	public void updateAspects( List<Aspect> aspectList )
	{
		// Inform our part
		this.part.receiveFilterList( aspectList );

			public final int width;

			private EnumButtonWidth( int width )
			{
				this.width = width;
			}
private EnumButtonWidth( int width )
		 * @param buttonWidth
		 * @param amount
		 */
		public AdjustmentButtonDef( EnumButtonWidth buttonWidth, int amount )
		{
			// Set the width
			this.width = buttonWidth.width;
public AdjustmentButtonDef( EnumButtonWidth buttonWidth, int amount )
		 * @param yPosition
		 * @return
		 */
		public GuiButton makeButton( int ID, int xPosition, int yPosition )
		{
			return new GuiButton( ID, xPosition, yPosition, this.width, AdjustmentButtonDef.BUTTON_HEIGHT, this.caption );
		}
public GuiButton makeButton( int ID, int xPosition, int yPosition )
	 * @param host
	 * @param player
	 */
	public GuiPriority( IPriorityHost host, EntityPlayer player )
	{
		// Call super and pass the priority container
		super( new ContainerPriority( host, player ) );
public GuiPriority( IPriorityHost host, EntityPlayer player )
	}

	@Override
	protected void drawGuiContainerBackgroundLayer( float alpha, int mouseX, int mouseY )
	{
		// Full white
		GL11.glColor4f( 1.0F, 1.0F, 1.0F, 1.0F );
protected void drawGuiContainerBackgroundLayer( float alpha, int mouseX, int mou
	 * Called when the player types a key
	 */
	@Override
	protected void keyTyped( char key, int keyID )
	{
		// Pass to super
		super.keyTyped( key, keyID );
protected void keyTyped( char key, int keyID )
	 * Called when a button is clicked.
	 */
	@Override
	public void actionPerformed( GuiButton button )
	{
		// Was the priority button clicked?
		if( button.id == GuiPriority.PART_SWITCH_BUTTON_ID )
public void actionPerformed( GuiButton button )
	 * Draw the foreground
	 */
	@Override
	public void drawGuiContainerForegroundLayer( int mouseX, int mouseY )
	{
		// Draw the title
		this.fontRendererObj.drawString( this.title, GuiPriority.TITLE_POS_X, GuiPriority.TITLE_POS_Y, 0 );
public void drawGuiContainerForegroundLayer( int mouseX, int mouseY )
		if( this.addTooltipFromButtons( mouseX, mouseY ) )
		{
			// Draw the tooltip
			this.drawTooltip( mouseX - this.guiLeft, mouseY - this.guiTop );
		}
	}

public void onGuiClosed()
	 * 
	 * @param priority
	 */
	public void onServerSendPriority( int priority )
	{
		// Set the textbox text
		this.amountField.setText( Integer.toString( priority ) );
public Bounds( final int t, final int l, final int b, final int r )
	 * Thickness of the tooltip's borders.
	 */
	private static final int TOOLTIP_BORDER_SIZE = 3;
	

	/**
	 * Lines to draw when drawTooltip is called.
private final void drawTooltipBorders( final Bounds bounds, final int colorStart

	/**
	 * Adds to the tooltip based on which button the mouse is over.
	 * @param mouseX
	 * @param mouseY
	 * @return True when a tooltip was added, false otherwise.
	 */
	protected boolean addTooltipFromButtons( int mouseX, int mouseY )
	{
		// Is the mouse over any buttons?
		for( Object obj : this.buttonList )
protected boolean addTooltipFromButtons( int mouseX, int mouseY )
				}
			}
		}
		
		return false;
	}

protected boolean addTooltipFromButtons( int mouseX, int mouseY )
	 * @param posY
	 * Y anchor position to draw the tooltip. Generally the mouse's Y position.
	 */
	protected final void drawTooltip( int posX, int posY )
	{
		if( !this.tooltip.isEmpty() )
		{
protected final void drawTooltip( int posX, int posY )

			// Disable depth testing
			GL11.glDisable( GL11.GL_DEPTH_TEST );
			
			// Bounds check the position
			if( posY < 0 )
			{
				posY = 0;
			}
			

			// Assume string length is zero
			int maxStringLength_px = 0;
protected final void drawTooltip( int posX, int posY )

			// Reenable scaling
			GL11.glEnable( GL12.GL_RESCALE_NORMAL );
			
			// Clear the tooltip
			this.tooltip.clear();
		}
	}

 */
@SideOnly(Side.CLIENT)
public abstract class AbstractGuiCellTerminalBase
	extends AbstractGuiWidgetHost
	implements IAspectSelectorGui
{

	/**
	 * Width of the gui
	 */
	private static final int GUI_SIZE_X = 176;

	/**
	 * Height of the gui
	private static final int SORT_MODE_BUTTON_ID = 0;

	/**
	 * Local translation of the title.
	 */
	private final String guiTitle;
private void sortMatchingList()
	}

	/**
	 * Updates the scroll position based on mouse wheel movement.
	 */
	private void updateScrollPosition()
	{
		// Get the mouse wheel movement
		int deltaMouseWheel = Mouse.getDWheel();

		if( deltaMouseWheel < 0 )
		{
			this.currentScroll++ ;
		}
		else if( deltaMouseWheel > 0 )
		{
			this.currentScroll-- ;
		}

		// Lower Bounds check the scrolling
		if( this.currentScroll < 0 )
		{
			this.currentScroll = 0;
		}
		else
		{
			// Get how many rows is required for the display-able widgets
			int requiredRows = (int)Math.ceil( (double)this.matchingSearchWidgets.size() / (double)AbstractGuiCellTerminalBase.WIDGETS_PER_ROW );

			// Subtract from the required rows the starting row
			int rowsToDraw = requiredRows - this.currentScroll;

			// Calculate how many blank rows that would leave
			int blankRows = AbstractGuiCellTerminalBase.ROWS_PER_PAGE - rowsToDraw;

			// Would that scroll leave any blank rows?
			if( blankRows > 0 )
			{
				// Subtract the blank rows from the scroll, bounding to 0
				this.currentScroll = Math.max( 0, this.currentScroll - blankRows );
			}

		}
	}

private void updateSearch()
		// Sort
		this.sortMatchingList();

	}

	/**
protected void drawGuiContainerBackgroundLayer( final float alpha, final int siz
	@Override
	protected void drawGuiContainerForegroundLayer( final int mouseX, final int mouseY )
	{
		// Draw the title
		this.fontRendererObj.drawString( this.guiTitle, AbstractGuiCellTerminalBase.TITLE_POS_X, AbstractGuiCellTerminalBase.TITLE_POS_Y, 0 );

protected void drawGuiContainerForegroundLayer( final int mouseX, final int mous
		}

		// Draw the tooltip
		this.drawTooltip( mouseX - this.guiLeft, mouseY - this.guiTop );
	}

	/**
protected void keyTyped( final char key, final int keyID )
			// Slot the screen.
			this.mc.thePlayer.closeScreen();
		}
		else
		{
			// Get the search term
			this.searchTerm = this.searchBar.getText().trim().toLowerCase();

			// Re-search the widgets
			this.updateSearch();
		}

	}

protected void mouseClicked( final int mouseX, final int mouseY, final int mouse

	}

	protected abstract void sortModeButtonClicked( ComparatorMode modeRequested );

	/**
public void drawWidgets( final int mouseX, final int mouseY )
		// Anything to draw?
		if( !this.matchingSearchWidgets.isEmpty() )
		{
			// Get the scroll position
			this.updateScrollPosition();

			// Calculate the starting index
			int startingIndex = this.currentScroll * AbstractGuiCellTerminalBase.WIDGETS_PER_ROW;

public AspectStack getSelectedAspect()
	}

	/**
	 * Sets the gui up.
	 */
	@Override
public void updateAspects()
			this.aspectWidgets.add( new WidgetAspectSelector( this, aspectStack, 0, 0, this.player ) );
		}

		// Update the search results
		this.updateSearch();

 * 
 */
public abstract class AbstractGuiConstantsACT
	extends AbstractGuiWidgetHost
{

	/**
	 * Minimum transparency of the aspect if there is not enough in the wand.
	 */
	protected static final float ASPECT_COST_MAX_ALPHA = 0.75F;
	
	/**
	 * ID of the clear grid button
	 */
	protected static final int BUTTON_SORT_ORDER_ID = 1;

	protected static final int BUTTON_SORT_ORDER_POS_X = -18;
	
	protected static final int BUTTON_SORT_ORDER_POS_Y = 8;

	protected static final int BUTTON_SORT_DIR_ID = 2;

	protected static final int BUTTON_SORT_DIR_POS_X = BUTTON_SORT_ORDER_POS_X;
	
	protected static final int BUTTON_SORT_DIR_POS_Y = BUTTON_SORT_ORDER_POS_Y + 20;
	
	protected static final int BUTTON_SORT_SIZE = 16;

	/**
	 * Y position of the scroll bar
	 */
	protected static final int SCROLLBAR_POS_Y = 18;
	
	/**
	 * Height of the scroll bar
	 */
	protected static final int SCROLLBAR_HEIGHT = 52;
	
	/**
	 * Position + Height of the scroll bar.
	 */
	protected static final int SCROLLBAR_VERTICAL_BOUND = AbstractGuiConstantsACT.SCROLLBAR_HEIGHT + AbstractGuiConstantsACT.SCROLLBAR_POS_Y;

	/**
	 * X offset to draw the search field.
	 */
	protected static final int TITLE_POS_Y = 6;

	public AbstractGuiConstantsACT( final Container container )
	{
		super( container );
	 * @param yPos
	 * @param aeItemRenderer
	 */
	public WidgetAEItem( IWidgetHost hostGUI, int xPos, int yPos, AppEngRenderItem aeItemRenderer )
	{
		super( hostGUI, xPos, yPos );

		this.aeItemRenderer = aeItemRenderer;
	}

	@Override
	public void getTooltip( final List<String> tooltip )
	{
		if( this.aeItemStack != null )
		{
			// Get the stack
			ItemStack stack = this.aeItemStack.getItemStack();

			// Get the tooltip list
			List<String> stackTooltip = stack.getTooltip( WidgetAEItem.MC.thePlayer, WidgetAEItem.MC.gameSettings.advancedItemTooltips );

			// Set colors and add
			for( int index = 0; index < stackTooltip.size(); index++ )
			{
				if( index == 0 )
				{
					// Item name based on rarity
					stackTooltip.set( index, stack.getRarity().rarityColor + stackTooltip.get( index ) );
				}
				else
				{
					// The rest grey
					stackTooltip.set( index, EnumChatFormatting.GRAY + stackTooltip.get( index ) );
				}

				// Add the item tooltip line
				tooltip.add( stackTooltip.get( index ) );
			}

			// Get the mod name
			String modName = ( (AEItemStack)this.aeItemStack ).getModID();
			modName = modName.substring( 0, 1 ).toUpperCase() + modName.substring( 1 );
			
			// Add the mod name
			tooltip.add( EnumChatFormatting.BLUE + "" + EnumChatFormatting.ITALIC + modName );
		}
	}

	/**
	 * Draws the itemstack if there is one.
	 */
public IAEItemStack getItemStack()
	}

	@Override
	public void mouseClicked()
	{
		// Unused
public void mouseClicked()
	 * 
	 * @param itemStack
	 */
	public void setItemStack( IAEItemStack itemStack )
	{
		this.aeItemStack = itemStack;
	}
import mcp.mobius.waila.api.IWailaRegistrar;
import net.minecraft.item.ItemStack;
import net.minecraft.tileentity.TileEntity;
import thaumicenergistics.blocks.BlockProviderBase;
import thaumicenergistics.tileentities.TileProviderBase;
import appeng.core.localization.WailaText;
import cpw.mods.fml.common.event.FMLInterModComms;
public ModuleWaila()
	public static void callbackRegister( IWailaRegistrar registrar )
	{
		// Register the providers
		registrar.registerBodyProvider( ModuleWaila.instance, BlockProviderBase.class );
	}

	/**
public int getContainerCapacity( final ItemStack container )
	 * @param metadata
	 * @return
	 */
	public IEssentiaContainerPermission getContainerInfo( final Item item, final int metadata ) // TODO
	{
		// Is the item not null?
		if( item != null )
public long getFreeBytes()
	}

	/**
	 * TODO: Implement this
	 */
	@Override
	public int getPriority()
public IAEFluidStack injectItems( final IAEFluidStack input, final Actionable mo
	}

	/**
	 * TODO: Implement this
	 * 
	 * @return
	 */
public boolean isPreformatted()
	}

	/**
	 * TODO: Implement this.
	 */
	@Override
	public boolean isPrioritized( final IAEFluidStack input )

	private static final double[] IDLE_DRAIN_AMOUNTS = { 0.5D, 1.0D, 1.5D, 2.0D };

	private static final int MAX_TYPES = 8;

	private static final int CELL_STATUS_MISSING = 0;

	private static final int CELL_STATUS_HAS_ROOM = 1;

	private static final int CELL_STATUS_TYPES_FULL = 2;

	private static final int CELL_STATUS_FULL = 3;

	private IIcon[] icons;

private void addContentsToCellDescription( final HandlerItemEssentiaCell cellHan
				else
				{
					// It does not, set to gray
					aspectChatColor = EnumChatFormatting.GRAY.toString();
				}

				// Build the display string
				String aspectInfo = String.format( "%!s(MISSING)%!s(MISSING)%!s(MISSING) x %!d(MISSING)", aspectChatColor, currentStack.getAspectName( player ),
					EnumChatFormatting.GRAY.toString(), currentStack.amount );

				// Add to the list
				displayList.add( aspectInfo );
public void addInformation( final ItemStack essentiaCell, final EntityPlayer pla
			// Add information about the essentia types in the cell
			this.addContentsToCellDescription( cellHandler, displayList, player );
		}

	}

public void getSubItems( final Item item, final CreativeTabs creativeTab, final
		for( int i = 0; i < ItemStorageBase.SUFFIXES.length; i++ )
		{
			listSubItems.add( new ItemStack( item, 1, i ) );

		}
	}

{

	@Override
	public IMessage onMessage( PacketClientArcaneCraftingTerminal message, MessageContext ctx )
	{
		message.execute();
		return null;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;
import net.minecraft.client.Minecraft;
private static World getClientWorld()
	 * @param stream
	 * @return
	 */
	protected static IAEItemStack readAEItemStack( ByteBuf stream )
	{
		IAEItemStack itemStack;
		try
protected static IAEItemStack readAEItemStack( ByteBuf stream )
	 * @param stream
	 * @return
	 */
	protected static Aspect readAspect( ByteBuf stream )
	{
		return Aspect.aspects.get( readString( stream ) );
	}
protected static Aspect readAspect( ByteBuf stream )
	 * @param stream
	 * @return
	 */
	protected static AbstractAEPartBase readPart( ByteBuf stream )
	{
		ForgeDirection side = ForgeDirection.getOrientation( stream.readInt() );

protected static AbstractAEPartBase readPart( ByteBuf stream )
	 * @param stream
	 * @return
	 */
	protected static EntityPlayer readPlayer( ByteBuf stream )
	{
		EntityPlayer player = null;

protected static EntityPlayer readPlayer( ByteBuf stream )
	 * @param stream
	 * @return
	 */
	protected static String readString( ByteBuf stream )
	{
		byte[] stringBytes = new byte[stream.readInt()];

protected static String readString( ByteBuf stream )
	 * @param stream
	 * @return
	 */
	protected static TileEntity readTileEntity( ByteBuf stream )
	{
		World world = AbstractPacket.readWorld( stream );

protected static TileEntity readTileEntity( ByteBuf stream )
	 * @param stream
	 * @return
	 */
	protected static World readWorld( ByteBuf stream )
	{
		World world = DimensionManager.getWorld( stream.readInt() );

protected static World readWorld( ByteBuf stream )
	 * @param itemStack
	 * @param stream
	 */
	protected static void writeAEItemStack( IAEItemStack itemStack, ByteBuf stream )
	{
		// Do we have a valid stack?
		if( itemStack != null )
protected static void writeAEItemStack( IAEItemStack itemStack, ByteBuf stream )
	 * @param aspect
	 * @param stream
	 */
	protected static void writeAspect( Aspect aspect, ByteBuf stream )
	{
		String aspectName = "";

protected static void writeAspect( Aspect aspect, ByteBuf stream )
	 * @param part
	 * @param stream
	 */
	protected static void writePart( AbstractAEPartBase part, ByteBuf stream )
	{
		stream.writeInt( part.getSide().ordinal() );

protected static void writePart( AbstractAEPartBase part, ByteBuf stream )
	 * @param stream
	 */
	@SuppressWarnings("null")
	protected static void writePlayer( EntityPlayer player, ByteBuf stream )
	{
		boolean validPlayer = ( player != null );

protected static void writePlayer( EntityPlayer player, ByteBuf stream )
	 * @param string
	 * @param stream
	 */
	protected static void writeString( String string, ByteBuf stream )
	{
		byte[] stringBytes = string.getBytes( Charsets.UTF_8 );

protected static void writeString( String string, ByteBuf stream )
	 * @param entity
	 * @param stream
	 */
	protected static void writeTileEntity( TileEntity entity, ByteBuf stream )
	{
		writeWorld( entity.getWorldObj(), stream );
		stream.writeInt( entity.xCoord );
protected static void writeTileEntity( TileEntity entity, ByteBuf stream )
	 * @param world
	 * @param stream
	 */
	protected static void writeWorld( World world, ByteBuf stream )
	{
		stream.writeInt( world.provider.dimensionId );
	}
private void toCompressedBytes( final ByteBuf packetStream )
			{

				@Override
				public void write( int byteToWrite ) throws IOException
				{
					// Write the byte to the packet stream
					packetStream.writeByte( byteToWrite & 0xFF );
				}
			} );

			// Compress
			compressor.write( streamToCompress.array(), 0, streamToCompress.writerIndex() );
public void write( int byteToWrite ) throws IOException
	 * Reads data from the packet stream.
	 */
	@Override
	public void fromBytes( ByteBuf stream )
	{
		this.mode = stream.readByte();
		this.player = AbstractPacket.readPlayer( stream );
public void fromBytes( ByteBuf stream )
	 * Writes data into the packet stream.
	 */
	@Override
	public void toBytes( ByteBuf stream )
	{
		// Write the mode
		stream.writeByte( this.mode );
public void readData( final ByteBuf stream )
	@Override
	public void writeData( final ByteBuf stream )
	{

		switch ( this.mode )
		{
			case PacketClientArcaneCraftingTerminal.MODE_RECEIVE_FULL_LIST:
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;

// TODO: Owner security
public abstract class AEPartEssentiaIO
	extends AbstractAEPartBase
	implements IGridTickable, IInventoryUpdateReceiver, IAspectSlotPart, IAEAppEngInventory
public void registerSpatialIOMovables()
		// Add infusion provider
		movableRegistry.whiteListTileEntity( TileInfusionProvider.class );

		// TODO Add golem crank
	}

	/**
else if( ing instanceof ItemStack )
						}
						else
						{
							System.out.println( "Missing ingredient clause for" );
							System.out.println( ing.getClass() );
							System.out.println();
						}

					}
					catch( Exception e )
					{
						System.out.println( e );
					}

					// Skip null stacks
else if( ing instanceof ItemStack )
			}
			else
			{
				System.out.println( this.displayName + ": getIngredients() failed" );
			}
		}

private void registerItem( final AEItemDefinition itemDef, final AspectList aspe
	}

	/**
	 * Updates the aspects for the Essentia cells.
	 */
	private void registerTECells()
	{
		// Get the aspect list for a 1k cell
		AspectList aspects = ThaumcraftApiHelper.getObjectAspects( AEApi.instance().items().itemCell1k.stack( 1 ) ).copy();

		aspects.add( Aspect.MAGIC, 3 );
		aspects.add( Aspect.AURA, 5 );

		ThaumcraftApi.registerObjectTag( TEApi.instance().items().EssentiaCell_1k.getStack(), aspects );
		ThaumcraftApi.registerObjectTag( TEApi.instance().items().EssentiaCell_4k.getStack(), aspects );
		ThaumcraftApi.registerObjectTag( TEApi.instance().items().EssentiaCell_16k.getStack(), aspects );
		ThaumcraftApi.registerObjectTag( TEApi.instance().items().EssentiaCell_64k.getStack(), aspects );

	}

public void registerAEAspects()
		}

		// Finally register my cells
		this.registerTECells();

		// Cleanup
		this.NORMAL_RECIPES = null;
private static void registerComponents( final Materials aeMaterials, final Block
		ItemStack QuartzGlass = aeBlocks.blockQuartzGlass.stack( 1 );

		// My items
		ItemStack EssentiaCell_1k = teItems.EssentiaCell_1k.getStack();

		ItemStack EssentiaCell_4k = teItems.EssentiaCell_4k.getStack();

		ItemStack EssentiaCell_16k = teItems.EssentiaCell_16k.getStack();

		ItemStack EssentiaCell_64k = teItems.EssentiaCell_64k.getStack();

		// Item Groups		
		ArrayList<ItemStack> GroupQuartz = new ArrayList<ItemStack>( 3 );
private static void registerComponents( final Materials aeMaterials, final Block
		AspectList storage1kAspects = new AspectList();
		storage1kAspects.add( Aspect.FIRE, 3 );
		storage1kAspects.add( Aspect.ORDER, 1 );
		RecipeRegistry.STORAGE_COMPONENT_1K = ThaumcraftApi.addArcaneCraftingRecipe( ResearchTypes.STORAGE.getKey(), EssentiaCell_1k,
			storage1kAspects, new Object[] { "EQE", "QPQ", "EQE", 'E', EtheralEssence, 'Q', CertusQuartz, 'P', LogicProcessor } );
		RecipeRegistry.replaceRecipeIngredientWithGroup( (ShapedArcaneRecipe)RecipeRegistry.STORAGE_COMPONENT_1K, CertusQuartz, GroupQuartz );

		// 4K Storage Component
		AspectList storage4kAspects = new AspectList();
		storage4kAspects.add( Aspect.FIRE, 3 );
		storage4kAspects.add( Aspect.ORDER, 2 );
		RecipeRegistry.STORAGE_COMPONENT_4K = ThaumcraftApi.addArcaneCraftingRecipe( ResearchTypes.STORAGE.getKey(), EssentiaCell_4k,
			storage4kAspects, new Object[] { "EPE", "1G1", "E1E", 'E', EtheralEssence, '1', EssentiaCell_1k, 'P', CalculationProcessor, 'G',
							QuartzGlass } );

		// 16K Storage Component
		AspectList storage16kAspects = new AspectList();
		storage16kAspects.add( Aspect.FIRE, 3 );
		storage16kAspects.add( Aspect.ORDER, 4 );
		RecipeRegistry.STORAGE_COMPONENT_16K = ThaumcraftApi.addArcaneCraftingRecipe( ResearchTypes.STORAGE.getKey(), EssentiaCell_16k,
			storage16kAspects, new Object[] { "SPE", "4G4", "E4S", 'E', EtheralEssence, 'S', SalisMundus, '4', EssentiaCell_4k, 'P',
							EngineeringProcessor, 'G', QuartzGlass } );

		// 16K Storage Component
		AspectList storage64kAspects = new AspectList();
		storage64kAspects.add( Aspect.FIRE, 3 );
		storage64kAspects.add( Aspect.ORDER, 8 );
		RecipeRegistry.STORAGE_COMPONENT_64K = ThaumcraftApi.addArcaneCraftingRecipe( ResearchTypes.STORAGE.getKey(), EssentiaCell_64k,
			storage64kAspects, new Object[] { "SPS", "6G6", "S6S", 'S', SalisMundus, '6', EssentiaCell_16k, 'P', EngineeringProcessor, 'G',
							QuartzGlass } );
	}

private static void registerMaterials( final Materials aeMaterials, final Items
		{
			AspectList certusAspects = new AspectList();
			certusAspects.add( Aspect.CRYSTAL, 4 );
			certusAspects.add( Aspect.ORDER, 2 );
			RecipeRegistry.DUPE_CERTUS = ThaumcraftApi.addCrucibleRecipe( ResearchRegistry.ResearchTypes.CERTUSDUPE.getKey(), Certus2, Certus1,
				certusAspects );
		}
			INFUSION ("INFUSION", "ARTIFICE", -6, 0),
			VISPOWER ("VISPOWER", "THAUMATURGY", 2, -1),
			COREUSE ("COREUSE", "GOLEMANCY", 4, 3),
			DUPE ("ALCHEMICALDUPLICATION", "ALCHEMY", -6, -7);

		private String realResearchKey;
		private String realResearchCategory;
private static void addPseudoParents()
					}
					break;

				default:
					break;

private static void registerStorage()
						new ResearchPage( storageComponentRecipes ), new ResearchPage( RecipeRegistry.STORAGE_CASING ),
						new ResearchPage( storageCellsShaped ), new ResearchPage( storageCellsShapeless ) };

		// Create the storage research
		ResearchTypes.STORAGE.createResearchItem( storageAspectList, COMPLEXITY_MEDIUM, storageIcon, storagePages );
		ResearchTypes.STORAGE.researchItem.setParents( ResearchTypes.BASIC.getKey(), PseudoResearchTypes.DISTILESSENTIA.getKey() );
		ResearchTypes.STORAGE.researchItem.setParentsHidden( "DISTILESSENTIA" );
		ResearchTypes.STORAGE.researchItem.registerResearchItem();
	}
import thaumcraft.api.aspects.IEssentiaTransport;
import thaumicenergistics.api.TEApi;
import thaumicenergistics.aspect.AspectStack;

public class TileEssentiaProvider
	extends TileProviderBase
	public static final String TILE_ID = "TileEssentiaProvider";

	/**
	 * How much power does this require just to be active?
	 */
	@Override
protected ItemStack getItemFromTile( final Object obj )

	}

	protected Aspect getNeighborWantedAspect( final ForgeDirection face )
	{
		System.out.println( face );

		// Get the tile entity next to this face
		TileEntity neighbor = this.worldObj.getTileEntity( this.xCoord + face.offsetX, this.yCoord + face.offsetY, this.zCoord + face.offsetZ );

		// Do we have essentia transport neighbor?
		if( ( neighbor != null ) && ( neighbor instanceof IEssentiaTransport ) )
		{
			// Get the aspect they want
			Aspect wantedAspect = ( (IEssentiaTransport)neighbor ).getSuctionType( face.getOpposite() );

			// Return the aspect they want
			return wantedAspect;
protected void onChannelUpdate()
	}

	@Override
	public int addEssentia( final Aspect aspect, final int amount, final ForgeDirection face )
	{
		// Doesn't accept essentia
		return 0;
	}

	@Override
	public boolean canInputFrom( final ForgeDirection face )
	{
		// Doesn't accept essentia
		return false;
	}

	@Override
	public boolean canOutputTo( final ForgeDirection face )
	{
		System.out.println( face );
		// Can output to any side
		return true;
	}

	@Override
	public int getEssentiaAmount( final ForgeDirection face )
	{
		// Get the aspect this neighbor wants
		Aspect wantedAspect = this.getNeighborWantedAspect( face );

		// Does the neighbor want anything?
		if( wantedAspect != null )
public int getEssentiaAmount( final ForgeDirection face )
	}

	@Override
	public Aspect getEssentiaType( final ForgeDirection face )
	{
		// Get the aspect this neighbor wants
		Aspect wantedAspect = this.getNeighborWantedAspect( face );

		// Does the neighbor want anything?
		if( wantedAspect != null )
public Aspect getEssentiaType( final ForgeDirection face )
	public int getMinimumSuction()
	{
		// Any amount of suction is good enough
		return 0;
	}

	@Override
	public int getSuctionAmount( final ForgeDirection face )
	{
		// Doesn't accept essentia
		return 0;
	}

	@Override
	public Aspect getSuctionType( final ForgeDirection face )
	{
		// Doesn't accept essentia
		return null;
	}

	@Override
	public boolean isConnectable( final ForgeDirection face )
	{
		// Can connect on any side
		return true;
public void setSuction( final Aspect aspect, final int amount )
	}

	@Override
	public int takeEssentia( final Aspect aspect, final int amount, final ForgeDirection face )
	{
		// Extract essentia from the network, and return the amount extracted
		return this.extractEssentiaFromNetwork( aspect, amount, false );
	}

}
public class TileGearBox
	extends TileEntity
{
	public static final String TILE_ID = "TileGearBox";

	/**
	 * Total amount of power per crank.
	 */
	private static final int BASE_POWER = 6;

	/**
	 * How much accumulated power is required to turn a grinder?
	 */
	private static final int REQUIRED_POWER = 18;

	/**
	 * Tracks the amount of power being sent per side
	 */
	private int[] crankPower = new int[ForgeDirection.VALID_DIRECTIONS.length];

	/**
	 * Tracks if there is a grinder per side
	 */
	private boolean[] hasGrinder = new boolean[ForgeDirection.VALID_DIRECTIONS.length];

	/**
	 * Gets the grinder on the specified side.
	 * 
	 * @param sideIndex
	 * @return
	 */
	private ICrankable getGrinder( final int sideIndex )
	{
		// Get the side
		ForgeDirection side = ForgeDirection.VALID_DIRECTIONS[sideIndex];

		// Get the tile
		TileEntity t = this.worldObj.getTileEntity( side.offsetX + this.xCoord, side.offsetY + this.yCoord, side.offsetZ + this.zCoord );

		if( t instanceof ICrankable )
		{
			return (ICrankable)t;
		}

		return null;
	}

	/**
	 * Locates attached grinders.
	 * 
	 * @return Number of attached grinders found.
	 */
	private int locateGrinders( final boolean isServerThread )
	{
		// Number of attached grinders
		int grinderCount = 0;

		// Check all sides
		for( int sideIndex = 0; sideIndex < ForgeDirection.VALID_DIRECTIONS.length; sideIndex++ )
		{
			// Get the side
			ForgeDirection side = ForgeDirection.VALID_DIRECTIONS[sideIndex];

			// Assume there is not a grinder
			this.hasGrinder[sideIndex] = false;

			// Get the grinder
			ICrankable crank = this.getGrinder( sideIndex );

			// Is there a grinder?
			if( crank == null )
			{
				continue;
			}

			// Can it turn?
			if( isServerThread && ( !crank.canTurn() ) )
			{
				continue;
			}

			// Is it facing the correct direction?
			if( crank.canCrankAttach( side.getOpposite() ) )
			{
				// Increment the grinder count
				grinderCount++ ;

				// Mark there is a grinder.
				this.hasGrinder[sideIndex] = true;
			}

		}

		return grinderCount;
	}

	@Override
	public boolean canUpdate()
	{
		return false;
	}

	/**
	 * Turns the crankshaft.
	 * 
	 * @return
	 */
	public boolean crank()
	{
		boolean isServerSide = EffectiveSide.isServerSide();

		// Get the grinders
		int grinderCount = this.locateGrinders( isServerSide );

		boolean hasGrinder = grinderCount > 0;

		// Don't do work on client side.
		if( !isServerSide )
		{
			return( hasGrinder );
		}

		// Were there any grinders?
		if( hasGrinder )
		{
			// Calculate the amount of power to send to each
			int powerTransfered = TileGearBox.BASE_POWER / grinderCount;

			// Update powers
			for( int sideIndex = 0; sideIndex < this.crankPower.length; sideIndex++ )
			{
				// Is there a grinder on this side?
				if( this.hasGrinder[sideIndex] )
				{
					// Does it have enough power to turn the grinder?
					if( ( this.crankPower[sideIndex] += powerTransfered ) >= TileGearBox.REQUIRED_POWER )
					{
						// Reset the power
						this.crankPower[sideIndex] = 0;

						// Turn the grinder
						this.getGrinder( sideIndex ).applyTurn();
					}
				}
				else
				{
					// No power is going to this side.
					this.crankPower[sideIndex] = 0;
				}
			}
		}

		return( hasGrinder );

	}
}
import appeng.me.GridAccessException;
import cpw.mods.fml.common.FMLCommonHandler;

public class TileInfusionProvider
	extends TileProviderBase
	implements IAspectSource, IMEMonitorHandlerReceiver<IAEFluidStack>
protected boolean getFluidMonitor()
	}

	/**
	 * Called when our channel updates.
	 */
	protected abstract void onChannelUpdate();
thaumicenergistics.item.material.iron.gear.name=Iron Gear
#Tooltips
thaumicenergistics.tooltip.essentia.cell.bytes=%!d(MISSING) of %!d(MISSING) bytes used.
thaumicenergistics.tooltip.essentia.cell.types=%!d(MISSING) of %!d(MISSING) essentia types stored.
thaumicenergistics.tooltip.button.clear.crafting=Deposit Crafting Grid
thaumicenergistics.tooltip.button.void=Allow Void?
thaumicenergistics.tooltip.button.void.disabled=Do not void essentia
thaumicenergistics.research_page.TEESSTERM.2=The §lEssentia Level Emitter§r wi
# Research Essentia Provider
tc.research_name.thaumicenergistics.TEESSPROV=Essentia Provider
tc.research_text.thaumicenergistics.TEESSPROV=Ask and you shall receive.
thaumicenergistics.research_page.TEESSPROV.1=While import and export buses are useful for an array of jobs, they lack the flexibility to interface with complex alchemical constructs. To overcome this limitation you have created a device that will allow these constructs to request essentia directly from the network.<BR>Using the §lEssentia Provider§r should prove to be a simple task. Simply connect it to both the network and construct, and it will do the rest.

# Research Infusion Provider
tc.research_name.thaumicenergistics.TEINFPROV=Infusion Provider

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public GeocodeResponse geocode(final GeocodeRequest request) {
            String responseAsJson = null;
            final int statusCode = response.getStatusLine().getStatusCode();

            if (statusCode != 200) {
                throw new GeocoderException("received http status code '" + statusCode + "'");
            }

            try {
                final HttpEntity entity = response.getEntity();
                responseAsJson = EntityUtils.toString(entity);
public GeocodeResponse geocode(final GeocodeRequest request) {
            } finally {
                closeQuietly(response);
            }
            //deserialize to json

            try {
import it.cybion.geocoder.requests.YahooWoeType;
import it.cybion.geocoder.responses.Feature;
import it.cybion.geocoder.responses.GeocodeResponse;
import it.cybion.geocoder.serialization.ObjectMapperFactory;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Test;

import static org.testng.Assert.assertEquals;
/**
 * @author Matteo Moci ( matteo (dot) moci (at) gmail (dot) com )
 */
public class GeocoderImplIntegration {

    private static final Logger LOGGER = LoggerFactory.getLogger(GeocoderImplIntegration.class);

    private GeocoderImpl geocoderImpl;

    private CloseableHttpClient closeable;

    @BeforeMethod
    public void setUp() throws Exception {

        this.closeable = HttpClients.createDefault();
        this.geocoderImpl = new GeocoderImpl("localhost", 5101,
                ObjectMapperFactory.INSTANCE.getObjectMapper(), closeable);

    }

    @AfterMethod
    public void tearDown() throws Exception {

        this.closeable.close();
        this.geocoderImpl = null;

    }

    @Test
    public void givenDefaultAndEnglishQueriesShouldBeSame() throws Exception {

        final GeocodeRequest aRequestDefaultLang = new GeocodeRequest("nyc");
        final GeocodeResponse nycResponse = this.geocoderImpl.geocode(aRequestDefaultLang);
        assertNotNull(nycResponse);

        final GeocodeRequest aRequestEnglishLang = new GeocodeRequest("nyc", "en");
        final GeocodeResponse response1 = this.geocoderImpl.geocode(aRequestEnglishLang);
        assertNotNull(response1);
        assertEquals(nycResponse, response1);
    }
public void givenAStreetShouldNot() throws Exception {
        final GeocodeRequest aRequestDefaultLang = new GeocodeRequest.GeocodeRequestBuilder().query(
                "via trionfale").countryCode("IT").lang("en").build();

        final GeocodeResponse response = this.geocoderImpl.geocode(aRequestDefaultLang);
        assertNotNull(response);
        assertEquals(response.getInterpretations().size(), 0);

public void givenRomeShouldReturnProvinceWithCountryAndLatLon() throws Exception
                "Rome, Italy").addWoeHint(YahooWoeType.ADMIN2).addResponseInclude(
                ResponseIncludes.PARENTS).build();

        final GeocodeResponse response = this.geocoderImpl.geocode(locationRequest);

        assertEquals(response.getInterpretations().size(), 2);
        final Feature romeFeature = response.getInterpretations().get(0).getFeature();
public void givenNettunoShouldReturnProvinceWithCountryAndLatLon() throws Except
                "Nettuno").addWoeHint(YahooWoeType.ADMIN2).addResponseInclude(
                ResponseIncludes.PARENTS).build();

        final GeocodeResponse response = this.geocoderImpl.geocode(locationRequest);

        assertEquals(response.getInterpretations().size(), 1);
        final Feature nettunoFeature = response.getInterpretations().get(0).getFeature();
public void givenChicagoShouldReturnProvinceWithCountryAndLatLon() throws Except
                "Chicago/Brooklyn").addWoeHint(YahooWoeType.ADMIN2).addResponseInclude(
                ResponseIncludes.PARENTS).build();

        final GeocodeResponse response = this.geocoderImpl.geocode(locationRequest);

        LOGGER.info(response + "");

public void givenWhenQueryStartsWithHttpShouldThrowException() throws Exception
                .build();

        try {
            final GeocodeResponse response = this.geocoderImpl.geocode(locationRequest);
            fail();
        } catch (GeocoderException e) {
            assertNotNull(e);
package it.cybion.geocoder;

import it.cybion.geocoder.serialization.ObjectMapperFactory;
import org.apache.http.conn.HttpClientConnectionManager;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.testng.annotations.AfterClass;
    @BeforeClass
    public void setUpGeocoder() throws Exception {

        final HttpClientConnectionManager connManager = new PoolingHttpClientConnectionManager();
        this.httpClient = HttpClients.createMinimal(connManager);
        this.geocoder = new GeocoderImpl("localhost", 5101,
                ObjectMapperFactory.INSTANCE.getObjectMapper(), httpClient);
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 * information or http://www.gnu.org/copyleft/lesser.html.
 *
 */
import java.sql.Connection;
import java.sql.SQLException;
import java.util.HashMap;

import org.apache.log4j.Logger;
import org.intermine.api.profile.Profile;
import org.intermine.api.tracker.factory.TrackerFactory;
import org.intermine.api.tracker.track.ListTrack;
import org.intermine.api.tracker.track.Track;
import org.intermine.api.tracker.util.TrackerUtil;
import org.intermine.objectstore.ObjectStoreWriter;
import org.intermine.objectstore.intermine.ObjectStoreWriterInterMineImpl;
import org.intermine.api.template.TemplateManager;

/**
 * Intermediate class which decouples the tracker components from the code that uses them.
 * @author dbutano
 *
 */
public class TrackerDelegate
{
    private static final Logger LOG = Logger.getLogger(TrackerDelegate.class);
    protected Map<String, Tracker> trackers = new HashMap<String, Tracker>();
    public TrackerDelegate(String[] trackerClassNames, ObjectStoreWriter osw) {
        Queue<Track> trackQueue = new LinkedList<Track>();
        this.osw = osw;
        try {
            connection = getConnection();
            Tracker tracker;
public synchronized void close() {
    }

    /**
     * clean up threads
     * @throws Throwable if something goes wrong
     */
public synchronized void close() throws ObjectStoreException {
                + statsEstTime + ", Execute: " + statsExeTime + ", Results Convert: "
                + statsConTime);

        try {
            logTableBatch.close(logTableConnection);
        } catch (SQLException e1) {
            LOG.error("Couldn't close OS log table.");
        }

        Connection c = null;
public String getVersion() {
        }
        if (version == null) {
            try {
                Connection c = getConnection();
                Statement s = c.createStatement();
                String versionQuery = "SELECT current_setting('server_version')";
                ResultSet rs = s.executeQuery(versionQuery);
                if (rs.next()) {
                    version = rs.getString(1);
                }
            } catch (SQLException e) {
                throw new IllegalArgumentException("Error fetching version number from database: "
                        + e.getMessage());
            }
        }
        return version;
private ShutdownHook() {
    }

    /**
     * Registers an object with the shutdown hook.
     *
     * @param object the object
public static synchronized void registerObject(Object object) {
    /**
     * Performs the shutdown.
     */
    private static synchronized void shutdown() {
        while (!objects.empty()) {
            Object o = objects.pop();
            try {
public void shutdown() {
    }

    /**
     * Send the signal that shutdown is happening - try and release resources.
     */
    public static void doShutdown() {
        if (mailQueue != null && mailService != null) {
import org.intermine.objectstore.ObjectStoreWriter;
import org.intermine.objectstore.ObjectStoreWriterFactory;
import org.intermine.objectstore.intermine.ObjectStoreInterMineImpl;
import org.intermine.objectstore.intermine.ObjectStoreWriterInterMineImpl;
import org.intermine.sql.Database;
import org.intermine.sql.DatabaseUtil;
import org.intermine.util.PropertiesUtil;
import org.intermine.web.autocompletion.AutoCompleter;
import org.intermine.web.context.InterMineContext;
import org.intermine.web.logic.Constants;
private UserProfile getSuperUser(ObjectStoreWriter uosw) {
     */
    @Override
    public void destroy() {
        if (userprofileOSW != null) {
            try {
                userprofileOSW.close();
            } catch (ObjectStoreException e) {
                LOG.warn("Error closing userprofile writer.", e);
            }
            ((ObjectStoreWriterInterMineImpl) userprofileOSW).getDatabase().shutdown();
        }
        if (os != null) {
            if (os instanceof ObjectStoreInterMineImpl) {
                try {
                    ((ObjectStoreInterMineImpl) os).close();
                } catch (ObjectStoreException e) {
                    LOG.error("Couldn't shut down OS. Memory leaks!");
                }
                ((ObjectStoreInterMineImpl) os).getDatabase().shutdown();
            }
        }
        if (trackerDelegate != null) {
            trackerDelegate.close();
        }
        InterMineContext.doShutdown();
    }


    /**
     * Remove class tags from the user profile that refer to classes that non longer exist
     * @param tagManager tag manager
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.*;

public class Sandbox {

    public static void main(String[] args) throws IOException {

        Sandbox test = new Sandbox();

        test.gui2();


    }
    private JFileChooser fc;

    private JPanel RightBottomCenter;

    private Cursor eraserCursor;

    public void gui2() {

        int size = 32;

        /*
         * we need two buffered images as the cursor only supports on/off for alpha
         *
         * so we need to draw to an image without alpha support
         * then draw that to one with alpha support
         * then make "white" transparent
         */
        BufferedImage image = new BufferedImage(size, size,
                BufferedImage.TYPE_INT_RGB);
        BufferedImage image2 = new BufferedImage(size, size,
                BufferedImage.TYPE_INT_ARGB);

        Graphics2D g = image.createGraphics();
        Graphics2D g2 = image2.createGraphics();

        g.setColor(Color.white);
        g.fillRect(0, 0, size, size);


        // turn on anti-aliasing.
        g.setStroke(new BasicStroke(4.0f)); // 4-pixel lines
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
                RenderingHints.VALUE_ANTIALIAS_ON);

        g.setColor(new Color(0.5f, 0f, 0f));
        g.drawOval(3, 3, size - 7, size - 7);

        g2.drawImage(image, 0, 0, null, null);


        for (int y = 0; y < size; y++) {
            for (int x = 0; x < size; x++) {

                int rgb = image.getRGB(x, y);

                int blue = rgb & 0xff;
                int green = (rgb & 0xff00) >> 8;
                int red = (rgb & 0xff0000) >> 16;
                //int alpha = (rgb & 0xff000000) >> 24;

                if (red == 255 && green == 255 && blue == 255) {
                    // make white transparent
                    image2.setRGB(x, y, 0);
                }

            }
        }

        eraserCursor = Toolkit.getDefaultToolkit().createCustomCursor(
                image2, new Point(size / 2, size / 2), "eraserCursor");

        JFrame frame = new JFrame("Test");
        frame.setSize(800, 800);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setLocationRelativeTo(null);

        frame.setVisible(true);

        frame.setCursor(eraserCursor);
    }

    public void gui() {

        JFrame frame = new JFrame("Test");
        frame.getContentPane().setBackground(Color.black);

        AImage cursorImage = new AImage("cursor.png");
        AImage cursorSelect = new AImage("cursorSelect.png");
        AImage cursorHover = new AImage("cursorHover.png");
        AImage cursorHoverYellow = new AImage("cursorHoverYellow.png");

        cursorImage.setVisible(false);
        cursorSelect.setVisible(false);
        cursorHover.setVisible(false);
        cursorHoverYellow.setVisible(false);


        JPanel pnl = new JPanel();
        pnl.setBackground(Color.darkGray);
        JPanel pnl2 = new JPanel();
        pnl2.setBackground(Color.darkGray);
        JPanel pnl3 = new JPanel();
        pnl3.setBackground(Color.darkGray);
        pnl3.setPreferredSize(new Dimension(50, 100));
        JPanel pnl5 = new JPanel();
        pnl5.setBackground(Color.gray);
        JPanel pnl4 = new JPanel();
        pnl4.setBackground(Color.black);

        frame.setLayout(new BorderLayout());

        frame.add(pnl, BorderLayout.EAST);
        frame.add(pnl2, BorderLayout.WEST);
        frame.add(pnl3, BorderLayout.NORTH);
        frame.add(pnl5, BorderLayout.SOUTH);
        frame.add(pnl4, BorderLayout.CENTER);

        frame.setCursor(frame.getToolkit().createCustomCursor(
                new BufferedImage(3, 3, BufferedImage.TYPE_INT_ARGB), new Point(
                0, 0),
                "null"));

        frame.setSize(800, 800);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setLocationRelativeTo(null);

        frame.setVisible(true);

        JPanel glass = (JPanel) frame.getGlassPane();
        glass.setVisible(true);
        glass.setLayout(null);
        glass.setOpaque(false);

        glass.add(cursorImage);
        glass.add(cursorSelect);
        glass.add(cursorHover);
        glass.add(cursorHoverYellow);

        CursorListener cursor = new CursorListener(
                cursorImage, cursorSelect);
        glass.addMouseMotionListener(cursor);
        glass.addMouseListener(new CursorClick(cursor));

        glass.revalidate();

        frame.setGlassPane(glass);

    }

    private static class CursorClick extends MouseAdapter {

        private final AImage cursorImage;

        private final AImage cursorSelect;

//        private final AImage cursorHover;
        private final CursorListener click;

        public CursorClick(CursorListener click) {
            this.cursorImage = click.getCursorImage();
            this.cursorSelect = click.getCursorSelect();
            this.click = click;
        }

        public AImage getCursorImage() {
            return cursorImage;
        }

        public AImage getCursorSelect() {
            return cursorSelect;
        }

        @Override
        public void mousePressed(MouseEvent e) {

            cursorImage.setVisible(false);

            cursorSelect.setLocation(e.getPoint());

            cursorSelect.setBounds(e.getX(), e.getY(), cursorImage.getImgIcon()
                    .getIconWidth(), cursorImage.getImgIcon().getIconHeight());

            cursorSelect.setVisible(true);
        }

        @Override
        public void mouseReleased(MouseEvent e) {

            cursorSelect.setVisible(false);

            cursorImage.setLocation(e.getPoint());

            cursorImage.setBounds(e.getX(), e.getY(), cursorImage.getImgIcon()
                    .getIconWidth(), cursorImage.getImgIcon().getIconHeight());



            cursorImage.setVisible(true);

        }

        @Override
        public void mouseExited(MouseEvent e) {
            cursorSelect.setVisible(false);
            cursorImage.setVisible(false);
        }
    }

    class CursorListener implements MouseMotionListener {

        private final AImage cursorImage;

        private final AImage cursorSelect;

//        private final AImage cursorHover;
        private CursorListener(AImage cursorImage, AImage cursorSelect) {
            this.cursorImage = cursorImage;
            this.cursorSelect = cursorSelect;
//            this.cursorHover = cursorHover;


        }

        public AImage getCursorImage() {
            return cursorImage;
        }

        public AImage getCursorSelect() {
            return cursorSelect;
        }

        @Override
        public void mouseDragged(MouseEvent e) {

            cursorImage.setVisible(false);

            cursorSelect.setLocation(e.getPoint());

            cursorSelect.setBounds(e.getX(), e.getY(), cursorImage.getImgIcon()
                    .getIconWidth(), cursorImage.getImgIcon().getIconHeight());



            cursorSelect.setVisible(true);
        }

        @Override
        public void mouseMoved(MouseEvent e) {

            cursorSelect.setVisible(false);
//            if (panel.getBounds().contains(e.getPoint())) {


            cursorImage.setLocation(e.getPoint());

            cursorImage.setBounds(e.getX(), e.getY(), cursorImage
                    .getImgIcon()
                    .getIconWidth(), cursorImage.getImgIcon()
                    .getIconHeight());


            cursorImage.setVisible(true);


        }
    }
}
public final void addToVolatileListenerBank(final JComponent aComponent) {
     */
    public final void backToDashboard() {

        //* Remove All Listeners from componentsContainingListeners *//
        removeAllListeners();

        //* Clear everything in the Center Panel of CoreUI *//
        clearUI();

        //* Re-add all DashboardUI components back to CoreUI *//
        getDashboardUI().addToCanvas();

    }

    /**
public final void clearUI() {
        getCoreUI().getSouthFromTopPanel()
                .add(getCoreUI().getFrameControlContainerPanel(),
                BorderLayout.EAST);
        getCoreUI().getFrameControlImagePane().getComponent(0)
                .addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(final MouseEvent e) {
                removeAllListeners();
                backToDashboard();
            }
        });

        //* Remove all from the title pane of the bottom bar and re-add title*//
        getCoreUI().getTitlePanel().removeAll();
public void mouseClicked(final MouseEvent e) {
                                              - getCoreUI().getBottomImagePane()
                .getHeight() - getCoreUI().getTopImagePane().getHeight()));


        System.gc();

        getCoreUI().getFrame().requestFocus();
        getCoreUI().getFrame().repaint();


    }
    private JFrame frame;

    /*
     * Center panel that displays the main part of Aurora 
     * ie. Dashboard, Library, etc.
     */
    private JPanel paneCenter;
    private JPanel paneKeyToPress;

    /*
     * 
     */
    private JPanel southFromTopPanel;

    private JPanel paneFrameControlContainer;

    /*
     * 
     */
    private JPanel paneUserSpace;

    private JLabel lblKeyAction;

    /*
     * 
     */
    private AuroraMini miniMode;

public AuroraCoreUI(final JFrame aFrame) {
     * |
     * | This method sets up the core UI for Aurora
     * |
     * | 
     * | 
     * | 
     * | 
     * | 
     * | 
     * |
     * |
     * .........................................................................
     *
     * 
     *
     */
    public void setUI() throws UnsupportedAudioFileException, IOException,
                               LineUnavailableException, InterruptedException,
                               FontFormatException {

        // Determine Global Size based on Screen Size 	

        // TODO work on Screen Gui Change

public void setUI() throws UnsupportedAudioFileException, IOException,

        System.out.println("Current Screen Ressolution: "
                           + screenWidth + "x" + screenHeight);
       
        //*
        // Check the resolution (in pixels) of the screen to determine if the screen
        // is large or not
public void setUI() throws UnsupportedAudioFileException, IOException,
                System.out.println("ERROR In Getting Font Resourcess");
            }
        }
        
        //*
        // The Background Panel Contains The Background Image for the Window as
        // Well as all components found in the window
public void setUI() throws UnsupportedAudioFileException, IOException,
        // Top Panel

        // Frame Buttons
        
        paneFrameControl = new AImagePane("Aurora_FrameButton1.png",
                controlWidth, controlHeight);
        paneFrameControl.setImageHeight(controlHeight);
public void setUI() throws UnsupportedAudioFileException, IOException,
        paneCenterFromBottom = new JPanel(new BorderLayout());
        paneCenterFromBottom.setOpaque(false);
        paneBottom.add(BorderLayout.CENTER, paneCenterFromBottom);
        
        // WELCOME LABEL
        // -----------------------------------------------------------------------

public void setUI() throws UnsupportedAudioFileException, IOException,

        // TIME LABEL
        // -----------------------------------------------------------------------
        
        paneHeaderOfCenterFromBottom = new JPanel(new BorderLayout());
        lblTime = new ATimeLabel();
        lblTime.setFont(boldFont.deriveFont(Font.PLAIN, timeFontSize));
public void setUI() throws UnsupportedAudioFileException, IOException,

        // KEY PRESS PANEL
        // -----------------------------------------------------------------------
  
        paneKeyToPress = new JPanel();
        paneKeyToPress.setOpaque(false);

public void setUI() throws UnsupportedAudioFileException, IOException,

        // USER SPACE
        // -----------------------------------------------------------------------
        
        paneUserSpace = new JPanel();
        paneUserSpace.setOpaque(false);
        paneUserSpace
public void setUI() throws UnsupportedAudioFileException, IOException,

        // VERSION LABEL
        // -----------------------------------------------------------------------
        
        lblVersion = new JLabel(version);
        lblVersion.setOpaque(false);
        lblVersion.setForeground(Color.LIGHT_GRAY);
private void setSizes() {
    public void setKeyIconHeight(int keyIconHeight) {
        this.keyIconHeight = keyIconHeight;
    }
    
    public int getKeyIconHeight() {
        return keyIconHeight;
    }
public boolean getLargeScreen() {
    public void setKeyIconWidth(int keyIconWidth) {
        this.keyIconWidth = keyIconWidth;
    }
    
    public int getKeyIconWidth() {
        return keyIconWidth;
    }

    public void setTimeFontSize(int timeFontSize) {
        this.timeFontSize = timeFontSize;
    }
    
    public int getTimeFontSize() {
        return timeFontSize;
    }
public int getControlHeight() {
    public void setControlWidth(int controlWidth) {
        this.controlWidth = controlWidth;
    }
    
    public int getControlWidth() {
        return controlWidth;
    }
public int getWelcomeFontSize() {
    public void setBackgroundImagePane(AImagePane backgroundImagePane) {
        this.paneBackground = backgroundImagePane;
    }
    
    public AImagePane getBackgroundImagePane() {
        return paneBackground;
    }

    public void setBottomImagePane(AImagePane bottomImagePane) {
        this.paneBottom = bottomImagePane;
    }
    
    public AImagePane getBottomImagePane() {
        return paneBottom;
    }

    public void setCenterPanel(JPanel centerPanel) {
        this.paneCenter = centerPanel;
    }
    
    public JPanel getCenterPanel() {
        return paneCenter;
    }

    public void setCenterFromBottomPanel(JPanel centerFromBottomPanel) {
        this.paneCenterFromBottom = centerFromBottomPanel;
    }
    
    public JPanel getCenterFromBottomPanel() {
        return paneCenterFromBottom;
    }

    public void setSouthFromTopPanel(JPanel southFromTopPanel) {
        this.southFromTopPanel = southFromTopPanel;
    }
    
    public JPanel getSouthFromTopPanel() {
        return southFromTopPanel;
    }

    public void setFrameControlImagePane(AImagePane frameControlImagePane) {
        this.paneFrameControl = frameControlImagePane;
    }
    
    public AImagePane getFrameControlImagePane() {
        return paneFrameControl;
    }

    public void setTopImagePane(AImagePane topImagePane) {
        this.paneTopImage = topImagePane;
    }
    
    public AImagePane getTopImagePane() {
        return paneTopImage;
    }

    public void setLogoImage(AImage logoImage) {
        this.imgLogo = logoImage;
    }
    
    public AImage getLogoImage() {
        return imgLogo;
    }

    public void setTitleLabel(JLabel aTitleLabel) {
        this.lblTitle = aTitleLabel;
    }
    
    public JLabel getTitleLabel() {
        return lblTitle;
    }

    public void setVi(ANuance vi) {
        this.vi = vi;
    }
    
    public ANuance getVi() {
        return vi;
    }

    public void setUserbarPanel(JPanel userbarPanel) {
        this.paneUserSpace = userbarPanel;
    }
    
    public JPanel getUserSpacePanel() {
        return paneUserSpace;
    }
public String getRevision() {
    public void setFrame(JFrame frame) {
        this.frame = frame;
    }
    
    public JFrame getFrame() {
        return frame;
    }

    public void setKeyIconImage(AImage keyIconImage) {
        this.imgKeyIcon = keyIconImage;
    }
    
    public AImage getKeyIconImage() {
        return imgKeyIcon;
    }

    public void setKeyActionLabel(JLabel keyActionLabel) {
        this.lblKeyAction = keyActionLabel;
    }
    
    public JLabel getKeyActionLabel() {
        return lblKeyAction;
    }
public static void setTimeLabel(ATimeLabel timeLabel) {
    public void setVersionLabel(JLabel versionLabel) {
        this.lblVersion = versionLabel;
    }
    
    public JLabel getVersionLabel() {
        return lblVersion;
    }
public void setHeaderOfCenterFromBottomPanel(
            JPanel headerOfCenterFromBottomPanel) {
        this.paneHeaderOfCenterFromBottom = headerOfCenterFromBottomPanel;
    }
    
    public JPanel getHeaderOfCenterFromBottomPanel() {
        return paneHeaderOfCenterFromBottom;
    }

    public void setKeyToPressPanel(JPanel keyToPressPanel) {
        this.paneKeyToPress = keyToPressPanel;
    }
    
    public JPanel getKeyToPressPanel() {
        return paneKeyToPress;
    }

    public void setScreenLabelPanel(JPanel screenLabelPanel) {
        this.screenLabelPanel = screenLabelPanel;
    }
    
    public JPanel getScreenLabelPanel() {
        return screenLabelPanel;
    }

    public void setVersionPanel(JPanel versionPanel) {
        this.versionPanel = versionPanel;
    }
    
    public JPanel getVersionPanel() {
        return versionPanel;
    }
public JPanel getTitlePanel() {
     * | Background sound
     * |
     * | This is a method that will set the background sound effects for Aurora
     * | 
     * .........................................................................
     *
     */
public void setSFX() throws UnsupportedAudioFileException, IOException,
     * |
     * | This method displays the exit dialog
     * |
     * | After the user clicks on the Exit button, the user will be presented 
     * | with a warning dialog asking them if they are sure they want to exit
     * | the application.
     * .........................................................................
     *
     */    
    public void showExitDialog() {
        if (warningDialog == null) {
            warningDialog = new ADialog(ADialog.aDIALOG_WARNING,
public ASurface getResource() {
    private void setCursor() {


        frame.setCursor(frame.getToolkit().createCustomCursor(
                new BufferedImage(3, 3, BufferedImage.TYPE_INT_ARGB), new Point(
                0, 0),
                "null"));

        AImage cursorImage = new AImage("cursor.png");
        AImage cursorSelect = new AImage("cursorSelect.png");

        cursorImage.setVisible(false);
        cursorSelect.setVisible(false);

        JPanel glass = new JPanel();

        glass.add(cursorImage);
        glass.add(cursorSelect);

        Cursor cursor = new Cursor(
                cursorImage, cursorSelect, frame.getContentPane(), glass);

        frame.getContentPane()
                .addMouseWheelListener(new MouseEventRedispatcher(glass, frame
                .getContentPane()));

        glass.addMouseMotionListener(cursor);
        glass.addMouseListener(new CursorClick(cursor));

        frame.setGlassPane(glass);

        glass.setVisible(true);
        glass.setLayout(null);
        glass.setOpaque(false);

    }

public void keyReleased(KeyEvent e) {
        }
    }

    private static class CursorClick extends MouseAdapter {

        private final AImage cursorImage;

        private final AImage cursorSelect;

        private final Cursor click;

//        private final AImage cursorHover;
        public CursorClick(Cursor click) {
            this.cursorImage = click.getCursorImage();
            this.cursorSelect = click.getCursorSelect();
            this.click = click;
        }

        public AImage getCursorImage() {
            return cursorImage;
        }

        public AImage getCursorSelect() {
            return cursorSelect;
        }

        @Override
        public void mousePressed(MouseEvent e) {

            cursorImage.setVisible(false);

            cursorSelect.setLocation(e.getPoint());

            cursorSelect.setBounds(e.getX() - 11, e.getY() - 8, cursorImage
                    .getImgIcon()
                    .getIconWidth(), cursorImage.getImgIcon().getIconHeight());

            cursorSelect.setVisible(true);

            click.redispatchMouseEvent(e, true);
        }

        @Override
        public void mouseReleased(MouseEvent e) {

            cursorSelect.setVisible(false);

            cursorImage.setLocation(e.getPoint());

            cursorImage.setBounds(e.getX() - 11, e.getY() - 8, cursorImage
                    .getImgIcon()
                    .getIconWidth(), cursorImage.getImgIcon().getIconHeight());

            cursorImage.setVisible(true);

            click.redispatchMouseEvent(e, true);

        }

        public void mouseClicked(MouseEvent e) {
            click.redispatchMouseEvent(e, true);
        }

        public void mouseEntered(MouseEvent e) {
            click.redispatchMouseEvent(e, true);
        }

        @Override
        public void mouseExited(MouseEvent e) {
            cursorSelect.setVisible(false);
            cursorImage.setVisible(false);
            click.redispatchMouseEvent(e, true);
        }
    }

    class Cursor implements MouseMotionListener {

        private final AImage cursorImage;

        private final AImage cursorSelect;

        private final JPanel glassPane;

        private final Container contentPane;

        private Cursor(AImage cursorImage, AImage cursorSelect,
                       Container contentPane, JPanel glassPane) {
            this.cursorImage = cursorImage;
            this.cursorSelect = cursorSelect;
            this.contentPane = contentPane;
            this.glassPane = glassPane;
        }

        public AImage getCursorImage() {
            return cursorImage;
        }

        public AImage getCursorSelect() {
            return cursorSelect;
        }

        @Override
        public void mouseDragged(MouseEvent e) {

            cursorImage.setVisible(false);

            cursorSelect.setLocation(e.getPoint());

            cursorSelect.setBounds(e.getX() - 11, e.getY() - 8, cursorImage
                    .getImgIcon()
                    .getIconWidth(), cursorImage.getImgIcon().getIconHeight());

            cursorSelect.setVisible(true);

            redispatchMouseEvent(e, true);
        }

        @Override
        public void mouseMoved(MouseEvent e) {

            cursorSelect.setVisible(false);
//            if (panel.getBounds().contains(e.getPoint())) {


            cursorImage.setLocation(e.getPoint());

            cursorImage.setBounds(e.getX() - 11, e.getY() - 8, cursorImage
                    .getImgIcon()
                    .getIconWidth(), cursorImage.getImgIcon()
                    .getIconHeight());


            cursorImage.setVisible(true);

            redispatchMouseEvent(e, true);

        }

        public void redispatchMouseEvent(MouseEvent e,
                                         boolean repaint) {
            Point glassPanePoint = e.getPoint();
            Container container = contentPane;
            Point containerPoint = SwingUtilities.convertPoint(glassPane,
                    glassPanePoint,
                    contentPane);
            //The mouse event is probably over the content pane.
            //Find out exactly which component it's over.
            Component component =
                      SwingUtilities.getDeepestComponentAt(container,
                    containerPoint.x,
                    containerPoint.y);

            if (component != null) {
                //Forward events
                Point componentPoint = SwingUtilities.convertPoint(glassPane,
                        glassPanePoint,
                        component);
                component.dispatchEvent(new MouseEvent(component,
                        e.getID(),
                        e.getWhen(),
                        e.getModifiers(),
                        componentPoint.x,
                        componentPoint.y,
                        e.getClickCount(),
                        e.isPopupTrigger()));
            } else {
                glassPanePoint = null;
            }

            //Update the glass pane if requested.
            if (repaint) {
                glassPane.repaint();
            }
        }
    }

    class MouseEventRedispatcher extends MouseAdapter {

        private final JPanel glassPane;
private void redispatchMouseEvent(MouseEvent e,
            Point containerPoint = SwingUtilities.convertPoint(glassPane,
                    glassPanePoint,
                    contentPane);
            
            //* 
            // The mouse event is probably over the content pane.
            // Find out exactly which component it's over.
            //*
public static void main(String[] args) throws InterruptedException, UnsupportedA
        }


        if (Double.parseDouble(System.getProperty("java.version").substring(2, 3)) >= 6
                && Integer.parseInt(System.getProperty("java.version").substring(6, 8)) >= 17) {

            //Initiate The LoginWindow
            System.out.println("Running Java Version: " + System.getProperty("java.version"));
            System.out.println("OS: " + System.getProperty("os.name"));
            StartScreenUI aurora_StartUp = new StartScreenUI(startMini);


        } else if (Double.parseDouble(System.getProperty("java.version").substring(0, 3)) == 1.7) {
            //Initiate The LoginWindow
            System.out.println("Running Java Version: " + System.getProperty("java.version"));
            System.out.println("OS: " + System.getProperty("os.name"));
            StartScreenUI aurora_StartUp = new StartScreenUI(startMini);


        } else {
            ressource = new ASurface("");
            try {
public static void main(String[] args) throws InterruptedException, UnsupportedA


    }
}

public CarouselPaneMouseListener(final ACarouselPane aCarouselPane) {
        @Override
        public final void mouseClicked(final MouseEvent e) {
            System.out.println("CLICKED");

            if (pane == null && pane instanceof ACarouselPane) {
                pane = (ACarouselPane) e.getComponent();
            }
public HoverButtonRight(GameLibraryUI gameLibraryUI,
            this.libraryUI = gameLibraryUI;
            this.coreUI = auroraCoreUI;

            //GridSplit = library.getGridSplit();
            GameBack = gameLibraryUI.getGameBack();
            imgGameLeft = gameLibraryUI.getImgGameLeft();
            imgGameRight = gameLibraryUI.getImgGameRight();
public void mouseClicked(MouseEvent e) {

                    GridAnimate.moveRight(libraryUI.getCurrentIndex());

                    //carlos
                    // GridSplit.incrementVisibleGridIndex();


                    try {
                        libraryUI.loadGames(libraryUI.getCurrentIndex() + 1);
public void mouseReleased(MouseEvent e) {

        @Override
        public void mouseEntered(MouseEvent e) {
            GridAnimate = libraryUI.getGridAnimate();
            imgGameRight = libraryUI.getImgGameRight();

import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * .------------------------------------------------------------------------.
     */
    private final AuroraCoreUI coreUI;

    /**
     * .-----------------------------------------------------------------------.
     * | DashboardLogic(DashboardUI)
public DashboardLogic(final DashboardUI dashboardUi) {

        this.storage = dashboardUI.getStorage();

    }


    @Override
    public final void setHandler(final AuroraScreenHandler handler) {
        this.dashboardHandler = (DashboardHandler) handler;
public final void launchAuroraApp(final ACarouselPane aCarouselPane) {
        if (pane == dashboardUI.getLibraryPane()) {
            //action on click right Panel
            if (dashboardUI != null) {
                GameLibraryUI libraryUI = new GameLibraryUI(dashboardUI
                        .getStartUI().getAuroraStorage(), dashboardUI,
                        dashboardUI.getCoreUI());
                libraryUI.loadUI();
            }
        } else if (pane == dashboardUI.getProfilePane()) {
            GamerProfileUI profileUI = new GamerProfileUI(dashboardUI,
                    dashboardUI.getCoreUI());
            profileUI.loadUI();
        } else if (pane == dashboardUI.getSettingsPane()) {
            SettingsUI settingsUI = new SettingsUI(dashboardUI,
                    dashboardUI.getCoreUI());

            settingsUI.loadUI();
        } else if (pane == dashboardUI.getAuroraNetPane()) {
            // do nothing for now
        }
public final void navigateCarousel(final ACarouselPane aCarouselPane) {
        }

    }
}
import aurora.V1.core.screen_logic.GameLibraryLogic;
import aurora.engine.V1.Logic.*;
import aurora.engine.V1.UI.*;
import java.awt.*;
import java.awt.event.ActionListener;
import java.lang.reflect.Field;
import java.net.MalformedURLException;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.*;

/**
 * .---------------------------------------------------------------------------.

    private int currentIndex;

    private ActionListener a;

    private int currentPanel;

    private ArrayList<Boolean> loadedPanels;

    public static int SIZE_GameCoverHeight;

    public static int SIZE_GameCoverWidth;

    public static int SIZE_ZoomButtonHeight;

    public static int SIZE_SelectedGameBarHeight;

    public static int SIZE_SelectedGameBarWidth;

    public static int SIZE_AddGameWidth;

    public static int SIZE_AddGameHeight;

    public static int SIZE_GameNameFont;

    private GridAnimation GridAnimate;


    private JPanel pnlAddGameContainer;

    public GameLibraryUI(AuroraStorage storage, final DashboardUI dashboardUi,
                         final AuroraCoreUI auroraCoreUI) {
        this.coreUI = auroraCoreUI;
public GameLibraryUI(AuroraStorage storage, final DashboardUI dashboardUi,
        handler.setLogic(logic);
        logic.setHandler(handler);

        this.clearUI();
        isGameLibraryKeyListenerAdded = false;

    }
public final void loadUI() {
        //* Zoom Buttons *//
        btnZoomPlus = new AButton("Aurora_ZoomP_normal.png",
                "Aurora_ZoomP_down.png",
                "Aurora_ZoomP_over.png", 0, SIZE_ZoomButtonHeight);
        btnZoomLess = new AButton("Aurora_ZoomM_normal.png",
                "Aurora_ZoomM_down.png",
                "Aurora_ZoomM_over.png", 0, SIZE_ZoomButtonHeight);


        //* Key Board Naviagtion Icon *//
public final void loadUI() {
        SelectedGameContainer = new JPanel();

        imgSelectedGamePane = new AImagePane("Aurora_SelectedGameBar.png",
                SIZE_SelectedGameBarWidth, SIZE_SelectedGameBarHeight,
                new FlowLayout(FlowLayout.CENTER, 0, 5));

        lblGameName = new JLabel("Select A Game For Info");
public final void loadUI() {
        pnlAddGameContainer = new JPanel(new BorderLayout());

        btnAddGame = new AButton("Aurora_Add_normal.png", "Aurora_Add_down.png",
                "Aurora_Add_over.png", SIZE_AddGameWidth, SIZE_AddGameHeight);


        //* Search Bar *//
public final void loadUI() {
        SearchContainer = new JPanel(new BorderLayout());
        SearchPane = new JPanel(new BorderLayout());


        // Handlers
        // --------------------------------------------------------------------.
public final void loadUI() {
        attactchHandlers();


        //Start Aurora Dabatase connection
        try {
            CoverDB = new ASimpleDB("AuroraDB", "AuroraTable", false);
        } catch (SQLException ex) {
            Logger.getLogger(GameLibraryUI.class.getName()).log(Level.SEVERE,
                    null, ex);
        }

        GridSplit = new GridManager(2, 4, coreUI);


        //Grid Animator
        this.GridAnimate = new GridAnimation(GridSplit, paneLibraryContainer);


    }

    @Override
    public void buildUI() {

        setSize();

        //* Add Zoom Buttons *//
//        coreUI.getTitlePanel().removeAll();
//        coreUI.getTitlePanel().add(ZoomM);
//        coreUI.getTitlePanel().add(coreUI.getTitleLabel());
//        coreUI.getTitlePanel().add(ZoomP);

        paneLibraryContainer.setOpaque(false);
        paneLibraryContainer.setBackground(Color.red);
        paneLibraryContainer.setLayout(new BorderLayout(0, 0));

        lblKeyAction.setFont(coreUI.getDefaultFont().deriveFont(Font.PLAIN,
                coreUI.getKeysFontSize()));
        lblKeyAction.setForeground(Color.YELLOW);



        //* Selected Game Name Bar *//
        SelectedGameContainer.setOpaque(false);

        lblGameName.setOpaque(false);
        lblGameName.setFont(coreUI.getDefaultFont().deriveFont(Font.PLAIN,
                SIZE_GameNameFont));
        lblGameName.setForeground(Color.LIGHT_GRAY);

        imgSelectedGamePane.setPreferredSize(new Dimension(
                SIZE_SelectedGameBarWidth, SIZE_SelectedGameBarHeight));
        imgSelectedGamePane.add(lblGameName);
        SelectedGameContainer.add(imgSelectedGamePane);

        //* Add Game Button *//
        pnlAddGameContainer.setOpaque(false);
        btnAddGame.addActionListener(addGameHandler);
        pnlAddGameContainer.add(btnAddGame, BorderLayout.CENTER);


        //* Search Bar *//
        SearchBarBG.setPreferredSize(new Dimension(SIZE_SearchBarWidth, 50));
        removeSearchButton.setPreferredSize(new Dimension(70, 51));

        gridSearchBar.setOpaque(false);
        gridSearchBar.setBorder(null);
        gridSearchBar.setColumns(19);
        gridSearchBar.setForeground(Color.darkGray);
        gridSearchBar.setFont(coreUI.getDefaultFont().deriveFont(Font.BOLD, 40));
        gridSearchBar.setPreferredSize(new Dimension(880, 50));

        SearchButton.setPreferredSize(new Dimension(70, 51));
        SearchButton.addActionListener(handler.new searchButtonHandler(this));

        SearchButtonBG.setPreferredSize(new Dimension(70, 51));
        SearchButtonBG.add(SearchButton, BorderLayout.NORTH);

        TextPane.setOpaque(false);
        TextPane.add(gridSearchBar, BorderLayout.NORTH);

        SearchContainer.setOpaque(false);
        SearchContainer.add(ButtonPane, BorderLayout.WEST);
        SearchContainer.add(TextPane, BorderLayout.CENTER);

        ButtonPane.setOpaque(false);
        ButtonPane.add(SearchButtonBG, BorderLayout.NORTH);

        SearchBarBG.add(SearchContainer, BorderLayout.WEST);
        SearchBarBG.validate();

        SearchPane.setOpaque(false);
        SearchPane.add(SearchBarBG, BorderLayout.EAST);
        SearchPane.setPreferredSize(new Dimension(SearchPane.getBounds().width,
                75));
        SearchPane.validate();

        //* Add Components to Central Container *//
        paneLibraryContainer.add(BorderLayout.WEST, imgFavorite);
        paneLibraryContainer.add(BorderLayout.CENTER, GridSplit.getGrid(0));
        paneLibraryContainer.add(BorderLayout.EAST, btnGameRight);

        //* Initiate Grid *//
        GridSplit.initiateGrid(0);



        // Add Games to Library
        // --------------------------------------------------------------------.

        try {

            //* Add Games Marked Fav first *//

            for (int i = 0; i < storage.getStoredLibrary().getGameNames().size();
                    i++) {

                Game Game = new Game(GridSplit, coreUI, dashboardUI, storage);
                if (storage.getStoredLibrary().getFaveStates().get(i)) {
                    Game.setGameName(storage.getStoredLibrary().getGameNames()
                            .get(i));
                    Game.setCoverUrl(storage.getStoredLibrary().getBoxArtPath()
                            .get(i));
                    //Handle appostrophese in game path
                    Game.setGamePath(storage.getStoredLibrary().getGamePath()
                            .get(i).replace("'", "''"));
                    Game.setFavorite(storage.getStoredLibrary().getFaveStates()
                            .get(i));
                    Game.setCoverSize(SIZE_GameCoverWidth, SIZE_GameCoverHeight);

                    GridSplit.addGame(Game);
                }
            }

            //* Add Non-Fav games after *//

            for (int i = 0; i < storage.getStoredLibrary().getGameNames().size();
                    i++) {

                Game Game = new Game(GridSplit, coreUI, dashboardUI, storage);
                if (!storage.getStoredLibrary().getFaveStates().get(i)) {
                    Game.setGameName(storage.getStoredLibrary().getGameNames()
                            .get(i));
                    Game.setCoverUrl(storage.getStoredLibrary().getBoxArtPath()
                            .get(i));
                    //Handle appostrophese in game path
                    Game.setGamePath(storage.getStoredLibrary().getGamePath()
                            .get(i).replace("'", "''"));
                    Game.setFavorite(storage.getStoredLibrary().getFaveStates()
                            .get(i));
                    Game.setCoverSize(SIZE_GameCoverWidth, SIZE_GameCoverHeight);

                    GridSplit.addGame(Game);
                }
            }

            GridSplit.finalizeGrid(addGameHandler, SIZE_GameCoverWidth,
                    SIZE_GameCoverHeight);

            //Load First Grid by default
            loadGames(0);
        } catch (MalformedURLException ex) {
            System.out.println("MalformedURLExeption \n" + ex);
        }

        addToCanvas();
    }

    @Override
public void addToCanvas() {

        //Finalize
        coreUI.getTitleLabel().setText("   Game Library   ");

        coreUI.getFrame().requestFocus();
    }

    public void attactchHandlers() {
public void setSize() {
        System.out.println("Height " + coreUI.getFrame().getHeight());
        System.out.println("Width " + coreUI.getFrame().getWidth());
        if (coreUI.isLargeScreen()) {
            SIZE_GameCoverHeight = coreUI.getFrame().getHeight() / 3 - (Ratio
                                                                        / 10)
                                   + 5;
            SIZE_GameCoverWidth = coreUI.getFrame().getWidth() / 5
                                  - (Ratio / 10) - 5;
            SIZE_ZoomButtonHeight = 30;
            SIZE_SelectedGameBarHeight = 65;
            SIZE_SelectedGameBarWidth = 380;
            SIZE_AddGameWidth = 351;
            SIZE_AddGameHeight = 51;
            SIZE_GameNameFont = 35;
            SIZE_FramePanePadding = 20;
            SIZE_SearchBarWidth = 880;

        } else {
            SIZE_FramePanePadding = 10;
            SIZE_GameCoverHeight = coreUI.getFrame().getHeight() / 3 - (Ratio
                                                                        / 10);
            SIZE_GameCoverWidth = coreUI.getFrame().getWidth() / 5
                                  - (Ratio / 10);
            SIZE_ZoomButtonHeight = 25;
            SIZE_AddGameWidth = 300;
            SIZE_AddGameHeight = 40;
            SIZE_SelectedGameBarHeight = 60;
            SIZE_SelectedGameBarWidth = 360;
            SIZE_GameNameFont = 32;
            SIZE_SearchBarWidth = coreUI.getFrame().getWidth() / 2 + coreUI
                    .getControlWidth() / 2;
        }
public GridManager getGridSplit() {
        return GridSplit;
    }

    public int getSIZE_AddGameHeight() {
        return SIZE_AddGameHeight;
    }

    public int getSIZE_AddGameWidth() {
        return SIZE_AddGameWidth;
    }

    public int getSIZE_FramePanePadding() {
        return SIZE_FramePanePadding;
    }

    public int getSIZE_GameCoverHeight() {
        return SIZE_GameCoverHeight;
    }

    public int getSIZE_GameCoverWidth() {
        return SIZE_GameCoverWidth;
    }

    public int getSIZE_GameNameFont() {
        return SIZE_GameNameFont;
    }

    public int getSIZE_SelectedGameBarHeight() {
        return SIZE_SelectedGameBarHeight;
    }

    public int getSIZE_SelectedGameBarWidth() {
        return SIZE_SelectedGameBarWidth;
    }

    public int getSIZE_ZoomButtonHeight() {
        return SIZE_ZoomButtonHeight;
    }

    public GridSearch getSearch() {
public AButton getZoomP() {
        return btnZoomPlus;
    }

    public ActionListener getA() {
        return a;
    }

    public AButton getBtnAddGame() {
        return btnAddGame;
    }
public GamerProfileUI(DashboardUI dahsboardUi, AuroraCoreUI auroraCoreUi) {

        this.dashboardUI = dahsboardUi;
        this.coreUI = auroraCoreUi;
        this.clearUI();
    }

    @Override
public SettingsUI(DashboardUI dashboardUI, AuroraCoreUI auroraCoreUI) {

        this.dashboardUI = dashboardUI;
        this.coreUI = auroraCoreUI;
        this.clearUI();
    }

    @Override
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void clear() {
            bitmapProvider.release(previousImage);
        }
        previousImage = null;
    }

    public void setData(GifHeader header, byte[] data) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public final static int schedule1PrecLmax(ITJob[] jobs, Proc1PrecLmax procedure)
		pendingJobs.clear();
		currentTime = JobUtils.sumDurations(jobs);
		//VisuFactory.getDotManager().show(new DottyBean(jobs));
		JobUtils.initPredecessorHooks(jobs, procedure);
		//Lawler algorithm : build sequence in backward order P = sum pj
		while( ! pendingJobs.isEmpty()) {
			//schedule job with the latest due date (minimize min fj(P))
public final static int schedule1PrecLmax(ITJob[] jobs, Proc1PrecLmax procedure)
			final int lateness = job.getLateness();
			if(lmax < lateness) { lmax = lateness;}
			//Update pending jobs
			job.forEachSuccessor(procedure);
		}
		assert(isScheduled(jobs));
		return lmax;

	private final static String[] CMD_PREFIX = {"--seed","0","-t", "LP"};

	//private final static String[] CONFS = {"basic", "pmtn", "prec"};
	private final static String[] CONFS = {"prec"};
	
		
	@BeforeClass
	public final static void setUp() {
		ChocoLogging.setVerbosity(Verbosity.QUIET);
		ChocoLogging.setVerbosity(Verbosity.VERBOSE);
	}
	
	@AfterClass
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    <ConfirmationsSetting value="0" id="Add" />
    <ConfirmationsSetting value="0" id="Remove" />
  </component>
  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_7" default="true" assert-keyword="true" jdk-15="true" project-jdk-name="1.8" project-jdk-type="JavaSDK">
    <output url="file://$PROJECT_DIR$/build/classes" />
  </component>
  <component name="ProjectType">

      <sourceFolder url="file://$MODULE_DIR$/src/main/jni" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/rs" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/shaders" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/res" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/assets" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/aidl" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/java" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/jni" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/rs" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/shaders" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/res" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/resources" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/assets" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/jni" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/rs" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/shaders" isTestSource="true" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/assets" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/blame" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/bundles" />
    <orderEntry type="jdk" jdkName="Android API 24 Platform" jdkType="Android SDK" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" exported="" scope="TEST" name="backport-util-concurrent-3.1" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="xercesMinimal-1.9.6.2" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="maven-profile-2.2.1" level="project" />
    <orderEntry type="library" exported="" name="support-compat-24.2.0" level="project" />
    <orderEntry type="library" exported="" name="support-v4-24.2.0" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="runner-0.5" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="maven-settings-2.2.1" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="hamcrest-library-1.3" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="accessibility-test-framework-2.1" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="asm-commons-5.0.1" level="project" />
    <orderEntry type="library" exported="" name="play-services-base-8.4.0" level="project" />
    <orderEntry type="library" exported="" name="customtabs-24.2.0" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="wagon-http-lightweight-1.0-beta-6" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="nekohtml-1.9.6.2" level="project" />
    <orderEntry type="library" exported="" name="support-fragment-24.2.0" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="asm-5.0.1" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="maven-repository-metadata-2.2.1" level="project" />
    <orderEntry type="library" exported="" name="materialish-progress-1.5" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="robolectric-3.1.2" level="project" />
    <orderEntry type="library" exported="" name="leanback-v17-24.2.0" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="asm-tree-5.0.1" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="sqlite4java-0.282" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="maven-project-2.2.1" level="project" />
    <orderEntry type="library" exported="" name="settingsmanager-common-1.2.1" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="plexus-container-default-1.0-alpha-9-stable-1" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="plexus-interpolation-1.11" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="shadows-core-v23-3.1.2" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="maven-artifact-manager-2.2.1" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="classworlds-1.1-alpha-2" level="project" />
    <orderEntry type="library" exported="" name="answers-1.3.1" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="maven-ant-tasks-2.1.3" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="ant-1.8.0" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="wagon-file-1.0-beta-6" level="project" />
    <orderEntry type="library" exported="" name="animated-vector-drawable-24.2.0" level="project" />
    <orderEntry type="library" exported="" name="settingsmanager-1.3.5" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="xstream-1.4.8" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="wagon-provider-api-1.0-beta-6" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="asm-util-5.0.1" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="bcprov-jdk16-1.46" level="project" />
    <orderEntry type="library" exported="" name="core-0.9.0.1" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="asm-analysis-5.0.1" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="robolectric-resources-3.1.2" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="protobuf-java-2.6.1" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="hamcrest-core-1.3" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="vtd-xml-2.11" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="junit-4.12" level="project" />
    <orderEntry type="library" exported="" name="play-services-basement-8.4.0" level="project" />
    <orderEntry type="module" module-name="plugins" exported="" />
android {
        applicationId "com.felkertech.n.cumulustv"
        minSdkVersion 21
        targetSdkVersion 24
        versionCode 45
        versionName "1.6.0.1.dogfood"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
    }
    signingConfigs {
public static void openAbout(final Activity activity) {
                        @Override
                        public void onPositive(MaterialDialog dialog) {
                            super.onPositive(dialog);
                            /*Intent gi = new Intent(Intent.ACTION_VIEW);
                            gi.setData(Uri.parse("http://cumulustv.herokuapp.com"));
                            mActivity.startActivity(gi);*/
                            String url = activity.getString(R.string.website_url);
                            CustomTabsIntent.Builder builder = new CustomTabsIntent.Builder();
                            CustomTabsIntent customTabsIntent = builder.build();
                            try {
                                customTabsIntent.launchUrl(activity, Uri.parse(url));
                            } catch (ActivityNotFoundException e) {
                                // There is no way to view the website.
                                activity.startActivity(new Intent(activity,
                                        HomepageWebViewActivity.class));
    private CaptioningManager mCaptioningManager;
    private JsonChannel jsonChannel;
    private boolean stillTuning;
    private HashMap<String, XmlTvParser.TvListing> epgData;

    @Override
    public void onCreate() {
public void onCreate() {
    @Override
    public void performCustomSync(final SyncAdapter syncAdapter, String inputId) {
        new EpgDataSyncThread(syncAdapter.getContext()).start();
        syncAdapter.performCustomSync(this, inputId);
    }

    @Override
public Session onCreateSession(String inputId) {
        simpleSession.setOverlayViewEnabled(true);
        return simpleSession;
    }
    private final class EpgDataSyncThread extends Thread {
        private Context mContext;

public Session onCreateSession(String inputId) {
        @Override
        public void run() {
            super.run();
            ChannelDatabase cdn = ChannelDatabase.getInstance(mContext);
            try {
                List<JsonChannel> channels = cdn.getJsonChannels();
public void handleMessage(Message msg) {
        i.sendEmptyMessageDelayed(0, (SETUP_DURATION - SETUP_UI_LAST) / channels.length);

        String[] projection = {TvContract.Channels.COLUMN_DISPLAY_NUMBER,
                TvContract.Channels.COLUMN_DISPLAY_NAME, TvContract.Channels._ID};
        //Now look up this channel in the DB
        try (Cursor cursor =
                     getContentResolver().query(TvContract.buildChannelsUriForInput(null),
                             projection, null, null, null)) {
            if (cursor == null || cursor.getCount() == 0) {
                return;
            }
            while(cursor.moveToNext()) {
                if (DEBUG) {
                    Log.d(TAG, "Tune to " +
                            cursor.getString(cursor.getColumnIndex(
        android:id="@+id/view"/>
    <Button android:text="Sync files with Google Drive" android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_below="@+id/gotoapp"
        style="@style/main_button"
        android:id="@+id/gdrive"/>
    <Button android:text="More..." android:layout_width="match_parent"
<?xml version="1.0" encoding="utf-8"?>
<items version="2" />

    <orderEntry type="library" exported="" scope="TEST" name="rules-0.5" level="project" />
    <orderEntry type="library" exported="" name="support-core-ui-24.2.0" level="project" />
    <orderEntry type="library" exported="" name="support-core-utils-24.2.0" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="javax.annotation-api-1.2" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="hamcrest-library-1.3" level="project" />
    <orderEntry type="library" exported="" name="appcompat-v7-24.2.0" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="javax.inject-1" level="project" />
    <orderEntry type="library" exported="" scope="TEST" name="hamcrest-integration-1.3" level="project" />

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private SafeString readString(ByteBuf buffer, int size) {
    }

    private SafeString readBytes(ByteBuf buffer, int size) {
        ByteBuf readedBytes = buffer.readBytes(size);
        try {
        	return new SafeString(readedBytes.nioBuffer());
        } finally {
        	readedBytes.release();
        }
    }

    private static int findEndOfLine(final ByteBuf buffer) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public Border getCenterrBorder() {
     */
    @Override
    public void dispose() {
        panMain.dispose();
        alb_picturePanel.dispose();
    }
import org.jfree.util.Log;

import org.openide.util.Exceptions;

import java.awt.Color;
import java.awt.Component;
import java.util.Collection;
import java.util.Collections;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.ExecutionException;

import javax.swing.ComboBoxModel;
public Date convertReverse(final String value) {

    //~ Instance fields --------------------------------------------------------

    final PropertyChangeListener listener = new CidsBeanListener();
    private CidsBean cidsBean;
    private Collection<MetaObject> allSelectedObjects;
    private final boolean editable;
public Date convertReverse(final String value) {
    private Object oldGeprueft_Von;
    private Object oldPruefdatum;
    private Object oldPruefkommentar;
    private final HashMap<CidsBean, String> propStringMap = new HashMap<CidsBean, String>();
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private de.cismet.cids.editors.DefaultBindableDateChooser bdcBefristungsdatum;
    private de.cismet.cids.editors.DefaultBindableDateChooser bdcEintragungsdatum;
public String getRepresentation() {
     *
     * @param  evt  DOCUMENT ME!
     */
    private void btnAddBelastetActionPerformed(final java.awt.event.ActionEvent evt) { //GEN-FIRST:event_btnAddBelastetActionPerformed
        fsDialoge.setCurrentListToAdd(CidsBeanSupport.getBeanCollectionFromProperty(cidsBean, "flurstuecke_belastet"));
        handleAddFlurstueck(true);
    }                                                                                  //GEN-LAST:event_btnAddBelastetActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void btnAddBeguenstigtActionPerformed(final java.awt.event.ActionEvent evt) { //GEN-FIRST:event_btnAddBeguenstigtActionPerformed
        fsDialoge.setCurrentListToAdd(CidsBeanSupport.getBeanCollectionFromProperty(
                cidsBean,
                "flurstuecke_beguenstigt"));
        handleAddFlurstueck(false);
    }                                                                                     //GEN-LAST:event_btnAddBeguenstigtActionPerformed

    /**
     * DOCUMENT ME!
private void handleAddFlurstueck(final boolean belastet) {
     *
     * @param  evt  DOCUMENT ME!
     */
    private void btnRemoveBeguenstigtActionPerformed(final java.awt.event.ActionEvent evt) { //GEN-FIRST:event_btnRemoveBeguenstigtActionPerformed
        final Object[] selection = lstFlurstueckeBeguenstigt.getSelectedValues();
        if ((selection != null) && (selection.length > 0)) {
            final int answer = JOptionPane.showConfirmDialog(
private void btnRemoveBeguenstigtActionPerformed(final java.awt.event.ActionEven
                }
            }
        }
    }                                                                                        //GEN-LAST:event_btnRemoveBeguenstigtActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void btnRemoveBelastetActionPerformed(final java.awt.event.ActionEvent evt) { //GEN-FIRST:event_btnRemoveBelastetActionPerformed
        final Object[] selection = lstFlurstueckeBelastet.getSelectedValues();
        if ((selection != null) && (selection.length > 0)) {
            final int answer = JOptionPane.showConfirmDialog(
private void btnRemoveBelastetActionPerformed(final java.awt.event.ActionEvent e
                }
            }
        }
    }                                                                                     //GEN-LAST:event_btnRemoveBelastetActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void btnAddArtActionPerformed(final java.awt.event.ActionEvent evt) { //GEN-FIRST:event_btnAddArtActionPerformed
        if (!baulastArtenListInitialized) {
            CismetThreadPool.execute(new BaulastArtenComboModelWorker());
        }

        StaticSwingTools.showDialog(StaticSwingTools.getParentFrame(this), dlgAddBaulastArt, true);
    } //GEN-LAST:event_btnAddArtActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void btnRemoveArtActionPerformed(final java.awt.event.ActionEvent evt) { //GEN-FIRST:event_btnRemoveArtActionPerformed
        final Object[] selection = lstBaulastArt.getSelectedValues();
        if ((selection != null) && (selection.length > 0)) {
            final int answer = JOptionPane.showConfirmDialog(
private void btnRemoveArtActionPerformed(final java.awt.event.ActionEvent evt) {
                }
            }
        }
    }                                                                                //GEN-LAST:event_btnRemoveArtActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void btnMenAbort1ActionPerformed(final java.awt.event.ActionEvent evt) { //GEN-FIRST:event_btnMenAbort1ActionPerformed
        dlgAddBaulastArt.setVisible(false);
    }                                                                                //GEN-LAST:event_btnMenAbort1ActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void btnMenOk1ActionPerformed(final java.awt.event.ActionEvent evt) { //GEN-FIRST:event_btnMenOk1ActionPerformed
        final Object selection = cbBaulastArt.getSelectedItem();
        if (selection instanceof LightweightMetaObject) {
            final CidsBean selectedBean = ((LightweightMetaObject)selection).getBean();
private void btnMenOk1ActionPerformed(final java.awt.event.ActionEvent evt) { //
            }
        }
        dlgAddBaulastArt.setVisible(false);
    }                                                                             //GEN-LAST:event_btnMenOk1ActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void lstFlurstueckeBelastetMouseClicked(final java.awt.event.MouseEvent evt) { //GEN-FIRST:event_lstFlurstueckeBelastetMouseClicked
        if (evt.getClickCount() > 1) {
            handleJumpToListeSelectionBean(lstFlurstueckeBelastet);
        }
    }                                                                                      //GEN-LAST:event_lstFlurstueckeBelastetMouseClicked

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void lstFlurstueckeBeguenstigtMouseClicked(final java.awt.event.MouseEvent evt) { //GEN-FIRST:event_lstFlurstueckeBeguenstigtMouseClicked
        if (evt.getClickCount() > 1) {
            handleJumpToListeSelectionBean(lstFlurstueckeBeguenstigt);
        }
    }                                                                                         //GEN-LAST:event_lstFlurstueckeBeguenstigtMouseClicked

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void lblLastInMapMouseClicked(final java.awt.event.MouseEvent evt) { //GEN-FIRST:event_lblLastInMapMouseClicked
        ObjectRendererUtils.switchToCismapMap();
        ObjectRendererUtils.addBeanGeomsAsFeaturesToCismapMap(allSelectedObjects, editable);
    }                                                                            //GEN-LAST:event_lblLastInMapMouseClicked

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void bdcBefristungsdatumActionPerformed(final java.awt.event.ActionEvent evt) { //GEN-FIRST:event_bdcBefristungsdatumActionPerformed
        // TODO add your handling code here:
    } //GEN-LAST:event_bdcBefristungsdatumActionPerformed

    /**
     * DOCUMENT ME!
public void setCidsBean(final CidsBean cidsBean) {
                final Collection<MetaObject> selObj = new ArrayList<MetaObject>(1);
                selObj.add(cidsBean.getMetaObject());
                setAllSelectedMetaObjects(selObj);
                if (this.cidsBean != null) {
                    this.cidsBean.removePropertyChangeListener(listener);
                }
                this.cidsBean = cidsBean;
                List<CidsBean> landParcelCol = CidsBeanSupport.getBeanCollectionFromProperty(
                        cidsBean,
public void setCidsBean(final CidsBean cidsBean) {
                                && propstring.equals(cidsBean.getMetaObject().getPropertyString());

                    chkGeprueft.setEnabled(finalCheckEnable);
                    cidsBean.addPropertyChangeListener(listener);
                } else {
                    final Object geprueftObj = cidsBean.getProperty("geprueft");
                    if ((geprueftObj instanceof Boolean) && ((Boolean)geprueftObj)) {
public void setCidsBean(final CidsBean cidsBean) {
     */
    @Override
    public void dispose() {
        if (cidsBean != null) {
            cidsBean.removePropertyChangeListener(listener);
        }
        dlgAddBaulastArt.dispose();
        fsDialoge.dispose();
        bindingGroup.unbind();
    }

    /**
public void run() {
                                        Exceptions.printStackTrace(ex);
                                    }
                                } else {
                                    cidsBean.removePropertyChangeListener(listener);
                                    chkGeprueft.setSelected(false);
                                    cidsBean.addPropertyChangeListener(listener);
                                }
                            }
                        });
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void dump(ExpressionDumper dumper) {
        dumper.display("}");
    }

    private static class Mapping {
        Expression key;
        Expression value;

        public Mapping(Expression key, Expression value) {
            this.key = key;
            this.value = value;
        }
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void testScribePermalinkClick() {
        verify(scribeClient).click(TestFixtures.TEST_TWEET, view.getViewTypeName());
    }

    public void testSetErrorImage_handlesNullPicasso() {
        when(mockDependencyProvider.getImageLoader()).thenReturn(null);
        final BaseTweetView tweetView = createViewWithMocks(context, TestFixtures.TEST_TWEET,
                R.style.tw__TweetDarkStyle, mockDependencyProvider);

        try {
            tweetView.setErrorImage();
        } catch (NullPointerException e) {
            fail("Should have handled null error image");
        }
    }

    public void testSetProfilePhotoView_handlesNullPicasso() {
        when(mockDependencyProvider.getImageLoader()).thenReturn(null);

public static Picasso mockPicasso(Picasso picasso, RequestCreator requestCreator
        when(picasso.load(anyString())).thenReturn(requestCreator);
        when(picasso.load(anyInt())).thenReturn(requestCreator);
        when(requestCreator.centerCrop()).thenReturn(requestCreator);
        when(requestCreator.fit()).thenReturn(requestCreator);
        when(requestCreator.placeholder(any(Drawable.class)))
                .thenReturn(requestCreator);
import com.twitter.sdk.android.tweetui.internal.TweetMediaUtils;
import com.twitter.sdk.android.tweetui.internal.TweetMediaView;

import java.text.DateFormat;
import java.util.Date;
import java.util.Locale;
void setMediaImage(String imagePath, double aspectRatio) {
        mediaView.resetSize();
        mediaView.setAspectRatio(aspectRatio);
        imageLoader.load(imagePath)
                .placeholder(mediaBg)
                .fit()
                .centerCrop()
                .into(mediaView, new PicassoCallback());
    }

    protected double getAspectRatio(MediaEntity photoEntity) {
protected double getAspectRatio(ImageValue imageValue) {
    protected void clearMediaView() {
        // Clear out the background behind any potential error images that we had
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
            mediaView.setBackground(null);
        } else {
            mediaView.setBackgroundDrawable(null);
        }

        mediaView.setOverlayDrawable(null);
protected void clearMediaView() {
    }

    /**
     * Picasso Callback which asynchronously sets the error bitmap onError.
     */
    class PicassoCallback implements com.squareup.picasso.Callback {
        @Override
        public void onSuccess() { /* intentionally blank */ }

        @Override
        public void onError() {
            setErrorImage();
        }
    }

    protected void setErrorImage() {
        // async load the error image and set the proper background color behind it once it's loaded
        // this does incur the necessity of clearing the background on each load of an image however
        final Picasso imageLoader = dependencyProvider.getImageLoader();

        if (imageLoader == null) return;

        imageLoader.load(photoErrorResId)
                .into(mediaView, new com.squareup.picasso.Callback() {
                    @Override
                    public void onSuccess() {
                        mediaView.setBackgroundColor(mediaBgColor);
                    }

                    @Override
                    public void onError() { /* intentionally blank */ }
                });
    }

    /**
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void render() {

    }

}
import uk.ac.york.ini.atc.ATC;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.Sprite;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
    public static int width;
    public static int height;

    private ATC atc;
    protected SpriteBatch spriteBatch;
    protected OrthographicCamera camera;

    /**
     * Dispose of unused resources
public void removed() {
     */
    public final void init(ATC atc) {
	this.atc = atc;

	// can be used for a custom coordinate system
	// Matrix4 projection = new Matrix4();
	// projection.setToOrtho(0, 1280, 720, 0, 0, 0);

	spriteBatch = new SpriteBatch();
	// use in conjunction with the above commented code
	// spriteBatch.setProjectionMatrix(projection);
    }

    /**
public void drawSprite(Sprite sprite) {
     * @param color
     */
    public void drawString(CharSequence str, float x, float y, Color color) {
	final BitmapFont font = new BitmapFont();
	font.setColor(color);
	font.draw(spriteBatch, str, x, y);
    }

    public abstract void render();

    public void update() {

    }

}
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.Texture.TextureFilter;
import com.badlogic.gdx.graphics.g2d.TextureRegion;

public class TitleScreen extends Screen {
public void load() {

	// loads the texture, whose size must be in power's of two
	texture = new Texture(Gdx.files.internal("data/nisairspace.png"));
	texture.setFilter(TextureFilter.Linear, TextureFilter.Linear);

	// select a specific area of the loaded texture, this will be passed
	// onto a wrapper and drawn
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
     * @param context The android context object
     */
    public EventStore(Context context) {
        dbHelper = new EventStoreHelper(context);
        open();
        Logger.ifDebug(TAG, "DB Path: " + database.getPath());
    }

    /**
     * Opens a new writable database and
     * sets the database to allow WAL.
     *
     * WAL: https://www.sqlite.org/wal.html
     *
     * @return success or failure to open
     */
    public boolean open() {

        // Opens the database
        database = dbHelper.getWritableDatabase();

        // Enable write ahead logging
        database.enableWriteAheadLogging();
        return database != null;
    }

public EmittableEvents getEmittableEvents() {
     * @return a boolean for database status
     */
    public boolean isDatabaseOpen() {
        return database.isOpen();
    }
}
            "(id INTEGER PRIMARY KEY, eventData BLOB, " +
            "dateCreated TIMESTAMP DEFAULT CURRENT_TIMESTAMP)";

    public EventStoreHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private static void runSINInWeirdMode(String[] args) {
		try {
		    ServerCore serverCore = new ServerCore();
		    serverCore.host();
		    new Thread(serverCore).start();
		    System.out.println("Hosted");
		} catch (IOException ex) {
		    Logger.getLogger(LoginScreen.class.getName()).log(Level.SEVERE, null, ex);
public void init() {
    }

    private void callToConnect() {
	new Thread() {
	    @Override
	    public void run() {
		try {
public void show() {
	update(20);
	context.setCameraToPlayer();
	Gdx.input.setInputProcessor(stage);
	new Thread(this).start();
	new Thread(new Runnable() {

	    @Override
	    public void run() {
public void run() {
		    }
		}
	    }
	}).start();
    }

    @Override
public void run() {

	    @Override
	    public void run() {
		System.gc();
		try {
		    Thread.sleep(10000L);
		} catch (InterruptedException ex) {
		    Logger.getLogger(Corev3.class.getName()).log(Level.SEVERE, null, ex);
		}
	    }
	}, "GC Runner").start();
public void send(NetworkableMessage m) {
    }

    private void update() {
	while (true) {
	    if (!core.isNotpaused()) {
		NetworkingObject get = (NetworkingObject) core.getContext().getObjects().get(Context.NETWORKING_ID);
		get.process();
public void draw(SpriteBatch batch, float parentAlpha) {
	paintComponent(batch);
    }

    public void paintComponent(SpriteBatch batch) {
	ShapeRenderer renderer = new ShapeRenderer();
	OrthographicCamera camera = new OrthographicCamera();
	camera.setToOrtho(true);
	camera.update();
	batch = new SpriteBatch();
	batch.setProjectionMatrix(camera.combined);

	int x = 800 - INVENTORY_WIDTH;
	int y = TILE_PADDING;
	renderer.setProjectionMatrix(camera.combined);
public void paintComponent(SpriteBatch batch) {
	renderer.end();
	Gdx.gl.glDisable(GL20.GL_BLEND);
	drawItems(batch, x, y);
    }

    public Inventory(GameContext context) {
	this.context = context;
    }

}
    private final ConcurrentLinkedQueue<Message> messages = new ConcurrentLinkedQueue<>();
    @Getter private int id = -1;
    @Getter @Setter private boolean destroyed = false;
    @Getter private List<Component> components = new LinkedList<>();
    @NonNull @Getter private final GameObjectType type;
    @Getter private GameContext context;

public synchronized void process() {
	}
	while (messages.size() > 0) {
	    Message message = messages.poll();
	    for (Component component : components) {
		component.processMessage(message);
	    }
	}
public AccountManager() {
	} catch (IOException ex) {
	    Logger.getLogger(AccountManager.class.getName()).log(Level.SEVERE, null, ex);
	}
	Thread thread = new Thread(new Runnable() {

	    @Override
	    public void run() {
public void run() {
		    saveAccounts();
		}
	    }
	}, "Accounts' thread");
	thread.start();
    }

public synchronized void connected(Connection connection) {
    private synchronized void connectedWantsPlayer(final Client client) {
	if (!core.isAlreadyPaused()) {
	    core.pause();
	    new Thread(new Runnable() {

		@Override
		public void run() {
		    processNewPlayer(client);
		}
	    }).start();
	}
    }

// Generated by delombok at Sun Dec 01 13:28:22 MSK 2013
/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package spaceisnear.server.objects;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.concurrent.ConcurrentLinkedQueue;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import spaceisnear.abstracts.AbstractGameObject;
import spaceisnear.abstracts.Context;
import spaceisnear.game.components.Component;
import spaceisnear.game.messages.Message;
import spaceisnear.game.objects.GameObjectType;
import spaceisnear.server.ServerContext;

/**
 * @author White Oak
 */
@RequiredArgsConstructor public abstract class ServerGameObject extends AbstractGameObject {

    private final ConcurrentLinkedQueue<Message> messages = new ConcurrentLinkedQueue<>();
    @Getter private int id = -1;
    @Getter @Setter private boolean destroyed = false;
    @Getter private final LinkedList<Component> components = new LinkedList<>();
    @Getter private final GameObjectType type;
    @Getter private final ServerContext context;

    public void setId(int id) {
	if (this.id == -1) {
	    this.id = id;
	    for (Component component : components) {
		component.setOwnerId(id);
	    }
	}
    }

    public final synchronized void addComponents(Component... a) {
	for (Component component : a) {
	    component.setContext(context);
	}
	this.components.addAll(Arrays.asList(a));
    }

    @Override
    public final void message(Message message) {
	messages.add(message);
    }

    @Override
    public synchronized void process() {
	if (destroyed) {
	    return;
	}
	while (!messages.isEmpty()) {
	    Message message = messages.poll();
	    for (Component component : components) {
		component.processMessage(message);
	    }
	}
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
 * Copyright 2013 Hannes Janetzek
 *
 * This file is part of the OpenScienceMap project (http://www.opensciencemap.org).
 *
public static void glDeleteBuffers(int num, int[] ids) {
			return null;

		int[] ret = new int[num];
		IntBuffer buf = MapRenderer.getIntBuffer(num);

		if (GLAdapter.GDX_WEBGL_QUIRKS) {
			for (int i = 0; i < num; i++) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
package net.kuujo.vertigo.auditor;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import org.vertx.java.core.Handler;
import org.vertx.java.core.Vertx;
import org.vertx.java.core.eventbus.Message;
import org.vertx.java.core.json.JsonObject;

/**
  private boolean enabled;
  private long expire = 30000;
  private long delay = 0;
  private long cleanupInterval = 100;
  private Map<String, Node> nodes = new LinkedHashMap<>();

  public static final String ADDRESS = "address";
private void checkExpire() {
    // Nodes are stored in a LinkedHashMap in the order in which they're created,
    // so we can iterate up to the oldest node which has not yet expired and stop.
    long currentTime = System.currentTimeMillis();
    for (Map.Entry<String, Node> entry : nodes.entrySet()) {
      Node node = entry.getValue();
      if (node.expire <= currentTime) {
        node.fail();
      }
      else {
public void handle(Message<JsonObject> message) {
  private Handler<Node> ackHandler = new Handler<Node>() {
    @Override
    public void handle(Node node) {
      clearNode(node);
      eb.publish(broadcastAddress, new JsonObject().putString("action", "ack").putString("id", node.id));
    }
  };

  private Handler<Node> failHandler = new Handler<Node>() {
    @Override
    public void handle(Node node) {
      clearNode(node);
      eb.publish(broadcastAddress, new JsonObject().putString("action", "fail").putString("id", node.id));
    }
  };
public void handle(Node node) {
  private void doCreate(Message<JsonObject> message) {
    String id = getMandatoryString("id", message);
    if (enabled) {
       // We simply add ack and fail handlers to the root node. If a descendant
      // node is failed then it will bubble up to the root. Once all child nodes
      // are acked the parent will be acked which will also bubble up to the root.
      Node node = new Root(id, vertx, System.currentTimeMillis() + expire, delay);
      node.ackHandler(ackHandler);
      node.failHandler(failHandler);
      nodes.put(node.id, node);
    }
    // If acking is disabled then immediately ack the message back to its source.
    else {
private void doCreate(Message<JsonObject> message) {
   * Clears all children of a node from storage.
   */
  private void clearNode(Node node) {
    for (Node child : node.children) {
      clearNode(child);
    }
    nodes.remove(node.id);
  }

private void clearNode(Node node) {
  private void doFork(Message<JsonObject> message) {
    String parentId = getMandatoryString("parent", message);
    if (nodes.containsKey(parentId)) {
      String id = getMandatoryString("id", message);
      Node node = new Node(id, vertx, System.currentTimeMillis() + expire, delay);
      nodes.get(parentId).addChild(node);
      nodes.put(id, node);
    }
  }

private void doFail(Message<JsonObject> message) {
  /**
   * Represents a single node in a message tree.
   */
  private static class Node {
    private final String id;
    private final Vertx vertx;
    private final long expire;
private void checkAck() {
              public void handle(Long timerID) {
                locked = true;
                ackHandler.handle(Node.this);
              }
            });
          }
          else {
            locked = true;
            ackHandler.handle(this);
          }
        }
        // If the message was failed then immediately invoke the fail handler.
        else if (!ack) {
          locked = true;
          failHandler.handle(this);
        }
      }
    }
protected void addChild(Node child) {
  /**
   * Represents the root element of a message tree.
   */
  private static final class Root extends Node {
    private Root(String id, Vertx vertx, long expire, long delay) {
      super(id, vertx, expire, delay);
    }
 */
package net.kuujo.vertigo.output;

import net.kuujo.vertigo.message.JsonMessage;

/**
   * @param message
   *   The message to publish to the channel.
   * @return
   *   The called channel instance.
   */
  Channel publish(JsonMessage message);

}
   * @param message
   *   The message to write to the connection.
   * @return
   *   The called connection instance.
   */
  Connection write(JsonMessage message);

}
private boolean isValid(JsonMessage message) {
  }

  @Override
  public Channel publish(JsonMessage message) {
    if (isValid(message)) {
      for (Connection connection : selector.select(message, connections)) {
        connection.write(message.copy());
      }
    }
    return this;
  }

}
import net.kuujo.vertigo.serializer.Serializer;

import org.vertx.java.core.eventbus.EventBus;
import org.vertx.java.core.json.JsonObject;

/**
 * A default connection.
public String getAddress() {
  }

  @Override
  public Connection write(JsonMessage message) {
    eventBus.send(address, Serializer.serialize(audit(message)));
    return this;
  }

  /**
   * Sends audit info to the message auditor.
   */
  protected JsonMessage audit(JsonMessage message) {
    String auditor = message.auditor();
    if (auditor != null) {
      String parent = message.parent();
      if (parent != null) {
        eventBus.send(auditor, new JsonObject().putString("action", "fork")
            .putString("id", message.id()).putString("parent", parent));
      }
    }
    return message;
  }

}
import org.vertx.java.core.eventbus.EventBus;
import org.vertx.java.core.eventbus.Message;
import org.vertx.java.core.impl.DefaultFutureResult;
import org.vertx.java.core.json.JsonObject;
import org.vertx.java.core.logging.Logger;
import org.vertx.java.platform.Container;
public String emit(JsonObject body, String tag, JsonMessage parent) {
   * Emits a new message.
   */
  private String emitNew(JsonMessage message) {
    eventBus.send(message.auditor(), new JsonObject().putString("action", "create").putString("id", message.id()));
    for (Channel channel : channels) {
      channel.publish(message.createChild());
    }
    hookEmit(message.id());
    return message.id();
  }
private String emitNew(JsonMessage message) {
   * Emits a child message.
   */
  private String emitChild(JsonMessage message) {
    for (Channel channel : channels) {
      channel.publish(message.copy());
    }
    hookEmit(message.parent());
    return message.parent();
  }
public DefaultPseudoConnection(EventBus eventBus) {
  }

  @Override
  public Connection write(JsonMessage message) {
    audit(message);
    return this;
  }

}
import org.vertx.java.core.eventbus.EventBus;
import org.vertx.java.core.eventbus.Message;
import org.vertx.java.core.impl.DefaultFutureResult;
import org.vertx.java.core.json.JsonObject;

import static org.vertx.testtools.VertxAssert.assertTrue;
public void handle(Message<JsonObject> message) {
  public void testAck() {
    final String auditor = "test";
    final JsonMessage source = JsonMessageBuilder.create(new JsonObject().putString("body", "Hello world!")).setAuditor(auditor).toMessage();

    vertx.eventBus().registerHandler("broadcast", ackHandler(source.id()), new Handler<AsyncResult<Void>>() {
      @Override
public void handle(AsyncResult<Void> result) {
          public void handle(AsyncResult<Void> result) {
            assertTrue(result.succeeded());
            final EventBus eventBus = vertx.eventBus();
            final JsonMessage test1 = source.createChild();
            final JsonMessage test2 = source.createChild();
            final JsonMessage test3 = test1.createChild();
            final JsonMessage test4 = test1.createChild();

            run(new VoidHandler() {
              @Override
              protected void handle() {
                eventBus.send(auditor, new JsonObject().putString("action", "create").putString("id", source.id()));
              }
            })
            .then(new VoidHandler() {
              @Override
              protected void handle() {
                eventBus.send(auditor, new JsonObject().putString("action", "fork").putString("id", test1.id()).putString("parent", test1.parent()));
                eventBus.send(auditor, new JsonObject().putString("action", "fork").putString("id", test2.id()).putString("parent", test2.parent()));
                eventBus.send(auditor, new JsonObject().putString("action", "ack").putString("id", source.id()));
              }
            })
            .then(new VoidHandler() {
              @Override
              protected void handle() {
                eventBus.send(auditor, new JsonObject().putString("action", "fork").putString("id", test3.id()).putString("parent", test3.parent()));
                eventBus.send(auditor, new JsonObject().putString("action", "fork").putString("id", test4.id()).putString("parent", test4.parent()));
                eventBus.send(auditor, new JsonObject().putString("action", "ack").putString("id", test1.id()));
                eventBus.send(auditor, new JsonObject().putString("action", "ack").putString("id", test2.id()));
              }
protected void handle() {
  public void testChildFail() {
    final String auditor = "test";
    final JsonMessage source = JsonMessageBuilder.create(new JsonObject().putString("body", "Hello world!")).setAuditor(auditor).toMessage();

    vertx.eventBus().registerHandler("broadcast", failHandler(source.id()), new Handler<AsyncResult<Void>>() {
      @Override
public void handle(AsyncResult<Void> result) {
            run(new VoidHandler() {
              @Override
              protected void handle() {
                eventBus.send(auditor, new JsonObject().putString("action", "create").putString("id", source.id()));
              }
            })
            .then(new VoidHandler() {
              @Override
              protected void handle() {
                eventBus.send(auditor, new JsonObject().putString("action", "fail").putString("id", source.id()));
              }
            });
          }
protected void handle() {
  public void testDescendantFail() {
    final String auditor = "test";
    final JsonMessage source = JsonMessageBuilder.create(new JsonObject().putString("body", "Hello world!")).setAuditor(auditor).toMessage();

    vertx.eventBus().registerHandler("broadcast", failHandler(source.id()), new Handler<AsyncResult<Void>>() {
      @Override
public void handle(AsyncResult<Void> result) {
          public void handle(AsyncResult<Void> result) {
            assertTrue(result.succeeded());
            final EventBus eventBus = vertx.eventBus();
            final JsonMessage test1 = source.createChild();
            final JsonMessage test2 = source.createChild();
            final JsonMessage test3 = test1.createChild();
            final JsonMessage test4 = test1.createChild();

            run(new VoidHandler() {
              @Override
              protected void handle() {
                eventBus.send(auditor, new JsonObject().putString("action", "create").putString("id", source.id()));
              }
            })
            .then(new VoidHandler() {
              @Override
              protected void handle() {
                eventBus.send(auditor, new JsonObject().putString("action", "fork").putString("id", test1.id()).putString("parent", test1.parent()));
                eventBus.send(auditor, new JsonObject().putString("action", "fork").putString("id", test2.id()).putString("parent", test2.parent()));
                eventBus.send(auditor, new JsonObject().putString("action", "ack").putString("id", source.id()));
              }
            })
            .then(new VoidHandler() {
              @Override
              protected void handle() {
                eventBus.send(auditor, new JsonObject().putString("action", "fork").putString("id", test3.id()).putString("parent", test3.parent()));
                eventBus.send(auditor, new JsonObject().putString("action", "fork").putString("id", test4.id()).putString("parent", test4.parent()));
                eventBus.send(auditor, new JsonObject().putString("action", "ack").putString("id", test1.id()));
                eventBus.send(auditor, new JsonObject().putString("action", "ack").putString("id", test2.id()));
              }
protected void handle() {
  public void testExpire() {
    final String auditor = "test";
    final JsonMessage source = JsonMessageBuilder.create(new JsonObject().putString("body", "Hello world!")).setAuditor(auditor).toMessage();

    vertx.eventBus().registerHandler("broadcast", failHandler(source.id()), new Handler<AsyncResult<Void>>() {
      @Override
public void handle(AsyncResult<Void> result) {
          public void handle(AsyncResult<Void> result) {
            assertTrue(result.succeeded());
            final EventBus eventBus = vertx.eventBus();
            final JsonMessage test1 = source.createChild();
            final JsonMessage test2 = source.createChild();
            run(new VoidHandler() {
              @Override
              protected void handle() {
                eventBus.send(auditor, new JsonObject().putString("action", "create").putString("id", source.id()));
              }
            })
            .then(new VoidHandler() {
              @Override
              protected void handle() {
                eventBus.send(auditor, new JsonObject().putString("action", "fork").putString("id", test1.id()).putString("parent", test1.parent()));
                eventBus.send(auditor, new JsonObject().putString("action", "fork").putString("id", test2.id()).putString("parent", test2.parent()));
              }
            });
          }
protected void handle() {
  public void testDelayedForkAck() {
    final String auditor = "test";
    final JsonMessage source = JsonMessageBuilder.create(new JsonObject().putString("body", "Hello world!")).setAuditor(auditor).toMessage();

    vertx.eventBus().registerHandler("broadcast", ackHandler(source.id()), new Handler<AsyncResult<Void>>() {
      @Override
public void handle(AsyncResult<Void> result) {
          public void handle(AsyncResult<Void> result) {
            assertTrue(result.succeeded());
            final EventBus eventBus = vertx.eventBus();
            final JsonMessage test1 = source.createChild();
            final JsonMessage test2 = source.createChild();
            final JsonMessage test3 = test1.createChild();
            final JsonMessage test4 = test1.createChild();

            run(new VoidHandler() {
              @Override
              protected void handle() {
                eventBus.send(auditor, new JsonObject().putString("action", "create").putString("id", source.id()));
              }
            })
            .then(new VoidHandler() {
              @Override
              protected void handle() {
                eventBus.send(auditor, new JsonObject().putString("action", "fork").putString("id", test1.id()).putString("parent", test1.parent()));
                eventBus.send(auditor, new JsonObject().putString("action", "fork").putString("id", test2.id()).putString("parent", test2.parent()));
                eventBus.send(auditor, new JsonObject().putString("action", "ack").putString("id", source.id()));
              }
            })
            .then(new VoidHandler() {
protected void handle() {
            .then(new VoidHandler() {
              @Override
              protected void handle() {
                eventBus.send(auditor, new JsonObject().putString("action", "fork").putString("id", test3.id()).putString("parent", test3.parent()));
                eventBus.send(auditor, new JsonObject().putString("action", "fork").putString("id", test4.id()).putString("parent", test4.parent()));
              }
            })
            .then(new VoidHandler() {
protected void handle() {
  public void testDelayedForkFail() {
    final String auditor = "test";
    final JsonMessage source = JsonMessageBuilder.create(new JsonObject().putString("body", "Hello world!")).setAuditor(auditor).toMessage();

    vertx.eventBus().registerHandler("broadcast", failHandler(source.id()), new Handler<AsyncResult<Void>>() {
      @Override
public void handle(AsyncResult<Void> result) {
          public void handle(AsyncResult<Void> result) {
            assertTrue(result.succeeded());
            final EventBus eventBus = vertx.eventBus();
            final JsonMessage test1 = source.createChild();
            final JsonMessage test2 = source.createChild();
            final JsonMessage test3 = test1.createChild();
            final JsonMessage test4 = test1.createChild();

            run(new VoidHandler() {
              @Override
              protected void handle() {
                eventBus.send(auditor, new JsonObject().putString("action", "create").putString("id", source.id()));
              }
            })
            .then(new VoidHandler() {
              @Override
              protected void handle() {
                eventBus.send(auditor, new JsonObject().putString("action", "fork").putString("id", test1.id()).putString("parent", test1.parent()));
                eventBus.send(auditor, new JsonObject().putString("action", "fork").putString("id", test2.id()).putString("parent", test2.parent()));
                eventBus.send(auditor, new JsonObject().putString("action", "ack").putString("id", source.id()));
              }
            })
            .then(new VoidHandler() {
protected void handle() {
            .then(new VoidHandler() {
              @Override
              protected void handle() {
                eventBus.send(auditor, new JsonObject().putString("action", "fork").putString("id", test3.id()).putString("parent", test3.parent()));
                eventBus.send(auditor, new JsonObject().putString("action", "fork").putString("id", test4.id()).putString("parent", test4.parent()));
              }
            })
            .then(new VoidHandler() {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
package com.pushtorefresh.storio.sample.ui.fragment;

import android.support.v4.app.Fragment;

public abstract class BaseFragment extends Fragment {
}
import butterknife.InjectView;
import butterknife.OnClick;
import rx.Observer;
import rx.android.schedulers.AndroidSchedulers;
import rx.schedulers.Schedulers;

public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup c
    void reloadData() {
        uiStateController.setUiStateLoading();

        storIODb
                .get()
                .listOfObjects(Tweet.class)
                .withMapFunc(Tweet.MAP_FROM_CURSOR)
void reloadData() {
                        // no impl
                    }
                });
    }

    @OnClick(R.id.tweets_empty_ui_add_tweets_button)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private double alphaBeta(Table nodeTable, byte depth, double alpha, double beta,
	 */
	public Move getBestMove()
	{
		infinity=currentState.getWinScore()+1;
		double winScore=currentState.getWinScore();
		if(currentPlayer.getPlayerSign()=='O')
public Move getBestMove()
				setBestMove(moveStack[i]);
				return bestMove;
			}
			byte maxSearchDepth=(byte)(Runtime.getRuntime().freeMemory()/(MemoryUtil.deepMemoryUsageOf(currentSearchState)*maxMoves));
			if(searchDepth>maxSearchDepth)
				searchDepth=maxSearchDepth;
			currentScore=alphaBeta(currentSearchState,searchDepth,-infinity,infinity,currentPlayer);
			if(currentPlayer.getPlayerSign()=='O')
				currentScore*=-1;
public void setTime(float time)
	{
		this.time = time;
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	private final WorldServer world;
	private final Chunk defaultEmptyChunk;
	private final ThreadLocal<Boolean> inUnload = new BooleanThreadLocal();
	private final boolean loadChunkIfNotFound;
	private final boolean generateChunkIfNotFound;
	private final ThreadLocal<Boolean> worldGenInProgress;
	private boolean loadedPersistentChunks = false;
	private int unloadTicks = 0;
public ThreadedChunkProvider(WorldServer world, IChunkLoader loader, IChunkProvi
		currentChunkLoader = this.loader = loader;
		loadedChunks = Collections.synchronizedList(new ArrayList<Chunk>());
		defaultEmptyChunk = new EmptyChunk(world, 0, 0);
		loadChunkIfNotFound = TickThreading.instance.loadChunkOnProvideRequest;
		generateChunkIfNotFound = TickThreading.instance.generateChunkOnProvideRequest;
		worldGenInProgress = world.worldGenInProgress = new BooleanThreadLocal();
		world.inImmediateBlockUpdate = new BooleanThreadLocal();
	}
public void tick() {
			ChunkGarbageCollector.garbageCollect(world);
		}

		if (!loadChunkIfNotFound && !loadedPersistentChunks && unloadTicks >= 5) {
			loadedPersistentChunks = true;
			int loaded = 0;
			int possible = world.getPersistentChunks().size();
public final Chunk provideChunk(int x, int z) {
			return chunk;
		}

		if (loadChunkIfNotFound || loadChunkOnProvideRequest || worldGenInProgress.get() == Boolean.TRUE) {
			return getChunkAtInternal(x, z, generateChunkIfNotFound || loadChunkOnProvideRequest, false);
		}

		return defaultEmptyChunk;
public void populate(IChunkProvider chunkProvider, int x, int z) {
				GameRegistry.generateWorld(x, z, world, generator, chunkProvider);
				chunk.setChunkModified();
			}
			if (chunk.isTerrainPopulated) {
				Log.warning("Chunk " + chunk + " had its isTerrainPopulated field set to true incorrectly by external code while populating");
			}
	public boolean lockRegionBorders = true;
	public boolean allowWorldUnloading = true;
	public boolean requireOpForDumpCommand = true;
	public boolean loadChunkOnProvideRequest = false;
	public boolean generateChunkOnProvideRequest = false;
	public boolean enableFastMobSpawning = false;
	public int saveInterval = 240;
	public int deadLockTime = 45;
public void preInit(FMLPreInitializationEvent event) {
		antiCheatNotify = config.get(GENERAL, "antiCheatNotify", antiCheatNotify, "Whether to notify admins if TT anti-cheat detects cheating").getBoolean(antiCheatNotify);
		cleanWorlds = config.get(GENERAL, "cleanWorlds", cleanWorlds, "Whether to clean worlds on unload - this should fix some memory leaks due to mods holding on to world objects").getBoolean(cleanWorlds);
		allowWorldUnloading = config.get(GENERAL, "allowWorldUnloading", allowWorldUnloading, "Whether worlds should be allowed to unload.").getBoolean(allowWorldUnloading);
		loadChunkOnProvideRequest = config.get(GENERAL, "loadChunkOnProvideRequest", loadChunkOnProvideRequest, "Whether to load chunks in ChunkProviderServer.provideChunk").getBoolean(loadChunkOnProvideRequest);
		generateChunkOnProvideRequest = config.get(GENERAL, "generateChunkOnProvideRequest", generateChunkOnProvideRequest, "Whether to generate chunks in ChunkProviderServer.provideChunk").getBoolean(generateChunkOnProvideRequest);
		lockRegionBorders = config.get(GENERAL, "lockRegionBorders", lockRegionBorders, "Whether to prevent blocks next to each other on region borders from ticking concurrently. false = faster but experimental").getBoolean(lockRegionBorders);
		config.save();
		int[] disabledDimensions = config.get(GENERAL, "disableFastMobSpawningDimensions", new int[]{-1}, "List of dimensions not to enable fast spawning in.").getIntList();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 */
package org.alfresco.bm.event;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import org.bson.types.ObjectId;

import com.mongodb.DBObject;
    public static final String FIELD_LOCK_OWNER = "lockOwner";
    public static final String FIELD_LOCK_TIME = "lockTime";
    public static final String FIELD_DATA = "data";
    public static final String FIELD_DATA_KEY = "dataKey";
    public static final String FIELD_DATA_OWNER = "dataOwner";
    
    /** The 'value' that is associated with the data */
    
    public static final String EVENT_BEAN_PREFIX = "event.";
    
    /**
     * Data storage for events that are unable to serialize their data to local storage
     */
    private static Map<String, Object> serverLocalData = Collections.synchronizedMap(new HashMap<String, Object>(1024));
    
    private String id;
    private final String name;
    private String sessionId;
    private final long scheduledTime;
    private String lockOwner;
    private long lockTime;
    private Object data;            // Either a DBObject or a String
    private String dataKey;
    private String dataOwner;
    
    /**
     * Construct an event with some data, scheduling it for the current time.
public Event(String name, long scheduledTime, Object data)
     * @param name                  the event name
     * @param scheduledTime         when the event should be processed
     * @param data                  the event data
     */
    public Event(String name, long scheduledTime, Object data, boolean forceInMemoryDataStorage)
    {
        if (name == null)
        {
public Event(String name, long scheduledTime, Object data, boolean forceInMemory
        this.name = name;
        this.scheduledTime = scheduledTime;
        this.sessionId = null;
        // Need to use Serializable-aware setter
        setDataObject(data, forceInMemoryDataStorage);
        
        // Certain event have to be unique within the context of the processing
        if (name.equals(Event.EVENT_NAME_START))
public String toString()
                ", lockOwner=" + lockOwner +
                ", lockTime=" + lockTime +
                ", data=" + dataStr +
                ", dataKey=" + dataKey +
                "  dataOwner= " + dataOwner +
                "]";
    }

public void setLockTime(long lockTime)
        this.lockTime = lockTime;
    }

    /**
     * Client-safe method to retrieve data based on in-memory or persisted storage
     */
    public Object getDataObject()
    {
        if (dataKey == null)
        {
            // The data came in and out of persisted storage
            return data;
        }
        else
        {
            Object data = Event.serverLocalData.get(dataKey);
            if (data == null)
            {
                // There is no value.  Check whether we have lost it.
                if (!Event.serverLocalData.containsKey(dataKey))
                {
                    // We have lost the data associated with this
                    throw new IllegalStateException("In-memory data cannot be found for event: " + this);
                }
            }
            return data;
        }
    }
    /**
     * Set the data, taking Serializability or client choice into account
     * 
     * @param data                      the data to store (in memory or persisted)
     * @param forceInMemoryDataStorage  <tt>true</tt> to force in-memory storage
     */
    private void setDataObject(Object data, boolean forceInMemoryDataStorage)
    {
        boolean canPersistData =
                data == null ||
                data instanceof String ||
                data instanceof DBObject ||
                data instanceof Number;
        
        if (forceInMemoryDataStorage || !canPersistData)
        {
            // We have to store the data in memory and just persist a key
            this.data = null;
            this.dataKey = UUID.randomUUID().toString();
            Event.serverLocalData.put(this.dataKey, data);
        }
        else
        {
            // A null, String or DBObject is provided, so we just accept it as is
            this.data = data;
            this.dataKey = null;
        }
    }

    /**
     * Method used by persistence framework ONLY.  DO NOT USE.
     * 
     * @return                      the data key in the event that data is stored in the VM only
     */
    @Deprecated
    public String getDataKey()
    {
        return dataKey;
    }
    /**
     * Method used by persistence framework ONLY.  DO NOT USE.
     */
    @Deprecated
    public void setDataKey(String dataKey)
    {
        this.dataKey = dataKey;
    }

    /**
     * Ensure that any locally-stored data is cleaned up
     */
    public void cleanData()
    {
        if (dataKey != null)
        {
            Event.serverLocalData.remove(dataKey);
        }
    }

    public String getDataOwner()
    {
        return dataOwner;
    }
    public void setDataOwner(String dataOwner)
    {
        this.dataOwner = dataOwner;
    }
}
public EventWork(
        this.sessionService = sessionService;
    }

    @SuppressWarnings("deprecation")
    @Override
    public void run()
    {
public void run()
                        "   Processor: " + processor);
                continue;
            }
            // Ensure that any locally-stored data has a data owner attached
            if (nextEvent.getDataKey() != null)
            {
                nextEvent.setDataOwner(serverId);
            }
            // Carry over the session ID, if required
            if (propagateSessionId)
            {
public void run()
            }
        }
        
        // Clean up any locally-store data and remove the event from the queue.
        // This *must* come after the new events have been published;
        // otherwise it's possible to have a short time without events.
        try
        {
            event.cleanData();
            boolean deleted = eventService.deleteEvent(event);
            if (!deleted)
            {
 */
package org.alfresco.bm.event.mongo;

import java.util.Date;

import org.alfresco.bm.event.AbstractEventService;
import org.alfresco.bm.event.Event;
    private static Log logger = LogFactory.getLog(MongoEventService.class);

    private final DBCollection collection;

    /**
     * Construct a event service against a Mongo database and given collection name
     */
    public MongoEventService(DB db, String collection)
    {
        this.collection = db.getCollection(collection);
    }
    
    @Override
public void start() throws Exception
    @Override
    public void stop() throws Exception
    {
    }

    @Override
public long count()
    }

    /**
     * Helper method to convert an {@link Event} into a {@link DBObject persistable object}
     */
    @SuppressWarnings("deprecation")
    public static DBObject convertEvent(Event event)
    {
        BasicDBObjectBuilder insertObjBuilder = BasicDBObjectBuilder
                .start();
        // Handle the data-key-data-owner link i.e. we store either the object or the key and owner of the key
        if (event.getDataKey() == null)
        {
            insertObjBuilder.add(Event.FIELD_DATA, event.getDataObject());
        }
        else
        {
            insertObjBuilder.add(Event.FIELD_DATA_KEY, event.getDataKey());
            insertObjBuilder.add(Event.FIELD_DATA_OWNER, event.getDataOwner());
        }
        insertObjBuilder
                .add(Event.FIELD_LOCK_OWNER, event.getLockOwner())
                .add(Event.FIELD_LOCK_TIME, new Date(event.getLockTime()))
public static DBObject convertEvent(Event event)
    /**
     * Helper method to convert a {@link DBObject persistable object} into an {@link Event}
     */
    @SuppressWarnings("deprecation")
    public static Event convertDBObject(DBObject obj)
    {
        String id = obj.get(Event.FIELD_ID).toString();
        Object data = obj.get(Event.FIELD_DATA);
        String dataKey = (String) obj.get(Event.FIELD_DATA_KEY);
        String dataOwner = (String) obj.get(Event.FIELD_DATA_OWNER);
        String lockOwner = (String) obj.get(Event.FIELD_LOCK_OWNER);
        long lockTime = obj.containsField(Event.FIELD_LOCK_TIME) ?
public static Event convertDBObject(DBObject obj)
                Long.valueOf(0L);
        String sessionId = (String) obj.get(Event.FIELD_SESSION_ID);
        
        Event event = new Event(name, scheduledTime, data);
        event.setId(id);
        event.setDataKey(dataKey);
        event.setDataOwner(dataOwner);
        event.setLockOwner(lockOwner);
        event.setLockTime(lockTime);
        event.setSessionId(sessionId);
        // Done
        return event;
    }
public String putEvent(Event event)
        }
        DBObject insertObj = convertEvent(event);
        
        try
        {
            collection.insert(insertObj);
public String putEvent(Event event)
        ObjectId eventIdObj = (ObjectId) insertObj.get(Event.FIELD_ID);
        String eventId = eventIdObj.toString();
        
        // Done
        if (logger.isDebugEnabled())
        {
public Event nextEvent(String serverId, long latestScheduledTime, boolean localD
                .and(Event.FIELD_LOCK_OWNER).is(null);
        if (localDataOnly)
        {
            qb.and(Event.FIELD_DATA_OWNER).is(serverId);
        }
        else
        {
            qb.or(
                    BasicDBObjectBuilder.start().add(Event.FIELD_DATA_OWNER, serverId).get(),
                    BasicDBObjectBuilder.start().add(Event.FIELD_DATA_OWNER, null).get());
        }
        DBObject queryObj = qb.get();
public Event nextEvent(String serverId, long latestScheduledTime, boolean localD
            event.setLockOwner(serverId);
            event.setLockTime(now);
        }
        // Done
        if (logger.isDebugEnabled())
        {
public Event nextEvent(String serverId, long latestScheduledTime, boolean localD
    @Override
    public boolean deleteEvent(Event event)
    {
        DBObject queryObj = BasicDBObjectBuilder
                .start()
                .add(Event.FIELD_ID, new ObjectId(event.getId()))
                .get();
        
        WriteResult wr = collection.remove(queryObj);
        if (wr.getN() != 1)
private EventRecord convertToEventRecord(DBObject eventRecordObj)
    /**
     * Helper to convert Mongo-persisted object to a client-visible {@link Event}
     */
    @SuppressWarnings("deprecation")
    private Event convertToEvent(DBObject eventObj)
    {
        String name = (String) eventObj.get(Event.FIELD_NAME);
        long scheduledTime = eventObj.containsField(Event.FIELD_SCHEDULED_TIME) ?
                ((Date) eventObj.get(Event.FIELD_SCHEDULED_TIME)).getTime() :
                -1L;
        Object data = eventObj.get(Event.FIELD_DATA);
        String dataKey = (String) eventObj.get(Event.FIELD_DATA_KEY);
        String dataOwner = (String) eventObj.get(Event.FIELD_DATA_OWNER);
        String lockOwner = (String) eventObj.get(Event.FIELD_LOCK_OWNER);
        String sessionId = (String) eventObj.get(Event.FIELD_SESSION_ID);
        
        Event event = new Event(name, scheduledTime, data, false);
        event.setDataKey(dataKey);
        event.setDataOwner(dataOwner);
        event.setLockOwner(lockOwner);
        event.setSessionId(sessionId);
        // Done
public void recordResult(EventRecord result)
        }
        
        DBObject eventObj = MongoEventService.convertEvent(event);
        DBObject insertObj = BasicDBObjectBuilder
                .start()
                .add(EventRecord.FIELD_PROCESSED_BY, result.getProcessedBy())
public RedirectEventProducer(String newEventName, long delay)
    public List<Event> getNextEvents(Event event)
    {
        String oldId = event.getId();
        @SuppressWarnings("deprecation")
        String oldDataKey = event.getDataKey();
        Object oldData = event.getDataObject();
        long oldScheduledTime = event.getScheduledTime();
        String oldSessionId = event.getSessionId();
        String oldDataOwner = event.getDataOwner();
        
        boolean forceInMemoryStorage = oldDataKey != null;
        long scheduledTime = System.currentTimeMillis() + delay;
        if (oldScheduledTime > scheduledTime)
        {
            scheduledTime = oldScheduledTime;
        }
        
        Event newEvent = new Event(newEventName, scheduledTime, oldData, forceInMemoryStorage);
        if (oldId != null)
        {
            newEvent.setId(oldId);
public RedirectEventProducer(String newEventName, long delay)
        {
            newEvent.setSessionId(oldSessionId);
        }
        if (oldDataOwner != null)
        {
            newEvent.setDataOwner(oldDataOwner);
        }
        
        return Collections.singletonList(newEvent);
    }
package org.alfresco.bm.event;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
 * @since 2.0
 */
@RunWith(JUnit4.class)
@SuppressWarnings("deprecation")
public class EventTest
{
    @Test
public void constructor01()
        long now = System.currentTimeMillis();
        
        Event event = new Event("A", null);
        assertNull(event.getDataKey());
        assertNull(event.getDataObject());
        assertNull(event.getDataOwner());
        assertNull(event.getId());
        assertNull(event.getLockOwner());
        assertEquals(0L, event.getLockTime());
public void constructor03()
        long now = System.currentTimeMillis();
        
        Event event = new Event("A", now, null, true);
        assertNull(event.getDataObject());
        assertNotNull(event.getDataKey());
    }
    
    @Test
    public void nullData()
    {
        Event event = new Event("A", 0L, null);
        assertNull(event.getDataKey());
        assertNull(event.getDataObject());
    }
    
    @Test
    public void nullDataInMem()
    {
        Event event = new Event("A", 0L, null, true);
        assertNotNull(event.getDataKey());
        assertNull(event.getDataObject());
    }
    
    @Test
    public void stringData()
    {
        Event event = new Event("A", 0L, "BOB");
        assertNull(event.getDataKey());
        assertEquals("BOB", event.getDataObject());
    }
    
    @Test
    public void stringDataInMem()
    {
        Event event = new Event("A", 0L, "BOB", true);
        assertNotNull(event.getDataKey());
        assertEquals("BOB", event.getDataObject());
    }
    
    @Test
    public void integerData()
    {
        Event event = new Event("A", 0L, Integer.MAX_VALUE);
        assertNull(event.getDataKey());
        assertEquals(Integer.MAX_VALUE, event.getDataObject());
    }
    
    @Test
    public void integerDataInMem()
    {
        Event event = new Event("A", 0L, Integer.MAX_VALUE, true);
        assertNotNull(event.getDataKey());
        assertEquals(Integer.MAX_VALUE, event.getDataObject());
    }
    
    @Test
public void dbObjectData()
        DBObject bobTheObj = BasicDBObjectBuilder.start().add("BOB", Integer.MAX_VALUE).get();
        
        Event event = new Event("A", 0L, bobTheObj);
        assertNull(event.getDataKey());
        assertEquals(bobTheObj, event.getDataObject());
    }
    
    @Test
public void dbObjectDataInMem()
        DBObject bobTheObj = BasicDBObjectBuilder.start().add("BOB", Integer.MAX_VALUE).get();
        
        Event event = new Event("A", 0L, bobTheObj, true);
        assertNotNull(event.getDataKey());
        assertEquals(bobTheObj, event.getDataObject());
    }
    
    @Test
    public void someObjectData()
    {
        Event event = new Event("A", 0L, this);
        assertNotNull(event.getDataKey());
        assertEquals(this, event.getDataObject());
    }
    
    @Test
    public void someObjectDataInMem()
    {
        Event event = new Event("A", 0L, this, true);
        assertNotNull(event.getDataKey());
        assertEquals(this, event.getDataObject());
    }
}
public void testBasicMultipleEventSuccess() throws Exception
    @Test
    public void testBasicSerializableEventData() throws Exception
    {
        Object dataThatWillNotSerialize = new DataThatWillNotSerialize();
        nextEvents.add(new Event(EVENT_NAME, dataThatWillNotSerialize));
        EventResult result = new EventResult(nextEvents);
public void testBasicSerializableEventData() throws Exception
        
        assertEquals(1, resultService.countResultsBySuccess());
        assertEquals(1, eventService.count());
        assertNull("The local data should not be available for other servers.", eventService.nextEvent("RANDOM_SERVER", Long.MAX_VALUE, false));
        Event nextEvent = eventService.nextEvent(SERVER_ID, Long.MAX_VALUE, false);
        assertNotNull(nextEvent);
        
        // Check that we can get hold of the next event's data
        assertTrue("Expect exactly the original event data.", dataThatWillNotSerialize == nextEvent.getDataObject());
    }
    
    @Test
public synchronized void persistenceAndSearchOfDBObject() throws Exception
        assertNotNull("Did not find event with DBObject data.", foundObj);
        // Retrieve
        event = eventService.getEvent(eventId);
        assertEquals("Original DBObject not pulled out.", foundObj.get(Event.FIELD_DATA), event.getDataObject());
    }
    
    /**
public void nextEvent()
            assertTrue("Scheduled time must be increasing. ", event.getScheduledTime() >= lastScheduledTime);
            lastScheduledTime = event.getScheduledTime();
            assertNotNull("Event must have an ID", event.getId());
            assertNotNull("Data payload not present on Event", event.getDataObject());
            // Delete the event
            assertTrue(
                    "Failed to delete event: " + event,
public void nextEvent()
    }
    
    @Test
    public void lockEventManual()
    {
        Event event = createEvent();

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

public static final EventRecord createEventRecord(long eventStartTime)
    }
    
    @Test
    public synchronized void persistenceAndSearchOfDBObject() throws Exception
    {
        EventRecord eventRecord = createEventRecord(System.currentTimeMillis());
public void setUp() throws Exception
        eventDataKey = new Event("a", "Some data");
        eventDataKey.setId("123456789012345678901234"); 
        eventDataKey.setSessionId("sessionA");
        eventDataKey.setDataOwner("Bob");
        eventInMem = new Event("a", this);
    }
    
public void testRedirectEventProducer_DataKey()
        assertEquals(eventOriginal.getId(), event.getId());
        assertEquals(eventOriginal.getSessionId(), event.getSessionId());
        assertEquals((double) (System.currentTimeMillis()+10000L), event.getScheduledTime(), 200L);
        assertEquals(eventOriginal.getDataOwner(), event.getDataOwner());
        assertTrue(eventOriginal.getDataObject() == event.getDataObject());
    }
    
    @Test
public void testRedirectEventProducer_InMem()
        assertEquals(eventOriginal.getId(), event.getId());
        assertEquals(eventOriginal.getSessionId(), event.getSessionId());
        assertEquals((double) (System.currentTimeMillis()), event.getScheduledTime(), 200L);
        assertEquals(eventOriginal.getDataOwner(), event.getDataOwner());
        assertTrue(eventOriginal.getDataObject() == event.getDataObject());
    }
    
    @Test
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import android.app.Activity;
import android.app.Application;
import android.app.ApplicationErrorReport;
import android.content.ComponentCallbacks;
import android.content.Context;
import android.os.Build;
import android.os.StatFs;

import java.io.File;
import java.net.HttpURLConnection;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.TimeUnit;

import io.fabric.sdk.android.Fabric;
import me.vickychijwani.spectre.analytics.AnalyticsService;
import me.vickychijwani.spectre.event.ApiErrorEvent;
import me.vickychijwani.spectre.event.BusProvider;
import me.vickychijwani.spectre.event.LoadGhostVersionEvent;
import me.vickychijwani.spectre.network.NetworkService;
import retrofit.RetrofitError;
import retrofit.client.Response;
public void onDeadEvent(DeadEvent event) {
        Log.w(TAG, "Dead event ignored: " + event.event.getClass().getName());
    }

    // brilliant hack for #75, courtesy http://stackoverflow.com/a/27253968/504611
    @Override
    public void registerComponentCallbacks(ComponentCallbacks callback) {
        super.registerComponentCallbacks(callback);
        ComponentCallbacksAdjustmentTool.INSTANCE.onComponentCallbacksRegistered(callback);
    }

    @Override
    public void unregisterComponentCallbacks(ComponentCallbacks callback) {
        super.unregisterComponentCallbacks(callback);
        ComponentCallbacksAdjustmentTool.INSTANCE.onComponentCallbacksUnregistered(callback);
    }

    public void forceUnregisterComponentCallbacks() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
            ComponentCallbacksAdjustmentTool.INSTANCE.unregisterAll(this);
        }
    }

    private static class ComponentCallbacksAdjustmentTool {
        static final ComponentCallbacksAdjustmentTool INSTANCE = new ComponentCallbacksAdjustmentTool();

        private final WeakHashMap<ComponentCallbacks, ApplicationErrorReport.CrashInfo> mCallbacks
                = new WeakHashMap<>();
        private boolean mSuspended = false;

        public void onComponentCallbacksRegistered(ComponentCallbacks callback) {
            Throwable thr = new Throwable("Callback registered here");
            ApplicationErrorReport.CrashInfo ci = new ApplicationErrorReport.CrashInfo(thr);
            if (! mSuspended) {
                if (callback.getClass().getName().startsWith("org.chromium.android_webview.AwContents")) {
                    mCallbacks.put(callback, ci);
                }
            } else {
                Log.e(TAG, "ComponentCallbacks was registered while tracking is suspended!");
            }
        }

        public void onComponentCallbacksUnregistered(ComponentCallbacks callback) {
            if (! mSuspended) {
                mCallbacks.remove(callback);
            }
        }

        public void unregisterAll(Context context) {
            mSuspended = true;
            for (Map.Entry<ComponentCallbacks, ApplicationErrorReport.CrashInfo> entry : mCallbacks.entrySet()) {
                ComponentCallbacks callback = entry.getKey();
                if (callback == null) continue;
                if (BuildConfig.DEBUG) {
                    Log.w(TAG, "Forcibly unregistering a misbehaving ComponentCallbacks: " + entry.getKey());
                    Log.w(TAG, entry.getValue().stackTrace);
                }
                try {
                    context.unregisterComponentCallbacks(entry.getKey());
                } catch (Exception exc) {
                    Log.e(TAG, "Unable to unregister ComponentCallbacks", exc);
                }
            }
            mCallbacks.clear();
            mSuspended = false;
        }
    }

}

import com.crashlytics.android.Crashlytics;

import butterknife.Bind;
import butterknife.ButterKnife;
import me.vickychijwani.spectre.BuildConfig;
import me.vickychijwani.spectre.R;
import me.vickychijwani.spectre.SpectreApplication;
import me.vickychijwani.spectre.view.BundleKeys;

/**
        void onWebViewCreated();
    }

    @Bind(R.id.web_view) WebView mWebView;
    private String mUrl;
    private OnWebViewCreatedListener mOnWebViewCreatedListener = null;

public WebViewFragment() {}
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.fragment_web_view, container, false);
        ButterKnife.bind(this, view);
        mUrl = getArguments().getString(BundleKeys.URL);
        if (TextUtils.isEmpty(mUrl)) {
            throw new IllegalArgumentException("Empty URL passed to WebViewFragment!");
public void onPause() {

    @Override
    public void onDestroyView() {
        // don't hold on to the listener (which could potentially be an Activity)
        mOnWebViewCreatedListener = null;
        // destroy the WebView completely
        if (mWebView != null) {
            mWebView.destroy();
            mWebView = null;
        }
        // NOTE: super must be called AFTER WebView is destroyed, because super method calls
        // ButterKnife.unbind which sets mWebView to null WITHOUT destroying it!
        super.onDestroyView();
        ((SpectreApplication) getActivity().getApplicationContext()).forceUnregisterComponentCallbacks();
    }

    // our custom methods
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public InternalDetailQueryExecutor() {
      throw new QueryExecutionException(e);
    } finally {
      execService = null;
    }
  }

public RawResultIterator(CarbonIterator<BatchRawResult> detailRawQueryResultIter

    if (null == batch || checkIfBatchIsProcessedCompletely(batch)) {
      if (detailRawQueryResultIterator.hasNext()) {
        batch = detailRawQueryResultIterator.next();
        counter = 0; // batch changed so reset the counter.
      } else {
public RawResultIterator(CarbonIterator<BatchRawResult> detailRawQueryResultIter
        return null;
      }
    } else { // completed one batch.
      batch = detailRawQueryResultIterator.next();
      counter = 0;
    }
public static void deleteSlice(int partitionCount, String schemaName, String cub
    }
  }

  public static void deletePartialLoadDataIfExist(CarbonLoadModel loadModel) throws IOException {
    CarbonTable carbonTable = loadModel.getCarbonDataLoadSchema().getCarbonTable();
    String metaDataLocation = carbonTable.getMetaDataFilepath();
    SegmentStatusManager segmentStatusManager =
        new SegmentStatusManager(carbonTable.getAbsoluteTableIdentifier());
    LoadMetadataDetails[] details = segmentStatusManager.readLoadMetadata(metaDataLocation);
    CarbonTablePath carbonTablePath = CarbonStorePath.getCarbonTablePath(loadModel.getStorePath(),
        carbonTable.getCarbonTableIdentifier());
    final List<String> loadFolders = new ArrayList<String>();
    for (LoadMetadataDetails loadMetadata : details) {
      loadFolders.add(carbonTablePath.getCarbonDataDirectoryPath(loadMetadata.getPartitionCount(),
          loadMetadata.getLoadName())
          .replace("\\", "/"));
    }

public static void deletePartialLoadDataIfExist(CarbonLoadModel loadModel) throw
      if (FileFactory.isFileExist(partitionPath, fileType)) {
        CarbonFile carbonFile = FileFactory.getCarbonFile(partitionPath, fileType);
        CarbonFile[] listFiles = carbonFile.listFiles(new CarbonFileFilter() {
          @Override
          public boolean accept(CarbonFile path) {
            return !loadFolders.contains(path.getAbsolutePath().replace("\\", "/"));
          }
        });
        for (int k = 0; k < listFiles.length; k++) {
          deleteStorePath(listFiles[k].getAbsolutePath());
        }
      }
    }
private static boolean isMergedSegment(String segName) {
      }
    }

    // handle the retaining of valid loads,

    // check if valid list is big enough for removing the number of seg to be retained.
    if (validList.size() > numberOfSegToBeRetained) {

      // after the sort remove the loads from the last as per the retaining count.
      Collections.sort(validList, new Comparator<LoadMetadataDetails>() {

        @Override public int compare(LoadMetadataDetails seg1, LoadMetadataDetails seg2) {
          double segNumber1 = Double.parseDouble(seg1.getLoadName());
          double segNumber2 = Double.parseDouble(seg2.getLoadName());

          if ((segNumber1 - segNumber2) < 0) {
            return -1;
          } else if ((segNumber1 - segNumber2) > 0) {
            return 1;
          }
          return 0;

        }
      });

      for (int i = 0; i < numberOfSegToBeRetained; i++) {

        // remove last segment
        validList.remove(validList.size() - 1);

      }
      return validList;
    }

    // case where there is no 2 loads available for merging.
    return new ArrayList<LoadMetadataDetails>(0);
  }

  /**
object CarbonDataRDDFactory extends Logging {
    readLoadMetadataDetails(carbonLoadModel, hdfsStoreLocation)
    var segList: util.List[LoadMetadataDetails] = carbonLoadModel.getLoadMetadataDetails

    var loadsToMerge = CarbonDataMergerUtil.identifySegmentsToBeMerged(
      hdfsStoreLocation,
      carbonLoadModel,
object CarbonDataRDDFactory extends Logging {
        override def run(): Unit = {

          while (loadsToMerge.size() > 1) {

            val futureList: util.List[Future[Void]] = new util.ArrayList[Future[Void]](
              CarbonCommonConstants
                .DEFAULT_COLLECTION_SIZE
            )
            scanSegmentsAndSubmitJob(futureList)

            futureList.asScala.foreach(future => {
object CarbonDataRDDFactory extends Logging {

    /**
     * This will scan all the segments and submit the loads to be merged into the executor.
     * @param futureList
     */
    def scanSegmentsAndSubmitJob(futureList: util.List[Future[Void]]): Unit = {
      breakable {
object CarbonDataRDDFactory extends Logging {
      // Deleting the any partially loaded data if present.
      // in some case the segment folder which is present in store will not have entry in status.
      // so deleting those folders.
      CarbonLoaderUtil.deletePartialLoadDataIfExist(carbonLoadModel)


      // reading the start time of data load.
      val loadStartTime = CarbonLoaderUtil.readCurrentTime()
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public CollisionManager(TR tr) {
    }
    private final Positionable [] positionableWorkArray = new Positionable[4096];
    private volatile int numPositionables =0;

    public void performCollisionTests() {
	try{World.relevanceExecutor.submit(new Callable<List<Positionable>>(){
	    @Override
	    public List<Positionable> call() {
		List<Positionable> list = inputRelevanceList;
		numPositionables = list.size();
		if(numPositionables<=positionableWorkArray.length)
		 list.toArray(positionableWorkArray);
		return list;
public void performCollisionTests() {
		    }// end for(j)
		}// end sync(gameStateLock)
		}// end for(i)
    }//end performCollisionTests

    public void remove(WorldObject worldObject) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
- (void)syncData
                  images[src] = image;
              }
              if (image == nil) {
                image = [[GLImage alloc] initWithBridge:_bridge withOnLoad:^{
                  [self onImageLoad:src];
                }];
                image.src = src;
                images[src] = image;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler.Sharable;
import io.netty.channel.ChannelHandlerContext;

import java.util.EnumMap;

 *
 */
@Sharable
public class PacketHandler extends FMLIndexedMessageToMessageCodec<PacketBase> {

	private static final PacketHandler INSTANCE = new PacketHandler();
    private static final EnumMap<Side, FMLEmbeddedChannel> CHANNELS =
    		Maps.newEnumMap(Side.class);
	
public static void init() {
        if (!CHANNELS.isEmpty()) {
            return;
        }

        CHANNELS.putAll(NetworkRegistry.INSTANCE.newChannel(Reference.MOD_ID, INSTANCE));
    }
    
    /**
public static void init() {
     * @param packetType The class of the packet.
     */
    public static void register(int id, Class<? extends PacketBase> packetType) {
    	INSTANCE.addDiscriminator(id, packetType);
    }

	@Override
	public void encodeInto(ChannelHandlerContext context, PacketBase packet,
			ByteBuf target) throws Exception {
		ByteArrayDataOutput output = ByteStreams.newDataOutput();
        packet.encode(output);
        target.writeBytes(output.toByteArray());
	}

	@Override
	public void decodeInto(ChannelHandlerContext context, ByteBuf source,
			PacketBase packet) {
		ByteArrayDataInput input = ByteStreams.newDataInput(source.array());
        input.skipBytes(1); // skip the packet identifier byte
        packet.decode(input);
        
        if (FMLCommonHandler.instance().getEffectiveSide().isClient()) {
            actionClient(packet);
        } else {
            actionServer(context, packet);
        }
	}
	
	@SideOnly(Side.CLIENT)
    private void actionClient(PacketBase packet) {
        Minecraft minecraft = Minecraft.getMinecraft();
        packet.actionClient(minecraft.theWorld, minecraft.thePlayer);
    }
    
    private void actionServer(ChannelHandlerContext context, PacketBase packet) {
        EntityPlayerMP player = ((NetHandlerPlayServer)context.channel()
        		.attr(NetworkRegistry.NET_HANDLER).get()).playerEntity;
        packet.actionServer(player.worldObj, player);
    }
    
    /**
public static Packet toMcPacket(PacketBase packet) {
        return CHANNELS.get(FMLCommonHandler.instance().getEffectiveSide()).generatePacketFrom(packet);
    }
    
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  private void trace(String label, long frame, int state, String url,
      String contentType, double progress, int errorCode) {
    logs.trace(new StringBuilder()
        .append("-").append(label).append("-> ")
        .append(url)
        .append(" ** {timestamp: ").append(System.currentTimeMillis())
        .append(", state: ").append(states.get(state))
        .append(", progress: ").append(progress)
        .append(", error: ").append(errors.get(errorCode))
        .append(", contentType: ").append(contentType)
        .append(", frame: ").append(frame).append("}").toString());
  }

  /**

      List<File> items = new ClasspathFinder().getUniqueClasspathElements();
      final File classpathDir = Files.createTempDirectory("jbd_classpath_").toFile();
      Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
        @Override
        public void run() {
          FileUtils.deleteQuietly(classpathDir);
        }
      }));
      List<String> paths = new ArrayList<String>();
      for (File curItem : items) {
        paths.add(curItem.getAbsoluteFile().toURI().toURL().toExternalForm());
public void run() {
  }

  private final File tmpDir;

  /**
   * Constructs a browser with default settings, UTC timezone, and no proxy.
public JBrowserDriver(final Settings settings) {
      Logs.fatal(t);
    }
    this.tmpDir = tmpDir;
    final File thisTmpDir = this.tmpDir;
    Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
      @Override
      public void run() {
        FileUtils.deleteQuietly(thisTmpDir);
      }
    }));

    synchronized (portsAvailable) {
      for (int curPort : settings.ports()) {
public void run() {
    logs = new Logs(logsRemote);
  }

  private void launchProcess(final int port) {
    final AtomicBoolean ready = new AtomicBoolean();
    final AtomicReference<String> logPrefix = new AtomicReference<String>("");
import java.io.PrintWriter;
import java.io.StringWriter;
import java.rmi.RemoteException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Set;
import java.util.logging.Level;

import org.openqa.selenium.logging.LogEntries;

class LogsServer extends RemoteObject implements LogsRemote, org.openqa.selenium.logging.Logs {
  private final LinkedList<Entry> entries = new LinkedList<Entry>();
  private static final LogsServer instance;
  static {
    LogsServer instanceTmp = null;
static LogsServer instance() {
  private LogsServer() throws RemoteException {}

  public void clear() {
    synchronized (entries) {
      entries.clear();
    }
  }

  public void trace(String message) {
    Settings settings = SettingsManager.settings();
    final Entry entry = new Entry(Level.FINEST, System.currentTimeMillis(), message);
    synchronized (entries) {
      entries.add(entry);
      if (settings != null && entries.size() > settings.maxLogs()) {
        entries.removeFirst();
      }
    }
    if (settings == null || settings.traceConsole()) {
public void trace(String message) {
  public void warn(String message) {
    Settings settings = SettingsManager.settings();
    final Entry entry = new Entry(Level.WARNING, System.currentTimeMillis(), message);
    synchronized (entries) {
      entries.add(entry);
      if (settings != null && entries.size() > settings.maxLogs()) {
        entries.removeFirst();
      }
    }
    if (settings == null || settings.warnConsole()) {
public void exception(Throwable t) {
        writer = new StringWriter();
        t.printStackTrace(new PrintWriter(writer));
        entry = new Entry(Level.WARNING, System.currentTimeMillis(), writer.toString());
        synchronized (entries) {
          entries.add(entry);
          if (settings != null && entries.size() > settings.maxLogs()) {
            entries.removeFirst();
          }
        }
      } catch (Throwable t2) {
public void exception(Throwable t) {
   */
  @Override
  public Entries getRemote(String s) {
    synchronized (entries) {
      Entries logEntries = new Entries(entries);
      entries.clear();
      return logEntries;
    }
  }

public Entries getRemote(String s) {
   */
  @Override
  public LogEntries get(String s) {
    synchronized (entries) {
      try {
        return new Entries(entries).toLogEntries();
      } finally {
        entries.clear();
      }
    }
  }

    private boolean traceConsole;
    private boolean warnConsole = true;
    private boolean wireConsole;
    private int maxLogs = 5000;
    private boolean hostnameVerification = true;
    private boolean javascript = true;
    private int socketTimeout = -1;
public Builder wireConsole(boolean wireConsole) {
     * Maximum number of log entries to store in memory, accessible via the Selenium APIs.
     * The oldest log entry is dropped once the max is reached. Regardless of this setting,
     * logs are cleared per instance of JBrowserDriver after a call to quit(), reset(), or Logs.get(String).
     * Defaults to <code>5000</code>.
     * 
     * @param maxLogs
     * @return this Builder
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManagerFactory;

import org.apache.commons.io.FileUtils;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpRequestBase;
  private final PoolingHttpClientConnectionManager manager;
  private final CloseableHttpClient client;
  private final CloseableHttpClient cachingClient;

  StreamConnectionClient() {
    File cacheDirTmp = SettingsManager.settings().cacheDir();
    try {
      cacheDirTmp = cacheDirTmp == null ? Files.createTempDirectory("jbd_webcache_").toFile() : cacheDirTmp;
      if (SettingsManager.settings().cacheDir() == null) {
        final File finalCacheDir = cacheDirTmp;
        Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
          @Override
          public void run() {
            FileUtils.deleteQuietly(finalCacheDir);
          }
        }));
      } else {
        cacheDirTmp.mkdirs();
      }
    } catch (Throwable t) {
      LogsServer.instance().exception(t);
    }
    cacheDir = cacheDirTmp;
    httpCache = new HttpCache(cacheDirTmp);

public void run() {
        .setMaxObjectSize(SettingsManager.settings().cacheEntrySize())
        .build();
    ConnectionSocketFactory sslSocketFactory = SettingsManager.settings()
    		.hostnameVerification() ? new SslSocketFactory(sslContext()) : new SslSocketWithoutHostnameVerificationFactory(sslContext());
    registry = RegistryBuilder.<ConnectionSocketFactory> create()
        .register("https", sslSocketFactory)
        .register("http", new SocketFactory())
public void run() {
        .build();
  }

  File cacheDir() {
    return cacheDir;
  }
public Socket createSocket(final HttpContext context) throws IOException {
      return newSocket(context);
    }
  }
  
  private static class SslSocketWithoutHostnameVerificationFactory extends SSLConnectionSocketFactory {
	  public SslSocketWithoutHostnameVerificationFactory(final SSLContext sslContext) {
		  super(sslContext, NoopHostnameVerifier.INSTANCE);
	  }
	  
	  @Override
	  public Socket createSocket(final HttpContext context) throws IOException {
		  return newSocket(context);
	  }
  }

  private static class SocketFactory extends PlainConnectionSocketFactory {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private SerializedPage postProcessPage(SerializedPage page)
    {
        checkState(!Thread.holdsLock(this), "Can not get next page while holding a lock on this");

        if (page == NO_MORE_PAGES) {
            // mark client closed
            closed.set(true);

            // add end marker back to queue
            checkState(pageBuffer.add(NO_MORE_PAGES), "Could not add no more pages marker");
            notifyBlockedCallers();

            // don't return end of stream marker
            page = null;
        }

        if (page != null) {
            synchronized (this) {
                if (!closed.get()) {
                    bufferBytes -= page.getRetainedSizeInBytes();
                    systemMemoryUsageListener.updateSystemMemoryUsage(-page.getRetainedSizeInBytes());
                }
            }
            if (!closed.get() && pageBuffer.peek() == NO_MORE_PAGES) {
                closed.set(true);
            }
            scheduleRequestIfNecessary();
        }
        return page;
    }

public synchronized void scheduleRequestIfNecessary()
            if (pageBuffer.peekLast() != NO_MORE_PAGES) {
                checkState(pageBuffer.add(NO_MORE_PAGES), "Could not add no more pages marker");
            }
            if (!closed.get() && pageBuffer.peek() == NO_MORE_PAGES) {
                closed.set(true);
            }
            notifyBlockedCallers();
            return;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public State state() {
	@Override
	public Promise<D, F, P> done(DoneCallback<D> callback) {
		synchronized (this) {
			doneCallbacks.add(callback);
			if (isResolved()) triggerDone(callback, resolveResult);
		}
		return this;
	}

	@Override
	public Promise<D, F, P> fail(FailCallback<F> callback) {
		synchronized (this) {
			failCallbacks.add(callback);
			if (isRejected()) triggerFail(callback, rejectResult);
		}
		return this;
	}
	
	@Override
	public Promise<D, F, P> always(AlwaysCallback<D, F> callback) {
		synchronized (this) {
			alwaysCallbacks.add(callback);
			if (!isPending()) triggerAlways(callback, state, resolveResult, rejectResult);
		}
		return this;
	}
protected void triggerDone(D resolved) {
				log.error("an uncaught exception occured in a DoneCallback", e);
			}
		}
	}
	
	protected void triggerDone(DoneCallback<D> callback, D resolved) {
protected void triggerFail(F rejected) {
				log.error("an uncaught exception occured in a FailCallback", e);
			}
		}
	}
	
	protected void triggerFail(FailCallback<F> callback, F rejected) {
protected void triggerAlways(State state, D resolve, F reject) {
				log.error("an uncaught exception occured in a AlwaysCallback", e);
			}
		}
		
		synchronized (this) {
			this.notifyAll();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 */
public class DroneClaimManager{

    private static Map<World, DroneClaimManager> claimManagers = new HashMap<World, DroneClaimManager>();
    private final Map<ChunkPosition, Integer> currentPositions = new HashMap<ChunkPosition, Integer>();
    private static final int TIMEOUT = DroneAIManager.TICK_RATE + 1;

    public static DroneClaimManager getInstance(World world){
        DroneClaimManager manager = claimManagers.get(world);
        if(manager == null) {
            manager = new DroneClaimManager();
            claimManagers.put(world, manager);
        }
        return manager;
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
android {
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    compile 'com.android.support:appcompat-v7:23.0.1'
    compile 'com.android.support:support-v4:23.0.1'
    compile 'com.android.support:cardview-v7:23.0.1'
    compile 'com.android.support:recyclerview-v7:23.0.1'
    compile 'com.android.support:design:23.0.1'
    compile 'com.google.android.gms:play-services:8.1.0'
    compile 'com.google.code.gson:gson:2.4'
    compile 'com.nineoldandroids:library:2.4.0'
    compile 'se.emilsjolander:stickylistheaders:2.7.0'
public void failure(RetrofitError e) {
            }
        });
    }
}
protected void onCreate(Bundle savedInstanceState) {
        setContentView(R.layout.activity_startup);

        //Our own Custom exception handler
        ExceptionHandler.setup(this);

        //Upload stats
        ImplicitCounter.Counter(this);

import android.content.Intent;
import android.os.Bundle;
import android.widget.LinearLayout;

import java.util.List;
protected void onLoadFinished(List<TransportManager.Departure> result) {
            mViewResults.addView(view);
        }
    }
}
package de.tum.in.tumcampus.adapters;

import android.app.Activity;
import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

	public RoomFinderListAdapter(Activity activity, ArrayList<HashMap<String, String>> d) {
		data = d;
		inflater = (LayoutInflater) activity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
	}

	@Override
    private final TextSwitcher mTimeSwitcher;
    private int mCountDown;
    private final Handler mHandler;

    /**
     * Standard constructor for DepartureView
public DepartureView(Context context, boolean big) {
        mTimeSwitcher.setOutAnimation(out);

        mHandler = new Handler();
    }

    /**
public void run() {
    }

    private void animateOut() {
        ValueAnimator va = ValueAnimator.ofInt(getHeight(), 0);
        va.setDuration(500);
        va.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator animation) {
                int value = (Integer) animation.getAnimatedValue();
                if (getLayoutParams() != null) {
                    getLayoutParams().height = value;
                    requestLayout();
                    if (value == 0) {
                        setVisibility(View.GONE);
                    }
                }
            }
        });
        va.start();
    }
}
private TUMCabeClient() {
    }

    public static TUMCabeClient getInstance(Context c) {
        TUMCabeClient.context = c;
        if (instance == null) {
            instance = new TUMCabeClient();
        }
public static Card getCard(int pos) {
     * 6. Add an instance of the manager class to the managers list below
     */
    public static synchronized void update(Context context) {
        mContext = context;

        // Use temporary array to avoid that the main thread is
        // trying to access an empty array
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
package com.pushtorefresh.storio.contentresolver.impl;

import android.net.Uri;
import android.support.annotation.NonNull;

import com.pushtorefresh.storio.contentresolver.Changes;

import java.util.Set;

import rx.Observable;
import rx.functions.Func1;

/**
 * Hides RxJava from ClassLoader via separate class.
 */
final class ChangesFilter implements Func1<Changes, Boolean> {

    @NonNull
    private final Set<Uri> uris;

    private ChangesFilter(@NonNull Set<Uri> uris) {
        this.uris = uris;
    }

    @NonNull
    static Observable<Changes> apply(@NonNull Observable<Changes> publishSubject, @NonNull Set<Uri> uris) {
        return publishSubject.filter(new ChangesFilter(uris));
    }

    @Override
    public Boolean call(Changes changes) {
        // if one of changed uri found in uris for subscription -> notify observer
        for (Uri uri : uris) {
            if (changes.affectedUris().contains(uri)) {
                return true;
            }
        }

        return false;
    }
}

import android.content.ContentResolver;
import android.content.ContentValues;
import android.database.ContentObserver;
import android.database.Cursor;
import android.net.Uri;
import android.os.Handler;
import com.pushtorefresh.storio.contentresolver.query.InsertQuery;
import com.pushtorefresh.storio.contentresolver.query.Query;
import com.pushtorefresh.storio.contentresolver.query.UpdateQuery;
import com.pushtorefresh.storio.internal.ChangesBus;
import com.pushtorefresh.storio.internal.Queries;

import java.util.Collections;
import rx.Observable;

import static com.pushtorefresh.storio.internal.Checks.checkNotNull;
import static com.pushtorefresh.storio.internal.Environment.RX_JAVA_IS_AVAILABLE;
import static com.pushtorefresh.storio.internal.Environment.throwExceptionIfRxJavaIsNotAvailable;

/**
    private final ContentResolver contentResolver;

    @NonNull
    private final ChangesBus<Changes> changesBus = new ChangesBus<Changes>();

    // can be null, if RxJava is not available
    @Nullable
    private final ContentObserver contentObserver;

    protected DefaultStorIOContentResolver(@NonNull ContentResolver contentResolver, @Nullable Map<Class<?>, ContentResolverTypeMapping<?>> typesMapping) {
        this.contentResolver = contentResolver;
        internal = new InternalImpl(typesMapping);

        if (RX_JAVA_IS_AVAILABLE) {
            final HandlerThread handlerThread = new HandlerThread("StorIOContentResolverNotificationsThread");
            handlerThread.start(); // multithreading: don't block me, bro!

            contentObserver = new ContentObserver(new Handler(handlerThread.getLooper())) {
                @Override
                public boolean deliverSelfNotifications() {
                    return false;
                }

                @SuppressWarnings("ConstantConditions")
                @Override
                public void onChange(boolean selfChange, Uri uri) {
                    // sending changes to changesBus
                    changesBus.onNext(Changes.newInstance(uri));
                }
            };
        } else {
            contentObserver = null;
        }
    }

    /**
public void onChange(boolean selfChange, Uri uri) {
    public Observable<Changes> observeChangesOfUris(@NonNull final Set<Uri> uris) {
        throwExceptionIfRxJavaIsNotAvailable("Observing changes in StorIOContentProvider");

        for (Uri uri : uris) {
            contentResolver.registerContentObserver(
                    uri,
                    true,
                    contentObserver
            );
        }

        // indirect usage of RxJava filter() required to avoid problems with ClassLoader when RxJava is not in ClassPath
        return ChangesFilter.apply(changesBus.asObservable(), uris);
    }

    /**
android {
    packagingOptions {
        exclude 'LICENSE.txt' // multiple libs have this file -> cause build error
    }
}

dependencies {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private final List<Boss> activeBosses;
    private final List<BossEgg> bossEggs;
    private final RareItemHunterPlugin plugin;

    public BossManager(RareItemHunterPlugin plugin) {
        this.plugin = plugin;
public BossManager(RareItemHunterPlugin plugin) {
        this.activeBosses = bp.getActiveBosses();
        
        bp.startSaving(20*30);
    }
    
    public BossTemplate getBossTemplate(String bossName){
public void hatchEggIfBoss(Block block) {
            }
        }
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <server.version>2.0.1-SNAPSHOT</server.version>
        <junit.version>4.11</junit.version>

        <bm.tomcat.port>9090</bm.tomcat.port>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    private final WeakReference<ContributionsRequestListener> mListener;

    ContributionsLoader(@NonNull WeakReference<ContributionsRequestListener> listener) {
        mListener = listener;
    }

    void beginRequest(Context context, String login) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    <contextListener class="ch.qos.logback.classic.jul.LevelChangePropagator">
        <resetJUL>true</resetJUL>
    </contextListener>

    <!-- To enable JMX Management -->
    <jmxConfigurator/>

    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%!l(MISSING)evel %!l(MISSING)ogger{0} - %!m(MISSING)sg%!n(MISSING)</pattern>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public boolean isPull() {
        return true;
    }

    /* package */ void maybeCreateRemoteDB() {
        // puller never needs to do this
    }

import com.couchbase.lite.Status;
import com.couchbase.lite.internal.InterfaceAudience;
import com.couchbase.lite.internal.RevisionInternal;
import com.couchbase.lite.support.HttpClientFactory;
import com.couchbase.lite.support.RemoteRequest;
import com.couchbase.lite.support.RemoteRequestCompletionBlock;
@InterfaceAudience.Private
public class PusherInternal extends ReplicationInternal implements Database.ChangeListener {

    private boolean createTarget;
    private boolean creatingTarget;
    private boolean observing;
    SortedSet<Long> pendingSequences;
    Long maxPendingSequence;

    /**
     * Constructor
     *
public void waitForPendingFutures() {
    }

    /**
     * Adds a local revision to the "pending" set that are awaiting upload:
     */
    @InterfaceAudience.Private
    private void addPending(RevisionInternal revisionInternal) {
        long seq = revisionInternal.getSequence();
        pendingSequences.add(seq);
        if (seq > maxPendingSequence) {
            maxPendingSequence = seq;
        }
    }

    /**
     * Removes a revision from the "pending" set after it's been uploaded. Advances checkpoint.
     */
    @InterfaceAudience.Private
    private void removePending(RevisionInternal revisionInternal) {
        long seq = revisionInternal.getSequence();
        if (pendingSequences == null || pendingSequences.isEmpty()) {
            Log.w(Log.TAG_SYNC, "%!s(MISSING): removePending() called w/ rev: %!s(MISSING), but pendingSequences empty",
                    this, revisionInternal);
            return;
        }
        boolean wasFirst = (seq == pendingSequences.first());
        if (!pendingSequences.contains(seq)) {
            Log.w(Log.TAG_SYNC, "%!s(MISSING): removePending: sequence %!s(MISSING) not in set, for rev %!s(MISSING)",
                    this, seq, revisionInternal);
        }
        pendingSequences.remove(seq);
        if (wasFirst) {
            // If I removed the first pending sequence, can advance the checkpoint:
            long maxCompleted;
            if (pendingSequences.size() == 0) {
                maxCompleted = maxPendingSequence;
            } else {
                maxCompleted = pendingSequences.first();
                --maxCompleted;
            }
            setLastSequence(Long.toString(maxCompleted));
        }
    }

    @Override
    @InterfaceAudience.Private
    void maybeCreateRemoteDB() {
        if (!createTarget) {
            return;
        }
public void onCompletion(HttpResponse httpResponse, Object result, Throwable e)
        pendingFutures.add(future);
    }

    @Override
    @InterfaceAudience.Private
    public void beginReplicating() {

        Log.d(Log.TAG_SYNC, "%!s(MISSING): beginReplicating() called", this);

public void beginReplicating() {
        if (filterName != null && filter == null) {
            Log.w(Log.TAG_SYNC, "%!s(MISSING): No ReplicationFilter registered for filter '%!s(MISSING)'; ignoring",
                    this, filterName);
            ;
        }

        // Process existing changes since the last push:
public void beginReplicating() {
        RevisionList changes = db.changesSince(lastSequenceLong, options, filter, filterParams);
        if (changes.size() > 0) {
            Log.d(Log.TAG_SYNC, "%!s(MISSING): Queuing %!d(MISSING) changes since %!s(MISSING)", this, changes.size(), lastSequence);
            batcher.queueObjects(changes);
            batcher.flush();
        } else {
            Log.d(Log.TAG_SYNC, "%!s(MISSING): No changes since %!s(MISSING)", this, lastSequence);
        }
public void beginReplicating() {
        }
    }


    @InterfaceAudience.Private
    private void stopObserving() {
        if (observing) {
protected void goOffline() {
        stopObserving();
    }

    @Override
    @InterfaceAudience.Private
    public void changed(Database.ChangeEvent event) {
public void changed(Database.ChangeEvent event) {
            }
            RevisionInternal rev = change.getAddedRevision();
            if (getLocalDatabase().runFilter(filter, filterParams, rev)) {
                addToInbox(rev);
            }
        }
    }

    @Override
    @InterfaceAudience.Private
    protected void processInbox(final RevisionList changes) {

        // Generate a set of doc/rev IDs in the JSON format that _revs_diff wants:
        // <http://wiki.apache.org/couchdb/HttpPostRevsDiff>
        Map<String, List<String>> diffs = new HashMap<String, List<String>>();
protected void processInbox(final RevisionList changes) {
        // Call _revs_diff on the target db:
        Log.v(Log.TAG_SYNC, "%!s(MISSING): posting to /_revs_diff", this);

        Future future = sendAsyncRequest("POST", "/_revs_diff", diffs, new RemoteRequestCompletionBlock() {

            @Override
            public void onCompletion(HttpResponse httpResponse, Object response, Throwable e) {
public void onCompletion(HttpResponse httpResponse, Object response, Throwable e
                    if (results.size() != 0) {
                        // Go through the list of local changes again, selecting the ones the destination server
                        // said were missing and mapping them to a JSON dictionary in the form _bulk_docs wants:
                        final List<Object> docsToSend = new ArrayList<Object>();
                        RevisionList revsToSend = new RevisionList();
                        for (RevisionInternal rev : changes) {
                            // Is this revision in the server's 'missing' list?
                            Map<String, Object> properties = null;
public void onCompletion(HttpResponse httpResponse, Object response, Throwable e
                            }

                            RevisionInternal populatedRev = transformRevision(loadedRev);

                            List<String> possibleAncestors = (List<String>) revResults.get("possible_ancestors");

public void onCompletion(HttpResponse httpResponse, Object response, Throwable e

                            revsToSend.add(rev);
                            docsToSend.add(properties);
                        }

                        // Post the revisions to the destination:
public void onCompletion(HttpResponse httpResponse, Object response, Throwable e
            }

        });
        pendingFutures.add(future);
    }

    /**
     * Post the revisions to the destination. "new_edits":false means that the server should
     * use the given _rev IDs instead of making up new ones.
     */
    @InterfaceAudience.Private
    protected void uploadBulkDocs(List<Object> docsToSend, final RevisionList changes) {
protected void uploadBulkDocs(List<Object> docsToSend, final RevisionList change
        bulkDocsBody.put("docs", docsToSend);
        bulkDocsBody.put("new_edits", false);

        Future future = sendAsyncRequest("POST", "/_bulk_docs", bulkDocsBody, new RemoteRequestCompletionBlock() {

            @Override
            public void onCompletion(HttpResponse httpResponse, Object result, Throwable e) {
public void onCompletion(HttpResponse httpResponse, Object result, Throwable e)
                addToCompletedChangesCount(numDocsToSend);
            }
        });
        pendingFutures.add(future);
    }

private boolean uploadMultipartRevision(final RevisionInternal revision) {

        addToChangesCount(1);

        Future future = sendAsyncMultipartRequest("PUT", path, multiPart, new RemoteRequestCompletionBlock() {
            @Override
            public void onCompletion(HttpResponse httpResponse, Object result, Throwable e) {
                try {
public void onCompletion(HttpResponse httpResponse, Object result, Throwable e)
                    addToCompletedChangesCount(1);

                }

            }
        });
        pendingFutures.add(future);

        return true;

    }

    // Fallback to upload a revision if uploadMultipartRevision failed due to the server's rejecting
    // multipart format.
    private void uploadJsonRevision(final RevisionInternal rev) {
        // Get the revision's properties:
        if (!db.inlineFollowingAttachmentsIn(rev)) {
private void uploadJsonRevision(final RevisionInternal rev) {
        }

        final String path = String.format("/%!s(MISSING)?new_edits=false", encodeDocumentId(rev.getDocID()));
        Future future = sendAsyncRequest("PUT",
                path,
                rev.getProperties(),
                new RemoteRequestCompletionBlock() {
public void onCompletion(HttpResponse httpResponse, Object result, Throwable e)
                        }
                    }
                });
        pendingFutures.add(future);
    }

    // Given a revision and an array of revIDs, finds the latest common ancestor revID
    // and returns its generation #. If there is none, returns 0.
    private static int findCommonAncestor(RevisionInternal rev, List<String> possibleRevIDs) {
        if (possibleRevIDs == null || possibleRevIDs.size() == 0) {
            return 0;
public String getContentEncoding() {
            return contentEncoding;
        }
    }
}
        SYNC, ASYNC
    }

    ;

    public static final String BY_CHANNEL_FILTER_NAME = "sync_gateway/bychannel";

    public static final String CHANNELS_QUERY_PARAM = "channels";
protected void setError(Throwable throwable) {


    @InterfaceAudience.Private
    /* package */ void addToCompletedChangesCount(int delta) {
        int previousVal = getCompletedChangesCount().getAndAdd(delta);
        Log.v(Log.TAG_SYNC, "%!s(MISSING): Incrementing completedChangesCount count from %!s(MISSING) by adding %!d(MISSING) -> %!d(MISSING)",
                this, previousVal, delta, completedChangesCount.get());
protected void setError(Throwable throwable) {
    }

    @InterfaceAudience.Private
    /* package */ void addToChangesCount(int delta) {
        int previousVal = getChangesCount().getAndAdd(delta);
        if (getChangesCount().get() < 0) {
            Log.w(Log.TAG_SYNC, "Changes count is negative, this could indicate an error");
public AtomicInteger getChangesCount() {
     * @exclude
     */
    @InterfaceAudience.Private
    public Future sendAsyncRequest(String method, String relativePath, Object body,
                                   RemoteRequestCompletionBlock onCompletion) {
        return sendAsyncRequest(method, relativePath, body, false, onCompletion);
    }
public Future sendAsyncRequest(String method, String relativePath, Object body,
     * @exclude
     */
    @InterfaceAudience.Private
    public Future sendAsyncRequest(String method, String relativePath, Object body, boolean dontLog404,
                                   RemoteRequestCompletionBlock onCompletion) {
        try {
            String urlStr = buildRelativeURLString(relativePath);
public Future sendAsyncRequest(String method, String relativePath, Object body,
     * @exclude
     */
    @InterfaceAudience.Private
    public Future sendAsyncRequest(String method, URL url, Object body, boolean dontLog404,
                                   final RemoteRequestCompletionBlock onCompletion) {
        Log.d(Log.TAG_SYNC, "[sendAsyncRequest()] " + method + " => " + url);
        RemoteRequestRetry request = new RemoteRequestRetry(
public void onCompletion(HttpResponse httpResponse, Object result, Throwable e)
        });


        Future future = request.submit(canSendCompressedRequests());
        return future;
    }

    /**
     * @exclude
     */
    @InterfaceAudience.Private
    public Future sendAsyncMultipartRequest(String method, String relativePath,
                                            MultipartEntity multiPartEntity,
                                            RemoteRequestCompletionBlock onCompletion) {
        URL url = null;
public Future sendAsyncMultipartRequest(String method, String relativePath,

        request.setAuthenticator(getAuthenticator());

        Future future = request.submit();
        return future;

    }

    /**
public CustomFuture sendAsyncMultipartDownloaderRequest(String method, String re

            request.setAuthenticator(getAuthenticator());

            CustomFuture future = request.submit();
            return future;
        } catch (MalformedURLException e) {
            Log.e(Log.TAG_SYNC, "Malformed URL for async request", e);
        }

        return null;
    }


    /**
     * Get the local database which is the source or target of this replication
     */
    /* package */ Database getLocalDatabase() {
        return db;
    }

    /* package */ void setLocalDatabase(Database db) {
        this.db = db;
    }

public void onCompletion(HttpResponse httpResponse, Object result, Throwable e)
    }

    @InterfaceAudience.Private
    /* package */ String buildRelativeURLString(String relativePath) {

        // the following code is a band-aid for a system problem in the codebase
        // where it is appending "relative paths" that start with a slash, eg:
public void onCompletion(HttpResponse httpResponse, Object result, Throwable e)
    }


    /* package */
    abstract void maybeCreateRemoteDB();

    /**
     * This is the _local document ID stored on the remote server to keep track of state.
public void setAuthenticator(Authenticator authenticator) {
    }

    @InterfaceAudience.Private
    /* package */ boolean serverIsSyncGatewayVersion(String minVersion) {
        String prefix = "Couchbase Sync Gateway/";
        if (serverType == null) {
            return false;
protected void retryReplicationIfError() {
    }

    @InterfaceAudience.Private
    /* package */ void setServerType(String serverType) {
        this.serverType = serverType;
    }

public void deleteCookie(String name) {
        this.clientFactory.deleteCookie(name);
    }

    /* package */ HttpClientFactory getClientFactory() {
        return clientFactory;
    }

public void run() {
     * <p/>
     * Avoids encoding the slash in _design documents since it may cause a 301 redirect.
     */
    /* package */ String encodeDocumentId(String docId) {
        if (docId.startsWith("_design/")) {
            // http://docs.couchdb.org/en/1.6.1/http-api.html#cap-/{db}/_design/{ddoc}
            String designDocId = docId.substring("_design/".length());
public Batcher(ScheduledExecutorService workExecutor,
    // Instance Methods - Public
    ///////////////////////////////////////////////////////////////////////////

    public int getDelay() {
        return delay;
    }
public void waitForPendingFutures() {
            try {
                pendingFuture.get();
            } catch (Exception e) {
                Log.w(Log.TAG_BATCHER, e.getMessage());
            }
        }

public void waitForPendingFutures() {
            try {
                pendingFuture.get();
            } catch (Exception e) {
                Log.w(Log.TAG_BATCHER, e.getMessage());
            }
        }
        Log.v(Log.TAG_BATCHER, "%!s(MISSING): /waitForPendingFutures", this);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.awt.geom.Area;
import java.awt.geom.RoundRectangle2D;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
    /**
     * Shade nine-patch icons cache.
     */
    private static final Map<String, NinePatchIcon> shadeIconCache = new HashMap<String, NinePatchIcon> ();

    /**
     * Returns cached shade nine-patch icon.
    public static NinePatchIcon getShadeIcon ( final int shadeWidth, final int round, final float shadeOpacity )
    {
        final String key = OUTER_SHADE_PREFIX + ";" + shadeWidth + ";" + round + ";" + shadeOpacity;
        if ( shadeIconCache.containsKey ( key ) )
        {
            return shadeIconCache.get ( key );
        }
        else
        {
            final NinePatchIcon ninePatchIcon = createShadeIcon ( shadeWidth, round, shadeOpacity );
            shadeIconCache.put ( key, ninePatchIcon );
            return ninePatchIcon;
        }
    }

    /**
public static NinePatchIcon createShadeIcon ( final int shadeWidth, final int ro
    public static NinePatchIcon getInnerShadeIcon ( final int shadeWidth, final int round, final float shadeOpacity )
    {
        final String key = INNER_SHADE_PREFIX + ";" + shadeWidth + ";" + round + ";" + shadeOpacity;
        if ( shadeIconCache.containsKey ( key ) )
        {
            return shadeIconCache.get ( key );
        }
        else
        {
            final NinePatchIcon ninePatchIcon = createInnerShadeIcon ( shadeWidth, round, shadeOpacity );
            shadeIconCache.put ( key, ninePatchIcon );
            return ninePatchIcon;
        }
    }

    /**
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public ObjCObjectRef(ObjCObject referent) {
    static class ObjectOwnershipHelper {
        private static final LongMap<Object> CUSTOM_OBJECTS = new LongMap<>();

        private static final long retainCount = Selector.register("retainCount").getHandle();
        private static final long retain = Selector.register("retain").getHandle();
        private static final long originalRetain = Selector.register("original_retain").getHandle();
public ObjCObjectRef(ObjCObject referent) {

        private static final Method retainMethod;
        private static final Method releaseMethod;
        
        private static final LongMap<Long> customClassToNativeSuper = new LongMap<>();

        static {
private static void registerCallbackMethod(long cls, long selector, long newSele
                throw new Error(
                        "Failed to register callback method on the ObjectOwnershipHelper: class_addMethod(...) failed");
            }
            
            // find the super class that is a native class and cache it
            long superClass = ObjCRuntime.class_getSuperclass(cls);
            long nativeSuper = 0;
            while(superClass != 0) {
                ObjCClass objCClass = ObjCClass.toObjCClass(superClass);
                if(!objCClass.isCustom()) {
                    nativeSuper = superClass;
                    break;
                }
                superClass = ObjCRuntime.class_getSuperclass(superClass);
            }
            if(nativeSuper == 0) {
                throw new Error("Couldn't find native super class for " + VM.newStringUTF(ObjCRuntime.class_getName(cls)));
            }
            synchronized(customClassToNativeSuper) {
                customClassToNativeSuper.put(cls, nativeSuper);
            }
        }

        @Callback
        private static @Pointer long retain(@Pointer long self, @Pointer long sel) {
            if (ObjCRuntime.int_objc_msgSend(self, retainCount) <= 1) {
                synchronized (CUSTOM_OBJECTS) {
                    ObjCClass cls = ObjCClass.toObjCClass(ObjCRuntime.object_getClass(self));
                    ObjCObject obj = ObjCObject.toObjCObject(cls.getType(), self, 0);
                    CUSTOM_OBJECTS.put(self, obj);
                }
            }     
            long cls = ObjCRuntime.object_getClass(self);
            long nativeSuper = 0;
            synchronized(customClassToNativeSuper) {
                nativeSuper = customClassToNativeSuper.get(cls);
            }
            Super sup = new Super(self, nativeSuper);
private static void registerCallbackMethod(long cls, long selector, long newSele

        @Callback
        private static void release(@Pointer long self, @Pointer long sel) {
            if (ObjCRuntime.int_objc_msgSend(self, retainCount) == 1) {
                synchronized (CUSTOM_OBJECTS) {
                    CUSTOM_OBJECTS.remove(self);
                }
            }            
            long cls = ObjCRuntime.object_getClass(self);
            long nativeSuper = 0;
            synchronized(customClassToNativeSuper) {
                nativeSuper = customClassToNativeSuper.get(cls);
            }
            Super sup = new Super(self, nativeSuper);
            ObjCRuntime.void_objc_msgSendSuper(sup.getHandle(), sel);
        }
        
        public static boolean isObjectRetained(ObjCObject object) {
            synchronized (CUSTOM_OBJECTS) {
                return CUSTOM_OBJECTS.containsKey(object.getHandle());
            }
        }
    }

    static class AssociatedObjectHelper {
        private static final String STRONG_REFS_KEY = AssociatedObjectHelper.class.getName() + ".StrongRefs";

        private static final int OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1;
        private static final long RELEASE_LISTENER_CLASS;
        private static final String OWNER_IVAR_NAME = "value";
public Super(long receiver, long objcClass) {
        @StructMember(1)
        public native Super objCClass(@Pointer long objCClass);
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Wifi configuration and util library built for Android.

[ ![Download](https://api.bintray.com/packages/isupatches/Maven/wisefy/images/download.svg) ](https://bintray.com/isupatches/Maven/wisefy/_latestVersion)

<a href="http://www.methodscount.com/?lib=com.isupatches%!A(MISSING)wisefy%!A(MISSING)1.0.5"><img src="https://img.shields.io/badge/Methods and size-core: 104 | deps: 16517 | 55 KB-e91e63.svg"/></a>

## Adding to your project

Then add it as a dependency:
Gradle:

```
compile 'com.isupatches:wisefy:1.0.7'
```

Maven:
Maven:
<dependency>
  <groupId>com.isupatches</groupId>
  <artifactId>wisefy</artifactId>
  <version>1.0.7</version>
  <type>pom</type>
</dependency>
```
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_102) on Sat Mar 25 21:42:17 CDT 2017 -->
<title>All Classes (wisefy 1.0.7 API)</title>
<meta name="date" content="2017-03-25">
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<script type="text/javascript" src="script.js"></script>
</head>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_102) on Sat Mar 25 21:42:17 CDT 2017 -->
<title>All Classes (wisefy 1.0.7 API)</title>
<meta name="date" content="2017-03-25">
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<script type="text/javascript" src="script.js"></script>
</head>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_102) on Sat Mar 25 21:42:17 CDT 2017 -->
<title>WiseFy (wisefy 1.0.7 API)</title>
<meta name="date" content="2017-03-25">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="WiseFy (wisefy 1.0.7 API)";
        }
    }
    catch(err) {
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_102) on Sat Mar 25 21:42:17 CDT 2017 -->
<title>WiseFy.withContext (wisefy 1.0.7 API)</title>
<meta name="date" content="2017-03-25">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="WiseFy.withContext (wisefy 1.0.7 API)";
        }
    }
    catch(err) {
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<h2 title="Class WiseFy.withContext" class="title">Class WiseFy.withContext</h2>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<h2 title="Class WiseFy.withContext" class="title">Class WiseFy.withContext</h2>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<h2 title="Class WiseFy.withContext" class="title">Class WiseFy.withContext</h2>
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_102) on Sat Mar 25 21:42:17 CDT 2017 -->
<title>com.isupatches.wisefy (wisefy 1.0.7 API)</title>
<meta name="date" content="2017-03-25">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_102) on Sat Mar 25 21:42:17 CDT 2017 -->
<title>com.isupatches.wisefy (wisefy 1.0.7 API)</title>
<meta name="date" content="2017-03-25">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="com.isupatches.wisefy (wisefy 1.0.7 API)";
        }
    }
    catch(err) {
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_102) on Sat Mar 25 21:42:17 CDT 2017 -->
<title>com.isupatches.wisefy Class Hierarchy (wisefy 1.0.7 API)</title>
<meta name="date" content="2017-03-25">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="com.isupatches.wisefy Class Hierarchy (wisefy 1.0.7 API)";
        }
    }
    catch(err) {
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_102) on Sat Mar 25 21:42:17 CDT 2017 -->
<title>GetManagerUtil (wisefy 1.0.7 API)</title>
<meta name="date" content="2017-03-25">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="GetManagerUtil (wisefy 1.0.7 API)";
        }
    }
    catch(err) {
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_102) on Sat Mar 25 21:42:17 CDT 2017 -->
<title>LogUtil (wisefy 1.0.7 API)</title>
<meta name="date" content="2017-03-25">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="LogUtil (wisefy 1.0.7 API)";
        }
    }
    catch(err) {
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_102) on Sat Mar 25 21:42:17 CDT 2017 -->
<title>SSIDUtil (wisefy 1.0.7 API)</title>
<meta name="date" content="2017-03-25">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="SSIDUtil (wisefy 1.0.7 API)";
        }
    }
    catch(err) {
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_102) on Sat Mar 25 21:42:17 CDT 2017 -->
<title>com.isupatches.wisefy.util (wisefy 1.0.7 API)</title>
<meta name="date" content="2017-03-25">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_102) on Sat Mar 25 21:42:17 CDT 2017 -->
<title>com.isupatches.wisefy.util (wisefy 1.0.7 API)</title>
<meta name="date" content="2017-03-25">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="com.isupatches.wisefy.util (wisefy 1.0.7 API)";
        }
    }
    catch(err) {
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_102) on Sat Mar 25 21:42:17 CDT 2017 -->
<title>com.isupatches.wisefy.util Class Hierarchy (wisefy 1.0.7 API)</title>
<meta name="date" content="2017-03-25">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="com.isupatches.wisefy.util Class Hierarchy (wisefy 1.0.7 API)";
        }
    }
    catch(err) {
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_102) on Sat Mar 25 21:42:17 CDT 2017 -->
<title>Constant Field Values (wisefy 1.0.7 API)</title>
<meta name="date" content="2017-03-25">
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<script type="text/javascript" src="script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Constant Field Values (wisefy 1.0.7 API)";
        }
    }
    catch(err) {
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_102) on Sat Mar 25 21:42:17 CDT 2017 -->
<title>Deprecated List (wisefy 1.0.7 API)</title>
<meta name="date" content="2017-03-25">
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<script type="text/javascript" src="script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Deprecated List (wisefy 1.0.7 API)";
        }
    }
    catch(err) {
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_102) on Sat Mar 25 21:42:17 CDT 2017 -->
<title>API Help (wisefy 1.0.7 API)</title>
<meta name="date" content="2017-03-25">
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<script type="text/javascript" src="script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="API Help (wisefy 1.0.7 API)";
        }
    }
    catch(err) {
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_102) on Sat Mar 25 21:42:17 CDT 2017 -->
<title>Index (wisefy 1.0.7 API)</title>
<meta name="date" content="2017-03-25">
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<script type="text/javascript" src="script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Index (wisefy 1.0.7 API)";
        }
    }
    catch(err) {
<h2 class="title">W</h2>
</dd>
<dt><span class="memberNameLink"><a href="com/isupatches/wisefy/WiseFy.html#WISEFY_FAILURE">WISEFY_FAILURE</a></span> - Static variable in class com.isupatches.wisefy.<a href="com/isupatches/wisefy/WiseFy.html" title="class in com.isupatches.wisefy">WiseFy</a></dt>
<dd>&nbsp;</dd>
</dl>
<a href="#I:C">C</a>&nbsp;<a href="#I:G">G</a>&nbsp;<a href="#I:I">I</a>&nbsp;<a href="#I:L">L</a>&nbsp;<a href="#I:S">S</a>&nbsp;<a href="#I:W">W</a>&nbsp;</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_102) on Sat Mar 25 21:42:17 CDT 2017 -->
<title>wisefy 1.0.7 API</title>
<script type="text/javascript">
    targetPage = "" + window.location.search;
    if (targetPage != "" && targetPage != "undefined")
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_102) on Sat Mar 25 21:42:17 CDT 2017 -->
<title>Overview List (wisefy 1.0.7 API)</title>
<meta name="date" content="2017-03-25">
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<script type="text/javascript" src="script.js"></script>
</head>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_102) on Sat Mar 25 21:42:17 CDT 2017 -->
<title>Overview (wisefy 1.0.7 API)</title>
<meta name="date" content="2017-03-25">
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<script type="text/javascript" src="script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Overview (wisefy 1.0.7 API)";
        }
    }
    catch(err) {
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<h1 class="title">wisefy 1.0.7 API</h1>
</div>
<div class="contentContainer">
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Packages table, listing packages, and an explanation">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_102) on Sat Mar 25 21:42:17 CDT 2017 -->
<title>Class Hierarchy (wisefy 1.0.7 API)</title>
<meta name="date" content="2017-03-25">
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<script type="text/javascript" src="script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Class Hierarchy (wisefy 1.0.7 API)";
        }
    }
    catch(err) {
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.isupatches.wisefy;


boolean isNetwork5gHz() {
        return frequency > 4900 && frequency < 5900;
    }


    /**
     * To check if a given network is 5gHz
     *
public ConnectivityManager getConnectivityManager(Context context) {
     */
    public WifiManager getWiFiManager(Context context) {
        if(context != null) {
            return (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
        } else {
            return null;
        }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public boolean requireDebugMode()
    @Override
    public void registerBinaryValueInstance(final BinaryValue binaryValue) {
        if(binaryValueInstances == null) {
             binaryValueInstances = new ArrayList<BinaryValue>();
             
             cleanupTasks.add(new CleanupTask() {
                 
                 @Override
                 public void cleanup(final XQueryContext context) {
                    if(context.binaryValueInstances != null) {
                       for(final BinaryValue bv : context.binaryValueInstances) {
                           try {
                               bv.close();
                           } catch (final IOException ioe) {
                               LOG.error("Unable to close binary value: " + ioe.getMessage(), ioe);
                           }
                       }
                       context.binaryValueInstances.clear();
                   }
                 }
             });
        }
        
        binaryValueInstances.add(binaryValue);
    }

    @Override
    public String getCacheClass() {
        return (String) getBroker().getConfiguration().getProperty(Configuration.BINARY_CACHE_CLASS_PROPERTY);
public void debug() {

    }
    
    private List<CleanupTask> cleanupTasks = new ArrayList<CleanupTask>();
    
    public void registerCleanupTask(final CleanupTask cleanupTask) {
        cleanupTasks.add(cleanupTask);
    }
    
    public interface CleanupTask {
        public void cleanup(final XQueryContext context);
    }
    
    @Override
package org.exist.xquery;

import org.exist.storage.DBBroker;
import org.exist.security.Subject;
import org.junit.Test;
import org.easymock.EasyMock;
import org.exist.security.xacml.AccessContext;
import static org.easymock.EasyMock.replay;
import static org.easymock.EasyMock.verify;
import static org.easymock.EasyMock.expect;
/**
 *
 * @author aretter
 */
public class XQueryContextTest {

public void prepareForExecution_setsUserFromSession() {
                .addMockedMethod("getBroker")
                .createMock();

        DBBroker mockBroker = EasyMock.createMock(DBBroker.class);

        Subject mockSubject = EasyMock.createMock(Subject.class);

        //expectations
        expect(context.getUserFromHttpSession()).andReturn(mockSubject);
public void prepareForExecution_setsUserFromSession() {

        verify(context);
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

public void run() {
		}
	}

	private static final class WebcamsDiscovery implements Callable<List<Webcam>> {

		private final WebcamDriver driver;

public WebcamsDiscovery(WebcamDriver driver) {
			}
			return webcams;
		}
	}

	/**
public synchronized void close() {
		}

		Runtime.getRuntime().removeShutdownHook(hook);
		close0();
	}

public BufferedImage getImage() {
				driver = new WebcamDefaultDriver();
			}

			ExecutorService executor = Executors.newSingleThreadExecutor();
			Future<List<Webcam>> future = executor.submit(new WebcamsDiscovery(driver));
			executor.shutdown();

			try {
public static void resetDriver() {

		driver = null;

		if (webcams != null && !webcams.isEmpty()) {
			webcams.clear();
		}

public WebcamDevice getDevice() {
	 */
	protected void dispose() {

		open = false;
		disposed = true;

		WebcamEvent we = new WebcamEvent(this);
		for (WebcamListener l : listeners) {
			try {
				l.webcamDisposed(we);
			} catch (Exception e) {
				LOG.error(String.format("Notify webcam disposed, exception when calling %!s(MISSING) listener", l.getClass()), e);
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.Observable;
import java.util.Observer;


/**
 * 
 * @author Bartosz Firyn (SarXos)
 */
class WebcamDeallocator implements Observer {

	private Webcam[] webcams = null;
	private WebcamSignalHandler handler = new WebcamSignalHandler();

	/**
	 * This constructor is used internally to create new deallocator for the
	 * @param devices the devices to be stored in deallocator
	 */
	private WebcamDeallocator(Webcam[] devices) {
		if (devices != null && devices.length > 0) {
			this.webcams = devices;
			this.handler.listen("TERM", this);
		}
	}

	/**
	 * Store devices to be deallocated when TERM signal has been received.
	 * 
	 * @param devices the devices array to be stored by deallocator
	 */
	protected static final void store(Webcam[] devices) {
		new WebcamDeallocator(devices);
	}

	@Override
	public void update(Observable observable, Object object) {
		for (Webcam device : webcams) {
			try {
				device.dispose();
			} catch (Throwable t) {
				caugh(t);
			}
		}
	}

	public void caugh(Throwable e) {
		File f = new File(String.format("webcam-capture-hs-%!s(MISSING)", System.currentTimeMillis()));
		PrintStream ps = null;
		try {
			e.printStackTrace(ps = new PrintStream(f));
		} catch (FileNotFoundException e2) {
			// ignore, stdout is not working, cannot do anything more
		} finally {
			if (ps != null) {
				ps.close();
			}
		}
	}
}
package com.github.sarxos.webcam;

import java.util.Observable;
import java.util.Observer;

import sun.misc.Signal;
import sun.misc.SignalHandler;
 * @author Bartosz Firyn (SarXos)
 */
@SuppressWarnings("restriction")
class WebcamSignalHandler extends Observable implements SignalHandler {

	private SignalHandler handler = null;

	public void listen(String signal, Observer observer) throws IllegalArgumentException {
		addObserver(observer);
		handler = Signal.handle(new Signal(signal), this);
	}

	@Override
	public void handle(Signal signal) {

		// do nothing on "signal default" or "signal ignore"
		if (handler == SIG_DFL || handler == SIG_IGN) {
			return;
		}

		setChanged();

		try {
			notifyObservers(signal);
		} finally {
			handler.handle(signal);
		}
	}
}

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
	 */
	private static final GetDevicesTask DEVICES_TASK = new GetDevicesTask(processor);

	/**
	 * Static devices list.
	 */
	private static final List<WebcamDevice> devices = new ArrayList<WebcamDevice>();

	private static final AtomicBoolean initialized = new AtomicBoolean(false);

	@Override
	public List<WebcamDevice> getDevices() {

		if (initialized.compareAndSet(false, true)) {

			LOG.debug("Searching devices");

			for (Device device : DEVICES_TASK.getDevices()) {
				devices.add(new WebcamDefaultDevice(device));
			}

			if (LOG.isDebugEnabled()) {
				for (WebcamDevice device : devices) {
					LOG.debug("Found device " + device);
				}
			}
		}

 * 
 * @author Bartosz Firyn (SarXos)
 */
public class WebcamGrabberProcessor {

	/**
	 * Thread factory for processor.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public class #E#InlineDependencyCache extends #E#InlineCacheImpl implements Depe
     */
    private Set<Reference<DependencyNode>> dependentNodes;

    private Reference<DependencyNode> selfReference;

    public #E#InlineDependencyCache(Object owner, #E#Calculatable calculable, MutableStatistics statistics) {
public class #E#InlineDependencyCache extends #E#InlineCacheImpl implements Depe
            dependentNodes = new THashSet<Reference<DependencyNode>>();
        }
        dependentNodes.add(node.getSelfReference());
    }

    @Override
     */
    private Set<Reference<DependencyNode>> dependentNodes;

    private Reference<DependencyNode> selfReference;

    public BooleanInlineDependencyCache(Object owner, BooleanCalculatable calculable, MutableStatistics statistics) {
public synchronized void trackDependency(DependencyNode node) {
            dependentNodes = new THashSet<Reference<DependencyNode>>();
        }
        dependentNodes.add(node.getSelfReference());
    }

    @Override
     */
    private Set<Reference<DependencyNode>> dependentNodes;

    private Reference<DependencyNode> selfReference;

    public ByteInlineDependencyCache(Object owner, ByteCalculatable calculable, MutableStatistics statistics) {
public synchronized void trackDependency(DependencyNode node) {
            dependentNodes = new THashSet<Reference<DependencyNode>>();
        }
        dependentNodes.add(node.getSelfReference());
    }

    @Override
     */
    private Set<Reference<DependencyNode>> dependentNodes;

    private Reference<DependencyNode> selfReference;

    public CharacterInlineDependencyCache(Object owner, CharacterCalculatable calculable, MutableStatistics statistics) {
public synchronized void trackDependency(DependencyNode node) {
            dependentNodes = new THashSet<Reference<DependencyNode>>();
        }
        dependentNodes.add(node.getSelfReference());
    }

    @Override
     */
    private Set<Reference<DependencyNode>> dependentNodes;

    private Reference<DependencyNode> selfReference;

    public DoubleInlineDependencyCache(Object owner, DoubleCalculatable calculable, MutableStatistics statistics) {
public synchronized void trackDependency(DependencyNode node) {
            dependentNodes = new THashSet<Reference<DependencyNode>>();
        }
        dependentNodes.add(node.getSelfReference());
    }

    @Override
     */
    private Set<Reference<DependencyNode>> dependentNodes;

    private Reference<DependencyNode> selfReference;

    public FloatInlineDependencyCache(Object owner, FloatCalculatable calculable, MutableStatistics statistics) {
public synchronized void trackDependency(DependencyNode node) {
            dependentNodes = new THashSet<Reference<DependencyNode>>();
        }
        dependentNodes.add(node.getSelfReference());
    }

    @Override
     */
    private Set<Reference<DependencyNode>> dependentNodes;

    private Reference<DependencyNode> selfReference;

    public IntInlineDependencyCache(Object owner, IntCalculatable calculable, MutableStatistics statistics) {
public synchronized void trackDependency(DependencyNode node) {
            dependentNodes = new THashSet<Reference<DependencyNode>>();
        }
        dependentNodes.add(node.getSelfReference());
    }

    @Override
     */
    private Set<Reference<DependencyNode>> dependentNodes;

    private Reference<DependencyNode> selfReference;

    public LongInlineDependencyCache(Object owner, LongCalculatable calculable, MutableStatistics statistics) {
public synchronized void trackDependency(DependencyNode node) {
            dependentNodes = new THashSet<Reference<DependencyNode>>();
        }
        dependentNodes.add(node.getSelfReference());
    }

    @Override
     */
    private Set<Reference<DependencyNode>> dependentNodes;

    private Reference<DependencyNode> selfReference;

    public ObjectInlineDependencyCache(Object owner, ObjectCalculatable calculable, MutableStatistics statistics) {
public synchronized void trackDependency(DependencyNode node) {
            dependentNodes = new THashSet<Reference<DependencyNode>>();
        }
        dependentNodes.add(node.getSelfReference());
    }

    @Override
     */
    private Set<Reference<DependencyNode>> dependentNodes;

    private Reference<DependencyNode> selfReference;

    public ShortInlineDependencyCache(Object owner, ShortCalculatable calculable, MutableStatistics statistics) {
public synchronized void trackDependency(DependencyNode node) {
            dependentNodes = new THashSet<Reference<DependencyNode>>();
        }
        dependentNodes.add(node.getSelfReference());
    }

    @Override
     */
    private Set<Reference<DependencyNode>> dependentNodes;

    private Reference<DependencyNode> selfReference;

    @Override
public synchronized int getApproxSize() {
    @Override
    public synchronized void trackDependency(DependencyNode node) {
        if (dependentNodes == null) {
            dependentNodes = new THashSet<Reference<DependencyNode>>();
        }
        dependentNodes.add(node.getSelfReference());
    }

    protected static boolean equal(@Nullable Object a, @Nullable Object b) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public int compare(final SortedTripleFileFacade o1, final SortedTripleFileFacade
				}
			}
		}
	}

	protected void onFinished() {
 */
package org.culturegraph.mf.stream.pipe.sort;

import org.culturegraph.mf.types.Triple;
import org.junit.Before;
import org.junit.Test;
public void shouldNotFailIfFlushingBeforeFirstRecord() {
		tripleSort.closeStream();
	}

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import com.aldebaran.proxy.ALVideoDeviceProxy;
import com.aldebaran.proxy.Variant;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.builder.LoggingErrorHandlerBuilder;
import org.apache.camel.builder.RouteBuilder;
import org.apache.commons.codec.binary.Base64;
import org.apache.commons.io.HexDump;
import org.bytedeco.javacpp.BytePointer;
import org.bytedeco.javacpp.opencv_core;
import org.bytedeco.javacpp.opencv_highgui;
import org.bytedeco.javacpp.opencv_imgproc;
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.lskk.lumen.core.ImageObject;
import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;

/**
 * Created by ceefour on 10/2/15.
    @Inject
    private ProducerTemplate producer;

    protected byte[] yuv422ToJpg(byte[] topImg) {
        // http://study.marearts.com/2014/12/yuyv-to-rgb-and-rgb-to-yuyv-using.html
        final byte[] topBytes;
        final opencv_core.Mat yuv422Mat = new opencv_core.Mat(naoVideoConfig.getResolution().getHeight(), naoVideoConfig.getResolution().getWidth(),
                opencv_core.CV_8UC2);
        final opencv_core.Mat bgrMat;
        try {
            yuv422Mat.ptr().put(topImg);
            bgrMat = new opencv_core.Mat(naoVideoConfig.getResolution().getHeight(), naoVideoConfig.getResolution().getWidth(),
                    opencv_core.CV_8UC3);
            try {
public void configure() throws Exception {
        errorHandler(new LoggingErrorHandlerBuilder(log));
        final int period = 1000 / naoVideoConfig.getCameraFps();
        log.info("Cameras capture timer with period = {}ms", period);
        from("timer:camera?period=" + period)
                .process(exchange -> {
                    final byte[] topYuv422;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import com.microsoft.applicationinsights.library.ApplicationInsights;
and add 

```java
ApplicationInsights.setup(this, getApplication());
ApplicationInsights.start();
```

android {
It is also possible to set the instrumentation key of your app in code. This will override the one you might have set in your gradle or manifest file. Setting the instrumentation key programmatically can be done while setting up Application Insights:

```java
ApplicationInsights.setup(this, getApplication(), "<YOUR-INSTRUMENTATION-KEY>");
ApplicationInsights.start();
```

The **developer mode** is enabled automatically in case the debugger is attached
You can explicitly enable/disable the developer mode like this:

```java
//do this after ApplicationInsights.setup(this, getApplication())
//and before ApplicationInsights.start()

ApplicationInsights.setDeveloperMode(false);
client.trackEvent("sample event", properties);

## <a name="7"></a>7. Automatic collection of life-cycle events (Sessions & Page Views)

This only works in Android SDK version 15 and up (Ice Cream Sandwich+) and is **enabled by default**. Don't forget to set the Application instance when setting up Application Insights (otherwise auto collection will be disabled):

```java
ApplicationInsights.setup(this, getApplication());
ApplicationInsights.setup(this, getApplication());
If you want to explicitly **Disable** automatic collection of life-cycle events (auto session tracking and auto page view tracking), call ```setAutoCollectionDisabled``` inbetween setup and start of Application Insights. 

```java
ApplicationInsights.setup(this);
ApplicationInsights.setAutoCollectionDisabled(true); //disable the auto-collection
ApplicationInsights.start();
```
package com.microsoft.applicationinsights.appsample;

import android.content.Intent;
import android.os.Bundle;
import android.support.v4.app.FragmentActivity;
protected void onCreate(Bundle savedInstanceState) {
                    .findFragmentById(R.id.item_list))
                    .setActivateOnItemClick(true);
        }
        ApplicationInsights.setup(this, getApplication());

        //ApplicationInsightsConfig config = ApplicationInsights.getConfig();
        //config.setSessionIntervalMs(30000);
public void tearDown() throws Exception {
    }

    public void testRegisterExceptionHandler() throws Exception {
        ExceptionTracking.registerExceptionHandler(this.getActivity());
        Thread.UncaughtExceptionHandler handler =
                Thread.getDefaultUncaughtExceptionHandler();
        Assert.assertNotNull("handler is set", handler);
        Assert.assertEquals("handler is of correct type", ExceptionTracking.class, handler.getClass());

        // double register without debug mode
        ApplicationInsights.setDeveloperMode(false);
        ExceptionTracking.registerExceptionHandler(this.getActivity());
        Assert.assertTrue("no exception for multiple registration without debug mode", true);

        // double register with debug mode and verify runtime exception
        ApplicationInsights.setDeveloperMode(true);
        RuntimeException exception = null;
        try {
            ExceptionTracking.registerExceptionHandler(this.getActivity());
        } catch (RuntimeException e) {
            exception = e;
        }
    public MockExceptionTracking(Context context,
                                 Thread.UncaughtExceptionHandler preexistingExceptionHandler,
                                 boolean ignoreDefaultHandler) {
        super(context, preexistingExceptionHandler, ignoreDefaultHandler);
        this.processKillCount = 0;
    }

public void testRegister() throws Exception {
    //TODO test at applicable location
//    public void testGetContext() throws Exception {
//        TelemetryClient client = TelemetryClient.getInstance();
//        Assert.assertNotNull("context is initialized", client.getContext());
//    }

    //TODO test at applicable location
import com.microsoft.applicationinsights.library.config.ApplicationInsightsConfig;
import com.microsoft.applicationinsights.logging.InternalLogging;

import java.util.Map;

public enum ApplicationInsights {
    private String instrumentationKey;

    /**
     * The context which contains additional information for the telemetry data sent out.
     */
    private TelemetryContext telemetryContext;

    private String userId;

    /**
     * The context associated with Application Insights.
     */
    private Context context;

    /**
     * The application needed for auto collecting telemetry data
     * Configure Application Insights
     * Note: This should be called before start
     *
     * @param context the context associated with Application Insights
     */
    public static void setup(Context context) {
        ApplicationInsights.INSTANCE.setupInstance(context, null, null);
public static void setup(Context context) {
     * Configure Application Insights
     * Note: This should be called before start
     *
     * @param context     the context associated with Application Insights
     * @param application the application needed for auto collecting telemetry data
     */
    public static void setup(Context context, Application application) {
        ApplicationInsights.INSTANCE.setupInstance(context, application, null);
public static void setup(Context context, Application application) {
     * Configure Application Insights
     * Note: This should be called before start
     *
     * @param context            the context associated with Application Insights
     * @param instrumentationKey the instrumentation key associated with the app
     */
    public static void setup(Context context, String instrumentationKey) {
public static void setup(Context context, String instrumentationKey) {
     * Configure Application Insights
     * Note: This should be called before start
     *
     * @param context            the context associated with Application Insights
     * @param application        the application needed for auto collecting telemetry data
     * @param instrumentationKey the instrumentation key associated with the app
     */
public static void setup(Context context, Application application, String instru
     * Configure Application Insights
     * Note: This should be called before start
     *
     * @param context            the context associated with Application Insights
     * @param instrumentationKey the instrumentation key associated with the app
     */
    public void setupInstance(Context context, Application application, String instrumentationKey) {
        if (!isSetup) {
            if (context != null) {
                this.context = context;
                this.instrumentationKey = instrumentationKey;
                this.application = application;
                isSetup = true;
                InternalLogging.info(TAG, "ApplicationInsights has been setup correctly.", null);
            } else {
                InternalLogging.warn(TAG, "ApplicationInsights could not be setup correctly " +
                      "because the given context was null");
            }
        }

public static void start() {
     */
    public void startInstance() {
        if (!isSetup) {
            InternalLogging.warn(TAG, "Could not start ApplicationInsight since it has not been " +
                  "setup correctly.");
            return;
        }
        if (!isRunning) {

            if (this.instrumentationKey == null) {
                this.instrumentationKey = readInstrumentationKey(this.context);
            }

            this.telemetryContext = new TelemetryContext(this.context, this.instrumentationKey, userId);
            EnvelopeFactory.INSTANCE.configure(telemetryContext, this.commonProperties);

            Persistence.initialize(this.context);
            Sender.initialize(this.config);
            Channel.initialize(this.config);

public void startInstance() {

            // Start crash reporting
            if (!this.exceptionTrackingDisabled) {
                ExceptionTracking.registerExceptionHandler(this.context);
            }

            isRunning = true;
public static boolean isDeveloperMode() {
    /**
     * Reads the instrumentation key from AndroidManifest.xml if it is available
     *
     * @param context the application context to check the manifest from
     * @return the instrumentation key configured for the application
     */
    private String readInstrumentationKey(Context context) {
private String readInstrumentationKey(Context context) {
    }

    /**
     * Returns the application context that Application Insights uses.
     *
     * @return context the Context that's used by the Application Insights SDK
     */
    public Context getContext() {
        return this.context;
    }


    /* Writes instructions on how to configure the instrumentation key.
        */
package com.microsoft.applicationinsights.library;

import android.content.Context;

import com.microsoft.applicationinsights.logging.InternalLogging;

import java.lang.Thread.UncaughtExceptionHandler;
    /**
     * Constructs a new instance of the ExceptionTracking class
     *
     * @param context                     The context associated with this tracker
     * @param preexistingExceptionHandler the pre-existing exception handler
     * @param ignoreDefaultHandler        indicates that the pre-existing handler should be ignored
     */
    protected ExceptionTracking(Context context,
                                UncaughtExceptionHandler preexistingExceptionHandler,
                                boolean ignoreDefaultHandler) {
        this.preexistingExceptionHandler = preexistingExceptionHandler;
        if (context != null) {
            this.ignoreDefaultHandler = ignoreDefaultHandler;
        } else {
            InternalLogging.error(TAG, "Failed to initialize ExceptionHandler because the provided Context was null");
        }
    }

    /**
     * Registers the application insights exception handler to track uncaught exceptions
     * {@code ignoreDefaulthandler} defaults to {@literal false}
     *
     * @param context the context associated with uncaught exceptions
     */
    protected static void registerExceptionHandler(Context context) {
        ExceptionTracking.registerExceptionHandler(context, false);
    }

    /**
     * Registers the application insights exception handler to track uncaught exceptions
     *
     * @param context              the context associated with uncaught exceptions
     * @param ignoreDefaultHandler if true the default exception handler will be ignored
     */
    protected static void registerExceptionHandler(Context context, boolean ignoreDefaultHandler) {
        synchronized (ExceptionTracking.LOCK) {
            UncaughtExceptionHandler preexistingExceptionHandler =
                  Thread.getDefaultUncaughtExceptionHandler();
protected static void registerExceptionHandler(Context context, boolean ignoreDe
                      "ExceptionHandler was already registered for this thread");
            } else {
                ExceptionTracking handler = new ExceptionTracking(
                      context,
                      preexistingExceptionHandler,
                      ignoreDefaultHandler);

protected int runningRequestCount() {
    }

    /**
     * Handler for the http response from the sender
     *
     * @param connection   a connection containing a response
     * @param responseCode the response code from the connection
    /**
     * Constructs a new INSTANCE of the Telemetry telemetryContext tag keys
     *
     * @param appContext the context for this telemetryContext
     */
    public TelemetryContext(Context appContext, String instrumentationKey, String userId) {


        // get an INSTANCE of the shared preferences manager for persistent context fields
        this.settings = appContext.getSharedPreferences(SHARED_PREFERENCES_KEY, Context.MODE_PRIVATE);
        this.operation = new Operation();
        this.device = new Device();
        configDeviceContext(appContext);
        this.session = new Session();
        configSessionContext();
        this.user = new User();
        configUserContext(userId);
        this.internal = new Internal();
        configInternalContext(appContext);
        this.application = new Application();
        configAppContext(appContext);

        this.lastSessionId = null;
        this.instrumentationKey = instrumentationKey;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
package org.gdg.frisbee.android.fragment;

import android.content.Context;
import android.support.v4.widget.SwipeRefreshLayout;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.support.v7.widget.StaggeredGridLayoutManager;
import android.view.View;
import android.view.ViewGroup;

import timber.log.Timber;

/**
 */
public class SwipeRefreshRecyclerViewFragment extends GdgRecyclerFragment {

    private SwipeRefreshLayout mSwipeRefreshLayout;

    public View createSwipeRefresh(final View listFragmentView) {

public View createSwipeRefresh(final View listFragmentView) {
        return mSwipeRefreshLayout;
    }

    /**
     * Set the {@link android.support.v4.widget.SwipeRefreshLayout.OnRefreshListener} to listen for
     * initiated refreshes.
public SwipeRefreshLayout getSwipeRefreshLayout() {
     * override the default behavior and properly signal when a gesture is possible. This is done by
     * overriding {@link #canChildScrollUp()}.
     */
    private class ListFragmentSwipeRefreshLayout extends SwipeRefreshLayout {

        public ListFragmentSwipeRefreshLayout(Context context) {
            super(context);
        }

        /**
         * As mentioned above, we need to override this method to properly signal when a
         * 'swipe-to-refresh' is possible.
public ListFragmentSwipeRefreshLayout(Context context) {
         */
        @Override
        public boolean canChildScrollUp() {
            final RecyclerView recyclerView = getListView();
            return recyclerView.getVisibility() == View.VISIBLE && canListViewScrollUp(recyclerView);
        }

    }
    /**
     * Utility method to check whether a {@link android.widget.ListView} can scroll up from it's current position.
     * Handles platform version differences, providing backwards compatible functionality where
     * needed.
     */
    private static boolean canListViewScrollUp(RecyclerView recyclerView) {
        try {
            RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager();
            if (layoutManager instanceof LinearLayoutManager) {
                int position = ((LinearLayoutManager) layoutManager).findFirstCompletelyVisibleItemPosition();
                return position != 0;
            } else if (layoutManager instanceof StaggeredGridLayoutManager) {
                int[] positions = ((StaggeredGridLayoutManager) layoutManager).findFirstCompletelyVisibleItemPositions(null);
                for (int i = 0; i < positions.length; i++) {
                    if (positions[i] == 0) {
                        return false;
                    }
                }
            }
        } catch (NullPointerException exception) {
            Timber.e(exception, "Exception in RecyclerView canListViewScrollUp.");
        }
        return true;
    }

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
package org.ehcache.clustered.client.internal.store;

import org.ehcache.clustered.client.internal.EhcacheClientEntity;
import org.ehcache.clustered.common.internal.messages.EhcacheEntityResponse;
import org.ehcache.clustered.common.internal.messages.ServerStoreMessageFactory;
import org.ehcache.clustered.common.internal.store.Chain;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.nio.ByteBuffer;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.TimeoutException;

/**
 * @author Ludovic Orban
 */
public class EventualServerStoreProxy implements ServerStoreProxy {

  private static final Logger LOGGER = LoggerFactory.getLogger(EventualServerStoreProxy.class);

  private final ServerStoreProxy delegate;
  private final List<InvalidationListener> invalidationListeners = new CopyOnWriteArrayList<InvalidationListener>();
  private final EhcacheClientEntity entity;
  private final Map<Class<? extends EhcacheEntityResponse>, EhcacheClientEntity.ResponseListener<? extends EhcacheEntityResponse>> responseListeners
    = new ConcurrentHashMap<Class<? extends EhcacheEntityResponse>, EhcacheClientEntity.ResponseListener<? extends EhcacheEntityResponse>>();

  @SuppressWarnings("unchecked")
  public EventualServerStoreProxy(final ServerStoreMessageFactory messageFactory, final EhcacheClientEntity entity) {
    this.entity = entity;
    this.delegate = new NoInvalidationServerStoreProxy(messageFactory, entity);
    this.responseListeners.put(EhcacheEntityResponse.ServerInvalidateHash.class, new EhcacheClientEntity.ResponseListener<EhcacheEntityResponse.ServerInvalidateHash>() {
      @Override
      public void onResponse(EhcacheEntityResponse.ServerInvalidateHash response) {
        if (response.getCacheId().equals(messageFactory.getCacheId())) {
          long key = response.getKey();
          LOGGER.debug("CLIENT: on cache {}, server requesting hash {} to be invalidated", messageFactory.getCacheId(), key);
          for (InvalidationListener listener : invalidationListeners) {
            listener.onInvalidateHash(key);
          }
        } else {
          LOGGER.debug("CLIENT: on cache {}, ignoring invalidation on unrelated cache : {}", messageFactory.getCacheId(), response.getCacheId());
        }
      }
    });
    this.responseListeners.put(EhcacheEntityResponse.ClientInvalidateHash.class, new EhcacheClientEntity.ResponseListener<EhcacheEntityResponse.ClientInvalidateHash>() {
        @Override
        public void onResponse(EhcacheEntityResponse.ClientInvalidateHash response) {
          final String cacheId = response.getCacheId();
          final long key = response.getKey();
          final int invalidationId = response.getInvalidationId();

          if (cacheId.equals(messageFactory.getCacheId())) {
            LOGGER.debug("CLIENT: doing work to invalidate hash {} from cache {} (ID {})", key, cacheId, invalidationId);
            for (InvalidationListener listener : invalidationListeners) {
              listener.onInvalidateHash(key);
            }
          } else {
          LOGGER.debug("CLIENT: on cache {}, ignoring invalidation on unrelated cache : {}", messageFactory.getCacheId(), response.getCacheId());
          }
        }
    });
    this.responseListeners.put(EhcacheEntityResponse.ClientInvalidateAll.class, new EhcacheClientEntity.ResponseListener<EhcacheEntityResponse.ClientInvalidateAll>() {
        @Override
        public void onResponse(EhcacheEntityResponse.ClientInvalidateAll response) {
          final String cacheId = response.getCacheId();
          final int invalidationId = response.getInvalidationId();

          if (cacheId.equals(messageFactory.getCacheId())) {
            LOGGER.debug("CLIENT: doing work to invalidate all from cache {} (ID {})", cacheId, invalidationId);
            for (InvalidationListener listener : invalidationListeners) {
              listener.onInvalidateAll();
            }
          } else {
          LOGGER.debug("CLIENT: on cache {}, ignoring invalidation on unrelated cache : {}", messageFactory.getCacheId(), response.getCacheId());
          }
        }
    });

    for (Map.Entry<Class<? extends EhcacheEntityResponse>, EhcacheClientEntity.ResponseListener<? extends EhcacheEntityResponse>> classResponseListenerEntry :
      this.responseListeners.entrySet()) {
      this.entity.addResponseListener(classResponseListenerEntry.getKey(), (EhcacheClientEntity.ResponseListener) classResponseListenerEntry.getValue());
    }

  }

  @Override
public String getCacheId() {

  @Override
  public void addInvalidationListener(InvalidationListener listener) {
    invalidationListeners.add(listener);
  }

  @Override
  public boolean removeInvalidationListener(InvalidationListener listener) {
    return invalidationListeners.remove(listener);
  }

  @SuppressWarnings("unchecked")
  @Override
  public void close() {
    for (Map.Entry<Class<? extends EhcacheEntityResponse>, EhcacheClientEntity.ResponseListener<? extends EhcacheEntityResponse>> classResponseListenerEntry :
      this.responseListeners.entrySet()) {
      this.entity.removeResponseListener(classResponseListenerEntry.getKey(), (EhcacheClientEntity.ResponseListener) classResponseListenerEntry.getValue());
    }
  }

  @Override
/*
 * Copyright Terracotta, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.ehcache.clustered.client.internal.store;

import org.ehcache.clustered.client.internal.EhcacheClientEntity;
import org.ehcache.clustered.common.internal.messages.EhcacheEntityResponse;
import org.ehcache.clustered.common.internal.messages.ServerStoreMessageFactory;
import org.ehcache.clustered.common.internal.store.Chain;

import java.nio.ByteBuffer;
import java.util.concurrent.TimeoutException;

/**
 * Provides client-side access to the services of a {@code ServerStore}.
 */
class NoInvalidationServerStoreProxy implements ServerStoreProxy {

  private final ServerStoreMessageFactory messageFactory;
  private final EhcacheClientEntity entity;

  NoInvalidationServerStoreProxy(ServerStoreMessageFactory messageFactory, final EhcacheClientEntity entity) {
    this.messageFactory = messageFactory;
    this.entity = entity;
  }

  @Override
  public String getCacheId() {
    return messageFactory.getCacheId();
  }

  @Override
  public void addInvalidationListener(InvalidationListener listener) {
    throw new UnsupportedOperationException();
  }

  @Override
  public boolean removeInvalidationListener(InvalidationListener listener) {
    throw new UnsupportedOperationException();
  }

  @Override
  public void close() {
    // No-op
  }

  @Override
  public Chain get(long key) throws TimeoutException {
    EhcacheEntityResponse response;
    try {
      response = entity.invoke(messageFactory.getOperation(key), false);
    } catch (TimeoutException e) {
      throw e;
    } catch (Exception e) {
      throw new ServerStoreProxyException(e);
    }
    if (response != null && response.getType() == EhcacheEntityResponse.Type.GET_RESPONSE) {
      return ((EhcacheEntityResponse.GetResponse)response).getChain();
    } else {
      throw new ServerStoreProxyException("Response for get operation was invalid : " +
                                          (response != null ? response.getType().toString() : "null message"));
    }
  }

  @Override
  public void append(long key, ByteBuffer payLoad) throws TimeoutException {
    try {
      entity.invoke(messageFactory.appendOperation(key, payLoad), true);
    } catch (TimeoutException e) {
      throw e;
    } catch (Exception e) {
      throw new ServerStoreProxyException(e);
    }
  }

  @Override
  public Chain getAndAppend(long key, ByteBuffer payLoad) throws TimeoutException {
    EhcacheEntityResponse response;
    try {
      response = entity.invoke(messageFactory.getAndAppendOperation(key, payLoad), true);
    } catch (TimeoutException e) {
      throw e;
    } catch (Exception e) {
      throw new ServerStoreProxyException(e);
    }
    if (response != null && response.getType() == EhcacheEntityResponse.Type.GET_RESPONSE) {
      return ((EhcacheEntityResponse.GetResponse)response).getChain();
    } else {
      throw new ServerStoreProxyException("Response for getAndAppend operation was invalid : " +
                                          (response != null ? response.getType().toString() : "null message"));
    }
  }

  @Override
  public void replaceAtHead(long key, Chain expect, Chain update) {
    // TODO: Optimize this method to just send sequences for expect Chain
    try {
      entity.invokeAsync(messageFactory.replaceAtHeadOperation(key, expect, update), true);
    } catch (Exception e) {
      throw new ServerStoreProxyException(e);
    }
  }

  @Override
  public void clear() throws TimeoutException {
    try {
      entity.invoke(messageFactory.clearOperation(), true);
    } catch (TimeoutException e) {
      throw e;
    } catch (Exception e) {
      throw new ServerStoreProxyException(e);
    }
  }
}
import org.slf4j.LoggerFactory;

import java.nio.ByteBuffer;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

  private static final Logger LOGGER = LoggerFactory.getLogger(StrongServerStoreProxy.class);

  private final ServerStoreProxy delegate;
  private final ConcurrentMap<Long, CountDownLatch> hashInvalidationsInProgress = new ConcurrentHashMap<Long, CountDownLatch>();
  private final Lock invalidateAllLock = new ReentrantLock();
  private volatile CountDownLatch invalidateAllLatch;
  private final List<InvalidationListener> invalidationListeners = new CopyOnWriteArrayList<InvalidationListener>();
  private final Map<Class<? extends EhcacheEntityResponse>, EhcacheClientEntity.ResponseListener<? extends EhcacheEntityResponse>> responseListeners
    = new ConcurrentHashMap<Class<? extends EhcacheEntityResponse>, EhcacheClientEntity.ResponseListener<? extends EhcacheEntityResponse>>();
  private final EhcacheClientEntity entity;
  private final EhcacheClientEntity.ReconnectListener reconnectListener;
  private final EhcacheClientEntity.DisconnectionListener disconnectionListener;

  @SuppressWarnings("unchecked")
  public StrongServerStoreProxy(final ServerStoreMessageFactory messageFactory, final EhcacheClientEntity entity) {
    this.delegate = new NoInvalidationServerStoreProxy(messageFactory, entity);
    this.entity = entity;
    this.reconnectListener = new EhcacheClientEntity.ReconnectListener() {
      @Override
public void onHandleReconnect(ReconnectMessage reconnectMessage) {
    };
    entity.addReconnectListener(reconnectListener);

    this.responseListeners.put(EhcacheEntityResponse.HashInvalidationDone.class, new EhcacheClientEntity.ResponseListener<EhcacheEntityResponse.HashInvalidationDone>() {
      @Override
      public void onResponse(EhcacheEntityResponse.HashInvalidationDone response) {
        if (response.getCacheId().equals(messageFactory.getCacheId())) {
public void onResponse(EhcacheEntityResponse.HashInvalidationDone response) {
        }
      }
    });
    this.responseListeners.put(EhcacheEntityResponse.AllInvalidationDone.class, new EhcacheClientEntity.ResponseListener<EhcacheEntityResponse.AllInvalidationDone>() {
      @Override
      public void onResponse(EhcacheEntityResponse.AllInvalidationDone response) {
        if (response.getCacheId().equals(messageFactory.getCacheId())) {
public void onResponse(EhcacheEntityResponse.AllInvalidationDone response) {
        }
      }
    });
    this.responseListeners.put(EhcacheEntityResponse.ServerInvalidateHash.class, new EhcacheClientEntity.ResponseListener<EhcacheEntityResponse.ServerInvalidateHash>() {
      @Override
      public void onResponse(EhcacheEntityResponse.ServerInvalidateHash response) {
        if (response.getCacheId().equals(messageFactory.getCacheId())) {
          long key = response.getKey();
          LOGGER.debug("CLIENT: on cache {}, server requesting hash {} to be invalidated", messageFactory.getCacheId(), key);
          for (InvalidationListener listener : invalidationListeners) {
            listener.onInvalidateHash(key);
          }
        } else {
          LOGGER.debug("CLIENT: on cache {}, ignoring invalidation on unrelated cache : {}", messageFactory.getCacheId(), response.getCacheId());
        }
      }
    });
    this.responseListeners.put(EhcacheEntityResponse.ClientInvalidateHash.class, new EhcacheClientEntity.ResponseListener<EhcacheEntityResponse.ClientInvalidateHash>() {
      @Override
      public void onResponse(EhcacheEntityResponse.ClientInvalidateHash response) {
        final String cacheId = response.getCacheId();
        final long key = response.getKey();
        final int invalidationId = response.getInvalidationId();

        if (cacheId.equals(messageFactory.getCacheId())) {
          LOGGER.debug("CLIENT: doing work to invalidate hash {} from cache {} (ID {})", key, cacheId, invalidationId);
          for (InvalidationListener listener : invalidationListeners) {
            listener.onInvalidateHash(key);
          }

          try {
            LOGGER.debug("CLIENT: ack'ing invalidation of hash {} from cache {} (ID {})", key, cacheId, invalidationId);
            entity.invokeAsync(messageFactory.clientInvalidationAck(invalidationId), false);
          } catch (Exception e) {
            //TODO: what should be done here?
            LOGGER.error("error acking client invalidation of hash {} on cache {}", key, cacheId, e);
          }
        } else {
          LOGGER.debug("CLIENT: on cache {}, ignoring invalidation on unrelated cache : {}", messageFactory.getCacheId(), response.getCacheId());
        }
      }
    });
    this.responseListeners.put(EhcacheEntityResponse.ClientInvalidateAll.class, new EhcacheClientEntity.ResponseListener<EhcacheEntityResponse.ClientInvalidateAll>() {
      @Override
      public void onResponse(EhcacheEntityResponse.ClientInvalidateAll response) {
        final String cacheId = response.getCacheId();
        final int invalidationId = response.getInvalidationId();

        if (cacheId.equals(messageFactory.getCacheId())) {
          LOGGER.debug("CLIENT: doing work to invalidate all from cache {} (ID {})", cacheId, invalidationId);
          for (InvalidationListener listener : invalidationListeners) {
            listener.onInvalidateAll();
          }

          try {
            LOGGER.debug("CLIENT: ack'ing invalidation of all from cache {} (ID {})", cacheId, invalidationId);
            entity.invokeAsync(messageFactory.clientInvalidationAck(invalidationId), false);
          } catch (Exception e) {
            //TODO: what should be done here?
            LOGGER.error("error acking client invalidation of all on cache {}", cacheId, e);
          }
        } else {
          LOGGER.debug("CLIENT: on cache {}, ignoring invalidation on unrelated cache : {}", messageFactory.getCacheId(), response.getCacheId());
        }
      }
    });

    for (Map.Entry<Class<? extends EhcacheEntityResponse>, EhcacheClientEntity.ResponseListener<? extends EhcacheEntityResponse>> classResponseListenerEntry :
      this.responseListeners.entrySet()) {
      this.entity.addResponseListener(classResponseListenerEntry.getKey(), (EhcacheClientEntity.ResponseListener) classResponseListenerEntry.getValue());
    }

    this.disconnectionListener = new EhcacheClientEntity.DisconnectionListener() {
      @Override
public String getCacheId() {

  @Override
  public void addInvalidationListener(InvalidationListener listener) {
    invalidationListeners.add(listener);
  }

  @Override
  public boolean removeInvalidationListener(InvalidationListener listener) {
    return invalidationListeners.remove(listener);
  }

  @SuppressWarnings("unchecked")
  @Override
  public void close() {
    this.entity.removeDisconnectionListener(this.disconnectionListener);
    this.entity.removeReconnectListener(this.reconnectListener);
    for (Map.Entry<Class<? extends EhcacheEntityResponse>, EhcacheClientEntity.ResponseListener<? extends EhcacheEntityResponse>> classResponseListenerEntry :
      this.responseListeners.entrySet()) {
      this.entity.removeResponseListener(classResponseListenerEntry.getKey(), (EhcacheClientEntity.ResponseListener) classResponseListenerEntry.getValue());
    }
  }

  @Override
public void setup() throws Exception {
    );
    clientEntity.createCache(CACHE_IDENTIFIER, serverStoreConfiguration);
    ServerStoreMessageFactory factory = new ServerStoreMessageFactory(CACHE_IDENTIFIER, clientEntity.getClientId());
    ServerStoreProxy serverStoreProxy = new NoInvalidationServerStoreProxy(factory, clientEntity);

    TestTimeSource testTimeSource = new TestTimeSource();

import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertThat;

public class NoInvalidationServerStoreProxyTest {

  private static final String CACHE_IDENTIFIER = "testCache";
  private static final URI CLUSTER_URI = URI.create("terracotta://localhost:9510");

  private static EhcacheClientEntity clientEntity;
  private static NoInvalidationServerStoreProxy serverStoreProxy;

  @BeforeClass
  public static void setUp() throws Exception {
public static void setUp() throws Exception {
    clientEntity.createCache(CACHE_IDENTIFIER, new ServerStoreConfiguration(resourcePool.getPoolAllocation(), Long.class.getName(),
        Long.class.getName(), Long.class.getName(), Long.class.getName(), LongSerializer.class.getName(), LongSerializer.class
        .getName(), null));
    serverStoreProxy = new NoInvalidationServerStoreProxy(new ServerStoreMessageFactory(CACHE_IDENTIFIER, clientEntity.getClientId()), clientEntity);
  }

  @AfterClass
import org.ehcache.clustered.client.config.builders.ClusteredResourcePoolBuilder;
import org.ehcache.clustered.client.internal.EhcacheClientEntity;
import org.ehcache.clustered.client.internal.EhcacheClientEntityFactory;
import org.ehcache.clustered.client.internal.UnitTestConnectionService;
import org.ehcache.clustered.client.internal.UnitTestConnectionService.PassthroughServerBuilder;
import org.ehcache.clustered.common.Consistency;
import org.ehcache.clustered.common.ServerSideConfiguration;
import org.ehcache.clustered.common.internal.ServerStoreConfiguration;
import org.ehcache.clustered.common.internal.messages.ServerStoreMessageFactory;
import org.ehcache.clustered.common.internal.store.Chain;
import org.ehcache.config.units.MemoryUnit;
import org.ehcache.impl.serialization.LongSerializer;
import org.junit.AfterClass;
import java.util.Collections;
import java.util.List;
import java.util.Properties;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
  private static EhcacheClientEntity clientEntity2;
  private static EventualServerStoreProxy serverStoreProxy1;
  private static EventualServerStoreProxy serverStoreProxy2;

  @BeforeClass
  public static void setUp() throws Exception {
    UnitTestConnectionService.add(CLUSTER_URI,
        new PassthroughServerBuilder()
            .resource("defaultResource", 128, MemoryUnit.MB)
            .build());
    UnitTestConnectionService unitTestConnectionService = new UnitTestConnectionService();
public static void setUp() throws Exception {

    ServerStoreConfiguration serverStoreConfiguration = new ServerStoreConfiguration(resourcePool.getPoolAllocation(), Long.class.getName(),
        Long.class.getName(), Long.class.getName(), Long.class.getName(), LongSerializer.class.getName(), LongSerializer.class
        .getName(), Consistency.STRONG);
    clientEntity1.createCache(CACHE_IDENTIFIER, serverStoreConfiguration);

    // required to attach the store to the client
public void onInvalidateAll() {
    // test that each time the server evicted, the other client got notified on top of normal invalidations
    assertThat(store2InvalidatedHashes.size(), is(ITERATIONS + evictionCount));

    serverStoreProxy1.removeInvalidationListener(listener1);
    serverStoreProxy2.removeInvalidationListener(listener2);
  }
public void onInvalidateAll() {

    latch.await(5, TimeUnit.SECONDS);
    assertThat(invalidatedHash.get(), is(1L));
    serverStoreProxy1.removeInvalidationListener(listener);
  }

public void onInvalidateAll() {

    latch.await(5, TimeUnit.SECONDS);
    assertThat(invalidatedHash.get(), is(1L));
    serverStoreProxy1.removeInvalidationListener(listener);
  }

public void onInvalidateAll() {

    latch.await(5, TimeUnit.SECONDS);
    assertThat(invalidatedAll.get(), is(true));
    serverStoreProxy1.removeInvalidationListener(listener);
  }

}
public String getDefaultServerResource() {
    public Set<String> getDedicatedResourcePoolIds() {
      return ehcacheStateService.getDedicatedResourcePoolIds();
    }
  }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.FileAlreadyExistsException;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import static fr.pilato.elasticsearch.crawler.fs.tika.TikaDocParser.generate;
import static fr.pilato.elasticsearch.crawler.fs.util.FsCrawlerUtil.extractMajorVersionNumber;
import static fr.pilato.elasticsearch.crawler.fs.util.FsCrawlerUtil.moveLegacyResource;

/**
 * @author dadoonet (David Pilato)
private void addFilesRecursively(FileAbstractor path, String filepath, Instant l
                            if (lastScanDate == null
                                    || child.lastModifiedDate.isAfter(lastScanDate)
                                    || (child.creationDate != null && child.creationDate.isAfter(lastScanDate))) {
                                indexFile(child, stats, filepath, path.getInputStream(child));
                                stats.addFile();
                            } else {
                                logger.debug("    - not modified: creation date {} , file date {}, last scan date {}",
private String getName(Object nameObject) {
        /**
         * Index a file
         */
        private void indexFile(FileAbstractModel fileAbstractModel, ScanStatistic stats, String filepath, InputStream fileReader) throws Exception {
            final String filename = fileAbstractModel.name;
            final Instant lastmodified = fileAbstractModel.lastModifiedDate;
            final long size = fileAbstractModel.size;
private void indexFile(FileAbstractModel fileAbstractModel, ScanStatistic stats,
            // Attributes

            if (fsSettings.getFs().isIndexContent()) {
                byte[] buffer = new byte[1024];
                ByteArrayOutputStream bos = new ByteArrayOutputStream();
                int i;
                while (-1 != (i = fileReader.read(buffer))) {
                    bos.write(buffer, 0, i);
                }
                byte[] data = bos.toByteArray();

                fileReader.close();
                bos.close();

                // https://github.com/dadoonet/fscrawler/issues/5 : Support JSon files
                if (fsSettings.getFs().isJsonSupport()) {
                    String id;
private void indexFile(FileAbstractModel fileAbstractModel, ScanStatistic stats,
                    } else {
                        id = SignTool.sign((new File(filepath, filename)).toString());
                    }
                    esIndex(fsSettings.getElasticsearch().getIndex(),
                            fsSettings.getElasticsearch().getType(),
                            id,
                            new String(data, "UTF-8"));
                    return;
                } else {
                    // Extracting content with Tika
                    generate(fsSettings, data, filename, doc, messageDigest);
                }
            }

private void indexFile(FileAbstractModel fileAbstractModel, ScanStatistic stats,
                    doc);
        }

        private void indexDirectory(String id, String name, String root, String virtual, String encoded)
                throws Exception {


import fr.pilato.elasticsearch.crawler.fs.meta.doc.Doc;
import fr.pilato.elasticsearch.crawler.fs.meta.settings.FsSettings;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.tika.metadata.Metadata;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.util.ArrayList;

    private final static Logger logger = LogManager.getLogger(TikaDocParser.class);

    public static void generate(FsSettings fsSettings, byte[] data, String filename, Doc doc, MessageDigest messageDigest) throws UnsupportedEncodingException {
        // Extracting content with Tika
        // See #38: https://github.com/dadoonet/fscrawler/issues/38
        int indexedChars = 100000;
        if (fsSettings.getFs().getIndexedChars() != null) {
            if (fsSettings.getFs().getIndexedChars().percentage()) {
                indexedChars = (int) Math.round(data.length * fsSettings.getFs().getIndexedChars().asDouble());
                logger.trace("using percentage [{}] to define indexed chars: [{}]",
                        fsSettings.getFs().getIndexedChars(), indexedChars);
            } else {
public static void generate(FsSettings fsSettings, byte[] data, String filename,
        Metadata metadata = new Metadata();

        String parsedContent = null;
        InputStream dataStream = new ByteArrayInputStream(data);
        DigestInputStream dis = null;

        if (messageDigest != null) {
            logger.trace("Generating hash with [{}]", messageDigest.getAlgorithm());
            dis = new DigestInputStream(dataStream, messageDigest);
            dataStream = dis;
        }

        try {
            // Set the maximum length of strings returned by the parseToString method, -1 sets no limit
            parsedContent = tika().parseToString(dataStream, metadata, indexedChars);
        } catch (Throwable e) {
            logger.debug("Failed to extract [" + indexedChars + "] characters of text for [" + filename + "]", e);
        }
public static void generate(FsSettings fsSettings, byte[] data, String filename,

        // Doc as binary attachment
        if (fsSettings.getFs().isStoreSource()) {
            doc.setAttachment(new String(Base64.getEncoder().encode(data), "UTF-8"));
        }
        // End of our document
    }

 *
 * You can run one by launching:
 * bin/elasticsearch -Des.http.port=9400
 *
 * The node can be run manually or when using maven, it's automatically started as
 * during the pre-integration phase and stopped after the tests.
public static SearchResponse countTestHelper(final String indexName, String quer
        final SearchResponse[] response = new SearchResponse[1];

        // We wait up to 5 seconds before considering a failing test
        staticLogger.info("  ---> Waiting up to 5 seconds for {} documents in index {}", expected == null ? "some" : expected, indexName);
        assertThat("We waited for 5 seconds but no document has been added", awaitBusy(() -> {
            long totalHits;

            // Let's search for entries
package fr.pilato.elasticsearch.crawler.fs.test.unit.tika;

import fr.pilato.elasticsearch.crawler.fs.meta.doc.Doc;
import fr.pilato.elasticsearch.crawler.fs.meta.settings.FsSettings;
import fr.pilato.elasticsearch.crawler.fs.test.AbstractFSCrawlerTestCase;
import fr.pilato.elasticsearch.crawler.fs.tika.TikaDocParser;
import org.junit.Test;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Map;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.Matchers.notNullValue;
import static org.hamcrest.Matchers.nullValue;

public class TikaDocParserTest extends AbstractFSCrawlerTestCase {

public void testExtractFromTxt() throws IOException {
        assertThat(raw, hasEntry("X-Parsed-By", "org.apache.tika.parser.DefaultParser"));
        assertThat(raw, hasEntry(is("Content-Encoding"), notNullValue()));
        assertThat(raw, hasEntry(is("Content-Type"), containsString("text/plain")));
    }

    @Test
public void testExtractFromWav() throws IOException {
        assertThat(raw, hasEntry("samplerate", "44100.0"));
    }

    private byte[] getBinaryContent(String filename) throws IOException {
        String url = getUrl("documents", filename);
        Path file = Paths.get(url);
        byte[] data = Files.readAllBytes(file);

        return data;
    }

    private Doc extractFromFileExtension(String extension) throws IOException {
private Doc extractFromFileExtension(String extension) throws IOException {
    }

    private Doc extractFromFile(String filename) throws IOException {
        byte[] data = getBinaryContent(filename);
        Doc doc = new Doc();
        TikaDocParser.generate(
                FsSettings.builder(getCurrentTestName()).build(),
                data,
                filename,
                doc,
                null);

        logger.debug("Generated Content: [{}]", doc.getContent());
        logger.debug("Generated Raw Metadata: [{}]", doc.getMeta().getRaw());
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
package org.graylog2.plugin;

import com.google.common.io.BaseEncoding;
import com.google.common.primitives.Doubles;
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.slf4j.Logger;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.net.Inet4Address;
public static String getSystemInformation() {
     * @return A string containing the decompressed data
     */
    public static String decompressZlib(byte[] compressedData) throws IOException {
        byte[] buffer = new byte[compressedData.length];
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        InflaterInputStream in = new InflaterInputStream(new ByteArrayInputStream(compressedData));
        for (int bytesRead = 0; bytesRead != -1; bytesRead = in.read(buffer)) {
            out.write(buffer, 0, bytesRead);
        }
        return new String(out.toByteArray(), StandardCharsets.UTF_8);
    }

    /**
public static String decompressZlib(byte[] compressedData) throws IOException {
     * @return A string containing the decompressed data
     */
    public static String decompressGzip(byte[] compressedData) throws IOException {
        byte[] buffer = new byte[compressedData.length];
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        GZIPInputStream in = new GZIPInputStream(new ByteArrayInputStream(compressedData));
        for (int bytesRead = 0; bytesRead != -1; bytesRead = in.read(buffer)) {
            out.write(buffer, 0, bytesRead);
        }
        return new String(out.toByteArray(), StandardCharsets.UTF_8);
    }

    /**
/**
 * This file is part of Graylog.
 *
 * Graylog is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Graylog is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Graylog.  If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * ToolsTest.java: Lennart Koopmann <lennart@scopeport.org> | Aug 5, 2010 6:49:52 PM
 */

package org.graylog2;

import com.google.common.collect.Lists;
import org.graylog2.plugin.Tools;
import org.joda.time.DateTime;
import org.junit.Test;

import java.io.ByteArrayOutputStream;
import java.io.EOFException;
import java.io.IOException;
import java.util.Calendar;
import java.util.HashMap;
import java.util.List;
import java.util.zip.Deflater;
import java.util.zip.GZIPOutputStream;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

/**
 * @author lennart
 */
public class ToolsTest {

    @Test
    public void testGetPID() {
        String result = Tools.getPID();
        assertTrue(Integer.parseInt(result) > 0);
    }

    @Test
    public void testGetUTCTimestamp() {

        assertTrue(Tools.getUTCTimestamp() > 0);
    }

    @Test
    public void testGetUTCTimestampWithMilliseconds() {

        assertTrue(Tools.getUTCTimestampWithMilliseconds() > 0.0d);
        assertTrue(Tools.getUTCTimestampWithMilliseconds(Calendar.getInstance().getTimeInMillis()) > 0.0d);
    }

    @Test
    public void testGetLocalHostname() {

        String hostname = Tools.getLocalHostname();

        assertFalse(hostname.isEmpty());
    }

    @Test
    public void testSyslogLevelToReadable() {
        assertEquals(Tools.syslogLevelToReadable(1337), "Invalid");
        assertEquals(Tools.syslogLevelToReadable(0), "Emergency");
        assertEquals(Tools.syslogLevelToReadable(2), "Critical");
        assertEquals(Tools.syslogLevelToReadable(6), "Informational");
    }

    @Test
    public void testSyslogFacilityToReadable() {
        assertEquals(Tools.syslogFacilityToReadable(9001), "Unknown");
        assertEquals(Tools.syslogFacilityToReadable(0), "kernel");
        assertEquals(Tools.syslogFacilityToReadable(11), "FTP");
        assertEquals(Tools.syslogFacilityToReadable(22), "local6");
    }

    @Test
    public void testGetSystemInformation() {
        String result = Tools.getSystemInformation();
        assertTrue(result.trim().length() > 0);
    }

    @Test
    public void testDecompressZlib() throws IOException {

        String testString = "Teststring 123";
        byte[] buffer = new byte[100];
        Deflater deflater = new Deflater();

        deflater.setInput(testString.getBytes());
        deflater.finish();
        deflater.deflate(buffer);
        deflater.end();

        assertEquals(testString, Tools.decompressZlib(buffer));
    }

    @Test
    public void testDecompressGzip() throws IOException {

        String testString = "Teststring 123";

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        GZIPOutputStream gzip = new GZIPOutputStream(out);
        gzip.write(testString.getBytes());
        gzip.close();

        byte[] buffer = out.toByteArray();

        assertEquals(testString, Tools.decompressGzip(buffer));
    }

    @Test(expected = EOFException.class)
    public void testDecompressGzipEmptyInput() throws IOException {

        Tools.decompressGzip(new byte[0]);
    }

    /**
     * ruby-1.9.2-p136 :001 > [Time.now.to_i, 2.days.ago.to_i]
     *  => [1322063329, 1321890529]
     */
    @Test
    public void testGetTimestampDaysAgo() {
        assertEquals(1321890529, Tools.getTimestampDaysAgo(1322063329, 2));
    }

    @Test
    public void testEncodeBase64() {
        assertEquals("bG9sd2F0LmVuY29kZWQ=", Tools.encodeBase64("lolwat.encoded"));
    }

    @Test
    public void testDecodeBase64() {
        assertEquals("lolwat.encoded", Tools.decodeBase64("bG9sd2F0LmVuY29kZWQ="));
    }
    
    @Test
    public void testGenerateServerId() {
        String id = Tools.generateServerId();

        /*
         * Make sure it has dashes in it. We need that to build a short ID later.
         * Short version: Everything falls apart if this is not an UUID-style ID.
         */
        assertTrue(id.contains("-"));
    }
    
    @Test
    public void testAsSortedList() {
        List<Integer> sortMe = Lists.newArrayList();
        sortMe.add(0);
        sortMe.add(2);
        sortMe.add(6);
        sortMe.add(1);
        sortMe.add(10);
        sortMe.add(25);
        sortMe.add(11);
        
        List<Integer> expected = Lists.newArrayList();
        expected.add(0);
        expected.add(1);
        expected.add(2);
        expected.add(6);
        expected.add(10);
        expected.add(11);
        expected.add(25);
        
        assertEquals(expected, Tools.asSortedList(sortMe));
    }

    @Test
    public void testSafeSubstring() {
        assertNull(Tools.safeSubstring(null, 10, 20));
        assertNull(Tools.safeSubstring("", 10, 20));
        assertNull(Tools.safeSubstring("foo", -1, 2));
        assertNull(Tools.safeSubstring("foo", 1, 0));
        assertNull(Tools.safeSubstring("foo", 5, 2));
        assertNull(Tools.safeSubstring("foo", 1, 1));
        assertNull(Tools.safeSubstring("foo", 2, 1));

        assertEquals("justatest", Tools.safeSubstring("justatest", 0, 9));
        assertEquals("tat", Tools.safeSubstring("justatest", 3, 6));
        assertEquals("just", Tools.safeSubstring("justatest", 0, 4));
        assertEquals("atest", Tools.safeSubstring("justatest", 4, 9));
    }

    @Test
    public void testGetInt() throws Exception {
        assertEquals(null, Tools.getDouble(null));
        assertEquals(null, Tools.getDouble(""));

        assertEquals(0.0, Tools.getDouble(0), 0);
        assertEquals(1.0, Tools.getDouble(1), 0);
        assertEquals(1.42, Tools.getDouble(1.42), 0);
        assertEquals(9001.0, Tools.getDouble(9001), 0);
        assertEquals(9001.23, Tools.getDouble(9001.23), 0);

        assertEquals(1253453.0, Tools.getDouble((long) 1253453), 0);

        assertEquals(88.0, Tools.getDouble("88"), 0);
        assertEquals(1.42, Tools.getDouble("1.42"), 0);
        assertEquals(null, Tools.getDouble("lol NOT A NUMBER"));

        assertEquals(null, Tools.getDouble(new HashMap<String, String>()));

        assertEquals(42.23, Tools.getDouble(new Object() {
            @Override
            public String toString() {
                return "42.23";
            }
        }), 0);
    }

    @Test
    public void testTimeFormatterWithOptionalMilliseconds() {
        /*
         * We can actually consider this working if it does not throw parser exceptions.
         * Check the toString() representation to make sure though. (using startsWith()
         * to avoid problems on test systems in other time zones, that are not CEST and do
         * not end with a +02:00 or shit.)
         */
        assertTrue(DateTime.parse("2013-09-15 02:21:02", Tools.timeFormatterWithOptionalMilliseconds()).toString().startsWith("2013-09-15T02:21:02.000"));
        assertTrue(DateTime.parse("2013-09-15 02:21:02.123", Tools.timeFormatterWithOptionalMilliseconds()).toString().startsWith("2013-09-15T02:21:02.123"));
        assertTrue(DateTime.parse("2013-09-15 02:21:02.12", Tools.timeFormatterWithOptionalMilliseconds()).toString().startsWith("2013-09-15T02:21:02.120"));
        assertTrue(DateTime.parse("2013-09-15 02:21:02.1", Tools.timeFormatterWithOptionalMilliseconds()).toString().startsWith("2013-09-15T02:21:02.100"));
    }

    @Test
    public void testElasticSearchTimeFormatToISO8601() {
        assertTrue(Tools.elasticSearchTimeFormatToISO8601("2014-07-31 14:21:02.000").equals("2014-07-31T14:21:02.000Z"));
    }

    @Test
    public void testTimeFromDouble() {
        assertTrue(Tools.dateTimeFromDouble(1381076986.306509).toString().startsWith("2013-10-06T"));
        assertTrue(Tools.dateTimeFromDouble(1381076986).toString().startsWith("2013-10-06T"));
        assertTrue(Tools.dateTimeFromDouble(1381079085.6).toString().startsWith("2013-10-06T"));
        assertTrue(Tools.dateTimeFromDouble(1381079085.06).toString().startsWith("2013-10-06T"));
    }
}
 */
package org.graylog2.plugin;

import org.junit.Test;

import java.net.URI;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;

public class ToolsTest {

public void testGetUriWithScheme() throws Exception {
        assertEquals(Tools.getUriWithScheme(new URI("http://example.com"), "gopher").getScheme(), "gopher");
        assertNull(Tools.getUriWithScheme(new URI("http://example.com"), null).getScheme());
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void render(float delta) {
            n.update(delta);
            n.draw(game.batch);
        }
        hud.draw(game.batch);

        game.batch.end();

public void render(float delta) {
    @Override
    public void resize(int width, int height) {
        gamePort.update(width, height);

    }

    public boolean isTooFarLeft()
public InteractiveTileObject(World world, TiledMap map, Rectangle bounds, boolea

        BodyDef bdef = new BodyDef();
        FixtureDef fdef = new FixtureDef();
        PolygonShape shape = new PolygonShape();

        if(isDynamic)
            bdef.type = BodyDef.BodyType.DynamicBody;
public InteractiveTileObject(World world, TiledMap map, Rectangle bounds, boolea

        shape.setAsBox(bounds.getWidth()/2, bounds.getHeight()/2);
        fdef.shape = shape;
        fdef.isSensor = true;
        fixture = body.createFixture(fdef);
    }
public void dispose()
    {
    	spr.getTexture().dispose();
    	
    	for(TextureRegion t : animFrames)
    		t.getTexture().dispose();
    }
}
public void defineMario()
        fdef.shape = shape;
        fdef.isSensor = true;
        b2body.createFixture(fdef);


        //bottom edge
public void defineMario()
        fdef.shape = edge;
        fdef.isSensor = true;
        b2body.createFixture(fdef).setUserData("bottom");

        //top edge
        fdef = new FixtureDef();
public void defineMario()
        fdef.shape = edge;
        fdef.isSensor = true;
        b2body.createFixture(fdef).setUserData("top");

        //left edge
        fdef = new FixtureDef();
public void defineMario()
        fdef.shape = edge;
        fdef.isSensor = true;
        b2body.createFixture(fdef).setUserData("left");

        //right edge
        fdef = new FixtureDef();
public void defineMario()
        fdef.shape = edge;
        fdef.isSensor = true;
        b2body.createFixture(fdef).setUserData("right");

    }

public void dispose()
    	//stand.getTexture().dispose();
    	
    	super.getTexture().dispose();
    	for(TextureRegion t : animFrames)
    		t.getTexture().dispose();
    }
}
public TestBody(World world, TiledMap map)
        fdef.shape = shape;
        fdef.isSensor = true;
        fixture = body.createFixture(fdef);
    }

    public void update(float dt)
    public B2WorldCreator(World world, TiledMap map)
    {
        npcIndex = 0;
        BodyDef bdef = new BodyDef();
        PolygonShape shape = new PolygonShape();
        FixtureDef fdef = new FixtureDef();
        Body body;
        this.world = world;
        this.map = map;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import java.io.IOException;
import java.net.ConnectException;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
	private final XbmcHost xbmc;
	private final EventPublisher eventPublisher;

	private final String rsUri;
	private final String wsUri;

	// stores which property is associated with each item
	private final Map<String, String> watches = new HashMap<String, String>();

	// the async connection to the XBMC instance
	private AsyncHttpClient client;
	private WebSocket webSocket;
	private boolean connected = false;

public XbmcConnector(XbmcHost xbmc, EventPublisher eventPublisher) {
		this.xbmc = xbmc;
		this.eventPublisher = eventPublisher;

		rsUri = String.format("http://%!s(MISSING):%!d(MISSING)/jsonrpc", xbmc.getHostname(), xbmc.getPort());
		wsUri = String.format("ws://%!s(MISSING):%!d(MISSING)/jsonrpc", xbmc.getHostname(), xbmc.getWSPort());
	}

	/***
public boolean isConnected() {
	 * Attempts to create a connection to the XBMC host and begin listening
	 * for updates over the async http web socket
	 *  
	 * @throws URISyntaxException
	 *             If the result of adding protocol and port to the hostname is
	 *             not a valid uri
	 * @throws ExecutionException 
	 * @throws InterruptedException 
	 * @throws IOException 
	 */
	public void open() throws URISyntaxException, IOException, InterruptedException, ExecutionException {
		AsyncHttpClientConfig config = createAsyncHttpClientConfig();
		WebSocketUpgradeHandler handler = createWebSocketHandler();
		
		client = new AsyncHttpClient(new NettyAsyncHttpProvider(config));
		webSocket = client.prepareGet(wsUri).execute(handler).get();
	}

	/***
	 * Close this connection to the XBMC instance
	 */
	public void close() {
		if (webSocket != null) 
			webSocket.close();
		if (client != null) 
			client.close();
	}
		
	private AsyncHttpClientConfig createAsyncHttpClientConfig() {
public void onFragment(String fragment, boolean last) {}
	 * Send a ping to the XBMC host and wait for a 'pong'.
	 */
	public void ping() {
		final JSONRPCPing ping = new JSONRPCPing(client, rsUri);
		
		ping.execute(new Runnable() {
			@Override
public void addItem(String itemName, String property) {
	}
	
	public void updatePlayerStatus() {
		final PlayerGetActivePlayers activePlayers = new PlayerGetActivePlayers(client, rsUri);
		
		activePlayers.execute(new Runnable() {
			@Override
public void run() {
	}

	public void playerPlayPause() {
		final PlayerGetActivePlayers activePlayers = new PlayerGetActivePlayers(client, rsUri);
		
		activePlayers.execute(new Runnable() {
			public void run() {
				PlayerPlayPause playPause = new PlayerPlayPause(client, rsUri);
				playPause.setPlayerId(activePlayers.getPlayerId());
				playPause.execute();
			}
		});
	}
	
	public void playerStop() {
		final PlayerGetActivePlayers activePlayers = new PlayerGetActivePlayers(client, rsUri);
		
		activePlayers.execute(new Runnable() {
			public void run() {
				PlayerStop stop = new PlayerStop(client, rsUri);
				stop.setPlayerId(activePlayers.getPlayerId());
				stop.execute();
			}
		});
	}
	
	public void showNotification(String title, String message) {
		final GUIShowNotification showNotification = new GUIShowNotification(client, rsUri);
		
		showNotification.setTitle(title);
		showNotification.setMessage(message);
private void requestPlayerUpdate(int playerId) {
		final List<String> properties = getPlayerProperties();
		
		// make the request for the player item details
		final PlayerGetItem item = new PlayerGetItem(client, rsUri);
		item.setPlayerId(playerId);
		item.setProperties(properties);
		
private void updateFanartUrl(final String property, String imagePath) {
		if (StringUtils.isEmpty(imagePath))
			return;
		
		final FilesPrepareDownload fanart = new FilesPrepareDownload(client, rsUri);
		fanart.setImagePath(imagePath);
		
		fanart.execute(new Runnable() {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public long getLineCount() throws RemoteException, IOException {
			while (r.readLine() != null) {
				count++;
			}
			return count;
		}
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public boolean onQueryTextChange(String queryText) {
    }

    @Override
    public void onDestroy() {
        mListPresenter.detachView();
        super.onDestroy();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
protected void handleResponse(Response response, Request<ApplicationInfo> reques
                    return;
                }

                ApplicationInfo info = EntityBuilder.get(api).createApplicationInfo(response.getObject());
                JDABotImpl.this.clientId = info.getId();
                request.onSuccess(info);
            }
protected void handleResponse(Response response, Request<List<Application>> requ
                {
                    JSONArray array = response.getArray();
                    List<Application> applications = new ArrayList<>(array.length());
                    EntityBuilder entityBuilder = EntityBuilder.get(getJDA());

                    for (int i = 0; i < array.length(); i++)
                        applications.add(entityBuilder.createApplication(array.getJSONObject(i)));
protected void handleResponse(Response response, Request<List<Application>> requ
            protected void handleResponse(Response response, Request<Application> request)
            {
                if (response.isOk())
                    request.onSuccess(EntityBuilder.get(getJDA()).createApplication(response.getObject()));
                else
                    request.onFailure(response);
            }
protected void handleResponse(Response response, Request<List<AuthorizedApplicat
                {
                    JSONArray array = response.getArray();
                    List<AuthorizedApplication> applications = new ArrayList<>(array.length());
                    EntityBuilder entityBuilder = EntityBuilder.get(getJDA());

                    for (int i = 0; i < array.length(); i++)
                        applications.add(entityBuilder.createAuthorizedApplication(array.getJSONObject(i)));
protected void handleResponse(Response response, Request<List<AuthorizedApplicat
            protected void handleResponse(Response response, Request<AuthorizedApplication> request)
            {
                if (response.isOk())
                    request.onSuccess(EntityBuilder.get(getJDA()).createAuthorizedApplication(response.getObject()));
                else
                    request.onFailure(response);
            }
protected Long handleInternally(JSONObject content)
            channel = api.getPrivateChannelMap().get(channelId);
        if (channel == null)
        {
            EventCache.get(api).cache(EventCache.Type.CHANNEL, channelId, () -> handle(responseNumber, allContent));
            EventCache.LOG.debug("Received a CALL_CREATE for a Group/PrivateChannel that is not yet cached. JSON: " + content);
            return null;
        }
protected Long handleInternally(JSONObject content)

            ((JDAClientImpl) api.asClient()).getCallUserMap().put(userId, cUser);
        }
        EventCache.get(api).playbackCache(EventCache.Type.CALL, channelId);
        return null;
    }
}
protected Long handleInternally(JSONObject content)
            channel = api.getPrivateChannelMap().get(channelId);
        if (channel == null)
        {
            EventCache.get(api).cache(EventCache.Type.CHANNEL, channelId, () -> handle(responseNumber, allContent));
            EventCache.LOG.debug("Received CALL_DELETE for a Group/PrivateChannel that is not yet cached. JSON: " + content);
            return null;
        }

        CallImpl call = (CallImpl) channel.getCurrentCall();
        if (call == null)
        {
            EventCache.get(api).cache(EventCache.Type.CALL, channelId, () -> handle(responseNumber, allContent));
            EventCache.LOG.debug("Received a CALL_DELETE for a Call that is not yet cached. JSON: " + content);
            return null;
        }
protected Long handleInternally(JSONObject content)
            channel = api.getPrivateChannelMap().get(channelId);
        if (channel == null)
        {
            EventCache.get(api).cache(EventCache.Type.CHANNEL, channelId, () -> handle(responseNumber, allContent));
            EventCache.LOG.debug("Received a CALL_UPDATE for a Group/PrivateChannel that has not yet been cached. JSON: " + content);
            return null;
        }

        CallImpl call = (CallImpl) channel.getCurrentCall();
        if (call == null)
        {
            EventCache.get(api).cache(EventCache.Type.CALL, channelId, () -> handle(responseNumber, allContent));
            EventCache.LOG.debug("Received a CALL_UPDATE for a Call that has not yet been cached. JSON: " + content);
            return null;
        }
protected Long handleInternally(JSONObject content)
        GroupImpl group = (GroupImpl) api.asClient().getGroupById(groupId);
        if (group == null)
        {
            EventCache.get(api).cache(EventCache.Type.CHANNEL, groupId, () -> handle(responseNumber, allContent));
            EventCache.LOG.debug("Received a CHANNEL_RECIPIENT_ADD for a group that is not yet cached! JSON: " + content);
            return null;
        }

        User user = EntityBuilder.get(api).createFakeUser(userJson, true);
        group.getUserMap().put(user.getIdLong(), user);

        CallImpl call = (CallImpl) group.getCurrentCall();
protected Long handleInternally(JSONObject content)
                        api, responseNumber,
                        group, user));

        EventCache.get(api).playbackCache(EventCache.Type.USER, user.getIdLong());
        return null;
    }
}
protected Long handleInternally(JSONObject content)
        GroupImpl group = (GroupImpl) api.asClient().getGroupById(groupId);
        if (group == null)
        {
            EventCache.get(api).cache(EventCache.Type.CHANNEL, groupId, () -> handle(responseNumber, allContent));
            EventCache.LOG.debug("Received a CHANNEL_RECIPIENT_REMOVE for a group that is not yet cached! JSON: " + content);
            return null;
        }

        User user = group.getUserMap().remove(userId);
        if (user == null)
        {
            EventCache.get(api).cache(EventCache.Type.USER, userId, () -> handle(responseNumber, allContent));
            EventCache.LOG.debug("Received a CHANNEL_RECIPIENT_REMOVE for a user that is not yet cached in the group! JSON: " + content);
            return null;
        }
public RelationshipAddHandler(JDAImpl api)
    @Override
    protected Long handleInternally(JSONObject content)
    {
        Relationship relationship = EntityBuilder.get(api).createRelationship(content);
        if (relationship == null)
        {
            WebSocketClient.LOG.warn("Received a RELATIONSHIP_ADD with an unknown type! JSON: " + content);
protected Long handleInternally(JSONObject content)
                WebSocketClient.LOG.warn("Received a RELATIONSHIP_ADD with an unknown type! JSON: " + content);
                return null;
        }
        EventCache.get(api).playbackCache(EventCache.Type.RELATIONSHIP, relationship.getUser().getIdLong());
        EventCache.get(api).playbackCache(EventCache.Type.USER, relationship.getUser().getIdLong());
        return null;
    }
}
protected Long handleInternally(JSONObject content)
        Relationship relationship = api.asClient().getRelationshipById(userId, type);
        if (relationship == null)
        {
            EventCache.get(api).cache(EventCache.Type.RELATIONSHIP, userId, () -> handle(responseNumber, allContent));
            EventCache.LOG.debug("Received a RELATIONSHIP_REMOVE for a relationship that was not yet cached! JSON: " + content);
            return null;
        }
protected void handleResponse(final Response response, final Request<Application
    {
        if (response.isOk())
        {
            request.onSuccess(EntityBuilder.get(api).createApplication(response.getObject()));
        }
        else
            request.onFailure(response);
protected void handleResponse(Response response, Request<List<Message>> request)
            return;
        }

        EntityBuilder builder = EntityBuilder.get(api);
        List<Message> mentions = new LinkedList<>();
        JSONArray arr = response.getArray();
        for (int i = 0; i < arr.length(); i++)
import com.neovisionaries.ws.client.WebSocketAdapter;
import com.neovisionaries.ws.client.WebSocketException;
import com.neovisionaries.ws.client.WebSocketFrame;
import net.dv8tion.jda.core.JDA;
import net.dv8tion.jda.core.audio.hooks.ConnectionListener;
import net.dv8tion.jda.core.audio.hooks.ConnectionStatus;
import net.dv8tion.jda.core.entities.Guild;
import java.net.*;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.RejectedExecutionException;
public class AudioWebSocket extends WebSocketAdapter
{
    public static final SimpleLog LOG = SimpleLog.getLog("JDAAudioSocket");
    public static final HashMap<JDA, ScheduledThreadPoolExecutor> KEEP_ALIVE_POOLS = new HashMap<>();
    public static final int DISCORD_SECRET_KEY_LENGTH = 32;

    public static final int INITIAL_CONNECTION_RESPONSE = 2;
public AudioWebSocket(ConnectionListener listener, String endpoint, JDAImpl api,
        this.token = token;
        this.shouldReconnect = shouldReconnect;

        synchronized (KEEP_ALIVE_POOLS)
        {
            KEEP_ALIVE_POOLS.computeIfAbsent(api, jda ->
                    new ScheduledThreadPoolExecutor(1, new KeepAliveThreadFactory(api)));
        }

        keepAlivePool = KEEP_ALIVE_POOLS.get(api);

        //Append the Secure Websocket scheme so that our websocket library knows how to connect
        if (!endpoint.startsWith("wss://"))
public void setAutoReconnect(boolean shouldReconnect)
        this.shouldReconnect = shouldReconnect;
    }

    private class KeepAliveThreadFactory implements ThreadFactory
    {
        final String identifier;
        AtomicInteger threadCount = new AtomicInteger(1);
    public static final String MISSING_CHANNEL = "MISSING_CHANNEL";
    public static final String MISSING_USER = "MISSING_USER";

    private static final HashMap<JDA, EntityBuilder> builders = new HashMap<>();
    private static final Pattern channelMentionPattern = Pattern.compile("<#(\\d+)>");

    protected final JDAImpl api;
    protected final TLongObjectMap<JSONObject> cachedGuildJsons = MiscUtil.newLongMap();
    protected final TLongObjectMap<Consumer<Guild>> cachedGuildCallbacks = MiscUtil.newLongMap();

    public static EntityBuilder get(JDA api)
    {
        EntityBuilder builder = builders.get(api);
        if (builder == null)
        {
            builder = new EntityBuilder(api);
            builders.put(api, builder);
        }
        return builder;
    }

    private EntityBuilder(JDA api)
    {
        this.api = (JDAImpl) api;
    }
public void createGuildFirstPass(JSONObject guild, Consumer<Guild> secondPassCal
            // be null.
            if (secondPassCallback != null)
                secondPassCallback.accept(guildObj);
            GuildLock.get(api).lock(id);
            return;
        }

else if (type == ChannelType.VOICE)
                readyHandler.acknowledgeGuild(guildObj, true, true, api.getAccountType() == AccountType.CLIENT);
            }

            GuildLock.get(api).lock(id);
            return;
        }

else if (type == ChannelType.VOICE)
        JSONArray voiceStates = guild.getJSONArray("voice_states");
        createGuildVoiceStatePass(guildObj, voiceStates);

        GuildLock.get(api).unlock(guildObj.getIdLong());
        if (secondPassCallback != null)
            secondPassCallback.accept(guildObj);
    }
public void createGuildSecondPass(long guildId, List<JSONArray> memberChunks)
        createGuildVoiceStatePass(guildObj, voiceStates);

        secondPassCallback.accept(guildObj);
        GuildLock.get(api).unlock(guildId);
    }

    public void handleGuildSync(GuildImpl guild, JSONArray members, JSONArray presences)
    {
        for (int i = 0; i < members.length(); i++)
        {
            JSONObject memberJson = members.getJSONObject(i);
            Member member = createMember(guild, memberJson);
        }

        for (int i = 0; i < presences.length(); i++)
private void createGuildMemberPass(GuildImpl guildObj, JSONArray members)
        for (int i = 0; i < members.length(); i++)
        {
            JSONObject memberJson = members.getJSONObject(i);
            Member member = createMember(guildObj, memberJson);
        }
    }

import net.dv8tion.jda.core.AccountType;
import net.dv8tion.jda.core.JDA;
import net.dv8tion.jda.core.MessageBuilder;
import net.dv8tion.jda.core.entities.impl.MessageImpl;
import net.dv8tion.jda.core.exceptions.AccountTypeException;
import net.dv8tion.jda.core.requests.*;
protected void handleResponse(Response response, Request<Message> request)
            {
                if (response.isOk())
                {
                    Message m = EntityBuilder.get(getJDA()).createMessage(response.getObject(), MessageChannel.this, false);
                    request.onSuccess(m);
                }
                else
protected void handleResponse(Response response, Request<Message> request)
            protected void handleResponse(Response response, Request<Message> request)
            {
                if (response.isOk())
                    request.onSuccess(EntityBuilder.get(api).createMessage(response.getObject(), MessageChannel.this, false));
                else
                    request.onFailure(response);
            }
protected void handleResponse(Response response, Request<Message> request)
            protected void handleResponse(Response response, Request<Message> request)
            {
                if (response.isOk())
                    request.onSuccess(EntityBuilder.get(api).createMessage(response.getObject(), MessageChannel.this, false));
                else
                    request.onFailure(response);
            }
protected void handleResponse(Response response, Request<Message> request)
            {
                if (response.isOk())
                {
                    Message m = EntityBuilder.get(getJDA()).createMessage(response.getObject(), MessageChannel.this, false);
                    request.onSuccess(m);
                }
                else
protected void handleResponse(Response response, Request<MessageHistory> request

                MessageHistory mHistory = new MessageHistory(MessageChannel.this);

                EntityBuilder builder = EntityBuilder.get(api);
                LinkedList<Message> msgs  = new LinkedList<>();
                JSONArray historyJson = response.getArray();

protected void handleResponse(Response response, Request<List<Message>> request)
                if (response.isOk())
                {
                    LinkedList<Message> pinnedMessages = new LinkedList<>();
                    EntityBuilder builder = EntityBuilder.get(getJDA());
                    JSONArray pins = response.getArray();

                    for (int i = 0; i < pins.length(); i++)
protected void handleResponse(Response response, Request<Message> request)
            {
                if (response.isOk())
                {
                    Message m = EntityBuilder.get(api).createMessage(response.getObject(), MessageChannel.this, false);
                    request.onSuccess(m);
                }
                else
protected void handleResponse(Response response, Request<List<Message>> request)
                    return;
                }

                EntityBuilder builder = EntityBuilder.get(api);
                LinkedList<Message> msgs  = new LinkedList<>();
                JSONArray historyJson = response.getArray();

protected void handleResponse(Response response, Request<List<Message>> request)
                    return;
                }

                EntityBuilder builder = EntityBuilder.get(api);
                LinkedList<Message> msgs  = new LinkedList<>();
                JSONArray historyJson = response.getArray();

{

    private final long id;
    private final Guild guild;
    private final JDA api;
    private final HashSet<Role> roles;

    private final Object mngLock = new Object();
    private boolean managed = false;
    private String name;

    public EmoteImpl(long id,  Guild guild)
    {
        this.id = id;
        this.guild = guild;
        this.api = guild.getJDA();
        this.roles = new HashSet<>();
    }

    public EmoteImpl(long id,  JDA api)
    {
        this.id = id;
        this.api = api;
protected void handleResponse(Response response, Request<List<Webhook>> request)

                List<Webhook> webhooks = new LinkedList<>();
                JSONArray array = response.getArray();
                EntityBuilder builder = EntityBuilder.get(getJDA());

                for (Object object : array)
                {
public AudioManager getAudioManager()
    }

    @Override
    public JDA getJDA()
    {
        return api;
    }
protected void handleResponse(final Response response, final Request<List<Invite
            {
                if (response.isOk())
                {
                    EntityBuilder entityBuilder = EntityBuilder.get(this.api);
                    JSONArray array = response.getArray();
                    List<Invite> invites = new ArrayList<>(array.length());
                    for (int i = 0; i < array.length(); i++)

package net.dv8tion.jda.core.entities.impl;

import net.dv8tion.jda.core.JDA;
import net.dv8tion.jda.core.entities.*;

public class GuildVoiceStateImpl implements GuildVoiceState
{
    private final Guild guild;
    private final Member member;

    private VoiceChannel connectedChannel;
    private boolean guildDeafened = false;
    private boolean suppressed = false;

    public GuildVoiceStateImpl(Guild guild, Member member)
    {
        this.guild = guild;
        this.member = member;
public boolean isSelfDeafened()
    }

    @Override
    public JDA getJDA()
    {
        return guild.getJDA();
    }
protected void handleResponse(final Response response, final Request<Invite> req
            {
                if (response.isOk())
                {
                    final Invite invite = EntityBuilder.get(this.api).createInvite(response.getObject());
                    request.onSuccess(invite);
                }
                else
protected void handleResponse(final Response response, final Request<Invite> req
            {
                if (response.isOk())
                {
                    final Invite invite = EntityBuilder.get(this.api).createInvite(response.getObject());
                    request.onSuccess(invite);
                }
                else
protected void handleResponse(final Response response, final Request<Invite> req
            {
                if (response.isOk())
                {
                    final EntityBuilder entityBuilder = EntityBuilder.get(this.api);
                    final JSONArray array = response.getArray();
                    for (int i = 0; i < array.length(); i++)
                    {
import net.dv8tion.jda.core.events.StatusChangeEvent;
import net.dv8tion.jda.core.exceptions.AccountTypeException;
import net.dv8tion.jda.core.exceptions.RateLimitedException;
import net.dv8tion.jda.core.hooks.IEventManager;
import net.dv8tion.jda.core.hooks.InterfacedEventManager;
import net.dv8tion.jda.core.managers.AudioManager;
import java.util.*;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadFactory;
import java.util.stream.Collectors;

    protected final JDAClient jdaClient;
    protected final JDABot jdaBot;
    protected final int maxReconnectDelay;

    protected WebSocketClient client;
    protected Requester requester;
    protected IEventManager eventManager = new InterfacedEventManager();
    protected IAudioSendFactory audioSendFactory = new DefaultSendFactory();
    protected Status status = Status.INITIALIZING;
    protected SelfUser selfUser;
    protected ShardInfo shardInfo;
    protected String token = null;
    protected boolean audioEnabled;
    protected boolean useShutdownHook;
    protected boolean bulkDeleteSplittingEnabled;
    protected boolean autoReconnect;
    protected long responseTotal;
public JDAImpl(AccountType accountType, HttpHost proxy, WebSocketFactory wsFacto
        this.wsFactory = wsFactory;
        this.autoReconnect = autoReconnect;
        this.audioEnabled = audioEnabled;
        this.useShutdownHook = useShutdownHook;
        this.bulkDeleteSplittingEnabled = bulkDeleteSplittingEnabled;
        this.pool = Executors.newScheduledThreadPool(corePoolSize, new JDAThreadFactory());
        this.maxReconnectDelay = maxReconnectDelay;
public void login(String token, ShardInfo shardInfo) throws LoginException, Rate

        client = new WebSocketClient(this);

        if (useShutdownHook)
        {
            Runtime.getRuntime().addShutdownHook(new Thread("JDA Shutdown Hook")
            {
                @Override
                public void run()
                {
                    JDAImpl.this.shutdown(true);
                }
            });
        }
    }

protected void handleResponse(Response response, Request<User> request)
                    return;
                }
                JSONObject user = response.getObject();
                request.onSuccess(EntityBuilder.get(api).createFakeUser(user, false));
            }
        };
    }
public void shutdown(boolean free)
    {
        setStatus(Status.SHUTTING_DOWN);
        audioManagers.valueCollection().forEach(AudioManager::closeAudioConnection);
        if (AudioWebSocket.KEEP_ALIVE_POOLS.containsKey(this))
            AudioWebSocket.KEEP_ALIVE_POOLS.get(this).shutdownNow();
        getClient().setAutoReconnect(false);
        getClient().close();
        getRequester().shutdown();
        pool.shutdown();

        if (free)
        {
            try
public void removeEventListener(Object... listeners)
        return Collections.unmodifiableList(eventManager.getRegisteredListeners());
    }

    public IAudioSendFactory getAudioSendFactory()
    {
        return audioSendFactory;
public Thread newThread(Runnable r)
            return thread;
        }
    }
}

public class MemberImpl implements Member
{
    private final Guild guild;
    private final User user;
    private final HashSet<Role> roles = new HashSet<>();
    private final GuildVoiceState voiceState;
    private Game game;
    private OnlineStatus onlineStatus = OnlineStatus.OFFLINE;

    public MemberImpl(Guild guild, User user)
    {
        this.guild = guild;
        this.user = user;
protected void handleResponse(Response response, Request<List<Webhook>> request)

                List<Webhook> webhooks = new LinkedList<>();
                JSONArray array = response.getArray();
                EntityBuilder builder = EntityBuilder.get(getJDA());

                for (Object object : array)
                {
protected void handleResponse(final Response response, final Request<List<Invite
            {
                if (response.isOk())
                {
                    EntityBuilder entityBuilder = EntityBuilder.get(this.api);
                    JSONArray array = response.getArray();
                    List<Invite> invites = new ArrayList<>(array.length());
                    for (int i = 0; i < array.length(); i++)
package net.dv8tion.jda.core.entities.impl;

import net.dv8tion.jda.core.JDA;
import net.dv8tion.jda.core.entities.EntityBuilder;
import net.dv8tion.jda.core.entities.Guild;
import net.dv8tion.jda.core.entities.PrivateChannel;
import net.dv8tion.jda.core.entities.User;
protected void handleResponse(Response response, Request<PrivateChannel> request
            {
                if (response.isOk())
                {
                    PrivateChannel priv = EntityBuilder.get(api).createPrivateChannel(response.getObject());
                    UserImpl.this.privateChannel = priv;
                    request.onSuccess(priv);
                }
protected void handleResponse(final Response response, final Request<List<Invite
            {
                if (response.isOk())
                {
                    EntityBuilder entityBuilder = EntityBuilder.get(this.api);
                    JSONArray array = response.getArray();
                    List<Invite> invites = new ArrayList<>(array.length());
                    for (int i = 0; i < array.length(); i++)
protected Long handleInternally(JSONObject content)
        if (type.isGuild())
        {
            guildId = content.getLong("guild_id");
            if (GuildLock.get(api).isLocked(guildId))
                return guildId;
        }

protected Long handleInternally(JSONObject content)
                api.getEventManager().handle(
                        new TextChannelCreateEvent(
                                api, responseNumber,
                                EntityBuilder.get(api).createTextChannel(content, guildId)));
                break;
            }
            case VOICE:
            {
                api.getEventManager().handle(
                        new VoiceChannelCreateEvent(
                                api, responseNumber,
                                EntityBuilder.get(api).createVoiceChannel(content, guildId)));
                break;
            }
            case PRIVATE:
            {
                api.getEventManager().handle(
                        new PrivateChannelCreateEvent(
                                api, responseNumber,
                                EntityBuilder.get(api).createPrivateChannel(content)));
                break;
            }
            case GROUP:
            {
                api.getEventManager().handle(
                        new GroupJoinEvent(
                                api, responseNumber,
                                EntityBuilder.get(api).createGroup(content)));
                break;
            }
            default:
                throw new IllegalArgumentException("Discord provided an CREATE_CHANNEL event with an unknown channel type! JSON: " + content);
        }
        EventCache.get(api).playbackCache(EventCache.Type.CHANNEL, content.getLong("id"));
        return null;
    }
}
protected Long handleInternally(JSONObject content)
        if (type.isGuild())
        {
            guildId = content.getLong("guild_id");
            if (GuildLock.get(api).isLocked(guildId))
                return guildId;
        }

protected Long handleInternally(JSONObject content)
                TextChannel channel = api.getTextChannelMap().remove(channelId);
                if (channel == null)
                {
                    EventCache.get(api).cache(EventCache.Type.CHANNEL, channelId, () -> handle(responseNumber, allContent));
                    EventCache.LOG.debug("CHANNEL_DELETE attempted to delete a text channel that is not yet cached. JSON: " + content);
                    return null;
                }
protected Long handleInternally(JSONObject content)
                VoiceChannel channel = guild.getVoiceChannelMap().remove(channelId);
                if (channel == null)
                {
                    EventCache.get(api).cache(EventCache.Type.CHANNEL, channelId, () -> handle(responseNumber, allContent));
                    EventCache.LOG.debug("CHANNEL_DELETE attempted to delete a voice channel that is not yet cached. JSON: " + content);
                    return null;
                }
protected Long handleInternally(JSONObject content)
                    channel = api.getFakePrivateChannelMap().remove(channelId);
                if (channel == null)
                {
                    EventCache.get(api).cache(EventCache.Type.CHANNEL, channelId, () -> handle(responseNumber, allContent));
                    EventCache.LOG.debug("CHANNEL_DELETE attempted to delete a private channel that is not yet cached. JSON: " + content);
                    return null;
                }
protected Long handleInternally(JSONObject content)
                GroupImpl group = (GroupImpl) ((JDAClientImpl) api.asClient()).getGroupMap().remove(groupId);
                if (group == null)
                {
                    EventCache.get(api).cache(EventCache.Type.CHANNEL, channelId, () -> handle(responseNumber, allContent));
                    EventCache.LOG.debug("CHANNEL_DELETE attempted to delete a group that is not yet cached. JSON: " + content);
                    return null;
                }
protected Long handleInternally(JSONObject content)
                TextChannelImpl channel = (TextChannelImpl) api.getTextChannelMap().get(channelId);
                if (channel == null)
                {
                    EventCache.get(api).cache(EventCache.Type.CHANNEL, channelId, () -> handle(responseNumber, allContent));
                    EventCache.LOG.debug("CHANNEL_UPDATE attempted to update a TextChannel that does not exist. JSON: " + content);
                    return null;
                }
protected Long handleInternally(JSONObject content)
                int bitrate = content.getInt("bitrate");
                if (channel == null)
                {
                    EventCache.get(api).cache(EventCache.Type.CHANNEL, channelId, () -> handle(responseNumber, allContent));
                    EventCache.LOG.debug("CHANNEL_UPDATE attempted to update a VoiceChannel that does not exist. JSON: " + content);
                    return null;
                }
private void handlePermissionOverride(JSONObject override, Channel channel, JSON
                Role role = ((GuildImpl) channel.getGuild()).getRolesMap().get(id);
                if (role == null)
                {
                    EventCache.get(api).cache(EventCache.Type.ROLE, id, () ->
                    {
                        handlePermissionOverride(override, channel, content, changedRoles, containedRoles, changedMembers, containedMembers);
                    });
private void handlePermissionOverride(JSONObject override, Channel channel, JSON

                if (permOverride == null)    //Created
                {
                    EntityBuilder.get(api).createPermissionOverride(override, channel);
                    changedRoles.add(role);
                }
                else if (permOverride.getAllowedRaw() != allow || permOverride.getDeniedRaw() != deny) //Updated
else if (permOverride.getAllowedRaw() != allow || permOverride.getDeniedRaw() !=
                Member member = channel.getGuild().getMemberById(override.getLong("id"));
                if (member == null)
                {
                    EventCache.get(api).cache(EventCache.Type.USER, id, () ->
                    {
                        handlePermissionOverride(override, channel, content, changedRoles, containedRoles, changedMembers, containedMembers);
                    });
else if (permOverride.getAllowedRaw() != allow || permOverride.getDeniedRaw() !=

                if (permOverride == null)    //Created
                {
                    EntityBuilder.get(api).createPermissionOverride(override, channel);
                    changedMembers.add(member);
                }
                else if (permOverride.getAllowedRaw() != allow || permOverride.getDeniedRaw() != deny)  //Updated
private void handleGroup(JSONObject content)
        GroupImpl group = (GroupImpl) api.asClient().getGroupById(groupId);
        if (group == null)
        {
            EventCache.get(api).cache(EventCache.Type.CHANNEL, groupId, () -> handle(responseNumber, allContent));
            EventCache.LOG.debug("Received CHANNEL_UPDATE for a group that was not yet cached. JSON: " + content);
            return;
        }

import gnu.trove.map.TLongObjectMap;
import gnu.trove.map.hash.TLongObjectHashMap;
import net.dv8tion.jda.core.JDA;
import net.dv8tion.jda.core.utils.SimpleLog;

import java.util.HashMap;
public class EventCache
{
    public static final SimpleLog LOG = SimpleLog.getLog("EventCache");
    private static Map<JDA, EventCache> caches = new HashMap<>();
    private Map<Type, TLongObjectMap<List<Runnable>>> eventCache = new HashMap<>();

    public static EventCache get(JDA jda)
    {
        return caches.computeIfAbsent(jda, k -> new EventCache());
    }

    public void cache(Type type, long triggerId, Runnable handler)
    {
        TLongObjectMap<List<Runnable>> triggerCache =
public GuildBanHandler(JDAImpl api, boolean banned)
    protected Long handleInternally(JSONObject content)
    {
        final long id = content.getLong("guild_id");
        if (GuildLock.get(api).isLocked(id))
            return id;

        JSONObject userJson = content.getJSONObject("user");
        GuildImpl guild = (GuildImpl) api.getGuildMap().get(id);
        if (guild == null)
        {
            EventCache.get(api).cache(EventCache.Type.GUILD, id, () ->
            {
                handle(responseNumber, allContent);
            });
            EventCache.LOG.debug("Received Guild Member " + (banned ? "Ban" : "Unban") + " event for a Guild not yet cached.");
            return null;
        }

        User user = EntityBuilder.get(api).createFakeUser(userJson, false);

        if (banned)
        {
protected Long handleInternally(JSONObject content)
    {
        Guild g = api.getGuildById(content.getLong("id"));
        Boolean wasAvail = (g == null || g.getName() == null) ? null : g.isAvailable();
        EntityBuilder.get(api).createGuildFirstPass(content, guild ->
        {
            if (guild.isAvailable())
            {
protected Long handleInternally(JSONObject content)
                                new GuildJoinEvent(
                                        api, responseNumber,
                                        guild));
                        EventCache.get(api).playbackCache(EventCache.Type.GUILD, guild.getIdLong());
                    }
                    else if (!wasAvail)                     //was previously unavailable
                    {
protected Long handleInternally(JSONObject content)
        if ((guild == null || !guild.isAvailable()) && content.has("unavailable") && content.getBoolean("unavailable"))
            return null;

        if (GuildLock.get(api).isLocked(id))
            return id;

        AudioManagerImpl manager = (AudioManagerImpl) api.getAudioManagerMap().get(guild.getIdLong());
public GuildEmojisUpdateHandler(JDAImpl api)
    protected Long handleInternally(JSONObject content)
    {
        final long guildId = content.getLong("guild_id");
        if (GuildLock.get(api).isLocked(guildId))
            return guildId;

        GuildImpl guild = (GuildImpl) api.getGuildMap().get(guildId);
        if (guild == null)
        {
            EventCache.get(api).cache(EventCache.Type.GUILD, guildId, () ->
                    handle(responseNumber, allContent));
            return null;
        }
public GuildMemberAddHandler(JDAImpl api)
    protected Long handleInternally(JSONObject content)
    {
        final long id = content.getLong("guild_id");
        if (GuildLock.get(api).isLocked(id))
            return id;

        GuildImpl guild = (GuildImpl) api.getGuildMap().get(id);
        if (guild == null)
        {
            EventCache.get(api).cache(EventCache.Type.GUILD, id, () ->
            {
                handle(responseNumber, allContent);
            });
            return null;
        }

        Member member = EntityBuilder.get(api).createMember(guild, content);
        api.getEventManager().handle(
                new GuildMemberJoinEvent(
                        api, responseNumber,
                        guild, member));
        EventCache.get(api).playbackCache(EventCache.Type.USER, member.getUser().getIdLong());
        return null;
    }
}
public GuildMemberRemoveHandler(JDAImpl api)
    protected Long handleInternally(JSONObject content)
    {
        final long id = content.getLong("guild_id");
        if (GuildLock.get(api).isLocked(id))
            return id;

        GuildImpl guild = (GuildImpl) api.getGuildMap().get(id);
public GuildMemberUpdateHandler(JDAImpl api)
    protected Long handleInternally(JSONObject content)
    {
        final long id = content.getLong("guild_id");
        if (GuildLock.get(api).isLocked(id))
            return id;

        JSONObject userJson = content.getJSONObject("user");
        final long userId = userJson.getLong("id");
        GuildImpl guild = (GuildImpl) api.getGuildMap().get(id);
        if (guild == null)
        {
            EventCache.get(api).cache(EventCache.Type.GUILD, userId, () ->
            {
                handle(responseNumber, allContent);
            });
protected Long handleInternally(JSONObject content)
        MemberImpl member = (MemberImpl) guild.getMembersMap().get(userId);
        if (member == null)
        {
            EventCache.get(api).cache(EventCache.Type.USER, userId, () ->
            {
                handle(responseNumber, allContent);
            });
protected Long handleInternally(JSONObject content)
            }
            else
            {
                EventCache.get(api).cache(EventCache.Type.ROLE, id, () ->
                {
                    handle(responseNumber, allContent);
                });
protected Long handleInternally(JSONObject content)
        if (currentTotal >= expectMemberCount)
        {
            JDAImpl.LOG.debug("Finished chunking for: " + guildId);
            EntityBuilder.get(api).createGuildSecondPass(guildId, memberChunks);
            memberChunksCache.remove(guildId);
            expectedGuildMembers.remove(guildId);
        }
public GuildRoleCreateHandler(JDAImpl api)
    protected Long handleInternally(JSONObject content)
    {
        final long guildId = content.getLong("guild_id");
        if (GuildLock.get(api).isLocked(guildId))
        {
            return guildId;
        }

        GuildImpl guild = (GuildImpl) api.getGuildMap().get(guildId);
        if (guild == null)
        {
            EventCache.get(api).cache(EventCache.Type.GUILD, guildId, () ->
            {
                handle(responseNumber, allContent);
            });
            EventCache.LOG.debug("GUILD_ROLE_CREATE was received for a Guild that is not yet cached: " + content);
            return null;
        }

        Role newRole = EntityBuilder.get(api).createRole(content.getJSONObject("role"), guild.getIdLong());
        api.getEventManager().handle(
                new RoleCreateEvent(
                        api, responseNumber,
                        newRole));
        EventCache.get(api).playbackCache(EventCache.Type.ROLE, newRole.getIdLong());
        return null;
    }
}
public GuildRoleDeleteHandler(JDAImpl api)
    protected Long handleInternally(JSONObject content)
    {
        final long guildId = content.getLong("guild_id");
        if (GuildLock.get(api).isLocked(guildId))
            return guildId;

        GuildImpl guild = (GuildImpl) api.getGuildMap().get(guildId);
        if (guild == null)
        {
            EventCache.get(api).cache(EventCache.Type.GUILD, guildId, () -> handle(responseNumber, allContent));
            EventCache.LOG.debug("GUILD_ROLE_DELETE was received for a Guild that is not yet cached: " + content);
            return null;
        }
protected Long handleInternally(JSONObject content)
        Role removedRole = guild.getRolesMap().remove(roleId);
        if (removedRole == null)
        {
            EventCache.get(api).cache(EventCache.Type.ROLE, roleId, () -> handle(responseNumber, allContent));
            EventCache.LOG.debug("GUILD_ROLE_DELETE was received for a Role that is not yet cached: " + content);
            return null;
        }
public GuildRoleUpdateHandler(JDAImpl api)
    protected Long handleInternally(JSONObject content)
    {
        final long guildId = content.getLong("guild_id");
        if (GuildLock.get(api).isLocked(guildId))
            return guildId;

        JSONObject rolejson = content.getJSONObject("role");
        GuildImpl guild = (GuildImpl) api.getGuildMap().get(guildId);
        if (guild == null)
        {
            EventCache.get(api).cache(EventCache.Type.GUILD, guildId, () ->
                    handle(responseNumber, allContent));
            EventCache.LOG.debug("Received a Role Update for a Guild that is not yet cached: " + content);
            return null;
protected Long handleInternally(JSONObject content)
        RoleImpl role = (RoleImpl) guild.getRolesMap().get(roleId);
        if (role == null)
        {
            EventCache.get(api).cache(EventCache.Type.ROLE, roleId, () -> handle(responseNumber, allContent));
            EventCache.LOG.debug("Received a Role Update for Role that is not yet cached: " + content);
            return null;
        }
protected Long handleInternally(JSONObject content)
        GuildImpl guild = (GuildImpl) api.getGuildMap().get(guildId);
        JSONArray members = content.getJSONArray("members");
        JSONArray presences = content.getJSONArray("presences");
        EntityBuilder.get(api).handleGuildSync(guild, members, presences);

        return null;
    }
public GuildUpdateHandler(JDAImpl api)
    protected Long handleInternally(JSONObject content)
    {
        final long id = content.getLong("id");
        if (GuildLock.get(api).isLocked(id))
            return id;

        GuildImpl guild = (GuildImpl) api.getGuildMap().get(id);
protected Long handleInternally(JSONObject content)
            TextChannel channel = api.getTextChannelMap().get(channelId);
            if (channel == null)
            {
                EventCache.get(api).cache(EventCache.Type.CHANNEL, channelId, () -> handle(responseNumber, allContent));
                EventCache.LOG.debug("Received a Bulk Message Delete for a TextChannel that is not yet cached.");
                return null;
            }

            if (GuildLock.get(api).isLocked(channel.getGuild().getIdLong()))
            {
                return channel.getGuild().getIdLong();
            }
private Long handleDefaultMessage(JSONObject content)
        Message message;
        try
        {
            message = EntityBuilder.get(api).createMessage(content, true);
        }
        catch (IllegalArgumentException e)
        {
private Long handleDefaultMessage(JSONObject content)
                case EntityBuilder.MISSING_CHANNEL:
                {
                    final long channelId = content.getLong("channel_id");
                    EventCache.get(api).cache(EventCache.Type.CHANNEL, channelId, () -> handle(responseNumber, allContent));
                    EventCache.LOG.debug("Received a message for a channel that JDA does not currently have cached");
                    return null;
                }
                case EntityBuilder.MISSING_USER:
                {
                    final long authorId = content.getJSONObject("author").getLong("id");
                    EventCache.get(api).cache(EventCache.Type.USER, authorId, () -> handle(responseNumber, allContent));
                    EventCache.LOG.debug("Received a message for a user that JDA does not currently have cached");
                    return null;
                }
private Long handleDefaultMessage(JSONObject content)
            case TEXT:
            {
                TextChannelImpl channel = (TextChannelImpl) message.getTextChannel();
                if (GuildLock.get(api).isLocked(channel.getGuild().getIdLong()))
                {
                    return channel.getGuild().getIdLong();
                }
protected Long handleInternally(JSONObject content)
        }
        if (channel == null)
        {
            EventCache.get(api).cache(EventCache.Type.CHANNEL, channelId, () -> handle(responseNumber, allContent));
            EventCache.LOG.debug("Got message delete for a channel/group that is not yet cached. ChannelId: " + channelId);
            return null;
        }

        if (channel instanceof TextChannel)
        {
            TextChannelImpl tChan = (TextChannelImpl) channel;
            if (GuildLock.get(api).isLocked(tChan.getGuild().getIdLong()))
            {
                return tChan.getGuild().getIdLong();
            }
protected Long handleInternally(JSONObject content)
        }
        if (channel == null)
        {
            EventCache.get(api).cache(EventCache.Type.CHANNEL, channelId, () -> handle(responseNumber, allContent));
            EventCache.LOG.debug("Received a reaction for a channel that JDA does not currently have cached");
            return null;
        }
protected Long handleInternally(JSONObject content)
            user = api.getFakeUserMap().get(userId);
        if (user == null)
        {
            EventCache.get(api).cache(EventCache.Type.USER, userId, () -> handle(responseNumber, allContent));
            EventCache.LOG.debug("Received a reaction for a user that JDA does not currently have cached");
            return null;
        }
protected Long handleInternally(JSONObject content)
        }
        if (channel == null)
        {
            EventCache.get(api).cache(EventCache.Type.CHANNEL, channelId, () -> handle(responseNumber, allContent));
            EventCache.LOG.debug("Received a reaction for a channel that JDA does not currently have cached");
            return null;
        }
private Long handleDefaultMessage(JSONObject content)
        Message message;
        try
        {
            message = EntityBuilder.get(api).createMessage(content);
        }
        catch (IllegalArgumentException e)
        {
private Long handleDefaultMessage(JSONObject content)
                case EntityBuilder.MISSING_CHANNEL:
                {
                    final long channelId = content.getLong("channel_id");
                    EventCache.get(api).cache(EventCache.Type.CHANNEL, channelId, () -> handle(responseNumber, allContent));
                    EventCache.LOG.debug("Received a message update for a channel that JDA does not currently have cached");
                    return null;
                }
                case EntityBuilder.MISSING_USER:
                {
                    final long authorId = content.getJSONObject("author").getLong("id");
                    EventCache.get(api).cache(EventCache.Type.USER, authorId, () -> handle(responseNumber, allContent));
                    EventCache.LOG.debug("Received a message update for a user that JDA does not currently have cached");
                    return null;
                }
private Long handleDefaultMessage(JSONObject content)
            case TEXT:
            {
                TextChannel channel = message.getTextChannel();
                if (GuildLock.get(api).isLocked(channel.getGuild().getIdLong()))
                {
                    return channel.getGuild().getIdLong();
                }
private Long handleDefaultMessage(JSONObject content)

    private Long handleMessageEmbed(JSONObject content)
    {
        EntityBuilder builder = EntityBuilder.get(api);
        final long messageId = content.getLong("id");
        final long channelId = content.getLong("channel_id");
        LinkedList<MessageEmbed> embeds = new LinkedList<>();
private Long handleMessageEmbed(JSONObject content)
            channel = api.asClient().getGroupById(channelId);
        if (channel == null)
        {
            EventCache.get(api).cache(EventCache.Type.CHANNEL, channelId, () ->
            {
                handle(responseNumber, allContent);
            });
private Long handleMessageEmbed(JSONObject content)
        if (channel instanceof TextChannel)
        {
            TextChannel tChannel = (TextChannel) channel;
            if (GuildLock.get(api).isLocked(tChannel.getGuild().getIdLong()))
            {
                return tChannel.getGuild().getIdLong();
            }
protected Long handleInternally(JSONObject content)
        if (content.has("guild_id"))
        {
            final long guildId = content.getLong("guild_id");
            if (GuildLock.get(api).isLocked(guildId))
                return guildId;
        }

public ReadyHandler(JDAImpl api)
    @Override
    protected Long handleInternally(JSONObject content)
    {
        EntityBuilder builder = EntityBuilder.get(api);

        //Core
        JSONArray guilds = content.getJSONArray("guilds");
protected Long handleInternally(JSONObject content)
    public void guildLoadComplete(JSONObject content)
    {
        api.getClient().setChunkingAndSyncing(false);
        EntityBuilder builder = EntityBuilder.get(api);
        JSONArray privateChannels = content.getJSONArray("private_channels");

        if (api.getAccountType() == AccountType.CLIENT)
public final void handle(long responseTotal, JSONObject o)
        this.responseNumber = responseTotal;
        final Long guildId = handleInternally(o.getJSONObject("d"));
        if (guildId != null)
            GuildLock.get(api).queue(guildId, o);
    }

    /**
protected Long handleInternally(JSONObject content)
        if (channel instanceof TextChannel)
        {
            final long guildId = ((TextChannel) channel).getGuild().getIdLong();
            if (GuildLock.get(api).isLocked(guildId))
                return guildId;
        }

protected Long handleInternally(JSONObject content)
        final long guildId = content.getLong("guild_id");
        api.getClient().getQueuedAudioConnectionMap().remove(guildId);

        if (GuildLock.get(api).isLocked(guildId))
            return guildId;

        if (content.isNull("endpoint"))
public VoiceStateUpdateHandler(JDAImpl api)
    protected Long handleInternally(JSONObject content)
    {
        final Long guildId = content.has("guild_id") ? content.getLong("guild_id") : null;
        if (guildId != null && GuildLock.get(api).isLocked(guildId))
            return guildId;

        if (guildId != null)
private void handleGuildVoiceState(JSONObject content)
        Guild guild = api.getGuildById(guildId);
        if (guild == null)
        {
            EventCache.get(api).cache(EventCache.Type.GUILD, guildId, () -> handle(responseNumber, allContent));
            EventCache.LOG.debug("Received a VOICE_STATE_UPDATE for a Guild that has yet to be cached. JSON: " + content);
            return;
        }

        VoiceChannelImpl channel = channelId != null ? (VoiceChannelImpl) guild.getVoiceChannelById(channelId) : null;
        if (channel == null && channelId != null)
        {
            EventCache.get(api).cache(EventCache.Type.CHANNEL, channelId, () -> handle(responseNumber, allContent));
            EventCache.LOG.debug("Received VOICE_STATE_UPDATE for a VoiceChannel that has yet to be cached. JSON: " + content);
            return;
        }
private void handleGuildVoiceState(JSONObject content)
            // in fact the issue was that the VOICE_STATE_UPDATE was sent after they had left, however, by caching
            // it we will preserve the integrity of the cache in the event that it was actually a mis-ordering of
            // GUILD_MEMBER_ADD and VOICE_STATE_UPDATE. I'll take some bad-data events over an invalid cache.
            EventCache.get(api).cache(EventCache.Type.USER, userId, () -> handle(responseNumber, allContent));
            EventCache.LOG.debug("Received VOICE_STATE_UPDATE for a Member that has yet to be cached. JSON: " + content);
            return;
        }
private void handleCallVoiceState(JSONObject content)

            if (channel == null)
            {
                EventCache.get(api).cache(EventCache.Type.CHANNEL, channelId, () -> handle(responseNumber, allContent));
                EventCache.LOG.debug("Received a VOICE_STATE_UPDATE for a Group/PrivateChannel that was not yet cached! JSON: " + content);
                return;
            }

            CallImpl call = (CallImpl) channel.getCurrentCall();
            if (call == null)
            {
                EventCache.get(api).cache(EventCache.Type.CALL, channelId, () -> handle(responseNumber, allContent));
                EventCache.LOG.debug("Received a VOICE_STATE_UPDATE for a Call that is not yet cached. JSON: " + content);
                return;
            }
private void handleCallVoiceState(JSONObject content)
            cUser = call.getCallUserMap().get(userId);
            if (cUser == null)
            {
                EventCache.get(api).cache(EventCache.Type.USER, userId, () -> handle(responseNumber, allContent));
                EventCache.LOG.debug("Received a VOICE_STATE_UPDATE for a user that is not yet a a cached CallUser for the call. (groups only). JSON: " + content);
                return;
            }
private void handleCallVoiceState(JSONObject content)
            CallUser cUser = ((JDAClientImpl) api.asClient()).getCallUserMap().remove(userId);
            if (cUser == null)
            {
                EventCache.get(api).cache(EventCache.Type.USER, userId, () -> handle(responseNumber, allContent));
                EventCache.LOG.debug("Received a VOICE_STATE_UPDATE for a User leaving a Call, but the Call was not yet cached! JSON: " + content);
                return;
            }
protected void handleResponse(Response response, Request<Void> request)
                String newToken = response.getObject().getString("token");
                newToken = newToken.replace("Bot ", "");

                ((JDAImpl) getJDA()).setToken(newToken);
                request.onSuccess(null);
            }
        };
import net.dv8tion.jda.core.JDA;
import net.dv8tion.jda.core.Permission;
import net.dv8tion.jda.core.entities.*;
import net.dv8tion.jda.core.entities.impl.EmoteImpl;
import net.dv8tion.jda.core.entities.impl.GuildImpl;
import net.dv8tion.jda.core.entities.impl.MemberImpl;
import net.dv8tion.jda.core.exceptions.AccountTypeException;
import net.dv8tion.jda.core.exceptions.GuildUnavailableException;
import net.dv8tion.jda.core.exceptions.PermissionException;
 */
public class GuildController
{
    protected final Guild guild;

    /**
     * Creates a new GuildController instance
     */
    public GuildController(Guild guild)
    {
        this.guild = guild;
    }

    /**
protected void handleResponse(Response response, Request<List<User>> request)
                    return;
                }

                EntityBuilder builder = EntityBuilder.get(guild.getJDA());
                List<User> bans = new LinkedList<>();
                JSONArray bannedArr = response.getArray();

import net.dv8tion.jda.core.entities.Guild;
import net.dv8tion.jda.core.entities.Member;
import net.dv8tion.jda.core.entities.VoiceChannel;
import net.dv8tion.jda.core.entities.impl.JDAImpl;
import net.dv8tion.jda.core.exceptions.GuildUnavailableException;
import net.dv8tion.jda.core.exceptions.PermissionException;
    public final Object CONNECTION_LOCK = new Object();

    protected final JDAImpl api;
    protected final Guild guild;
    protected AudioConnection audioConnection = null;
    protected VoiceChannel queuedAudioConnection = null;


    public AudioManagerImpl(Guild guild)
    {
        this.guild = guild;
        this.api = (JDAImpl) guild.getJDA();
        init(); //Just to make sure that the audio libs have been initialized.
    }

public class GuildLock
{
    public static final SimpleLog LOG = SimpleLog.getLog("JDAGuildLock");
    private static final Map<JDA, GuildLock> locks = new HashMap<>();

    public static synchronized GuildLock get(JDA jda)
    {
        if (!locks.containsKey(jda))
        {
            locks.put(jda, new GuildLock(jda));
        }
        return locks.get(jda);
    }

    private final JDA api;
    private final TLongObjectMap<List<JSONObject>> cache = new TLongObjectHashMap<>();
public void clear()
        cached.clear();
    }

    private GuildLock(JDA api)
    {
        this.api = api;
    }
protected void invalidate()
        api.getPrivateChannelMap().clear();
        api.getFakeUserMap().clear();
        api.getFakePrivateChannelMap().clear();
        EntityBuilder.get(api).clearCache();
        EventCache.get(api).clear();
        GuildLock.get(api).clear();
        this.<ReadyHandler>getHandler("READY").clearCache();
        this.<GuildMembersChunkHandler>getHandler("GUILD_MEMBERS_CHUNK").clearCache();

protected void handleResponse(Response response, Request<Channel> request)
            return;
        }

        EntityBuilder builder = EntityBuilder.get(api);
        Channel channel = voice
                ? builder.createVoiceChannel(response.getObject(), guild.getIdLong())
                : builder.createTextChannel(response.getObject(),  guild.getIdLong());
protected void finalizeData()
    protected void handleResponse(final Response response, final Request<Invite> request)
    {
        if (response.isOk())
            request.onSuccess(EntityBuilder.get(this.api).createInvite(response.getObject()));
        else
            request.onFailure(response);
    }
protected void finalizeData()
    protected void handleResponse(Response response, Request<Role> request)
    {
        if (response.isOk())
            request.onSuccess(EntityBuilder.get(api).createRole(response.getObject(), guild.getIdLong()));
        else
            request.onFailure(response);
    }
protected void handleResponse(Response response, Request<Webhook> request)
            return;
        }
        JSONObject json = response.getObject();
        Webhook webhook = EntityBuilder.get(api).createWebhook(json);

        request.onSuccess(webhook);
    }
protected void handleResponse(Response response, Request<List<User>> request)
            return;
        }

        final EntityBuilder builder = EntityBuilder.get(api);
        final JSONArray array = response.getArray();
        final List<User> users = new LinkedList<>();
        for (int i = 0; i < array.length(); i++)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import org.graylog2.plugin.inputs.MessageInput;
import org.graylog2.plugin.inputs.util.ThroughputCounter;
import org.graylog2.plugin.system.NodeId;
import org.graylog2.shared.buffers.InputBufferImpl;
import org.graylog2.shared.buffers.ProcessBuffer;
import org.graylog2.shared.buffers.processors.DecodingProcessor;
import org.graylog2.shared.bindings.providers.EventBusProvider;
import org.graylog2.shared.bindings.providers.MetricRegistryProvider;
import org.graylog2.shared.bindings.providers.NodeIdProvider;
import org.graylog2.shared.bindings.providers.ServiceManagerProvider;
import org.graylog2.shared.inputs.InputRegistry;
import org.graylog2.shared.stats.ThroughputStats;
import org.jboss.netty.util.HashedWheelTimer;

import java.util.concurrent.Semaphore;

protected void configure() {
        install(new FactoryModuleBuilder().build(new TypeLiteral<IOState.Factory<MessageInput>>(){}));

        bind(InputRegistry.class).asEagerSingleton();
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.TimeUnit;
      void addBagItem();
   }

   private static final ThreadLocal<FastList<WeakReference<BagEntry>>> threadList;
   private final CopyOnWriteArrayList<T> sharedList;
   private final Synchronizer synchronizer;
   private final AtomicLong sequence;
   private final IBagStateListener listener;

   static {
      threadList = new ThreadLocal<FastList<WeakReference<BagEntry>>>() {
         @Override
         protected FastList<WeakReference<BagEntry>> initialValue() {
            return new FastList<WeakReference<BagEntry>>(WeakReference.class);
         }
      };
   }
public ConcurrentBag(IBagStateListener listener)
   public T borrow(long timeout, final TimeUnit timeUnit) throws InterruptedException
   {
      // Try the thread-local list first
      final FastList<WeakReference<BagEntry>> list = threadList.get();
      for (int i = list.size(); i > 0; i--) {
         final BagEntry element = list.removeLast().get();
         if (element != null && element.state.compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) {

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.TimeUnit;
      void addBagItem();
   }

   private static final ThreadLocal<FastList<WeakReference<BagEntry>>> threadList;
   private final CopyOnWriteArrayList<T> sharedList;
   private final Synchronizer synchronizer;
   private final AtomicLong sequence;
   private final IBagStateListener listener;

   static {
      threadList = new ThreadLocal<FastList<WeakReference<BagEntry>>>() {
         @Override
         protected FastList<WeakReference<BagEntry>> initialValue() {
            return new FastList<WeakReference<BagEntry>>(WeakReference.class);
         }
      };
   }
public ConcurrentBag(IBagStateListener listener)
   public T borrow(long timeout, final TimeUnit timeUnit) throws InterruptedException
   {
      // Try the thread-local list first
      final FastList<WeakReference<BagEntry>> list = threadList.get();
      for (int i = list.size(); i > 0; i--) {
         final BagEntry element = list.removeLast().get();
         if (element != null && element.state.compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
package org.openhab.io.rest.internal.filter;

import java.util.concurrent.Executors;

import javax.servlet.http.HttpServletRequest;

public class PollingDelayFilter implements PerRequestBroadcastFilter {
	private static final Logger logger = LoggerFactory.getLogger(PollingDelayFilter.class);
	
	@Override
	public BroadcastAction filter(String broadcasterId, Object originalMessage, Object message) {
		return new BroadcastAction(message);
public BroadcastAction filter(String broadcasterId, final AtmosphereResource res
			boolean isItemMessage = originalMessage instanceof Item || originalMessage instanceof GroupItem;
			boolean isStreamingTransport = ResponseTypeHelper.isStreamingTransport(request);
			
			if(!isStreamingTransport && message instanceof PageBean && isItemMessage) {
				final String delayedBroadcasterName = resource.getRequest().getPathInfo();
				Executors.newSingleThreadExecutor().submit(new Runnable() {
		            public void run() {
		                try {
		                    Thread.sleep(300);
		                    BroadcasterFactory broadcasterFactory = resource.getAtmosphereConfig().getBroadcasterFactory();
							GeneralBroadcaster delayedBroadcaster = broadcasterFactory.lookup(GeneralBroadcaster.class, delayedBroadcasterName);
							if(delayedBroadcaster != null)
public void run() {
							logger.error("Could not broadcast message", e);
						} 
		            }
		        });
			} else {
				//pass message to next filter
				return new BroadcastAction(ACTION.CONTINUE, message);
public void run() {
		return new BroadcastAction(ACTION.ABORT, message);
	}
	
}
public void setBroadcaster(GeneralBroadcaster broadcaster) {
		return cachedEntries;
	}
	
	public void registerItems(){
		StartCacheExecutor();
		BroadcasterConfig config = broadcaster.getBroadcasterConfig();
		
		config.setBroadcasterCache(new UUIDBroadcasterCache());
		config.getBroadcasterCache().configure(broadcaster.getBroadcasterConfig());
		config.getBroadcasterCache().start();

		addBroadcastFilter(config, new PerRequestBroadcastFilter() {

import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.core.UriBuilder;

import org.atmosphere.cpr.AtmosphereResource;
import org.atmosphere.cpr.BroadcasterCache;
import org.atmosphere.cpr.PerRequestBroadcastFilter;
import org.atmosphere.cpr.BroadcastFilter.BroadcastAction.ACTION;
import org.openhab.core.items.Item;
import org.openhab.io.rest.RESTApplication;
import org.openhab.io.rest.internal.resources.ResponseTypeHelper;
import org.openhab.io.rest.internal.resources.SitemapResource;
import org.openhab.io.rest.internal.resources.beans.PageBean;
	private static final Logger logger = LoggerFactory.getLogger(SitemapStateChangeListener.class);
	
	@Override
	public void registerItems() {
		super.registerItems();
		//if other filters have let this through then clear out any cached messages for the client.
		//There should at most be only one message (version of the sitemap) in the cache for a client.
		broadcaster.getBroadcasterConfig().addFilter(new PerRequestBroadcastFilter() {
			
			@Override
			public BroadcastAction filter(String broadcasterId,
					Object originalMessage, Object message) {
				return new BroadcastAction(message);
			}

			@Override
			public BroadcastAction filter(String broadcasterId,
					AtmosphereResource resource, Object originalMessage, Object message) {
				//this will clear any cached messages before we add the new one
				BroadcasterCache uuidCache = broadcaster.getBroadcasterConfig().getBroadcasterCache();
				List<Object> entries = uuidCache.retrieveFromCache(broadcasterId, resource.uuid());
				if(entries != null)
					logger.trace("UUID {} had {} previous messages", resource.uuid(), entries.size());
				return new BroadcastAction(ACTION.CONTINUE, message);
			}
		});
	}
	
	@Override
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

package org.eclipse.collections.impl.bimap.mutable;

import org.eclipse.collections.impl.map.mutable.UnifiedMap;
import org.eclipse.collections.impl.test.Verify;
import org.eclipse.collections.impl.test.domain.Key;
public void withKeysValues()
    }

    @Test
    public void forcePut_inverseKeyAndValuePreservation()
    {
        Key key1 = new Key("1");
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        this.threadPool = threadPool;
        this.dumpMonitorService = dumpMonitorService;

        this.enabled = componentSettings.getAsBoolean("enabled", true);
        this.interval = componentSettings.getAsTime("interval", timeValueSeconds(1));
        this.gcThreshold = componentSettings.getAsTime("gc_threshold", timeValueMillis(5000));
    }

    @Override protected void doStart() throws ElasticSearchException {

package org.elasticsearch.monitor.jvm;

import org.elasticsearch.common.collect.Iterators;
import org.elasticsearch.common.io.stream.StreamInput;
import org.elasticsearch.common.io.stream.StreamOutput;
 */
public class JvmStats implements Streamable, Serializable, ToXContent {

    private final static RuntimeMXBean runtimeMXBean;
    private final static MemoryMXBean memoryMXBean;
    private final static ThreadMXBean threadMXBean;

    private static boolean sunGc;
    private static Method getLastGcInfoMethod;
    private static Method getMemoryUsageBeforeGcMethod;
    private static Method getMemoryUsageAfterGcMethod;
        memoryMXBean = ManagementFactory.getMemoryMXBean();
        threadMXBean = ManagementFactory.getThreadMXBean();

        try {
            Class sunGcClass = Class.forName("com.sun.management.GarbageCollectorMXBean");
            Class gcInfoClass = Class.forName("com.sun.management.GcInfo");

            getLastGcInfoMethod = sunGcClass.getDeclaredMethod("getLastGcInfo");
            getLastGcInfoMethod.setAccessible(true);

            getMemoryUsageBeforeGcMethod = gcInfoClass.getDeclaredMethod("getMemoryUsageBeforeGc");
            getMemoryUsageBeforeGcMethod.setAccessible(true);
            getMemoryUsageAfterGcMethod = gcInfoClass.getDeclaredMethod("getMemoryUsageAfterGc");
            getMemoryUsageAfterGcMethod.setAccessible(true);
            getStartTimeMethod = gcInfoClass.getDeclaredMethod("getStartTime");
            getStartTimeMethod.setAccessible(true);
            getEndTimeMethod = gcInfoClass.getDeclaredMethod("getEndTime");
            getEndTimeMethod.setAccessible(true);
            getDurationMethod = gcInfoClass.getDeclaredMethod("getDuration");
            getDurationMethod.setAccessible(true);

            sunGc = true;
        } catch (Throwable ex) {
            sunGc = false;
        }
    }

    public static JvmStats jvmStats() {
public static JvmStats jvmStats() {
            stats.gc.collectors[i].name = gcMxBean.getName();
            stats.gc.collectors[i].collectionCount = gcMxBean.getCollectionCount();
            stats.gc.collectors[i].collectionTime = gcMxBean.getCollectionTime();
            if (sunGc) {
                try {
                    Object lastGcInfo = getLastGcInfoMethod.invoke(gcMxBean);
                    if (lastGcInfo != null) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void bind() {

    public void unbind() {
        merlinServiceBinder.unbind();
    }

    public void registerConnectable(Connectable connectable) {
public void register(T registerable) {
        return registerables;
    }

}
public void registerBindable(Bindable bindable) {
        return bindables;
    }

}

    private static boolean isBound;

    private final IBinder binder = new LocalBinder();

    private ConnectivityChangesRegister connectivityChangesRegister;
    private ConnectivityChangesForwarder connectivityChangesForwarder;
public IBinder onBind(Intent intent) {
    @Override
    public boolean onUnbind(Intent intent) {
        isBound = false;
        connectivityChangesRegister.unregister();
        return super.onUnbind(intent);
    }

    private void start() {
        connectivityChangesForwarder.forwardInitialNetworkStatus();
        connectivityChangesRegister.register(connectivityChangesListener);
    }

    private final ConnectivityChangesListener connectivityChangesListener = new ConnectivityChangesListener() {
        @Override
        public void onConnectivityChanged(ConnectivityChangeEvent connectivityChangeEvent) {
public void bindService() {
    public void unbind() {
        if (MerlinService.isBound()) {
            context.unbindService(merlinServiceConnection);
            merlinServiceConnection = null;
        }
    }
public void whenUnbinding_thenUnbindsService() {
    }

    @Test
    public void whenRegisteringConnectable_thenRegistersConnectable() {
        Connectable connectable = mock(Connectable.class);

    public MockitoRule mockitoRule = MockitoJUnit.rule();

    @Mock
    private Register<Connectable> connector;
    @Mock
    private Register<Disconnectable> disconnector;
    @Mock
    private Register<Bindable> binder;

    private Registrar registrar;

    @Before
    public void setUp() {
        registrar = new Registrar(connector, disconnector, binder);
    }

    @Test(expected = MerlinException.class)
    public void givenMissingConnector_whenRegisteringConnectable_thenThrowsDeveloperException() {
        registrar = new Registrar(null, null, null);

        Connectable connectable = mock(Connectable.class);
        registrar.registerConnectable(connectable);
    }

    @Test(expected = MerlinException.class)
    public void givenMissingDisconnector_thenRegisteringDisconnectable_thenThrowsDeveloperException() {
        registrar = new Registrar(null, null, null);

        Disconnectable disconnectable = mock(Disconnectable.class);
        registrar.registerDisconnectable(disconnectable);
    }

    @Test(expected = MerlinException.class)
    public void givenMissingBinder_whenRegisteringBindable_thenThrowsDeveloperException() {
        registrar = new Registrar(null, null, null);

        Bindable bindable = mock(Bindable.class);
        registrar.registerBindable(bindable);
    }

    @Test
    public void givenConnector_whenRegisteringConnectable_thenRegistersConnectableWithConnector() {
        Connectable connectable = mock(Connectable.class);

        registrar.registerConnectable(connectable);

        verify(connector).register(connectable);
    }

    @Test
    public void givenDisconnector_whenRegisteringDisconnectable_thenRegistersDisconnectableWithDisconnector() {
        Disconnectable disconnectable = mock(Disconnectable.class);

        registrar.registerDisconnectable(disconnectable);

        verify(disconnector).register(disconnectable);
    }

    @Test
    public void givenBinder_whenRegisteringBindable_thenRegistersBindableWithBinder() {
        Bindable bindable = mock(Bindable.class);

        registrar.registerBindable(bindable);

        verify(binder).register(bindable);
    }

}
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnit;
import static org.fest.assertions.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.verify;

public class MerlinServiceTest {


    @Rule
    public MockitoRule mockitoRule = MockitoJUnit.rule();

    @Mock
    private Intent intent;
public void givenRegisteredMerlinService_whenConnectivityChangeOccurs_thenNotifi
        verify(connectivityChangesForwarder).forward(ANY_CONNECTIVITY_CHANGE_EVENT);
    }

    private MerlinService.LocalBinder givenBoundMerlinService() {
        MerlinService.LocalBinder binder = ((MerlinService.LocalBinder) merlinService.onBind(intent));
        binder.setConnectivityChangesRegister(connectivityChangesRegister);

import android.content.res.Resources;
import android.support.annotation.IntegerRes;
import android.support.annotation.StringRes;
import android.support.design.widget.Snackbar;
import android.view.View;
    private static final String EMPTY_MESSAGE = "";
    private final Snackbar snackbar;

    static MerlinSnackbar withDuration(Resources resources, View attachTo, @IntegerRes int durationResource) {
        int duration = resources.getInteger(durationResource);
        Snackbar snackbar = Snackbar.make(attachTo, EMPTY_MESSAGE, duration);
MerlinSnackbar withText(@StringRes int messageResource) {
        return this;
    }

    void show() {
        if (!snackbar.isShown()) {
            snackbar.show();
        }
    }

    void dismiss() {
package com.novoda.merlin.demo.connectivity.display;

import android.content.res.Resources;
import android.support.annotation.StringRes;
import android.view.View;

    private final Resources resources;
    private final MerlinsBeard merlinsBeard;

    private MerlinSnackbar snackbar;

    public NetworkStatusDisplayer(Resources resources, MerlinsBeard merlinsBeard) {
public NetworkStatusDisplayer(Resources resources, MerlinsBeard merlinsBeard) {
    }

    public void displayPositiveMessage(@StringRes int messageResource, View attachTo) {
        snackbar = MerlinSnackbar.withDuration(resources, attachTo, R.integer.snackbar_duration);
        snackbar.withText(messageResource)
                .withTheme(new PositiveThemer())
                .show();
    }

    public void displayNegativeMessage(@StringRes int messageResource, View attachTo) {
        snackbar = MerlinSnackbar.withDuration(resources, attachTo, R.integer.snackbar_duration);
        snackbar.withText(messageResource)
                .withTheme(new NegativeThemer())
                .show();
    }

    public void displayNetworkSubtype(View attachTo) {
        String subtype = merlinsBeard.getMobileNetworkSubtypeName();
        snackbar = MerlinSnackbar.withDuration(resources, attachTo, R.integer.snackbar_duration);

        if (subtypeAbsent(subtype)) {
            snackbar.withText(R.string.subtype_not_available)
                    .withTheme(new NegativeThemer())
                    .show();
        } else {
            snackbar.withText(resources.getString(R.string.subtype_value, subtype))
                    .withTheme(new PositiveThemer())
                    .show();
        }
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void processPdu(CommandResponderEvent event) {
     */
    @Override
    public void onResponse(ResponseEvent event) {
        dispatchPdu(event.getPeerAddress(), event.getResponse());
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public Number fromString(String string) {
  @FXML
  ImageView countryImageView;
  @FXML
  Region userInfoRoot;

  @Resource
  StatisticsService statisticsService;
void initialize() {
    );

    rating90DaysXAxis.setTickLabelFormatter(DAY_AXIS_FORMATTER);
  }

  private void displayAvailableAchievements(List<AchievementDefinition> achievementDefinitions) {
private static boolean isUnlocked(PlayerAchievement playerAchievement) {
    return UNLOCKED.equals(playerAchievement.getState());
  }

  public Region getRoot() {
    return userInfoRoot;
  }

  @FXML
  void onRatingOver90DaysButtonClicked() {
    loadStatistics(StatisticsType.GLOBAL_90_DAYS);

import com.faforever.client.api.FafApiAccessor;
import com.faforever.client.api.PlayerEvent;
import com.faforever.client.player.PlayerService;
import com.faforever.client.task.AbstractPrioritizedTask;
import com.faforever.client.task.TaskService;

import javax.annotation.Resource;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

  @Override
  public CompletableFuture<Map<String, PlayerEvent>> getPlayerEvents(String username) {
    int playerId = playerService.getPlayerForUsername(username).getId();

    return taskService.submitTask(new AbstractPrioritizedTask<Map<String, PlayerEvent>>(HIGH) {
      @Override
package com.faforever.client.legacy;

import com.faforever.client.config.CacheNames;
import com.faforever.client.remote.AbstractServerAccessor;
import com.faforever.client.remote.ClientMessageSerializer;
import com.faforever.client.remote.ServerWriter;
import org.apache.commons.compress.utils.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.core.env.Environment;

import javax.annotation.PreDestroy;
public StatisticsServerAccessorImpl() {
  }

  @Override
  @Cacheable(value = CacheNames.STATISTICS, key = "#type + #username")
  public CompletableFuture<PlayerStatisticsMessage> requestPlayerStatistics(StatisticsType type, String username) {
    // FIXME this is not safe (as well aren't similar implementations in other accessors)
    playerStatisticsFuture = new CompletableFuture<>();
package com.faforever.client.mod;

import com.faforever.client.api.FafApiAccessor;
import com.faforever.client.config.CacheNames;
import com.faforever.client.preferences.PreferencesService;
import com.faforever.client.remote.FafService;
import com.faforever.client.task.TaskService;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.context.ApplicationContext;

import javax.annotation.PostConstruct;
public Path getPathForMod(ModInfoBean mod) {
  }

  @Override
  @Cacheable(CacheNames.MODS)
  public CompletableFuture<List<ModInfoBean>> getAvailableMods() {
    return CompletableFuture.supplyAsync(() -> {
          List<ModInfoBean> availableMods = fafApiAccessor.getMods();
public Path getPathForMod(ModInfoBean mod) {
  }

  @Override
  @Cacheable(CacheNames.MODS)
  public CompletableFuture<List<ModInfoBean>> lookupMod(String string, int maxResults) {
    return CompletableFuture.supplyAsync(() -> {
      try {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import android.app.Application;
import android.content.Context;

import com.facebook.stetho.Stetho;
import com.squareup.leakcanary.LeakCanary;
import com.squareup.leakcanary.RefWatcher;

import moose.com.ac.data.DbHelper;
import moose.com.ac.util.PreferenceUtil;
/*
    private static DbHelper dbHelper;

    private static RefWatcher refWatcher;

    @Override
    public void onCreate() {
        super.onCreate();
        context = this;
        new PreferenceUtil(this);
        dbHelper = new DbHelper(this);
        if (!isInUnitTests()) {
public static DbHelper getDbHelper() {
        return dbHelper == null ? new DbHelper(context) : dbHelper;
    }

}
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.widget.LinearLayout;
import android.widget.TextView;

    private SearchView searchView;
    private AppCompatTextView userName;
    private CircleImageView logo;
    private LinearLayout linearLayout;

    private boolean searchShow = false;

private void initView() {
        }
        logo = (CircleImageView) drawerHeader.findViewById(R.id.login_userimg);
        userName = (AppCompatTextView) drawerHeader.findViewById(R.id.login_username);
        linearLayout = (LinearLayout) findViewById(R.id.linear_layout);

        TextView textViewComplex = (TextView) findViewById(R.id.tv_complex);
        TextView textViewHot = (TextView) findViewById(R.id.tv_hot);
private void fetchDialog() {

    @Deprecated
    public void snack(String msg) {
        Snackbar snackBar = Snackbar.make(linearLayout, msg, Snackbar.LENGTH_SHORT);
        snackBar.setAction(R.string.snackbar_action, v -> {
            snackBar.dismiss();
        });
public abstract class BaseActivity extends RxAppCompatActivity {

    protected Context mContext;
    protected final UncaughtHandler mUncaughtHandler = new UncaughtHandler();

    protected class UncaughtHandler implements Thread.UncaughtExceptionHandler {
        private final String LINE_SEPARATOR = "\n";

        public UncaughtHandler() {
        }

        @Override
        public void uncaughtException(Thread thread, Throwable exception) {
            StringWriter stackTrace = new StringWriter();
            exception.printStackTrace(new PrintWriter(stackTrace));
            String errorReport = "******** CAUSE OF ERROR ********\n\n" +
                    stackTrace.toString() +
                    "\n******** DEVICE INFORMATION ********\n" +
                    "Brand: " +
                    Build.BRAND +
                    LINE_SEPARATOR +
                    "Device: " +
                    Build.DEVICE +
                    LINE_SEPARATOR +
                    "Model: " +
                    Build.MODEL +
                    LINE_SEPARATOR +
                    "Id: " +
                    Build.ID +
                    LINE_SEPARATOR +
                    "Product: " +
                    Build.PRODUCT +
                    LINE_SEPARATOR +
                    "\n******** FIRMWARE ********\n" +
                    "SDK: " +
                    Build.VERSION.SDK +
                    LINE_SEPARATOR +
                    "Release: " +
                    Build.VERSION.RELEASE +
                    LINE_SEPARATOR +
                    "Incremental: " +
                    Build.VERSION.INCREMENTAL +
                    LINE_SEPARATOR;

            Intent intent = new Intent(mContext, CrashActivity.class);
            intent.putExtra(Config.CRASH, errorReport);
            mContext.startActivity(intent);
            android.os.Process.killProcess(android.os.Process.myPid());
            System.exit(10);
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mContext = this;
        Thread.setDefaultUncaughtExceptionHandler(mUncaughtHandler);
        onInitView(savedInstanceState);
    }

        android:layout_marginTop="?attr/actionBarSize">-->

    <FrameLayout
        android:id="@+id/linear_layout"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_marginBottom="8dp"
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public static void loadDefaultFaces() {
            GUIMain.log("Loaded Twitch faces!");
            GUIMain.currentSettings.saveTwitchFaces();
            doneWithTwitchFaces = true;

            //TODO if currentSettings.FFZFacesEnable
            handleFFZChannel("global");//this corrects the global emotes and downloads them if we don't have them
            GUIMain.channelSet.stream().forEach(s -> handleFFZChannel(s.replaceAll("#", "")));
            doneWithFrankerFaces = true;
            GUIMain.log("Loaded FrankerFaceZ faces!");
            // END TODO
        });
    }

public static Response toggleFace(String faceName) {
                return toReturn;
            }
        }
        String errorMessage = "Could not find face " + faceName + " in the loaded Twitch faces ";
        //TODO if currentSettings.ffzEnable
        Set<String> channels = ffzFaceMap.keySet();
        for (String chan : channels) {
            ArrayList<FrankerFaceZ> faces = ffzFaceMap.get(chan);
            for (FrankerFaceZ f : faces) {
                if (f.getRegex().equalsIgnoreCase(faceName)) {
                    boolean newStatus = !f.isEnabled();
                    f.setEnabled(newStatus);
                    toReturn.setResponseText("Toggled the FrankerFaceZ face " + f.getRegex() + (newStatus ? " ON" : " OFF"));
                    toReturn.wasSuccessful();
                    return toReturn;
                }
            }
        }
        errorMessage += "or loaded FrankerFaceZ faces!";
        //end TODO
        toReturn.setResponseText(errorMessage);
        return toReturn;
    }
public static void handleFaces(Map<Integer, Integer> ranges, Map<Integer, Simple
                break;
            case FRANKER_FACE:
                if (doneWithFrankerFaces) {
                    //TODO check the option to loop through all the loaded ones, as per issue #81
                    //right now we just do loaded specific channel (if existing) & global
                    String[] channels = {"global", channel};
                    for (String currentChannel : channels) {
                        ArrayList<FrankerFaceZ> faces = ffzFaceMap.get(currentChannel);
                        if (faces != null) {
 * @author Nick K
 */
public class AuthorizeAccountGUI extends JFrame {
    public AuthorizeAccountGUI() {
        initComponents();
        if (GUIMain.currentSettings.accountManager.getUserAccount() != null) {
            accountNameField.setText(GUIMain.currentSettings.accountManager.getUserAccount().getName());
private void authorizeButtonActionPerformed() {
            if (boxEditStream.isSelected()) URL += "+channel_editor";
            if (boxFollowed.isSelected()) URL += "+user_follows_edit";
            Utils.openWebPage(URL);
            TokenListener tl = new TokenListener(this);
            tl.start();
        }
    }

private void initComponents() {
        closeButton.setText("Close");
        closeButton.setFocusable(false);
        closeButton.addActionListener(e -> closeButtonActionPerformed());

        GroupLayout contentPaneLayout = new GroupLayout(contentPane);
        contentPane.setLayout(contentPaneLayout);
        contentPaneLayout.setHorizontalGroup(
public String getViewerCountString() {
     * This is the main boolean to check to see if this tab should pulse.
     * <p>
     * This boolean checks to see if the tab wasn't toggled, if it's visible (not in a combined tab),
     * and if it's not selected. TODO check for global setting of pulsing tabs
     *
     * @return True if this tab should pulse, else false.
     */
    public boolean shouldPulse() {
        boolean shouldPulseLocal = (this instanceof CombinedChatPane) ?
                ((CombinedChatPane) this).getActiveChatPane().shouldPulseLoc() : shouldPulseLoc;
        return shouldPulseLocal && isTabVisible() && GUIMain.channelPane.getSelectedIndex() != index && index != 0;
    }

    private boolean shouldPulseLoc = true;
public void onMessage(MessageWrapper m, boolean showChannel) {
            if (u.isGlobalMod()) {
                insertIcon(m, IconEnum.GLOBALMOD, null);
            }
            //TODO if GUIMain.currentSettings.donorsEnabled
            if (u.isDonor()) {
                insertIcon(m, u.getDonationStatus(), null);
            }
            if (u.isStaff()) {
                insertIcon(m, IconEnum.STAFF, null);
private void findEmoticons(String text, Map<Integer, Integer> ranges, Map<Intege
        if (u != null && u.getEmotes() != null) {
            FaceManager.handleFaces(ranges, rangesStyle, text, FaceManager.FACE_TYPE.TWITCH_FACE, null, u.getEmotes());
        }
        //TODO if (currentSettings.FFZFaceEnabled)
        FaceManager.handleFaces(ranges, rangesStyle, text, FaceManager.FACE_TYPE.FRANKER_FACE, channel, null);
    }

    protected void print(MessageWrapper wrapper, String string, SimpleAttributeSet set) {
public void onIconMessage(MessageWrapper m, IconEnum status) {
        try {
            Message message = m.getLocal();
            print(m, "\n", GUIMain.norm);
            for (int i = 0; i < 5; i++) {
                insertIcon(m, status, (status == IconEnum.SUBSCRIBER ? message.getChannel() : null));
            }
            print(m, " " + message.getContent() + (status == IconEnum.SUBSCRIBER ? (" (" + (subCount + 1) + ") ") : " "), GUIMain.norm);
            for (int i = 0; i < 5; i++) {
                insertIcon(m, status, (status == IconEnum.SUBSCRIBER ? message.getChannel() : null));
            }
        } catch (Exception e) {
public void deletePane() {
        if (GUIMain.currentSettings.logChat) {
            Utils.logChat(getText().split("\\n"), chan, 2);
        }
        //TODO ensure the viewer list & other popped out GUIs are deleted
        if (getPoppedOutPane() != null) {
            getPoppedOutPane().dispose();
        }
public void mouseReleased(MouseEvent e) {
                            menuItem.addActionListener(listener);
                            popupMenu.add(menuItem);

                            //TODO if (GUIMain.currentSettings.pulseTabs) {
                            menuItem = new JMenuItem("Toggle Tab Pulsing " + (first ? (detected.shouldPulseLoc() ? "OFF" : "ON") : (detectedCombo.shouldPulseLoc() ? "OFF" : "ON")));
                            menuItem.addActionListener(listener);
                            popupMenu.add(menuItem);
                            //}
                            if (first) {
                                menuItem = new JMenuItem("Go to " + detected.getChannel() + "'s channel");
                                menuItem.addActionListener(listener);
private void initComponents() {

        //---- label4 ----
        label4.setIcon(new ImageIcon(getClass().getResource("/image/icon70.png")));

        GroupLayout contentPaneLayout = new GroupLayout(contentPane);
        contentPane.setLayout(contentPaneLayout);
        contentPaneLayout.setHorizontalGroup(
public GUIMain() {
        heartbeat.addHeartbeatThread(new ViewerCount());
        heartbeat.addHeartbeatThread(new UserManager());
        heartbeat.addHeartbeatThread(new BanQueue());
        //TODO if (GUISettings.trackDonations)
        heartbeat.addHeartbeatThread(new DonationCheck());
        heartbeat.start();
    }


    private static String lastSoundDir = "";

    GUISounds_2 s2;
    AuthorizeAccountGUI mainAccGUI;

    public GUISettings() {
        initComponents();
public void keyReleased(KeyEvent e) {
            label1.setOpaque(false);
            scrollPane2.setViewportView(label1);
        }

        GroupLayout contentPaneLayout = new GroupLayout(contentPane);
        contentPane.setLayout(contentPaneLayout);
        contentPaneLayout.setHorizontalGroup(
public void keyReleased(KeyEvent e) {
    public static JScrollPane scrollPane2;
    public static JTextArea label1;
    // JFormDesigner - End of variables declaration  //GEN-END:variables

}
private void initComponents() {
        skipButton.setFocusable(false);
        skipButton.addActionListener(e -> skipButtonActionPerformed());

        GroupLayout contentPaneLayout = new GroupLayout(contentPane);
        contentPane.setLayout(contentPaneLayout);
        contentPaneLayout.setHorizontalGroup(
private void initComponents() {
    public static JButton downloadButton;
    public static JButton skipButton;
    // JFormDesigner - End of variables declaration  //GEN-END:variables


}
public GUIViewerList(String channel) {
    public synchronized void updateCategory(ViewerType type, HashSet<String> names) {
        final DefaultMutableTreeNode node;
        Enumeration<TreePath> userPath = getExpandedDescendants();
        switch (type) {
            case STAFF:
                staff.removeAllChildren();
public synchronized void updateCategory(ViewerType type, HashSet<String> names)
            if (!names.isEmpty()) {
                names.stream().sorted().forEach(s -> node.add(new DefaultMutableTreeNode(s)));
            }
            updateRoot(userPath);
        }
    }

    private synchronized void updateRoot(Enumeration<TreePath> userPath) {
        DefaultMutableTreeNode root = default_root;
        root.removeAllChildren();
        if (staff.getChildCount() > 0) root.add(staff);
private synchronized void updateRoot(Enumeration<TreePath> userPath) {
                viewerTree.expandPath(userPath.nextElement());
            }
        }
    }

    private void setViewerTreeModel(DefaultTreeModel model) {
private void initComponents(String channel) {
        // JFormDesigner - Component initialization - DO NOT MODIFY  //GEN-BEGIN:initComponents
        // Generated using JFormDesigner Evaluation license - Nick K
        searchBar = new JTextField();
        JScrollPane scrollPane2 = new JScrollPane();
        viewerTree = new JTree();

        //======== this ========
public void mouseReleased(MouseEvent e) {
                    }
                }
            });
            scrollPane2.setViewportView(viewerTree);
        }
        setMinimumSize(new Dimension(250, 490));
        GroupLayout contentPaneLayout = new GroupLayout(contentPane);
        contentPane.setLayout(contentPaneLayout);
        contentPaneLayout.setHorizontalGroup(
                contentPaneLayout.createParallelGroup()
                        .addComponent(searchBar, GroupLayout.DEFAULT_SIZE, 179, Short.MAX_VALUE)
                        .addComponent(scrollPane2, GroupLayout.DEFAULT_SIZE, 179, Short.MAX_VALUE)
        );
        contentPaneLayout.setVerticalGroup(
                contentPaneLayout.createParallelGroup()
                        .addGroup(GroupLayout.Alignment.TRAILING, contentPaneLayout.createSequentialGroup()
                                .addComponent(searchBar, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(scrollPane2, GroupLayout.DEFAULT_SIZE, 423, Short.MAX_VALUE))
        );
        addWindowListener(new WindowAdapter() {
            @Override
public void windowClosing(WindowEvent e) {
    // Generated using JFormDesigner Evaluation license - Nick K
    private JTextField searchBar;
    private JTree viewerTree;
}
public void run() {
                }
            } catch (Exception e) {
                GUIMain.log(e);
            }
        }
    }
private String makeHeader() {
        header += "Content-Type: text/html; charset=UTF-8\n\n";
        return header;
    }
}
public void onMessage(String channel, String sender, String message) {
                            break;
                        case PLAY_ADVERT:
                            if (key != null) {
                                playAdvert(key, first, channel);
                            }
                            break;
                        case START_RAFFLE:
public void onMessage(String channel, String sender, String message) {
                            commandResponse = APIRequests.Twitch.getUptimeString(channel.substring(1));
                            break;
                        case SEE_PREV_SOUND_DON:
                            //TODO if currentSettings.seePreviousDonEnable
                            if (GUIMain.currentSettings.loadedDonationSounds)
                                commandResponse = SoundEngine.getEngine().getLastDonationSound();
                            break;
                        case SEE_PREV_SOUND_SUB:
                            //TODO if currentSettings.seePreviousSubEnable
                            if (GUIMain.currentSettings.loadedSubSounds)
                                commandResponse = SoundEngine.getEngine().getLastSubSound();
                            break;
                        case SEE_OR_SET_REPLY_TYPE:
                            commandResponse = parseReplyType(first, botnakUserName);
public Response playAdvert(Oauth key, String first, String channel) {
                    SimpleDateFormat sdf = new SimpleDateFormat("m:ss");
                    Date d = new Date(diff);
                    Date toPlay = new Date(480000 - diff);
                    r.setResponseText("Error playing last ad! Last ad was was only " + sdf.format(d)
                            + " ago! You must wait " + sdf.format(toPlay) + " to play another ad!");
                }
            }
public void doConnect(String channel) {
        GUIMain.currentSettings.accountManager.addTask(new Task(getViewer(), Task.Type.JOIN_CHANNEL, channel));
        if (GUIMain.currentSettings.logChat) Utils.logChat(null, channel, 0);
        if (!GUIMain.channelSet.contains(channel)) GUIMain.channelSet.add(channel);
        //TODO if currentSettings.FFZFacesEnable
        if (FaceManager.doneWithFrankerFaces)
            FaceManager.handleFFZChannel(channel.substring(1));
    }

    /**
public synchronized void onClearChat(String channel, String name) {
        if (name != null) {
            BanQueue.addToMap(channel, name);
        } else {
            //TODO perhaps add the option to actually clear the chat based on user setting?
            MessageQueue.addMessage(new Message().setChannel(channel).setType(Message.MessageType.BAN_NOTIFY)
                    .setContent("The chat was cleared by a moderator. (Prevented by Botnak)"));
        }
public void beat() {
                    Utils.parseBufferedReader(br, stanSB, false);
                    JSONObject site = new JSONObject(stanSB.toString());
                    JSONObject chatters = site.getJSONObject("chatters");
                    JSONArray mods = chatters.getJSONArray("moderators");
                    for (int i = 0; i < mods.length(); i++) {
                        collectedUsers.add(mods.getString(i));
                    }
                    list.updateCategory(GUIViewerList.ViewerType.MOD, collectedUsers);
                    collectedUsers.clear();
                    JSONArray staff = chatters.getJSONArray("staff");
                    for (int i = 0; i < staff.length(); i++) {
                        User u = new User(staff.getString(i));
                        u.setStaff(true);
                        addUser(u);
                        collectedUsers.add(staff.getString(i));
                    }
                    list.updateCategory(GUIViewerList.ViewerType.STAFF, collectedUsers);
                    collectedUsers.clear();
                    JSONArray admins = chatters.getJSONArray("admins");
                    for (int i = 0; i < admins.length(); i++) {
                        User u = new User(admins.getString(i));
                        u.setAdmin(true);
                        addUser(u);
                        collectedUsers.add(admins.getString(i));
                    }
                    list.updateCategory(GUIViewerList.ViewerType.ADMIN, collectedUsers);
                    collectedUsers.clear();
                    JSONArray global_mods = chatters.getJSONArray("global_mods");
                    for (int i = 0; i < global_mods.length(); i++) {
                        User u = new User(global_mods.getString(i));
                        u.setGlobalMod(true);
                        addUser(u);
                        collectedUsers.add(global_mods.getString(i));
                    }
                    list.updateCategory(GUIViewerList.ViewerType.GLOBAL_MOD, collectedUsers);
                    collectedUsers.clear();
                    JSONArray viewers = chatters.getJSONArray("viewers");
                    for (int i = 0; i < viewers.length(); i++) {
                        collectedUsers.add(viewers.getString(i));
                    }
                    list.updateCategory(GUIViewerList.ViewerType.VIEWER, collectedUsers);
                    collectedUsers.clear();
                    Thread.sleep(750);
                } catch (Exception e) {
                    e.printStackTrace();
public void beat() {
        }
    }

    private void addUser(User u) {
        if (getChannelManager().getUser(u.getNick(), false) == null)
            getChannelManager().addUser(u);
public static void checkAndAdd(ArrayList<String> list, String... toAdd) {
    }

    /**
     * Checks to see if the file(s)  is (are) actually existing and non-blank.
     *
     * @param files The path(s) to the file(s) to check.
     * @return true if (all) the file(s) exist(s)
public static void logChat(String[] message, String channel, int type) {
    }

    /**
     * Removes a file extension from a path.
     *
     * @param s The path to a file, or the file name with its extension.
     * @return The file/path name without the extension.
    public String date;
    public float soundVolumeGain = 100;

    public Settings() {//default account
        modIcon = Settings.class.getResource("/image/mod.png");
        broadIcon = Settings.class.getResource("/image/broad.png");
public Settings() {//default account
        long time = System.currentTimeMillis();
        SimpleDateFormat sdf = new SimpleDateFormat("dd-MM-yy");
        date = sdf.format(new Date(time));
        logDir.mkdirs();
        font = new Font("Calibri", Font.PLAIN, 18);
        defaultDir.mkdirs();
        faceDir.mkdirs();
public Settings() {//default account
        subIconsDir.mkdirs();
        subSoundDir.mkdirs();
        donationSoundDir.mkdirs();
        //TODO if frankerFaceZEnable
        frankerFaceZDir.mkdirs();
    }

    /**
public void load() {
                GUIMain.log("Loading name faces...");
                loadNameFaces();
            }
            //TODO if frankerFaceZEnable
            if (frankerFaceZDir.exists() && frankerFaceZDir.length() > 0) {
                GUIMain.log("Loading FrankerFaceZ faces...");
                loadFFZFaces();
            }
            GUIMain.log("Loading keywords...");
            loadKeywords();//first time boot adds the username
public void loadPropData(int type) {
                }
                cleanupChat = Boolean.parseBoolean(p.getProperty("ClearChat", "true"));
                logChat = Boolean.parseBoolean(p.getProperty("LogChat", "false"));
                chatMax = Integer.parseInt(p.getProperty("MaxChat", "100"));
                faceMaxHeight = Integer.parseInt(p.getProperty("FaceMaxHeight", "20"));
                font = Utils.stringToFont(p.getProperty("Font").split(","));
public void updateSubscriber(User u, String channel, boolean currentlyActive) {

                    //or twitchnotify could have been a douchenozzle and did not send the message
                    String content = s.get().getName() + " has RE-subscribed offline!";
                    //TODO if currentSettings.sendSubMessages {
                    GUIMain.currentSettings.accountManager.getBot().sendMessage(channel, ".me " + u.getNick() + " has just RE-subscribed!");
                    MessageQueue.addMessage(new Message().setContent(content).setType(Message.MessageType.SUB_NOTIFY).setChannel(channel));
                    s.get().resetStreak();
                    s.get().setStarted(LocalDateTime.now());
public void updateSubscriber(User u, String channel, boolean currentlyActive) {
                // this is a new, offline sub. Botnak is going to throw a new sub message just
                // as if they had subbed the instant they sent the message
                //or twitchnotify could have been a douchenozzle and did not send the message
                //TODO if currentSettings.sendSubMessages {
                GUIMain.currentSettings.accountManager.getBot().sendMessage(channel, ".me " + u.getNick() + " has just subscribed!");
                String content = u.getNick().toLowerCase() + " has subscribed offline!";
                MessageQueue.addMessage(new Message().setContent(content).setType(Message.MessageType.SUB_NOTIFY).setChannel(channel));
                addSub(new Subscriber(u.getNick().toLowerCase(), LocalDateTime.now(), true, 0));
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public ReturnType call() throws Exception {
    }

    public static <T> Dao<T, String> initialiseDao(SQLiteOpenHelper openHelper, Class<T> domainClass) throws SQLException {
        ConnectionSource connectionSource = new AndroidConnectionSource(openHelper);
        return createDao(connectionSource, domainClass);
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        implements
        FragmentManager.OnBackStackChangedListener,
        Theme.ChangeableTheme,
        BowlerFragment.OnBowlerSelectedListener,
        LeagueEventFragment.OnLeagueSelectedListener,
        SeriesFragment.SeriesListener,
        GameFragment.GameFragmentCallbacks,
        NavigationDrawerAdapter.NavigationCallback
{

/**
 * Created by Joseph Roque on 15-03-13. Manages the UI to display information about the bowlers
 * being tracked by the application, and offers a callback interface {@link
 * BowlerFragment.OnBowlerSelectedListener} for handling interactions.
 */
@SuppressWarnings("Convert2Lambda")
public class BowlerFragment
    private NameAverageAdapter<Bowler> mAdapterBowlers;

    /** Callback listener for user events related to bowlers. */
    private OnBowlerSelectedListener mBowlerSelectedListener;
    /** Callback listener for user events related to leagues. */
    private LeagueEventFragment.OnLeagueSelectedListener mLeagueSelectedListener;
    /** Callback listener for user events related to series. */
    private SeriesFragment.SeriesListener mSeriesListener;

    /** List to store bowler data from bowler table in database. */
    private List<Bowler> mListBowlers;
public void onAttach(Activity activity)
         */
        try
        {
            mBowlerSelectedListener = (OnBowlerSelectedListener) activity;
            mLeagueSelectedListener = (LeagueEventFragment.OnLeagueSelectedListener) activity;
            mSeriesListener = (SeriesFragment.SeriesListener) activity;
        }
        catch (ClassCastException ex)
        {
public void onAttach(Activity activity)
    }

    @Override
    public View onCreateView(LayoutInflater inflater,
                             ViewGroup container,
                             Bundle savedInstanceState)
public void onClick(DialogInterface dialog, int which)
                                Bowler quickBowler = new Bowler(mQuickBowlerId,
                                        mQuickBowlerName,
                                        (short) 0);
                                mBowlerSelectedListener.onBowlerSelected(quickBowler, false, true);
                                mLeagueSelectedListener.onLeagueSelected(new LeagueEvent(
                                                mQuickLeagueId,
                                                mQuickLeagueName,
                                                (short) 0,
                                                mQuickNumberOfGames),
                                        false);
                                mSeriesListener.onCreateNewSeries(false);
                            }
                            else
                            {
                                Bowler recentBowler = new Bowler(mRecentBowlerId,
                                        mRecentBowlerName,
                                        (short) 0);
                                mBowlerSelectedListener.onBowlerSelected(recentBowler, false, true);
                                mLeagueSelectedListener.onLeagueSelected(new LeagueEvent(
                                                mRecentLeagueId,
                                                mRecentLeagueName,
                                                (short) 0,
                                                mRecentNumberOfGames),
                                        false);
                                mSeriesListener.onCreateNewSeries(false);
                            }
                            dialog.dismiss();
                        }
protected void onPostExecute(Bowler result)
                return;

            //Creates new instance of LeagueEventFragment for bowler
            fragment.mBowlerSelectedListener.onBowlerSelected(result, true, false);
        }
    }

protected void onPostExecute(Bowler newBowler)
     * Container Activity must implement this interface to allow LeagueEventFragment to be loaded
     * when a bowler is selected.
     */
    public interface OnBowlerSelectedListener
    {

        /**
/**
 * Created by Joseph Roque on 15-03-18. Manages the UI to display information about the games being
 * tracked by the application, and offers a callback interface {@link
 * GameFragment.GameFragmentCallbacks} for handling interactions.
 */
@SuppressWarnings({"Convert2Lambda", "CheckStyle"})
public class GameFragment
    private TextView mTextViewAutoAdvance;

    /** Instance of callback interface for handling user events. */
    private GameFragmentCallbacks mCallback;

    /** Ids which represent current games that are available to be edited. */
    private long[] mGameIds;
public void run()
                                alterPinState((byte) i, false);
                        }
                    }
                    mCallback.resetAutoAdvanceTimer();
                    break;
                default:
                    // does nothing
public void onAttach(Activity activity)
         */
        try
        {
            mCallback = (GameFragmentCallbacks) activity;
        }
        catch (ClassCastException ex)
        {
public void onAttach(Activity activity)
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
public void onResume()
                ? Integer.valueOf(strDelay.substring(0, strDelay.indexOf(" ")))
                : 0;

        mCallback.setAutoAdvanceConditions(mImageViewNextBall,
                mTextViewAutoAdvance,
                autoAdvanceEnabled,
                autoAdvanceDelay);
        mCallback.stopAutoAdvanceTimer();

        //Loads scores of games being edited from database
        loadInitialScores();
        //Loads first game to edit
        loadGameFromDatabase(mCurrentGame);
        mCallback.loadGameScoresForDrawer(mGameIds);
    }

    @Override
public boolean onOptionsItemSelected(MenuItem item)

            case R.id.action_series_stats:
                //Displays all stats related to series of games
                mCallback.onSeriesStatsOpened();
                return true;

            case R.id.action_reset_game:
public boolean onOptionsItemSelected(MenuItem item)

            case R.id.action_stats:
                //Displays all stats related to current game
                mCallback.onGameStatsOpened(mGameIds[mCurrentGame], (byte) (mCurrentGame + 1));
                return true;

            default:
public void onClick(DialogInterface dialog, int which)
        mGameScoresMinusFouls[mCurrentGame] = scoreToSet;
        clearAllText(false);
        getActivity().supportInvalidateOptionsMenu();
        mCallback.updateGameScore((byte) (mCurrentGame + 1),
                mGameScoresMinusFouls[mCurrentGame]);
        saveGame(true);
    }

public void onClick(View v)
                            updateBalls(mCurrentFrame, (byte) 0);
                        updateScore();
                        updateFrameColor(false);
                        mCallback.stopAutoAdvanceTimer();
                        break;
                    default:
                        throw new RuntimeException("Invalid frame id");
public void onClick(View v)
                            showSetMatchPlayLockedDialog();
                        else
                            showSetMatchPlayDialog();
                        mCallback.stopAutoAdvanceTimer();
                        break;

                    case R.id.iv_lock:
public void onClick(View v)
                        if (mManualScoreSet[mCurrentGame])
                            return;
                        setGameLocked(!mGameLocked[mCurrentGame]);
                        mCallback.stopAutoAdvanceTimer();
                        break;

                    case R.id.iv_foul:
public void onClick(View v)
                            return;
                        mFouls[mCurrentFrame][mCurrentBall] = !mFouls[mCurrentFrame][mCurrentBall];
                        updateFouls();
                        mCallback.resetAutoAdvanceTimer();
                        break;

                    case R.id.iv_reset_frame:
public void onClick(View v)
                        updateFrameColor(false);
                        updateBalls(mCurrentFrame, (byte) 0);
                        updateScore();
                        mCallback.stopAutoAdvanceTimer();
                        break;

                    case R.id.iv_clear:
                        clearPins();
                        mCallback.resetAutoAdvanceTimer();
                        break;

                    case R.id.iv_next_ball:
else if (++mCurrentBall == 3)
                        mHasFrameBeenAccessed[mCurrentFrame] = true;
                        setVisibilityOfNextAndPrevItems();
                        updateFrameColor(false);
                        mCallback.stopAutoAdvanceTimer();
                        break;

                    case R.id.iv_prev_ball:
else if (++mCurrentBall == 3)
                        }
                        setVisibilityOfNextAndPrevItems();
                        updateFrameColor(false);
                        mCallback.stopAutoAdvanceTimer();
                        break;

                    default:
public void onClick(View v)
                                updateBalls(mCurrentFrame, (byte) 0);
                            updateScore();
                            updateFrameColor(false);
                            mCallback.stopAutoAdvanceTimer();
                            break;
                        }
                    }
public void run()
                        .setText(mFouls[mCurrentFrame][mCurrentBall]
                                ? "F"
                                : "");
                mCallback.updateGameScore((byte) (mCurrentGame + 1),
                        mGameScoresMinusFouls[mCurrentGame]);
            }
        });
    }
private void loadGameFromDatabase(final byte newGame)
            public void run()
            {
                mCurrentGame = newGame;
                mCallback.onGameChanged(mCurrentGame);
                SQLiteDatabase database =
                        DatabaseHelper.getInstance(getActivity()).getReadableDatabase();

public byte getCurrentGame()
    /**
     * Callback interface offers methods upon user interaction.
     */
    public interface GameFragmentCallbacks
    {

        /**
/**
 * Created by Joseph Roque on 15-03-15. Manages the UI to display information about the leagues
 * being tracked by the application, and offers a callback interface {@link
 * LeagueEventFragment.OnLeagueSelectedListener} for handling interactions.
 */
@SuppressWarnings("Convert2Lambda")
public class LeagueEventFragment
    private NameAverageAdapter<LeagueEvent> mAdapterLeagueEvents;

    /** Callback listener for user events related to leagues. */
    private OnLeagueSelectedListener mLeagueSelectedListener;
    /** Callback listener for user events related to series. */
    private SeriesFragment.SeriesListener mSeriesListener;

    /** List to store league / event data from league / event table in database. */
    private List<LeagueEvent> mListLeaguesEvents;
public void onAttach(Activity activity)
         */
        try
        {
            mLeagueSelectedListener = (OnLeagueSelectedListener) activity;
            mSeriesListener = (SeriesFragment.SeriesListener) activity;
        }
        catch (ClassCastException ex)
        {
public void onAttach(Activity activity)
    }

    @Override
    public View onCreateView(LayoutInflater inflater,
                             ViewGroup container,
                             Bundle savedInstanceState)
public boolean onOptionsItemSelected(MenuItem item)
        {
            case R.id.action_stats:
                //Displays stats of current bowler in a new StatsFragment
                mLeagueSelectedListener.onBowlerStatsOpened();
                return true;
            default:
                return super.onOptionsItemSelected(item);
private OpenLeagueEventSeriesTask(LeagueEventFragment fragment)
                }
                else
                    cursor.close();
                    throw new RuntimeException("Event series id could not be loaded from database");
            }
            else
                return Pair.create(selectedLeagueEvent, new Series(-1, null, null));
protected void onPostExecute(Pair<LeagueEvent, Series> result)
                 * displaying the event's corresponding series
                 */

                fragment.mLeagueSelectedListener.onLeagueSelected(result.first, false);
                fragment.mSeriesListener.onSeriesSelected(result.second, true);
            }
            else
            {
protected void onPostExecute(Pair<LeagueEvent, Series> result)
                            .apply();
                }

                fragment.mLeagueSelectedListener.onLeagueSelected(result.first, true);
            }
        }
    }
protected void onPostExecute(LeagueEvent result)
     * Container Activity must implement this interface to allow SeriesFragment/GameFragment to be
     * loaded when a league/event is selected.
     */
    public interface OnLeagueSelectedListener
    {

        /**

/**
 * Created by Joseph Roque on 15-03-17. Manages the UI to display information about the series being
 * tracked by the application, and offers a callback interface {@link SeriesFragment.SeriesListener}
 * for handling interactions.
 */
@SuppressWarnings("Convert2Lambda")
public class SeriesFragment
    private SeriesAdapter mAdapterSeries;

    /** Callback listener for user events related to series. */
    private SeriesListener mSeriesListener;

    /** List to store series data from series table in database. */
    private List<Series> mListSeries;
public void onCreate(Bundle savedInstaceState)
    public void onAttach(Activity activity)
    {
        super.onAttach(activity);

        /*
         * This makes sure the container Activity has implemented
         * the callback interface. If not, an exception is thrown
         */
        try
        {
            mSeriesListener = (SeriesListener) activity;
        }
        catch (ClassCastException ex)
        {
public void onAttach(Activity activity)
    }

    @Override
    public View onCreateView(LayoutInflater inflater,
                             ViewGroup container,
                             Bundle savedInstanceState)
public boolean onOptionsItemSelected(MenuItem item)
                showEditDateDialog();
                return true;
            case R.id.action_stats:
                mSeriesListener.onLeagueStatsOpened();
                return true;
            default:
                return super.onOptionsItemSelected(item);
public void updateTheme()
    public void onSItemClick(final int position)
    {
        //When series is clicked, its games are displayed in a new GameFragment
        mSeriesListener.onSeriesSelected(mListSeries.get(position), false);
    }

    @Override
public void run()
    @Override
    public void onFabClick()
    {
        mSeriesListener.onCreateNewSeries(false);
    }

    /**
protected void onPostExecute(List<Series> listSeries)
     * Container Activity must implement this interface to allow GameFragment/StatsFragment to be
     * loaded when a series is selected.
     */
    public interface SeriesListener
    {

        /**
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private BitSet getAndLoadIfNotPresent(final Query query, final LeafReaderContext
        }
        final IndexReader.CacheKey coreCacheReader = cacheHelper.getKey();
        final ShardId shardId = ShardUtils.extractShardId(context.reader());
        if (shardId != null // can't require it because of the percolator
                && indexSettings.getIndex().equals(shardId.getIndex()) == false) {
            // insanity
            throw new IllegalStateException("Trying to load bit set for index " + shardId.getIndex()
                    + " with cache of index " + indexSettings.getIndex());
package org.elasticsearch.search.aggregations;

import org.apache.lucene.index.CompositeReaderContext;
import org.apache.lucene.index.IndexReaderContext;
import org.apache.lucene.index.LeafReaderContext;
import org.apache.lucene.search.Collector;
import org.elasticsearch.cluster.metadata.IndexMetaData;
import org.elasticsearch.common.lease.Releasable;
import org.elasticsearch.common.lease.Releasables;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.common.util.MockBigArrays;
import org.elasticsearch.index.IndexSettings;
import org.elasticsearch.index.cache.bitset.BitsetFilterCache;
import org.elasticsearch.index.cache.bitset.BitsetFilterCache.Listener;
import org.elasticsearch.index.mapper.ObjectMapper.Nested;
import org.elasticsearch.index.query.QueryShardContext;
import org.elasticsearch.index.query.support.NestedScope;
import org.elasticsearch.indices.breaker.CircuitBreakerService;
import org.elasticsearch.indices.breaker.NoneCircuitBreakerService;
import org.elasticsearch.indices.fielddata.cache.IndicesFieldDataCache;
public String toString() {
            return "ShardSearcher(" + ctx.get(0) + ")";
        }
    }
}
public void testNoDocs() throws IOException {
            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {
                // intentionally not writing any docs
            }
            try (IndexReader indexReader = DirectoryReader.open(directory)) {
                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG,
                    NESTED_OBJECT);
                MaxAggregationBuilder maxAgg = new MaxAggregationBuilder(MAX_AGG_NAME)
public void testSingleNestingMax() throws IOException {
                }
                iw.commit();
            }
            try (IndexReader indexReader = DirectoryReader.open(directory)) {
                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG,
                    NESTED_OBJECT);
                MaxAggregationBuilder maxAgg = new MaxAggregationBuilder(MAX_AGG_NAME)
public void testDoubleNestingMax() throws IOException {
                }
                iw.commit();
            }
            try (IndexReader indexReader = DirectoryReader.open(directory)) {
                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG,
                    NESTED_OBJECT + "." + NESTED_OBJECT2);
                MaxAggregationBuilder maxAgg = new MaxAggregationBuilder(MAX_AGG_NAME)
public void testOrphanedDocs() throws IOException {
                iw.addDocuments(documents);
                iw.commit();
            }
            try (IndexReader indexReader = DirectoryReader.open(directory)) {
                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG,
                    NESTED_OBJECT);
                SumAggregationBuilder sumAgg = new SumAggregationBuilder(SUM_AGG_NAME)
public void testResetRootDocId() throws Exception {
                iw.commit();
                iw.close();
            }
            try (IndexReader indexReader = DirectoryReader.open(directory)) {

                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG,
                    "nested_field");
public void testNoDocs() throws IOException {
            try (RandomIndexWriter iw = new RandomIndexWriter(random(), directory)) {
                // intentionally not writing any docs
            }
            try (IndexReader indexReader = DirectoryReader.open(directory)) {
                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG,
                        NESTED_OBJECT);
                ReverseNestedAggregationBuilder reverseNestedBuilder
public void testMaxFromParentDocs() throws IOException {
                }
                iw.commit();
            }
            try (IndexReader indexReader = DirectoryReader.open(directory)) {
                NestedAggregationBuilder nestedBuilder = new NestedAggregationBuilder(NESTED_AGG,
                        NESTED_OBJECT);
                ReverseNestedAggregationBuilder reverseNestedBuilder
import org.apache.lucene.analysis.DelegatingAnalyzerWrapper;
import org.apache.lucene.index.BinaryDocValues;
import org.apache.lucene.index.DirectoryReader;
import org.apache.lucene.index.IndexWriter;
import org.apache.lucene.index.IndexWriterConfig;
import org.apache.lucene.index.LeafReader;
import org.apache.lucene.index.memory.MemoryIndex;
import org.apache.lucene.search.BooleanClause;
import org.apache.lucene.search.BooleanQuery;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.Query;
import org.apache.lucene.search.Weight;
import org.apache.lucene.store.RAMDirectory;
import org.apache.lucene.util.BytesRef;
import org.elasticsearch.ElasticsearchException;
import org.elasticsearch.ResourceNotFoundException;
import org.elasticsearch.common.xcontent.XContentParser;
import org.elasticsearch.common.xcontent.XContentType;
import org.elasticsearch.index.analysis.FieldNameAnalyzer;
import org.elasticsearch.index.mapper.DocumentMapper;
import org.elasticsearch.index.mapper.DocumentMapperForType;
import org.elasticsearch.index.mapper.MappedFieldType;
import org.elasticsearch.index.query.QueryRewriteContext;
import org.elasticsearch.index.query.QueryShardContext;
import org.elasticsearch.index.query.QueryShardException;

import java.io.IOException;
import java.util.Objects;
protected Analyzer getWrappedAnalyzer(String fieldName) {
            docSearcher.setQueryCache(null);
        }

        Version indexVersionCreated = context.getIndexSettings().getIndexVersionCreated();
        boolean mapUnmappedFieldsAsString = context.getIndexSettings()
                .getValue(PercolatorFieldMapper.INDEX_MAP_UNMAPPED_FIELDS_AS_STRING_SETTING);
        // We have to make a copy of the QueryShardContext here so we can have a unfrozen version for parsing the legacy
        // percolator queries
        QueryShardContext percolateShardContext = new QueryShardContext(context);
        MappedFieldType fieldType = context.fieldMapper(field);
        if (fieldType == null) {
            throw new QueryShardException(context, "field [" + field + "] does not exist");
public Weight createNormalizedWeight(Query query, boolean needsScores) throws IO
        };
    }

}
import org.elasticsearch.action.support.WriteRequest;
import org.elasticsearch.common.bytes.BytesArray;
import org.elasticsearch.common.bytes.BytesReference;
import org.elasticsearch.common.xcontent.XContentBuilder;
import org.elasticsearch.common.xcontent.XContentFactory;
import org.elasticsearch.common.xcontent.XContentType;
import org.elasticsearch.index.mapper.MapperParsingException;
import org.elasticsearch.index.query.MatchPhraseQueryBuilder;
import org.elasticsearch.index.query.MultiMatchQueryBuilder;
import org.elasticsearch.script.Script;
import org.elasticsearch.script.ScriptType;
import org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder;
import org.elasticsearch.search.sort.SortOrder;
import org.elasticsearch.test.ESSingleNodeTestCase;

        protected Map<String, Function<Map<String, Object>, Object>> pluginScripts() {
            Map<String, Function<Map<String, Object>, Object>> scripts = new HashMap<>();
            scripts.put("1==1", vars -> Boolean.TRUE);
            return scripts;
        }
    }
public void testPercolateQueryWithNestedDocuments() throws Exception {
        assertHitCount(response, 0);
    }

    public void testPercolatorQueryViaMultiSearch() throws Exception {
        createIndex("test", client().admin().indices().prepareCreate("test")
            .addMapping("type", "field1", "type=text")
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.util.Collections;
import java.util.IdentityHashMap;
import java.util.Map;

final class ViewGroupDescriptor extends ChainedDescriptor<ViewGroup> {
  private final Map<ViewGroup, ElementContext> mElementToContextMap =
      Collections.synchronizedMap(new IdentityHashMap<ViewGroup, ElementContext>());

  public ViewGroupDescriptor() {
  }

protected void onUnhook(ViewGroup element) {
    context.unhook();
  }

  @Override
  protected void onGetChildren(ViewGroup element, Accumulator<Object> children) {
    ElementContext context = mElementToContextMap.get(element);
    context.getChildren(children);
  }

  private final class ElementContext {
    // This is a cache that maps from a View to the Fragment that contains it. If the
    // View isn't contained by a Fragment, then this maps the View to itself.
    // For Views contained by Fragments, we emit the Fragment instead, and then let
    // the Fragment's descriptor emit the View as its sole child. This allows us to
    // see Fragments in the inspector as part of the UI tree.
    private final Map<View, Object> mViewToElementMap =
        Collections.synchronizedMap(new IdentityHashMap<View, Object>());

    private ViewGroup mElement;
    private boolean mIsDecorView;

public void hook(ViewGroup element) {
    public void unhook() {
      if (mElement != null) {
        mElement = null;
        mViewToElementMap.clear();
      }
    }

public void getChildren(Accumulator<Object> children) {
      for (int i = 0, N = mElement.getChildCount(); i < N; ++i) {
        final View child = mElement.getChildAt(i);
        if (isChildVisible(child)) {
          final Object element = getElementForView(child);
          children.store(element);
        }
      }
public void getChildren(Accumulator<Object> children) {
    private boolean isChildVisible(View child) {
      return !mIsDecorView || !(child instanceof DOMHiddenView);
    }

    private Object getElementForView(View view) {
      if (view == null) {
        return null;
      }

      Object element = mViewToElementMap.get(view);
      if (element != null) {
        return element;
      }

      Object fragment = FragmentCompatUtil.findFragmentForView(view);
      if (fragment != null) {
        mViewToElementMap.put(view, fragment);
        return fragment;
      } else {
        mViewToElementMap.put(view, view);
        return view;
      }
    }
  }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private HostConfiguration setupSSLIfNeeded(Settings settings, HostConfiguration
        int port = 443;
        SecureProtocolSocketFactory sslFactory = new SSLSocketFactory(settings);

        replaceProtocol(hostConfig, sslFactory, schema, port);

        return hostConfig;
    }
private HostConfiguration setupSocksProxy(Settings settings, HostConfiguration h
            String schema = sslEnabled ? "https" : "http";
            int port = sslEnabled ? 443 : 80;
            SocksSocketFactory socketFactory = new SocksSocketFactory(proxyHost, proxyPort, proxyUser, proxyPass);
            replaceProtocol(hostConfig, socketFactory, schema, port);
        }

        return hostConfig;
    }

    private void replaceProtocol(HostConfiguration hostConfig, ProtocolSocketFactory socketFactory, String schema, int defaultPort) {
        //
        // switch protocol
        // due to how HttpCommons work internally this dance is best to be kept as is
        //

        // NB: not really needed (see below that the protocol is reseted) but in place just in case
        hostConfig = new ProtocolAwareHostConfiguration(hostConfig);
        Protocol directHttp = Protocol.getProtocol(schema);
        Protocol proxiedHttp = new DelegatedProtocol(socketFactory, directHttp, schema, defaultPort);
        // NB: register the new protocol since when using absolute URIs, HttpClient#executeMethod will override the configuration (#387)
        // NB: hence why the original/direct http protocol is saved - as otherwise the connection is not closed since it is considered different
public boolean equals(Object obj) {
    public int hashCode() {
        return original.hashCode();
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /**
   * Keeps track of which ChatUserControl in which pane belongs to which user.
   */
  private final Map<String, Map<Pane, ChatUserControl>> userToChatUserControls;
  @FXML
  Button advancedUserFilter;
  @FXML
public ChannelTabController() {
  }

  // TODO clean this up
  public Map<String, Map<Pane, ChatUserControl>> getUserToChatUserControls() {
    return userToChatUserControls;
  }

void initialize() {
   */
  private void filterChatUserControlsBySearchString() {
    synchronized (userToChatUserControls) {
      for (Map<Pane, ChatUserControl> chatUserControlMap : userToChatUserControls.values()) {
        for (Map.Entry<Pane, ChatUserControl> chatUserControlEntry : chatUserControlMap.entrySet()) {
          ChatUserControl chatUserControl = chatUserControlEntry.getValue();
          boolean display = isUsernameMatch(chatUserControl);
          chatUserControl.setVisible(display);
          chatUserControl.setManaged(display);
        }
      }
    }
  }

  //TODO: I don't like how this is public
  public boolean isUsernameMatch(ChatUserControl chatUserControl) {
    String lowerCaseSearchString = chatUserControl.getPlayerInfoBean().getUsername().toLowerCase();
    return lowerCaseSearchString.contains(userSearchTextField.getText().toLowerCase());
  }

private void onUserJoinedChannel(ChatUser chatUser) {

    player.moderatorForChannelsProperty().bind(chatUser.moderatorInChannelsProperty());
    player.usernameProperty().addListener((observable, oldValue, newValue) -> {
      for (Map.Entry<Pane, ChatUserControl> entry : userToChatUserControls.get(oldValue).entrySet()) {
        Pane pane = entry.getKey();
        ChatUserControl chatUserControl = entry.getValue();

        pane.getChildren().remove(chatUserControl);
        addChatUserControlSorted(pane, chatUserControl);
      }
    });
    player.usernameProperty().bind(chatUser.usernameProperty());
private Pane getPaneForSocialStatus(SocialStatus socialStatus) {
  private void onUserLeft(String username) {
    JavaFxUtil.assertBackgroundThread();

    Map<Pane, ChatUserControl> paneToChatUserControlMap = userToChatUserControls.get(username);
    if (paneToChatUserControlMap == null) {
      return;
    }

    for (Map.Entry<Pane, ChatUserControl> entry : paneToChatUserControlMap.entrySet()) {
      Platform.runLater(() -> entry.getKey().getChildren().remove(entry.getValue()));
    }
    paneToChatUserControlMap.clear();
    userToChatUserControls.remove(username);
  }

  private ChatUserControl addToPane(PlayerInfoBean playerInfoBean, Pane pane) {
    return createChatUserControlForPlayerIfNecessary(pane, playerInfoBean);
  }

  private void removeFromPane(PlayerInfoBean playerInfoBean, Pane pane) {
    // Re-add Plateform.runLater() as soon as RT-40417 is fixed
//        Platform.runLater(() -> {
    Map<Pane, ChatUserControl> paneChatUserControlMap = userToChatUserControls.get(playerInfoBean.getUsername());
    if (paneChatUserControlMap == null) {
      // User has not yet been added to this pane; no need to remove him
      return;
    }
    Platform.runLater(() -> {
      ChatUserControl chatUserControl = paneChatUserControlMap.remove(pane);
      pane.getChildren().remove(chatUserControl);
    });
//        });
  }

  /**
   * Creates a {@link com.faforever.client.chat.ChatUserControl} for the given playerInfoBean and adds it to the given
   * pane if there isn't already such a control in this pane. After the control has been added, the user search filter
   * is applied.
   */
  private ChatUserControl createChatUserControlForPlayerIfNecessary(Pane pane, PlayerInfoBean playerInfoBean) {
    String username = playerInfoBean.getUsername();
    if (!userToChatUserControls.containsKey(username)) {
      userToChatUserControls.put(username, new HashMap<>(1, 1));
    }

    Map<Pane, ChatUserControl> paneToChatUserControlMap = userToChatUserControls.get(username);

    ChatUserControl existingChatUserControl = paneToChatUserControlMap.get(pane);
    if (existingChatUserControl != null) {
      return existingChatUserControl;
    }

    if (!applicationContext.isActive()) {
      logger.warn("Application context has been closed, not creating control for player {}", playerInfoBean.getUsername());
    }
    ChatUserControl chatUserControl = applicationContext.getBean(ChatUserControl.class);
    chatUserControl.setPlayerInfoBean(playerInfoBean);
    paneToChatUserControlMap.put(pane, chatUserControl);

    chatUserControl.setColorsAllowedInPane((pane == othersPane || pane == chatOnlyPane) && playerInfoBean.getSocialStatus() != SELF);

    Platform.runLater(() -> {
      addChatUserControlSorted(pane, chatUserControl);
      isUsernameMatch(chatUserControl);
    });

    return chatUserControl;
  }

  /**
   * Inserts the given ChatUserControl into the given Pane such that it is correctly sorted alphabetically.
   */
  private void addChatUserControlSorted(Pane pane, ChatUserControl chatUserControl) {
    ObservableList<Node> children = pane.getChildren();

    if (chatUserControl.getPlayerInfoBean().getSocialStatus() == SELF) {
      children.add(0, chatUserControl);
      return;
    }

    for (Node child : children) {
      if (!(child instanceof ChatUserControl)) {
        continue;
      }

      String newUser = chatUserControl.getPlayerInfoBean().getUsername();
      String nextUser = ((ChatUserControl) child).getPlayerInfoBean().getUsername();

      if (nextUser.equals(userService.getUsername())) {
        continue;
      }

      if (newUser.compareToIgnoreCase(nextUser) < 0) {
        children.add(children.indexOf(child), chatUserControl);
        return;
      }
    }

    children.add(chatUserControl);
  }

  private Collection<Pane> getTargetPanesForUser(PlayerInfoBean playerInfoBean) {
package com.faforever.client.chat;

import com.faforever.client.fx.FxmlLoader;
import com.faforever.client.fx.JavaFxUtil;
import com.faforever.client.game.GameInfoBean;
import com.faforever.client.game.GameService;
import com.faforever.client.replay.ReplayService;
import com.faforever.client.reporting.ReportingService;
import com.faforever.client.theme.ThemeService;
import com.faforever.client.user.UserService;
import com.faforever.client.util.RatingUtil;
import javafx.application.Platform;
import javafx.beans.property.FloatProperty;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.WeakChangeListener;
import javafx.collections.MapChangeListener;
import javafx.fxml.FXML;
import javafx.scene.control.Label;
import javafx.scene.control.Tooltip;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.HBox;
import javafx.scene.paint.Color;
import javafx.stage.PopupWindow;
import org.springframework.context.ApplicationContext;

import static com.faforever.client.chat.ChatColorMode.CUSTOM;
import static com.faforever.client.chat.SocialStatus.SELF;
import static java.util.Collections.singletonList;

public class ChatUserControl extends HBox {


  private static final String CLAN_TAG_FORMAT = "[%!s(MISSING)]";

  @FXML
  ImageView countryImageView;
  @FXML
  ImageView avatarImageView;
  @Resource
  ApplicationContext applicationContext;
  @Resource
  FxmlLoader fxmlLoader;
  @Resource
  AvatarService avatarService;
  @Resource
  CountryFlagService countryFlagService;
  @Resource
  PreferencesService preferencesService;
  @Resource
  UserService userService;
  @Resource
  ChatService chatService;
  @Resource
  GamesController gamesController;
  private PlayerInfoBean playerInfoBean;
  private boolean colorsAllowedInPane;
  private ChangeListener<ChatColorMode> colorModeChangeListener;

  @FXML
  void onContextMenuRequested(ContextMenuEvent event) {
    ChatUserContextMenuController contextMenuController = applicationContext.getBean(ChatUserContextMenuController.class);
    contextMenuController.setPlayerInfoBean(playerInfoBean);
    contextMenuController.getContextMenu().show(getScene().getWindow(), event.getScreenX(), event.getScreenY());
  }

  @FXML
void onUsernameClicked(MouseEvent mouseEvent) {
  }

  @PostConstruct
  void init() {
    // TODO clean up FXML loading
    fxmlLoader.loadCustomControl("chat_user_control.fxml", this);

    colorModeChangeListener = (observable, oldValue, newValue) -> configureColor();
  }

  private void configureColor() {
    ChatPrefs chatPrefs = preferencesService.getPreferences().getChat();

    if (playerInfoBean.getSocialStatus() == SELF) {
      usernameLabel.getStyleClass().add(SELF.getCssClass());
private void configureColor() {
        color = chatPrefs.getUserToColor().get(playerInfoBean.getUsername());
      }

      //FIXME: something here returned NPE when starting chat and users starting messaging aeolus on non-dev server
      chatPrefs.getUserToColor().addListener((MapChangeListener<? super String, ? super Color>) change -> {
        if (playerInfoBean.getUsername().equals(change.getKey())) {
          Color newColor = chatPrefs.getUserToColor().get(playerInfoBean.getUsername());
          assignColor(newColor);
        }
      });
    } else if (chatPrefs.getChatColorMode().equals(ChatColorMode.RANDOM) && colorsAllowedInPane) {
      color = ColorGeneratorUtil.generateRandomColor(chatUser.getUsername().hashCode());
    }
private void assignColor(Color color) {
    }
  }

  public PlayerInfoBean getPlayerInfoBean() {
    return playerInfoBean;
  }
public void setPlayerInfoBean(PlayerInfoBean playerInfoBean) {
    configureAvatarImageView();
    configureClanLabel();
    configureGameStatusView();
    configureRatingTooltip();

    usernameLabel.setText(playerInfoBean.getUsername());
  }
private void configureCountryImageView() {
  }

  private void configureAvatarImageView() {
    playerInfoBean.avatarUrlProperty().addListener((observable, oldValue, newValue) -> {
      Platform.runLater(() -> setAvatarUrl(newValue));
    });
    setAvatarUrl(playerInfoBean.getAvatarUrl());

    Tooltip avatarTooltip = new Tooltip(playerInfoBean.getAvatarTooltip());
private void configureAvatarImageView() {

  private void configureClanLabel() {
    setClanTag(playerInfoBean.getClan());
    playerInfoBean.clanProperty().addListener((observable, oldValue, newValue) -> {
      Platform.runLater(() -> setClanTag(newValue));
    });
  }

  private void configureGameStatusView() {
    setGameStatus(playerInfoBean.getGameStatus());
    playerInfoBean.gameStatusProperty().addListener((observable, oldValue, newValue) -> {
      Platform.runLater(() -> setGameStatus(newValue));
    });

  }

  private void configureRatingTooltip() {
    if (!playerInfoBean.getChatOnly()) {
      Tooltip userRatingTooltip = new Tooltip();

      String rating = i18n.get("userInfo.ratingFormat", RatingUtil.getRoundedGlobalRating(playerInfoBean), RatingUtil.getLeaderboardRating(playerInfoBean));
      userRatingTooltip.setText(rating);

      addRatingListenerToTooltip(playerInfoBean.leaderboardRatingMeanProperty(), userRatingTooltip);
      addRatingListenerToTooltip(playerInfoBean.globalRatingMeanProperty(), userRatingTooltip);

      Tooltip.install(clanLabel, userRatingTooltip);
      Tooltip.install(usernameLabel, userRatingTooltip);
    }
  }

  private void setCountry(String country) {
private void setCountry(String country) {
    }
  }

  private void setAvatarUrl(String avatarUrl) {
    if (StringUtils.isEmpty(avatarUrl)) {
      avatarImageView.setVisible(false);
    } else {
      avatarImageView.setImage(avatarService.loadAvatar(avatarUrl));
      avatarImageView.setVisible(true);
    }
  }

  private void setClanTag(String newValue) {
    if (StringUtils.isEmpty(newValue)) {
      clanLabel.setVisible(false);
    } else {
      clanLabel.setText(String.format(CLAN_TAG_FORMAT, newValue));
      clanLabel.setVisible(true);
    }
  }

  public void setGameStatus(GameStatus gameStatus) {
    switch (gameStatus) {
      case PLAYING:
        statusImageView.setImage(new Image(themeService.getThemeFile(ThemeService.PLAYING_STATUS_IMAGE)));
        break;
      case HOST:
        statusImageView.setImage(new Image(themeService.getThemeFile(ThemeService.HOSTING_STATUS_IMAGE)));
        break;
      case LOBBY:
        statusImageView.setImage(new Image(themeService.getThemeFile(ThemeService.LOBBY_STATUS_IMAGE)));
        break;
      default:
        statusImageView.setImage(null);
    }
    statusImageView.setVisible(true);
  }

  private void addRatingListenerToTooltip(FloatProperty ratingProperty, Tooltip tooltip) {
    ratingProperty.addListener((observable, oldValue, newValue) -> {
      String updatedRating = i18n.get("userInfo.ratingFormat", RatingUtil.getGlobalRating(playerInfoBean), RatingUtil.getLeaderboardRating(playerInfoBean));
      tooltip.setText(updatedRating);
    });
  }

  @FXML
  void onMouseEnterGameStatus() {
    if (playerInfoBean.getGameStatus() == GameStatus.NONE) {
public void setColorsAllowedInPane(boolean colorsAllowedInPane) {
    this.colorsAllowedInPane = colorsAllowedInPane;
    configureColor();
  }
}
void init() {
  }

  private void filterUsers() {
    Map<String, Map<Pane, ChatUserControl>> userToChatUserControls = channelTabController.getUserToChatUserControls();
    for (Map<Pane, ChatUserControl> chatUserControlMap : userToChatUserControls.values()) {
      for (Map.Entry<Pane, ChatUserControl> chatUserControlEntry : chatUserControlMap.entrySet()) {
        ChatUserControl chatUserControl = chatUserControlEntry.getValue();
        boolean display;
        display = filterUser(chatUserControl);
        chatUserControl.setVisible(display);
        chatUserControl.setManaged(display);
      }
    }
  }

  private boolean filterUser(ChatUserControl chatUserControl) {
    return channelTabController.isUsernameMatch(chatUserControl)
        && isInClan(chatUserControl)
        && isBoundedByRating(chatUserControl)
        && isGameStatusMatch(chatUserControl);
  }

  @VisibleForTesting
  boolean isInClan(ChatUserControl chatUserControl) {
    if (clanFilterField.getText().isEmpty()) {
      return true;
    }

    String clan = chatUserControl.getPlayerInfoBean().getClan();
    if (clan == null) {
      return false;
    } else {
boolean isInClan(ChatUserControl chatUserControl) {
  }

  @VisibleForTesting
  boolean isBoundedByRating(ChatUserControl chatUserControl) {
    int globalRating = RatingUtil.getGlobalRating(chatUserControl.getPlayerInfoBean());
    int minRating;
    int maxRating;

boolean isBoundedByRating(ChatUserControl chatUserControl) {
  }

  @VisibleForTesting
  boolean isGameStatusMatch(ChatUserControl chatUserControl) {
    if (gameStatusFilter == null) {
      return true;
    }

    GameStatus gameStatus = chatUserControl.getPlayerInfoBean().getGameStatus();
    if (gameStatusFilter == LOBBY) {
      return LOBBY == gameStatus || HOST == gameStatus;
    } else {
import com.faforever.client.chat.ChannelTabController;
import com.faforever.client.chat.ChatController;
import com.faforever.client.chat.ChatUserContextMenuController;
import com.faforever.client.chat.ChatUserControl;
import com.faforever.client.chat.CountryFlagService;
import com.faforever.client.chat.CountryFlagServiceImpl;
import com.faforever.client.chat.FilterUserController;
PersistentNotificationController persistentNotificationController() {

  @Bean
  @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
  ChatUserControl chatUserControl() {
    return new ChatUserControl();
  }

  @Bean
  @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
  ChatUserContextMenuController chatUserContextMenuController() {
    return loadController("chat_user_context_menu.fxml");
  }
TransientNotificationsController transientNotificationsController() {
  TransientNotificationController transientNotificationController() {
    return loadController("transient_notification.fxml");
  }
}
<?import javafx.scene.control.Label?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.layout.HBox?>
<fx:root xmlns:fx="http://javafx.com/fxml/1" alignment="CENTER_LEFT" maxWidth="1.7976931348623157E308"
         minWidth="-Infinity" onContextMenuRequested="#onContextMenuRequested" spacing="5.0"
         styleClass="chat-user-control-root" type="HBox" xmlns="http://javafx.com/javafx/8.0.40">
  <ImageView fx:id="avatarImageView" fitHeight="20.0" fitWidth="40.0" pickOnBounds="true" preserveRatio="true" styleClass="chat-user-control-avatar" HBox.hgrow="NEVER" />
  <ImageView fx:id="countryImageView" fitHeight="16.0" fitWidth="16.0" pickOnBounds="true" preserveRatio="true"
             styleClass="chat-user-control-country" HBox.hgrow="NEVER"/>
  <ImageView fx:id="statusImageView" fitHeight="16.0" fitWidth="16.0" onMouseClicked="#onMouseClickGameStatus"
             onMouseEntered="#onMouseEnterGameStatus" pickOnBounds="true" preserveRatio="true"
             styleClass="chat-user-control-status" HBox.hgrow="NEVER"/>
</fx:root>
import static org.hamcrest.Matchers.empty;
import static org.hamcrest.Matchers.hasSize;
import static org.junit.Assert.*;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.mock;
public void testOnDisconnected() throws Exception {
  }

  @Test
  @SuppressWarnings("unchecked")
  public void testOnUserJoinedChannel() throws Exception {
    channelJoined(TEST_CHANNEL_NAME);

    ChatUser chatUser = mock(ChatUser.class);

    verify(chatService).addUsersListener(eq(TEST_CHANNEL_NAME), onUsersListenerCaptor.capture());

    MapChangeListener.Change<? extends String, ? extends ChatUser> usersChange = mock(MapChangeListener.Change.class);
    when(usersChange.wasAdded()).thenReturn(true);
    when(usersChange.getValueAdded()).thenReturn(chatUser);
    onUsersListenerCaptor.getValue().onChanged(usersChange);
    // TODO assert something useful
  }

  @SuppressWarnings("unchecked")
  private void channelJoined(String channel) {
    MapChangeListener.Change<? extends String, ? extends Channel> testChannelChange = mock(MapChangeListener.Change.class);
    when(testChannelChange.getKey()).thenReturn(channel);
    channelsListener.getValue().onChanged(testChannelChange);
  }

  @Test
  @SuppressWarnings("unchecked")
  public void testOnChatUserLeftChannel() throws Exception {
    channelJoined(TEST_CHANNEL_NAME);

    ChatUser chatUser = mock(ChatUser.class);

    verify(chatService).addUsersListener(eq(TEST_CHANNEL_NAME), onUsersListenerCaptor.capture());

    MapChangeListener.Change<? extends String, ? extends ChatUser> change = mock(MapChangeListener.Change.class);
    when(change.wasRemoved()).thenReturn(true);
    when(change.getValueRemoved()).thenReturn(chatUser);
    onUsersListenerCaptor.getValue().onChanged(change);
    // TODO assert something useful
  }

  @Test
  public void testOnPrivateMessage() throws Exception {
    ChatMessage chatMessage = mock(ChatMessage.class);

public void testOnChannelsJoinedRequest() throws Exception {
    connectionState.set(ConnectionState.DISCONNECTED);
  }

  @Test
  @SuppressWarnings("unchecked")
  public void testOnJoinChannelButtonClicked() throws Exception {
    Tab tab = new Tab();
    tab.setId(TEST_CHANNEL_NAME);

    when(channelTabController.getRoot()).thenReturn(tab);
    when(userService.getUsername()).thenReturn(TEST_USER_NAME);
    when(chatService.isDefaultChannel(TEST_CHANNEL_NAME)).thenReturn(false);

    instance.channelNameTextField.setText(TEST_CHANNEL_NAME);
    instance.onJoinChannelButtonClicked();

    verify(chatService).joinChannel(TEST_CHANNEL_NAME);
    assertThat(instance.chatsTabPane.getTabs(), is(empty()));

    verify(chatService).addUsersListener(eq(TEST_CHANNEL_NAME), onUsersListenerCaptor.capture());

    MapChangeListener.Change<? extends String, ? extends ChatUser> change = mock(MapChangeListener.Change.class);
    when(change.wasAdded()).thenReturn(true);
    when(change.getValueAdded()).thenReturn(new ChatUser(TEST_USER_NAME, null));
    onUsersListenerCaptor.getValue().onChanged(change);


    CountDownLatch tabAddedLatch = new CountDownLatch(1);
    instance.chatsTabPane.getTabs().addListener((InvalidationListener) observable -> tabAddedLatch.countDown());
    tabAddedLatch.await(2, TimeUnit.SECONDS);
public class FilterUserControllerTest extends AbstractPlainJavaFxTest {

  @Mock
  ChatUserControl chatUserControl;

  @Mock
  PlayerInfoBean playerInfoBean;
public void setUp() throws Exception {
    instance.channelTabController = loadController("channel_tab.fxml");
    instance.i18n = i18n;

    when(chatUserControl.getPlayerInfoBean()).thenReturn(playerInfoBean);
  }

  @Test
public void testIsInClan() throws Exception {
    when(playerInfoBean.getClan()).thenReturn(testClan);
    instance.clanFilterField.setText(testClan);

    assertTrue(instance.isInClan(chatUserControl));
  }

  @Test
public void testIsBoundedByRatingWithinBounds() throws Exception {
    instance.minRatingFilterField.setText("300");
    instance.maxRatingFilterField.setText("700");

    assertTrue(instance.isBoundedByRating(chatUserControl));
  }

  @Test
public void testIsBoundedByRatingNotWithinBounds() throws Exception {
    instance.minRatingFilterField.setText("600");
    instance.maxRatingFilterField.setText("300");

    assertFalse(instance.isBoundedByRating(chatUserControl));
  }

  @Test
  public void testIsGameStatusMatchPlaying() throws Exception {
    when(playerInfoBean.getGameStatus()).thenReturn(PLAYING);
    instance.gameStatusFilter = PLAYING;

    assertTrue(instance.isGameStatusMatch(chatUserControl));
  }

  @Test
  public void testIsGameStatusMatchLobby() throws Exception {
    when(playerInfoBean.getGameStatus()).thenReturn(HOST);
    instance.gameStatusFilter = HOST;

    assertTrue(instance.isGameStatusMatch(chatUserControl));

    when(playerInfoBean.getGameStatus()).thenReturn(LOBBY);
    instance.gameStatusFilter = LOBBY;

    assertTrue(instance.isGameStatusMatch(chatUserControl));
  }

  @Test
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
public void setUp() throws Exception {
    when(pircBotX.getUserChannelDao()).thenReturn(userChannelDao);

    doAnswer(
        invocation -> WaitForAsyncUtils.async(() -> invocation.getArgumentAt(0, Task.class).run())
    ).when(threadPoolExecutor).execute(any(Task.class));

    botStartedFuture = new CompletableFuture<>();
    doAnswer(invocation -> {
      botStartedFuture.complete(true);
public void testOnChatUserList() throws Exception {
  }

  private void connect() throws Exception {
    mockTaskService();
    instance.connect();
    verify(pircBotXFactory).createPircBotX(configurationCaptor.capture());

    CompletableFuture<Void> future = listenForConnected();
    firePircBotXEvent(new ConnectEvent(pircBotX));
    future.get(TIMEOUT, TIMEOUT_UNIT);

    SocialMessage socialMessage = new SocialMessage();
    socialMessage.setChannels(Collections.singletonList(DEFAULT_CHANNEL_NAME));
private void firePircBotXEvent(Event event) {
    configurationCaptor.getValue().getListenerManager().onEvent(event);
  }

  @SuppressWarnings("unchecked")
  private void mockTaskService() {
    doAnswer((InvocationOnMock invocation) -> {
      PrioritizedTask<Boolean> prioritizedTask = invocation.getArgumentAt(0, PrioritizedTask.class);
      prioritizedTask.run();

      Future<Boolean> result = WaitForAsyncUtils.asyncFx(prioritizedTask::getValue);
      return completedFuture(result.get(1, TimeUnit.SECONDS));
    }).when(instance.taskService).submitTask(any());
  }

  private CompletableFuture<Void> listenForConnected() {
    CompletableFuture<Void> future = new CompletableFuture<>();
    instance.connectionStateProperty().addListener((observable, oldValue, newValue) -> {
      if (newValue == ConnectionState.CONNECTED) {
        future.complete(null);
      }
    });
    return future;
  }

  @Test
public void testSendMessageInBackground() throws Exception {
    CompletableFuture<String> future = instance.sendMessageInBackground(DEFAULT_CHANNEL_NAME, message);

    assertThat(future.get(TIMEOUT, TIMEOUT_UNIT), is(message));
    verify(pircBotX).sendIRC();
    verify(outputIrc).message(DEFAULT_CHANNEL_NAME, message);
  }

public void testLeaveChannel() throws Exception {
  @Test
  public void testSendActionInBackground() throws Exception {
    connect();
    String action = "test action";

    when(taskService.submitTask(any())).thenReturn(completedFuture(action));

    CompletableFuture<String> future = instance.sendActionInBackground(DEFAULT_CHANNEL_NAME, action);

    verify(pircBotX).sendIRC();
    verify(outputIrc).action(DEFAULT_CHANNEL_NAME, action);
    assertThat(future.get(TIMEOUT, TIMEOUT_UNIT), is(action));
  }

  @Test
public void testUsersListenerJoinQuit() throws Exception {

  @Test
  public void testJoinChannel() throws Exception {
    when(taskService.submitTask(any())).thenReturn(completedFuture(null));

    connect();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void removeCamelContext(CamelContext camelctx) {
        ServiceController<?> controller;
        synchronized (contexts) {
            controller = contexts.get(camelctx);
        }
        if (controller != null) {
            controller.setMode(Mode.REMOVE);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public static void activateTooltips(FacesContext context, UIComponent component)
				options = "{" + options.substring(0, options.length() - 1) + "}";

			String js = "$(function () {\n" + "$('#" + id + "').tooltip(" + options + ")\n" + "});\n";
			context.getResponseWriter().write("<script type='text/javascript'>" + js + "</script>");
		}
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
POM_NAME=Snackbar
POM_ARTIFACT_ID=snackbar
POM_PACKAGING=aar
GROUP=com.nispok
VERSION_NAME=2.7.3

POM_DESCRIPTION=Snackbar Android library
POM_URL=https://github.com/nispok/snackbar
private void finish() {
        mIsShowing = false;
    }

    public int getActionColor() {
        return mActionColor;
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
     * @return true if they match, false otherwise.
     */
    boolean matches(Service service);
    
    /**
     * Clone this service.
     *
     * @return the logout type of the service.
     */
    LogoutType getLogoutType();
    
    /**
     * Gets the attribute filtering policy to determine
     * how attributes are to be filtered and released for
     * @since 4.1
     */
    URL getLogoutUrl();
    
    /**
     * Gets the public key associated with this service
     * that is used to authorize the request by
     * @since 4.1
     */
    RegisteredServicePublicKey getPublicKey();
    
}
     * @param service The service for which we are granting a ticket
     * @param expirationPolicy the expiration policy.
     * @param credentialsProvided if the credentials are provided.
     * @return the service ticket granted to a specific service for the
     * principal of the TicketGrantingTicket
     */
    ServiceTicket grantServiceTicket(String id, Service service,
        ExpirationPolicy expirationPolicy, boolean credentialsProvided);

    /**
     * Gets an immutable map of service ticket and services accessed by this ticket-granting ticket.
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import org.springframework.util.Assert;

    private final UniqueTicketIdGenerator defaultServiceTicketIdGenerator
            = new DefaultUniqueTicketIdGenerator();

    /**
     * Instantiates a new Central authentication service impl.
     */
public ServiceTicket grantServiceTicket(
                ticketId,
                service,
                this.serviceTicketExpirationPolicy,
                currentAuthentication != null);

        this.serviceTicketRegistry.addTicket(serviceTicket);

private void verifyRegisteredServiceProperties(final RegisteredService registere
            throw new UnauthorizedServiceException(UnauthorizedServiceException.CODE_UNAUTHZ_SERVICE, msg);
        }
    }
}
public void copyFrom(final RegisteredService source) {
        this.setLogoutUrl(source.getLogoutUrl());
        this.setPublicKey(source.getPublicKey());
        this.setRequiredHandlers(source.getRequiredHandlers());

    }

    /**
package org.jasig.cas.ticket;

import com.google.common.collect.ImmutableMap;
import org.apache.commons.lang3.builder.EqualsBuilder;
import org.jasig.cas.authentication.Authentication;
import org.jasig.cas.authentication.principal.Service;
import javax.persistence.Table;
import javax.validation.constraints.NotNull;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;


/**
 * Concrete implementation of a TicketGrantingTicket. A TicketGrantingTicket is
 * the global identifier of a principal into the system. It grants the Principal
public Authentication getAuthentication() {
    @Override
    public synchronized ServiceTicket grantServiceTicket(final String id,
        final Service service, final ExpirationPolicy expirationPolicy,
        final boolean credentialsProvided) {
        final ServiceTicket serviceTicket = new ServiceTicketImpl(id, this,
            service, this.getCountOfUses() == 0 || credentialsProvided,
            expirationPolicy);
public synchronized ServiceTicket grantServiceTicket(final String id,
        final List<Authentication> authentications = getChainedAuthentications();
        service.setPrincipal(authentications.get(authentications.size()-1).getPrincipal());

        this.services.put(id, service);

        return serviceTicket;
    }

    /**
     * Gets an immutable map of service ticket and services accessed by this ticket-granting ticket.
     * Unlike {@link Collections#unmodifiableMap(java.util.Map)},
     * which is a view of a separate map which can still change, an instance of {@link ImmutableMap}
     * contains its own data and will never change.
     *
public Service getProxiedBy() {

        @Override
        public ServiceTicket grantServiceTicket(final String id, final Service service,
                final ExpirationPolicy expirationPolicy, final boolean credentialsProvided) {
            final ServiceTicket t = this.getTicket().grantServiceTicket(id, service,
                    expirationPolicy, credentialsProvided);
            updateTicket();
            return t;
        }
private TicketGrantingTicket createMockTicketGrantingTicket(final String id,

        final String svcId = svcTicket.getService().getId();
        when(tgtMock.grantServiceTicket(anyString(), argThat(new VerifyServiceByIdMatcher(svcId)),
                any(ExpirationPolicy.class), anyBoolean())).thenReturn(svcTicket);
        when(tgtMock.getRoot()).thenReturn(root);
        when(tgtMock.getChainedAuthentications()).thenReturn(chainedAuthnList);
        when(svcTicket.getGrantingTicket()).thenReturn(tgtMock);   

    public static final String CONST_TEST_URL = "https://test.com";

    public static final String CONST_EXCEPTION_EXPECTED = "Exception expected.";

    public static final String CONST_EXCEPTION_NON_EXPECTED = "Exception not expected.";
public static Service getService() {
        return getService(CONST_TEST_URL);
    }

    public static Service getService(final String name) {
        final MockHttpServletRequest request = new MockHttpServletRequest();
        request.addParameter("service", name);
public Authentication getAuthentication() {
    }

    public ServiceTicket grantServiceTicket(final Service service) {
        return grantServiceTicket(ID_GENERATOR.getNewTicketId("ST"), service, null, true);
    }

    @Override
    public ServiceTicket grantServiceTicket(
            final String id,
            final Service service,
            final ExpirationPolicy expirationPolicy,
            final boolean credentialsProvided) {
        usageCount++;
        return new MockServiceTicket(id, service, this);
    }
private void addTicketsToRegistry(final TicketRegistry registry, final int tgtCo
                      GENERATOR.getNewTicketId("ST"),
                      new MockService("junit"),
                      TEST_EXP_POLICY,
                      false));
          }
        }
    }
public void verifyServiceRemovals() throws Exception{
        }

        for (final RegisteredService r2 : list) {
            this.dao.delete(r2);
            Thread.sleep(2000);
            assertNull(this.dao.findServiceById(r2.getId()));
public void verifyIsExpiredTrueBecauseOfRoot() {
        final TicketGrantingTicket t = new TicketGrantingTicketImpl("test", TestUtils.getAuthentication(),
                new NeverExpiresExpirationPolicy());
        final ServiceTicket s = t.grantServiceTicket(this.uniqueTicketIdGenerator.getNewTicketId(ServiceTicket.PREFIX),
                TestUtils.getService(), new NeverExpiresExpirationPolicy(), false);
        t.markTicketExpired();

        assertTrue(s.isExpired());
public void verifyIsExpiredFalse() {
        final TicketGrantingTicket t = new TicketGrantingTicketImpl("test", TestUtils.getAuthentication(),
                new NeverExpiresExpirationPolicy());
        final ServiceTicket s = t.grantServiceTicket(this.uniqueTicketIdGenerator.getNewTicketId(ServiceTicket.PREFIX),
                TestUtils.getService(), new MultiTimeUseOrTimeoutExpirationPolicy(1, 5000), false);
        assertFalse(s.isExpired());
    }

public void verifyTicketGrantingTicket() {
        final TicketGrantingTicket t = new TicketGrantingTicketImpl("test", TestUtils.getAuthentication(),
                new NeverExpiresExpirationPolicy());
        final ServiceTicket s = t.grantServiceTicket(this.uniqueTicketIdGenerator.getNewTicketId(ServiceTicket.PREFIX),
                TestUtils.getService(), new MultiTimeUseOrTimeoutExpirationPolicy(1, 5000), false);
        final TicketGrantingTicket t1 = s.grantTicketGrantingTicket(
                this.uniqueTicketIdGenerator.getNewTicketId(TicketGrantingTicket.PREFIX), a,
                new NeverExpiresExpirationPolicy());
public void verifyTicketGrantingTicketGrantedTwice() {
        final TicketGrantingTicket t = new TicketGrantingTicketImpl("test", TestUtils.getAuthentication(),
                new NeverExpiresExpirationPolicy());
        final ServiceTicket s = t.grantServiceTicket(this.uniqueTicketIdGenerator.getNewTicketId(ServiceTicket.PREFIX),
                TestUtils.getService(), new MultiTimeUseOrTimeoutExpirationPolicy(1, 5000), false);
        s.grantTicketGrantingTicket(this.uniqueTicketIdGenerator.getNewTicketId(TicketGrantingTicket.PREFIX), a,
                new NeverExpiresExpirationPolicy());

public void verifyServiceTicketAsFromInitialCredentials() {
            TestUtils.getAuthentication(), new NeverExpiresExpirationPolicy());
        final ServiceTicket s = t.grantServiceTicket(this.uniqueTicketIdGenerator
            .getNewTicketId(ServiceTicket.PREFIX), TestUtils.getService(),
            new NeverExpiresExpirationPolicy(), false);

        assertTrue(s.isFromNewLogin());
    }
public void verifyServiceTicketAsFromNotInitialCredentials() {
                this.uniqueTicketIdGenerator.getNewTicketId(ServiceTicket.PREFIX),
                TestUtils.getService(),
                new NeverExpiresExpirationPolicy(),
                false);
        final ServiceTicket s = t.grantServiceTicket(
                this.uniqueTicketIdGenerator.getNewTicketId(ServiceTicket.PREFIX),
                TestUtils.getService(),
                new NeverExpiresExpirationPolicy(),
                false);

        assertFalse(s.isFromNewLogin());
    }
public void verifyWebApplicationServices() {
            TestUtils.getAuthentication(), new NeverExpiresExpirationPolicy());
        t.grantServiceTicket(this.uniqueTicketIdGenerator
            .getNewTicketId(ServiceTicket.PREFIX), testService,
            new NeverExpiresExpirationPolicy(), false);
        Map<String, Service> services = t.getServices();
        assertEquals(1, services.size());
        final String ticketId = services.keySet().iterator().next();
public void verifyWebApplicationExpire() {
        final TicketGrantingTicket t = new TicketGrantingTicketImpl("test", null, null,
            TestUtils.getAuthentication(), new NeverExpiresExpirationPolicy());
        t.grantServiceTicket(this.uniqueTicketIdGenerator
            .getNewTicketId(ServiceTicket.PREFIX), testService,
            new NeverExpiresExpirationPolicy(), false);
        assertFalse(t.isExpired());
        t.markTicketExpired();
        assertTrue(t.isExpired());
    }
}
public void verifyGetTicketsFromRegistryEqualToTicketsAdded() {
            final TicketGrantingTicket ticketGrantingTicket = new TicketGrantingTicketImpl("TEST" + i,
                    TestUtils.getAuthentication(), new NeverExpiresExpirationPolicy());
            final ServiceTicket st = ticketGrantingTicket.grantServiceTicket("tests" + i, TestUtils.getService(),
                    new NeverExpiresExpirationPolicy(), false);
            tickets.add(ticketGrantingTicket);
            tickets.add(st);
            this.ticketRegistry.addTicket(ticketGrantingTicket);
public void verifyProxiedInstancesEqual() {
        assertEquals(t.isRoot(), returned.isRoot());

        final ServiceTicket s = t.grantServiceTicket("stest", TestUtils.getService(),
                new NeverExpiresExpirationPolicy(), false);
        this.ticketRegistry.addTicket(s);

        final ServiceTicket sreturned = (ServiceTicket) this.ticketRegistry.getTicket("stest");
public void verifyUpdateOfRegistry() {
        final TicketGrantingTicket returned = (TicketGrantingTicket) this.ticketRegistry.getTicket("test");

        final ServiceTicket s = returned.grantServiceTicket("test2", TestUtils.getService(),
                new NeverExpiresExpirationPolicy(), true);

        this.ticketRegistry.addTicket(s);
        final ServiceTicket s2 = (ServiceTicket) this.ticketRegistry.getTicket("test2");
public void verifyTicketIsExpiredByTime() throws InterruptedException {
    @Test
    public void verifyTicketIsExpiredByCount() {
        for (int i = 0; i < NUMBER_OF_USES; i++) {
            this.ticket.grantServiceTicket("test", TestUtils.getService(), new NeverExpiresExpirationPolicy(), false);
        }
        assertTrue(this.ticket.isExpired());
    }
public void verifyTicketExpirationWithRememberMe() {
                        RememberMeCredential.AUTHENTICATION_ATTRIBUTE_REMEMBER_ME, true));
        final TicketGrantingTicketImpl t = new TicketGrantingTicketImpl("111", authentication, this.p);
        assertFalse(t.isExpired());
        t.grantServiceTicket("55", TestUtils.getService(), this.p, false);
        assertTrue(t.isExpired());

    }
public void verifyTicketExpirationWithoutRememberMe() {
        final Authentication authentication = TestUtils.getAuthentication();
        final TicketGrantingTicketImpl t = new TicketGrantingTicketImpl("111", authentication, this.p);
        assertFalse(t.isExpired());
        t.grantServiceTicket("55", TestUtils.getService(), this.p, false);
        assertFalse(t.isExpired());

    }

}
public void verifyTicketIsExpired() throws InterruptedException {

    @Test
    public void verifyTicketUsedButWithTimeout() throws InterruptedException {
        this.ticket.grantServiceTicket("test", TestUtils.getService(), this.expirationPolicy, false);
        Thread.sleep(TIMEOUT - TIMEOUT_BUFFER);
        assertFalse(this.ticket.isExpired());
    }

    @Test
    public void verifyNotWaitingEnoughTime() {
        this.ticket.grantServiceTicket("test", TestUtils.getService(), this.expirationPolicy, false);
        assertTrue(this.ticket.isExpired());
    }
}
public void verifyTgtIsExpiredByHardTimeOut() throws InterruptedException {
         // keep tgt alive via sliding window until within SLIDING_TIME / 2 of the HARD_TIMEOUT
         while (System.currentTimeMillis() - ticketGrantingTicket.getCreationTime()
                 < (HARD_TIMEOUT - SLIDING_TIMEOUT / 2)) {
             ticketGrantingTicket.grantServiceTicket("test", TestUtils.getService(), expirationPolicy, false);
             Thread.sleep(SLIDING_TIMEOUT - TIMEOUT_BUFFER);
             assertFalse(this.ticketGrantingTicket.isExpired());
         }

         // final sliding window extension past the HARD_TIMEOUT
         ticketGrantingTicket.grantServiceTicket("test", TestUtils.getService(), expirationPolicy, false);
         Thread.sleep(SLIDING_TIMEOUT / 2 + TIMEOUT_BUFFER);
         assertTrue(ticketGrantingTicket.isExpired());

    }

    @Test
    public void verifyTgtIsExpiredBySlidingWindow() throws InterruptedException {
        ticketGrantingTicket.grantServiceTicket("test", TestUtils.getService(), expirationPolicy, false);
        Thread.sleep(SLIDING_TIMEOUT - TIMEOUT_BUFFER);
        assertFalse(ticketGrantingTicket.isExpired());

        ticketGrantingTicket.grantServiceTicket("test", TestUtils.getService(), expirationPolicy, false);
        Thread.sleep(SLIDING_TIMEOUT - TIMEOUT_BUFFER);
        assertFalse(ticketGrantingTicket.isExpired());

        ticketGrantingTicket.grantServiceTicket("test", TestUtils.getService(), expirationPolicy, false);
        Thread.sleep(SLIDING_TIMEOUT + TIMEOUT_BUFFER);
        assertTrue(ticketGrantingTicket.isExpired());

public void verifyGetTicketsFromRegistryEqualToTicketsAdded() {
            final TicketGrantingTicket ticketGrantingTicket = new TicketGrantingTicketImpl("TEST" + i,
                    TestUtils.getAuthentication(), new NeverExpiresExpirationPolicy());
            final ServiceTicket st = ticketGrantingTicket.grantServiceTicket("tests" + i, getService(),
                    new NeverExpiresExpirationPolicy(), false);
            tickets.add(ticketGrantingTicket);
            tickets.add(st);
            this.ticketRegistry.addTicket(ticketGrantingTicket);
public Authentication getAuthentication() {
        public ServiceTicket grantServiceTicket(final String id,
                                                final Service service,
                                                final ExpirationPolicy expirationPolicy,
                                                final boolean credentialsProvided) {
            return null;
        }

public void verifyEncodeDecodeTGTImpl() throws Exception {

        final ServiceTicket ticket = expectedTGT.grantServiceTicket(ST_ID,
                TestUtils.getService(),
                new NeverExpiresExpirationPolicy(), false);
        CachedData result = transcoder.encode(expectedTGT);
        final TicketGrantingTicket resultTicket = (TicketGrantingTicket) transcoder.decode(result);

public void verifyEncodeDecode() throws Exception {

        final Credential userPassCredential = new UsernamePasswordCredential(USERNAME, PASSWORD);
        final TicketGrantingTicket expectedTGT = new MockTicketGrantingTicket(TGT_ID, userPassCredential, this.principalAttributes);
        expectedTGT.grantServiceTicket(ST_ID, null, null, false);
        assertEquals(expectedTGT, transcoder.decode(transcoder.encode(expectedTGT)));

        internalProxyTest("http://localhost");
private void internalProxyTest(final String proxyUrl) throws MalformedURLExcepti
        svc.setServiceId("https://some.app.edu");
        final Credential proxyCredential = new HttpBasedServiceCredential(new URL(proxyUrl), svc);
        final TicketGrantingTicket expectedTGT = new MockTicketGrantingTicket(TGT_ID, proxyCredential, this.principalAttributes);
        expectedTGT.grantServiceTicket(ST_ID, null, null, false);
        assertEquals(expectedTGT, transcoder.decode(transcoder.encode(expectedTGT)));        
    }

    @Test
    public void verifyEncodeDecodeTGTWithUnmodifiableMap() throws Exception {
        final Credential userPassCredential = new UsernamePasswordCredential(USERNAME, PASSWORD);
        final TicketGrantingTicket expectedTGT =
                new MockTicketGrantingTicket(TGT_ID, userPassCredential, Collections.unmodifiableMap(this.principalAttributes));
        expectedTGT.grantServiceTicket(ST_ID, null, null, false);
        assertEquals(expectedTGT, transcoder.decode(transcoder.encode(expectedTGT)));
    }

public void verifyEncodeDecodeTGTWithUnmodifiableList() throws Exception {
        final Map<String, Object> newAttributes = new HashMap<>();
        newAttributes.put(NICKNAME_KEY, Collections.unmodifiableList(values));
        final TicketGrantingTicket expectedTGT = new MockTicketGrantingTicket(TGT_ID, userPassCredential, newAttributes);
        expectedTGT.grantServiceTicket(ST_ID, null, null, false);
        assertEquals(expectedTGT, transcoder.decode(transcoder.encode(expectedTGT)));
    }

public void verifyEncodeDecodeTGTWithLinkedHashMap() throws Exception {
        final Credential userPassCredential = new UsernamePasswordCredential(USERNAME, PASSWORD);
        final TicketGrantingTicket expectedTGT =
                new MockTicketGrantingTicket(TGT_ID, userPassCredential, new LinkedHashMap<String, Object>(this.principalAttributes));
        expectedTGT.grantServiceTicket(ST_ID, null, null, false);
        assertEquals(expectedTGT, transcoder.decode(transcoder.encode(expectedTGT)));
    }

public void verifyEncodeDecodeTGTWithListOrderedMap() throws Exception {
        @SuppressWarnings("unchecked")
        final TicketGrantingTicket expectedTGT =
                new MockTicketGrantingTicket(TGT_ID, userPassCredential, ListOrderedMap.listOrderedMap(this.principalAttributes));
        expectedTGT.grantServiceTicket(ST_ID, null, null, false);
        assertEquals(expectedTGT, transcoder.decode(transcoder.encode(expectedTGT)));
    }

public void verifyEncodeDecodeTGTWithUnmodifiableSet() throws Exception {
        newAttributes.put(NICKNAME_KEY, Collections.unmodifiableSet(values));
        final Credential userPassCredential = new UsernamePasswordCredential(USERNAME, PASSWORD);
        final TicketGrantingTicket expectedTGT = new MockTicketGrantingTicket(TGT_ID, userPassCredential, newAttributes);
        expectedTGT.grantServiceTicket(ST_ID, null, null, false);
        assertEquals(expectedTGT, transcoder.decode(transcoder.encode(expectedTGT)));
    }

public void verifyEncodeDecodeTGTWithSingleton() throws Exception {
        newAttributes.put(NICKNAME_KEY, Collections.singleton(NICKNAME_VALUE));
        final Credential userPassCredential = new UsernamePasswordCredential(USERNAME, PASSWORD);
        final TicketGrantingTicket expectedTGT = new MockTicketGrantingTicket(TGT_ID, userPassCredential, newAttributes);
        expectedTGT.grantServiceTicket(ST_ID, null, null, false);
        assertEquals(expectedTGT, transcoder.decode(transcoder.encode(expectedTGT)));
    }

public void verifyEncodeDecodeTGTWithSingletonMap() throws Exception {
        final Map<String, Object> newAttributes = Collections.singletonMap(NICKNAME_KEY, (Object) NICKNAME_VALUE);
        final Credential userPassCredential = new UsernamePasswordCredential(USERNAME, PASSWORD);
        final TicketGrantingTicket expectedTGT = new MockTicketGrantingTicket(TGT_ID, userPassCredential, newAttributes);
        expectedTGT.grantServiceTicket(ST_ID, null, null, false);
        assertEquals(expectedTGT, transcoder.decode(transcoder.encode(expectedTGT)));
    }

public int getCountOfUses() {
        public boolean equals(final Object other) {
            return other instanceof MockServiceTicket && ((MockServiceTicket) other).getId().equals(id);
        }
        
        @Override
        public int hashCode() {
            final HashCodeBuilder bldr = new HashCodeBuilder(17, 33);
public ServiceTicket grantServiceTicket(
                final String id,
                final Service service,
                final ExpirationPolicy expirationPolicy,
                final boolean credentialsProvided) {
            this.usageCount++;
            return new MockServiceTicket(id);
        }
private void addTicketsToRegistry(final TicketRegistry registry, final int tgtCo
                      GENERATOR.getNewTicketId("ST"),
                      new MockService("junit"),
                      TEST_EXP_POLICY,
                      false));
          }
        }
    }
static ServiceTicket newST(final TicketGrantingTicket parent) {
               ID_GENERATOR.getNewTicketId("ST"),
               new MockService("https://service.example.com"),
               EXP_POLICY_ST,
               false);
    }

    void addTicketInTransaction(final Ticket ticket) {
tgc.signing.key=szxK-5_eJjs-aUj-64MpUZ-GPPzGLhYPLGl0wrYjYNVAGva2P0lLe6UGKGM7k8dW
# The path to which the SSO Warning cookie will be scoped
# warn.cookie.path=/cas

##
# CAS UI Theme Resolution
#
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int main(int argc, char * const argv[])

    std::cout << "Message ends at offset " << listener.bufferOffset() << "\n";

    return 0;
}
Ir::Ir(const char *buffer, const int len, const int64_t templateId, const int64_
    begin();
}

void Ir::readTokenAtCurrentPosition()
{
    char tmp[256];
class Ir

    // constructors and destructors

    /// Construct an Ir from a buffer with serialized tokens of len total size.
    Ir(const char *buffer = NULL, const int len = 0, const int64_t templateId = -1, const int64_t templateVersion = -1);

    virtual ~Ir()
    {
        if (buffer_ != NULL)
        {
            delete[] buffer_;
            buffer_ = NULL;
        }
    }

    int64_t templateId(void) const
    {
class IrCollection
    virtual ~IrCollection()
    {
        delete[] buffer_;
    }

    /**
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public Battle(int id, Stack<CombatantInfo> newCombatants, boolean silly)
			Utility.log("Initializing battle with combatant " + combatant.name);
			if(combatant.isPlayer)
			{
				ModMain.pp.sendTo(new InitiateBattlePacket(battleID,combatant, silly), (EntityPlayerMP)combatant.entityReference);
				combatant.setTurnTickTimer(turnTickTime);
			}
			else if(isFightingEntity(combatant.entityReference))
public void addCombatant(CombatantInfo newCombatant)

			if(newCombatant.isPlayer)
			{
				ModMain.pp.sendTo(new InitiateBattlePacket(battleID,newCombatant,silly), (EntityPlayerMP)newCombatant.entityReference);
				newCombatant.setTurnTickTimer(turnTickTime);
			}
			
private void calculationsPhase()
					
					if(missCheck(combatant, combatants.get(combatant.target)))
					{
						name = ((EntityPlayer)combatantEntity).getDisplayName();
						name = ScorePlayerTeam.formatPlayerName(combatantEntity.worldObj.getScoreboard().getPlayersTeam(name), name);

						if((targetName = EntityList.getEntityString(targetEntity)) == null)
						{
							targetName = ((EntityPlayer)targetEntity).getDisplayName();
							targetName = ScorePlayerTeam.formatPlayerName(targetEntity.worldObj.getScoreboard().getPlayersTeam(targetName), targetName);
						}
						notifyPlayersWithMessage(name + " attacks " + targetName + " but missed!");
private void calculationsPhase()
					{
						targetEntity.hurtResistantTime = 0;

						name = ((EntityPlayer)combatantEntity).getDisplayName();
						name = ScorePlayerTeam.formatPlayerName(combatantEntity.worldObj.getScoreboard().getPlayersTeam(name), name);

						if((targetName = EntityList.getEntityString(targetEntity)) == null)
						{
							targetName = ((EntityPlayer)targetEntity).getDisplayName();
							targetName = ScorePlayerTeam.formatPlayerName(targetEntity.worldObj.getScoreboard().getPlayersTeam(targetName), targetName);
						}
						
private void calculationsPhase()
				}
				else if(combatantEntity instanceof EntityMob || combatantEntity instanceof EntityGolem)
				{
					if(((EntityCreature)combatantEntity).getEntityToAttack() instanceof EntityLivingBase && combatants.containsKey(((EntityMob) combatantEntity).getEntityToAttack().getEntityId()))
						targetEntity = (EntityLivingBase) ((EntityCreature)combatantEntity).getEntityToAttack();
					else
						targetEntity = null;
					
					if(targetEntity == null)
						targetName = "NULL (THIS SHOULD NEVER HAPPEN!?!)";
					else if((targetName = EntityList.getEntityString(targetEntity)) == null)
						targetName = ((EntityPlayer)targetEntity).getDisplayName();
					
					Utility.log(EntityList.getEntityString(combatantEntity) + " targeting " + (targetEntity != null ? targetName : "null"));
					
					if(targetEntity == null)
					{
						rand = ModMain.bss.random.nextInt(combatants.size()) + combatants.size();
						int k=0,j=0,picked=0;
						boolean nonPlayersExist = true;
						for(; j<rand; k++)
						{
							if(combatantEntity instanceof EntityGolem && !combatantArray[k %!c(MISSING)ombatantArray.length].isPlayer
									&& combatantArray[k %!c(MISSING)ombatantArray.length].id != combatantEntity.getEntityId() && nonPlayersExist)
							{
								j++;
								picked = k %!c(MISSING)ombatantArray.length;
							}
							else if(combatantArray[k %!c(MISSING)ombatantArray.length].isPlayer)
							{
								j++;
								picked = k %!c(MISSING)ombatantArray.length;
							}
							if(k > combatants.size() && j == 0)
							{
								if(combatantEntity instanceof EntityGolem)
								{
									nonPlayersExist = false;
									k=0;
									j=0;
									continue;
								}
								picked = -1;
								break;
							}
						}
						if(picked == -1)
							continue;
						targetEntity = combatantArray[picked].entityReference;
					}
					
					if(missCheck(combatant, combatants.get(targetEntity.getEntityId())))
					{
						name = EntityList.getEntityString(combatantEntity);
						
						if((targetName = EntityList.getEntityString(targetEntity)) == null)
						{
							targetName = ((EntityPlayer)targetEntity).getDisplayName();
							targetName = ScorePlayerTeam.formatPlayerName(targetEntity.worldObj.getScoreboard().getPlayersTeam(targetName), targetName);
						}
						
else if(combatantArray[k %!c(MISSING)ombatantArray.length].isPlayer)
						
						if((targetName = EntityList.getEntityString(targetEntity)) == null)
						{
							targetName = ((EntityPlayer)targetEntity).getDisplayName();
							targetName = ScorePlayerTeam.formatPlayerName(targetEntity.worldObj.getScoreboard().getPlayersTeam(targetName), targetName);
						}
						
else if(combatantArray[k %!c(MISSING)ombatantArray.length].isPlayer)
				}
				else if(combatantEntity instanceof EntitySlime)
				{
					targetEntity = ((EntitySlime)combatantEntity).worldObj.getClosestVulnerablePlayerToEntity(combatantEntity, 16.0);
					if(targetEntity == null || !combatants.containsKey(targetEntity.getEntityId()))
					{

						rand = ModMain.bss.random.nextInt(combatants.size()) + combatants.size();
						int k=0,j=0,picked=0;
						for(; j<rand; k++)
						{
							if(combatantArray[k %!c(MISSING)ombatantArray.length].isPlayer)
							{
								j++;
								picked = k %!c(MISSING)ombatantArray.length;
							}
							if(k > combatants.size() && j == 0)
							{
								picked = -1;
								break;
							}
						}
						if(picked == -1)
							continue;
						targetEntity = combatantArray[picked].entityReference;
					}
					
					if(missCheck(combatant, combatants.get(targetEntity.getEntityId())))
else if(combatantEntity instanceof EntitySlime)
						
						if((targetName = EntityList.getEntityString(targetEntity)) == null)
						{
							targetName = ((EntityPlayer)targetEntity).getDisplayName();
							targetName = ScorePlayerTeam.formatPlayerName(targetEntity.worldObj.getScoreboard().getPlayersTeam(targetName), targetName);
						}
						
else if(combatantEntity instanceof EntitySlime)
						
						if((targetName = EntityList.getEntityString(targetEntity)) == null)
						{
							targetName = ((EntityPlayer)targetEntity).getDisplayName();
							targetName = ScorePlayerTeam.formatPlayerName(targetEntity.worldObj.getScoreboard().getPlayersTeam(targetName), targetName);
						}
						
protected void notifyPlayers(boolean forceUpdate)
		for(CombatantInfo combatant : combatants.values())
		{
			if(combatant.isPlayer)
				ModMain.pp.sendTo(new BattleStatusPacket(!battleEnded && (combatant.entityReference.isEntityAlive()), forceUpdate, combatants.size(), status == BattleStatus.PLAYER_PHASE, combatant.ready, combatant.turnTickTimer), (EntityPlayerMP)combatant.entityReference);
		}
	}
	
	protected void notifyPlayer(boolean forceUpdate, CombatantInfo player, boolean fledBattle)
	{
		ModMain.pp.sendTo(new BattleStatusPacket(!battleEnded && (player.entityReference.isEntityAlive()) && !fledBattle, forceUpdate, combatants.size(), status == BattleStatus.PLAYER_PHASE, player.ready, player.turnTickTimer), (EntityPlayerMP)player.entityReference);
	}
	
	protected void notifyPlayersWithMessage(String message)
protected void notifyPlayersWithMessage(String message)
		{
			if(combatant.isPlayer)
			{
				ModMain.pp.sendTo(new BattleMessagePacket(message), (EntityPlayerMP) combatant.entityReference);
			}
		}
	}
protected void notifyPlayerOfCombatants(EntityLivingBase player)
	{
		for(CombatantInfo combatant : combatants.values())
		{
			ModMain.pp.sendTo(new BattleCombatantPacket(combatant), (EntityPlayerMP)player);
		}
	}
	
protected void notifyPlayersHealthInformation()
			{
				for(int j=0; j<combatantListCopy.length; j++)
				{
					ModMain.pp.sendTo(new CombatantHealthPacket(combatantListCopy[j].id, combatantListCopy[j].health), (EntityPlayerMP)combatantListCopy[i].entityReference);
				}
			}
		}
	}
}
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraftforge.event.entity.living.LivingAttackEvent;
import cpw.mods.fml.common.eventhandler.SubscribeEvent;

public class BattleEventListener {
	
public void entityAttacked(LivingAttackEvent event)
		String name = null;
		
		if((sName = EntityList.getEntityString(event.source.getEntity())) == null)
			sName = ((EntityPlayer)event.source.getEntity()).getDisplayName();

		if((name = EntityList.getEntityString(event.entity)) == null)
			name = ((EntityPlayer)event.entity).getDisplayName();
		
		Utility.log(sName + "(" + event.source.getEntity().getEntityId()
				+ ") hit " + name + "(" + event.entity.getEntityId() + ").");
public void entityAttacked(LivingAttackEvent event)
		else
		{
			if((name = EntityList.getEntityString(ModMain.bss.attackingEntity)) == null)
				name = ((EntityPlayer)ModMain.bss.attackingEntity).getDisplayName();
		}
		
		Utility.log("Battle Attacker is currently " + name);
import java.util.TreeMap;

import net.minecraft.entity.EntityList;
import net.minecraft.entity.EntityLiving;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.boss.EntityDragon;
import net.minecraft.entity.boss.EntityWither;
import net.minecraft.server.MinecraftServer;
import burnedkirby.TurnBasedMinecraft.CombatantInfo.Type;
import burnedkirby.TurnBasedMinecraft.core.CombatantInfoSet;
import burnedkirby.TurnBasedMinecraft.core.network.BattleStatusPacket;

public class BattleSystemServer {
else if(exitedBattle.contains(entityAttacker.getEntityId()) || exitedBattle.cont
			String attackerName = null;
			String attackedName = null;
			
			if(entityAttacker instanceof EntityLiving && ((EntityLiving)entityAttacker).hasCustomNameTag())
				attackerName = ((EntityLiving)entityAttacker).getCustomNameTag();
			else if((attackerName = EntityList.getEntityString(entityAttacker)) == null)
				attackerName = ((EntityPlayer)entityAttacker).getDisplayName();

			if(entityAttacked instanceof EntityLiving && ((EntityLiving)entityAttacked).hasCustomNameTag())
				attackedName = ((EntityLiving)entityAttacked).getCustomNameTag();
			else if((attackedName = EntityList.getEntityString(entityAttacked)) == null)
				attackedName = ((EntityPlayer)entityAttacked).getDisplayName();
			
			combatants.push(new CombatantInfo(entityAttacker instanceof EntityPlayer, entityAttacker.getEntityId(), entityAttacker, true, attackerName, false, Type.DO_NOTHING, entityAttacked.getEntityId()));
			combatants.push(new CombatantInfo(entityAttacked instanceof EntityPlayer, entityAttacked.getEntityId(), entityAttacked, false, attackedName, false, Type.DO_NOTHING, entityAttacked.getAITarget() != null ? entityAttacked.getAITarget().getEntityId() : 0));
else if((attackedName = EntityList.getEntityString(entityAttacked)) == null)
				
				String newName = null;
				
				if(newCombatant instanceof EntityLiving && ((EntityLiving)newCombatant).hasCustomNameTag())
					newName = ((EntityLiving)newCombatant).getCustomNameTag();
				else if((newName = EntityList.getEntityString(newCombatant)) == null)
					newName = ((EntityPlayer)newCombatant).getDisplayName();
				
				battleToJoin.addCombatant(new CombatantInfo(newCombatant instanceof EntityPlayer, newCombatant.getEntityId(), newCombatant, isSideOne, newName, false, Type.DO_NOTHING, inBattleCombatant.getEntityId()));
			}
public void manageQuery(int battleID, short type, EntityPlayer player)

			if(battles.get(battleID) == null)
			{
				ModMain.pp.sendTo(new BattleStatusPacket(false), (EntityPlayerMP)player);
				return;
			}
			switch(type)
public void managePlayerUpdate(int battleID, CombatantInfo player)
		{
			if(battles.get(battleID) == null)
			{
				ModMain.pp.sendTo(new BattleStatusPacket(false), (EntityPlayerMP)player.entityReference);
				return;
			}
			battles.get(battleID).updatePlayerStatus(player);
public synchronized void run() {
					
					while(!removalQueue.isEmpty())
					{
						System.out.println("Battle removed.");
						battles.remove(removalQueue.pop());
					}
					

package burnedkirby.TurnBasedMinecraft;

import java.util.Iterator;

import net.minecraftforge.common.MinecraftForge;
import burnedkirby.TurnBasedMinecraft.core.CommonProxy;
import burnedkirby.TurnBasedMinecraft.core.network.PacketPipeline;
import cpw.mods.fml.common.FMLCommonHandler;
import cpw.mods.fml.common.Loader;
import cpw.mods.fml.common.Mod;
import cpw.mods.fml.common.Mod.EventHandler;
import cpw.mods.fml.common.Mod.Instance;
import cpw.mods.fml.common.ModContainer;
import cpw.mods.fml.common.SidedProxy;
import cpw.mods.fml.common.event.FMLInitializationEvent;
import cpw.mods.fml.common.event.FMLPostInitializationEvent;
import cpw.mods.fml.common.event.FMLServerStartingEvent;
import cpw.mods.fml.common.event.FMLServerStoppingEvent;


@Mod(modid=ModMain.modid,name="BurnedKirby's Turn-Based Minecraft",version=ModMain.versionNumber)
	
	public static final String battleSettingsFile = modFolder + "/battleSettings.xml";
	
	public static PacketPipeline pp = new PacketPipeline();
	
	@EventHandler
	public void initialize(FMLInitializationEvent event){
public void initialize(FMLInitializationEvent event){
		proxy.initializeSettings();
		proxy.initializeMusicManager();
		
		pp.initialize();
	}
	
	@EventHandler
	public void initialize(FMLPostInitializationEvent event){
		pp.postInitialize();
	}
	
	@EventHandler
package burnedkirby.TurnBasedMinecraft.core;

import cpw.mods.fml.common.FMLCommonHandler;
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.Entity;
import net.minecraft.server.MinecraftServer;
package burnedkirby.TurnBasedMinecraft.core.network;

import java.io.UnsupportedEncodingException;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;
import net.minecraft.entity.player.EntityPlayer;

/**
 * Special thanks to Sirgingalot for his netty tutorial
 * from which most of this network code for 1.7.2 and onwards
 * is from.
 *
 */

public abstract class AbstractPacket {

	public abstract void encodeInto(ChannelHandlerContext ctx, ByteBuf buffer);
	
	public abstract void decodeInto(ChannelHandlerContext ctx, ByteBuf buffer);
	
	public abstract void handleClientSide(EntityPlayer player);
	
	public abstract void handleServerSide(EntityPlayer player);
	
	protected void encodeUTF(String msg, ByteBuf buffer) throws UnsupportedEncodingException
	{
		buffer.writeInt(msg.length());
		buffer.writeBytes(msg.getBytes("UTF-8"));
	}
	
	protected String decodeUTF(ByteBuf buffer) throws UnsupportedEncodingException
	{
		int length = buffer.readInt();
		byte[] data = new byte[length];
		buffer.readBytes(length).readBytes(data);
		return new String(data, "UTF-8");
	}
}
package burnedkirby.TurnBasedMinecraft.core.network;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;

import java.io.UnsupportedEncodingException;

import net.minecraft.entity.player.EntityPlayer;
import burnedkirby.TurnBasedMinecraft.CombatantInfo;
import burnedkirby.TurnBasedMinecraft.CombatantInfo.Type;
import burnedkirby.TurnBasedMinecraft.ModMain;
 * This is sent as a response from the player's BattleQueryPacket.
 *
 */
public class BattleCombatantPacket extends AbstractPacket {

	CombatantInfo combatant;
	
public BattleCombatantPacket(CombatantInfo combatant)
	public BattleCombatantPacket() {
		combatant = new CombatantInfo();
	}
/*	
	@Override
	public void write(ByteArrayDataOutput out) {
		out.writeBoolean(combatant.isPlayer);
		out.writeInt(combatant.id);
		out.writeBoolean(combatant.isSideOne);
		out.writeUTF(combatant.name);
		out.writeBoolean(combatant.ready);
		out.writeInt(combatant.type.ordinal());
		out.writeInt(combatant.target);
	}

	@Override
	public void read(ByteArrayDataInput in) throws ProtocolException {
		combatant.isPlayer = in.readBoolean();
		combatant.id = in.readInt();
		combatant.isSideOne = in.readBoolean();
		combatant.name = in.readUTF();
		combatant.ready = in.readBoolean();
		combatant.type = Type.values()[in.readInt()];
		combatant.target = in.readInt();
	}

	@Override
	public void execute(EntityPlayer player, Side side)
			throws ProtocolException {
		if(side.isServer())
		{
			
		}
		else
		{
			if(ModMain.proxy.getGui() != null)
				((BattleGui)ModMain.proxy.getGui()).receiveCombatant(combatant);
		}
	}*/

	@Override
	public void encodeInto(ChannelHandlerContext ctx, ByteBuf buffer) {
		buffer.writeBoolean(combatant.isPlayer);
		buffer.writeInt(combatant.id);
		buffer.writeBoolean(combatant.isSideOne);
		try {
			encodeUTF(combatant.name, buffer);
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
			return;
		}
		buffer.writeBoolean(combatant.ready);
		buffer.writeInt(combatant.type.ordinal());
		buffer.writeInt(combatant.target);
	}

	@Override
	public void decodeInto(ChannelHandlerContext ctx, ByteBuf buffer) {
		combatant.isPlayer = buffer.readBoolean();
		combatant.id = buffer.readInt();
		combatant.isSideOne = buffer.readBoolean();
		try {
			combatant.name = decodeUTF(buffer);
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
			return;
		}
		combatant.ready = buffer.readBoolean();
		combatant.type = Type.values()[buffer.readInt()];
		combatant.target = buffer.readInt();
	}

	@Override
	public void handleClientSide(EntityPlayer player) {
		if(ModMain.proxy.getGui() != null)
			((BattleGui)ModMain.proxy.getGui()).receiveCombatant(combatant);
	}

	@Override
	public void handleServerSide(EntityPlayer player) {
		
	}

}
package burnedkirby.TurnBasedMinecraft.core.network;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;

import java.io.UnsupportedEncodingException;

import net.minecraft.entity.player.EntityPlayer;
import burnedkirby.TurnBasedMinecraft.CombatantInfo;
import burnedkirby.TurnBasedMinecraft.CombatantInfo.Type;
import burnedkirby.TurnBasedMinecraft.ModMain;
 * Packet sent to server from the player that has information
 * on what the player has decided to do on their turn.
 */
public class BattleCommandPacket extends AbstractPacket {
	
	private int battleID;
	private CombatantInfo combatant;
public BattleCommandPacket() {
	}

	@Override
	public void encodeInto(ChannelHandlerContext ctx, ByteBuf buffer) {
		buffer.writeInt(battleID);
		buffer.writeBoolean(combatant.isPlayer);
		buffer.writeInt(combatant.id);
		buffer.writeBoolean(combatant.isSideOne);
		try {
			encodeUTF(combatant.name, buffer);
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
			return;
		}
		buffer.writeBoolean(combatant.ready);
		buffer.writeInt(combatant.type.ordinal());
		buffer.writeInt(combatant.target);
	}

	@Override
	public void decodeInto(ChannelHandlerContext ctx, ByteBuf buffer) {
		battleID = buffer.readInt();
		combatant.isPlayer = buffer.readBoolean();
		combatant.id = buffer.readInt();
		combatant.isSideOne = buffer.readBoolean();
		try {
			combatant.name = decodeUTF(buffer);
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
			return;
		}
		combatant.ready = buffer.readBoolean();
		combatant.type = Type.values()[buffer.readInt()];
		combatant.target = buffer.readInt();
	}

	@Override
	public void handleClientSide(EntityPlayer player) {
	}

	@Override
	public void handleServerSide(EntityPlayer player) {
		ModMain.bss.managePlayerUpdate(battleID, combatant);
	}

/*	@Override
	public void write(ByteArrayDataOutput out) {
		out.writeInt(battleID);
		out.writeBoolean(combatant.isPlayer);
		out.writeInt(combatant.id);
		out.writeBoolean(combatant.isSideOne);
		out.writeUTF(combatant.name);
		out.writeBoolean(combatant.ready);
		out.writeInt(combatant.type.ordinal());
		out.writeInt(combatant.target);
	}

	@Override
	public void read(ByteArrayDataInput in) {
		battleID = in.readInt();
		combatant.isPlayer = in.readBoolean();
		combatant.id = in.readInt();
		combatant.isSideOne = in.readBoolean();
		combatant.name = in.readUTF();
		combatant.ready = in.readBoolean();
		combatant.type = Type.values()[in.readInt()];
		combatant.target = in.readInt();
	}

	@Override
	public void execute(EntityPlayer player, Side side) {
		if(side.isServer())
		{
			ModMain.bss.managePlayerUpdate(battleID, combatant);
		}
		else
		{
			
		}
	}*/

}
package burnedkirby.TurnBasedMinecraft.core.network;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;

import java.io.UnsupportedEncodingException;

import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.ChatComponentText;

public class BattleMessagePacket extends AbstractPacket {
	
	String message;
	
public BattleMessagePacket(String message)
		this.message = message;
	}

/*	@Override
	public void write(ByteArrayDataOutput out) {
		out.writeUTF(message);
	}

	@Override
	public void read(ByteArrayDataInput in) throws ProtocolException {
		message = in.readUTF();
	}

	@Override
	public void execute(EntityPlayer player, Side side)
			throws ProtocolException {
		if(side.isServer())
		{}
		else
		{
			Minecraft.getMinecraft().ingameGUI.getChatGUI().printChatMessage(message);
		}
	}*/

	@Override
	public void encodeInto(ChannelHandlerContext ctx, ByteBuf buffer) {
		try {
			encodeUTF(message, buffer);
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
	}

	@Override
	public void decodeInto(ChannelHandlerContext ctx, ByteBuf buffer) {
		try {
			message = decodeUTF(buffer);
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
	}

	@Override
	public void handleClientSide(EntityPlayer player) {
		player.addChatComponentMessage(new ChatComponentText(message));
	}

	@Override
	public void handleServerSide(EntityPlayer player) {
		
	}

}
package burnedkirby.TurnBasedMinecraft.core.network;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;
import net.minecraft.entity.player.EntityPlayer;

/**
 * This packet sent from server to player notifies the player that a turn has
 * ended and the Battle GUI can now return to the main menu.
 *
 */
public class BattlePhaseEndedPacket extends AbstractPacket {

	@Override
	public void encodeInto(ChannelHandlerContext ctx, ByteBuf buffer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void decodeInto(ChannelHandlerContext ctx, ByteBuf buffer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void handleClientSide(EntityPlayer player) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void handleServerSide(EntityPlayer player) {
		// TODO Auto-generated method stub
		
	}

/*	@Override
	public void write(ByteArrayDataOutput out) {
		// TODO Auto-generated method stub

	}

	@Override
	public void read(ByteArrayDataInput in) throws ProtocolException {
		// TODO Auto-generated method stub

	}

	@Override
	public void execute(EntityPlayer player, Side side)
			throws ProtocolException {
		if(side.isServer())
		{
			
		}
		else
		{
//			ModMain.bg.updateTurnEnd(true);
		}
	}*/

}
package burnedkirby.TurnBasedMinecraft.core.network;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;
import net.minecraft.entity.player.EntityPlayer;
import burnedkirby.TurnBasedMinecraft.ModMain;

/**
 * Packet sent by player in battle to server that is a query for battle status.
 *
 */
public class BattleQueryPacket extends AbstractPacket {
	
	int battleID;
	short type;
public BattleQueryPacket(int battleID, short type)
	public BattleQueryPacket() {}

	@Override
	public void encodeInto(ChannelHandlerContext ctx, ByteBuf buffer) {
		buffer.writeInt(battleID);
		buffer.writeShort(type);
	}

	@Override
	public void decodeInto(ChannelHandlerContext ctx, ByteBuf buffer) {
		battleID = buffer.readInt();
		type = buffer.readShort();
	}

	@Override
	public void handleClientSide(EntityPlayer player) {
	}

	@Override
	public void handleServerSide(EntityPlayer player) {
		ModMain.bss.manageQuery(battleID, type, player);
	}

/*	@Override
	public void write(ByteArrayDataOutput out) {
		out.writeInt(battleID);
		out.writeShort(type);
	}

	@Override
	public void read(ByteArrayDataInput in) {
		battleID = in.readInt();
		type = in.readShort();
	}*/

	/**
	 * If battle does not exist or has ended, will send a BattleStatusPacket that the battle
	 * has ended.
	 */
/*	@Override
	public void execute(EntityPlayer player, Side side) throws ProtocolException {
		if(side.isServer())
		{
			ModMain.bss.manageQuery(battleID, type, player);
//			if(!ModMain.bss.battleExists(battleID) || !ModMain.bss.getBattle(battleID).isBattleInProgress())
//			{
//				PacketDispatcher.sendPacketToPlayer(new BattleStatusPacket(false,false,0,0).makePacket(), (Player)player);
//				return;
//			}
//			
//			Vector<Integer> sideOne = ModMain.bss.getBattleSide(battleID, true);
////			if(sideOne == null)
////			{
////				PacketDispatcher.sendPacketToPlayer(new BattleStatusPacket(false,0,0).makePacket(), (Player)player);
////			}
//			Vector<Integer> sideTwo = ModMain.bss.getBattleSide(battleID, false);
//			if(type == 0) //Send sizes to player.
//			{
//				PacketDispatcher.sendPacketToPlayer(new BattleStatusPacket(true, false, sideOne.size(), sideTwo.size()).makePacket(), (Player)player);
//			}
//			else if(type == 1) //Send side one information to player.
//			{
//				Enumeration<Integer> list = sideOne.elements();
//				String name = "";
//				int id;
//				while(list.hasMoreElements())
//				{
//					id = list.nextElement();
//					name = Utility.getEntityByID(id).getEntityName();
//					PacketDispatcher.sendPacketToPlayer(new BattleCombatantPacket(id, true, name).makePacket(), (Player)player);
//				}
//			}
//			else if(type == 2) //Send side two information to player.
//			{
//				Enumeration<Integer> list = sideTwo.elements();
//				String name = "";
//				int id;
//				while(list.hasMoreElements())
//				{
//					id = list.nextElement();
//					name = Utility.getEntityByID(id).getEntityName();
//					PacketDispatcher.sendPacketToPlayer(new BattleCombatantPacket(id, false, name).makePacket(), (Player)player);
//				}
//			}
		}
		else
		{
			//throw new ProtocolException("Packet can only be received by the server!");
		}
	}*/

}
package burnedkirby.TurnBasedMinecraft.core.network;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.player.EntityPlayer;
import burnedkirby.TurnBasedMinecraft.ModMain;
import burnedkirby.TurnBasedMinecraft.gui.BattleGui;

 * the player is in exists, and the sizes of the two sides.
 * This packet is sent as a response from the player's BattleQueryPacket.
 */
public class BattleStatusPacket extends AbstractPacket {
	
	boolean found;
	boolean forceUpdate;
public BattleStatusPacket()
	{}

	@Override
	public void encodeInto(ChannelHandlerContext ctx, ByteBuf buffer) {
		buffer.writeBoolean(found);
		buffer.writeBoolean(forceUpdate);
		buffer.writeInt(battleSize);
		buffer.writeBoolean(playerPhase);
		buffer.writeBoolean(turnChoiceReceived);
		buffer.writeShort(timer);
	}

	@Override
	public void decodeInto(ChannelHandlerContext ctx, ByteBuf buffer) {
		found = buffer.readBoolean();
		forceUpdate = buffer.readBoolean();
		battleSize = buffer.readInt();
		playerPhase = buffer.readBoolean();
		turnChoiceReceived = buffer.readBoolean();
		timer = buffer.readShort();
	}

	@Override
	public void handleClientSide(EntityPlayer player) {
		if(found)
		{
			if(((BattleGui)ModMain.proxy.getGui()) == null && Minecraft.getMinecraft().currentScreen instanceof BattleGui)
			{
				Minecraft.getMinecraft().setIngameFocus();
				return;
			}
			else if(((BattleGui)ModMain.proxy.getGui()) == null)
				return;
			((BattleGui)ModMain.proxy.getGui()).checkBattleInfo(forceUpdate, battleSize, playerPhase, turnChoiceReceived, timer);
		}
		else if(!found && Minecraft.getMinecraft().currentScreen instanceof BattleGui)
		{
			Minecraft.getMinecraft().setIngameFocus();
		}
	}

	@Override
	public void handleServerSide(EntityPlayer player) {
	}

/*	@Override
	public void write(ByteArrayDataOutput out) {
		out.writeBoolean(found);
		out.writeBoolean(forceUpdate);
		out.writeInt(battleSize);
		out.writeBoolean(playerPhase);
		out.writeBoolean(turnChoiceReceived);
		out.writeShort(timer);
	}

	@Override
	public void read(ByteArrayDataInput in) throws ProtocolException {
		found = in.readBoolean();
		forceUpdate = in.readBoolean();
		battleSize = in.readInt();
		playerPhase = in.readBoolean();
		turnChoiceReceived = in.readBoolean();
		timer = in.readShort();
	}

	@Override
	public void execute(EntityPlayer player, Side side)
			throws ProtocolException {
		if(side.isServer())
		{
			//throw new ProtocolException("Packet can only be received by the player!");
		}
		else
		{
			if(found) //TODO check if null pointer exception can happen
			{
				if(((BattleGui)ModMain.proxy.getGui()) == null && Minecraft.getMinecraft().currentScreen instanceof BattleGui)
				{
					Minecraft.getMinecraft().setIngameFocus();
					return;
				}
				else if(((BattleGui)ModMain.proxy.getGui()) == null)
					return;
				((BattleGui)ModMain.proxy.getGui()).checkBattleInfo(forceUpdate, battleSize, playerPhase, turnChoiceReceived, timer);
			}
			else if(!found && Minecraft.getMinecraft().currentScreen instanceof BattleGui)
			{
				Minecraft.getMinecraft().setIngameFocus();
			}
		}
	}*/

}
package burnedkirby.TurnBasedMinecraft.core.network;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;
import net.minecraft.entity.player.EntityPlayer;
import burnedkirby.TurnBasedMinecraft.ModMain;
import burnedkirby.TurnBasedMinecraft.gui.BattleGui;

public class CombatantHealthPacket extends AbstractPacket {
	
	int entityID;
	float health;
public CombatantHealthPacket(int entityID, float health)
	}

	@Override
	public void encodeInto(ChannelHandlerContext ctx, ByteBuf buffer) {
		buffer.writeInt(entityID);
		buffer.writeFloat(health);
	}

	@Override
	public void decodeInto(ChannelHandlerContext ctx, ByteBuf buffer) {
		entityID = buffer.readInt();
		health = buffer.readFloat();
	}

	@Override
	public void handleClientSide(EntityPlayer player) {
		((BattleGui)ModMain.proxy.getGui()).receiveCombatantHealthInfo(entityID, health);
	}

	@Override
	public void handleServerSide(EntityPlayer player) {
	}

/*	@Override
	public void write(ByteArrayDataOutput out) {
		out.writeInt(entityID);
		out.writeFloat(health);
	}

	@Override
	public void read(ByteArrayDataInput in) throws ProtocolException {
		entityID = in.readInt();
		health = in.readFloat();
	}

	@Override
	public void execute(EntityPlayer player, Side side)
			throws ProtocolException {
		if(side.isServer())
		{
		}
		else
		{
			((BattleGui)ModMain.proxy.getGui()).receiveCombatantHealthInfo(entityID, health);
		}
	}*/

}
package burnedkirby.TurnBasedMinecraft.core.network;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;

import java.io.UnsupportedEncodingException;

import net.minecraft.entity.player.EntityPlayer;
import burnedkirby.TurnBasedMinecraft.CombatantInfo;
import burnedkirby.TurnBasedMinecraft.ModMain;

/**
 * Packet sent to player from the server which notifies the player of
 * entering battle and brings up the BattleGUI.
 */
public class InitiateBattlePacket extends AbstractPacket {
	
	int battleID;
	CombatantInfo player;
public InitiateBattlePacket() {
	}

	@Override
	public void encodeInto(ChannelHandlerContext ctx, ByteBuf buffer) {
		buffer.writeInt(battleID);
		buffer.writeBoolean(player.isPlayer);
		buffer.writeInt(player.id);
		buffer.writeBoolean(player.isSideOne);
		buffer.writeBoolean(silly);
		try {
			encodeUTF(player.name, buffer);
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
	}

	@Override
	public void decodeInto(ChannelHandlerContext ctx, ByteBuf buffer) {
		battleID = buffer.readInt();
		player.isPlayer = buffer.readBoolean();
		player.id = buffer.readInt();
		player.isSideOne = buffer.readBoolean();
		silly = buffer.readBoolean();
		try {
			player.name = decodeUTF(buffer);
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
	}

	@Override
	public void handleClientSide(EntityPlayer player) {
		ModMain.proxy.newGui(battleID, this.player, silly);
	}

	@Override
	public void handleServerSide(EntityPlayer player) {
	}

/*	@Override
	public void write(ByteArrayDataOutput out) {
		out.writeInt(battleID);
		out.writeBoolean(player.isPlayer);
		out.writeInt(player.id);
		out.writeBoolean(player.isSideOne);
		out.writeUTF(player.name);
	}

	@Override
	public void read(ByteArrayDataInput in) {
		battleID = in.readInt();
		player.isPlayer = in.readBoolean();
		player.id = in.readInt();
		player.isSideOne = in.readBoolean();
		player.name = in.readUTF();
	}

	@Override
	public void execute(EntityPlayer player, Side side) throws ProtocolException {
		if(side.isServer())
		{
			
		}
		else
		{
			ModMain.proxy.newGui(battleID, this.player);
		}
	}*/

}
package burnedkirby.TurnBasedMinecraft.core.network;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.codec.MessageToMessageCodec;

import java.util.Collections;
import java.util.Comparator;
import java.util.EnumMap;
import java.util.LinkedList;
import java.util.List;

import net.minecraft.client.Minecraft;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.network.INetHandler;
import net.minecraft.network.NetHandlerPlayServer;
import burnedkirby.TurnBasedMinecraft.core.Utility;
import cpw.mods.fml.common.FMLCommonHandler;
import cpw.mods.fml.common.network.FMLEmbeddedChannel;
import cpw.mods.fml.common.network.FMLOutboundHandler;
import cpw.mods.fml.common.network.NetworkRegistry;
import cpw.mods.fml.common.network.internal.FMLProxyPacket;
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;

/**
 * Special thanks to Sirgingalot for his netty tutorial
 * from which most of this network code for 1.7.2 and onwards
 * is from.
 *
 */

@ChannelHandler.Sharable
public class PacketPipeline extends
		MessageToMessageCodec<FMLProxyPacket, AbstractPacket> {
	
	private EnumMap<Side, FMLEmbeddedChannel> channels;
	private LinkedList<Class<? extends AbstractPacket>> packets = new LinkedList<Class<? extends AbstractPacket>>();
	private boolean isPostInitialised = false;
	
	public boolean registerPacket(Class<? extends AbstractPacket> clazz) {
		if (this.packets.size() > 256) {
			Utility.log("Tried to register a packet past max amount!");
			return false;
		}
		
		if (this.packets.contains(clazz)) {
			Utility.log("Tried to register a packet already registered!");
			return false;
		}
		
		if (this.isPostInitialised) {
			Utility.log("Tried to register a packet after initialization!");
			return false;
		}
		
		this.packets.add(clazz);
		return true;
	}

	@Override
	protected void encode(ChannelHandlerContext ctx, AbstractPacket msg,
			List<Object> out) throws Exception {
		ByteBuf buffer = Unpooled.buffer();
		Class<? extends AbstractPacket> clazz = msg.getClass();
		if(!this.packets.contains(msg.getClass())) {
			throw new NullPointerException("No packet registered for: " + msg.getClass().getCanonicalName());
		}
		
		byte discriminator = (byte) this.packets.indexOf(clazz);
		buffer.writeByte(discriminator);
		msg.encodeInto(ctx, buffer);
		FMLProxyPacket proxyPacket = new FMLProxyPacket(buffer.copy(), ctx.channel().attr(NetworkRegistry.FML_CHANNEL).get());
		out.add(proxyPacket);
	}

	@Override
	protected void decode(ChannelHandlerContext ctx, FMLProxyPacket msg,
			List<Object> out) throws Exception {
		ByteBuf payload = msg.payload();
		byte discriminator = payload.readByte();
		Class<? extends AbstractPacket> clazz = this.packets.get(discriminator);
		if (clazz == null) {
			throw new NullPointerException("No packet registered for discriminator: " + discriminator);
		}
		
		AbstractPacket pkt = clazz.newInstance();
		pkt.decodeInto(ctx, payload.slice());
		
		EntityPlayer player;
		switch(FMLCommonHandler.instance().getEffectiveSide()) {
		case CLIENT:
			player = this.getClientPlayer();
			pkt.handleClientSide(player);
			break;
			
		case SERVER:
			INetHandler netHandler = ctx.channel().attr(NetworkRegistry.NET_HANDLER).get();
			player = ((NetHandlerPlayServer) netHandler).playerEntity;
			pkt.handleServerSide(player);
			break;
			
		default:
		}
		
		out.add(pkt);
	}
	
	public void initialize() {
		this.channels = NetworkRegistry.INSTANCE.newChannel("BK_TBM_Channel", this);
		
		registerPacket(BattleCombatantPacket.class);
		registerPacket(BattleCommandPacket.class);
		registerPacket(BattleMessagePacket.class);
		registerPacket(BattlePhaseEndedPacket.class);
		registerPacket(BattleQueryPacket.class);
		registerPacket(BattleStatusPacket.class);
		registerPacket(CombatantHealthPacket.class);
		registerPacket(InitiateBattlePacket.class);
	}
	
	public void postInitialize() {
		if(this.isPostInitialised) {
			return;
		}
		
		this.isPostInitialised = true;
		Collections.sort(this.packets, new Comparator<Class<? extends AbstractPacket>>() {

			@Override
			public int compare(Class<? extends AbstractPacket> clazz1,
					Class<? extends AbstractPacket> clazz2) {
				int com = String.CASE_INSENSITIVE_ORDER.compare(clazz1.getCanonicalName(), clazz2.getCanonicalName());
				if (com == 0) {
					com = clazz1.getCanonicalName().compareTo(clazz2.getCanonicalName());
				}
				
				return com;
			}
		});
	}

	@SideOnly(Side.CLIENT)
	private EntityPlayer getClientPlayer() {
		return Minecraft.getMinecraft().thePlayer;
	}
	
	public void sendToAll(AbstractPacket message) {
		this.channels.get(Side.SERVER).attr(FMLOutboundHandler.FML_MESSAGETARGET).set(FMLOutboundHandler.OutboundTarget.ALL);
		this.channels.get(Side.SERVER).writeAndFlush(message);
	}
	
	public void sendTo(AbstractPacket message, EntityPlayerMP player) {
		this.channels.get(Side.SERVER).attr(FMLOutboundHandler.FML_MESSAGETARGET).set(FMLOutboundHandler.OutboundTarget.PLAYER);
		this.channels.get(Side.SERVER).attr(FMLOutboundHandler.FML_MESSAGETARGETARGS).set(player);
		this.channels.get(Side.SERVER).writeAndFlush(message);
	}
	
	public void sendToAllAround(AbstractPacket message, NetworkRegistry.TargetPoint point) {
		this.channels.get(Side.SERVER).attr(FMLOutboundHandler.FML_MESSAGETARGET).set(FMLOutboundHandler.OutboundTarget.ALLAROUNDPOINT);
		this.channels.get(Side.SERVER).attr(FMLOutboundHandler.FML_MESSAGETARGETARGS).set(point);
		this.channels.get(Side.SERVER).writeAndFlush(message);
	}
	
	public void sendToDimension(AbstractPacket message, int dimensionId) {
		this.channels.get(Side.SERVER).attr(FMLOutboundHandler.FML_MESSAGETARGET).set(FMLOutboundHandler.OutboundTarget.DIMENSION);
		this.channels.get(Side.SERVER).attr(FMLOutboundHandler.FML_MESSAGETARGETARGS).set(dimensionId);
		this.channels.get(Side.SERVER).writeAndFlush(message);
	}
	
	public void sendToServer(AbstractPacket message) {
		this.channels.get(Side.CLIENT).attr(FMLOutboundHandler.FML_MESSAGETARGET).set(FMLOutboundHandler.OutboundTarget.TOSERVER);
		this.channels.get(Side.CLIENT).writeAndFlush(message);
	}
}
public void initGui() {
		info[1] = "";
		getMenu(-2);
		updatingCombatants = false;
		ModMain.pp.sendToServer(new BattleQueryPacket(battleID,(short) 0));
		turnChoiceSent = false;
		if(silly)
		{
public void checkBattleInfo(boolean forceUpdate, int battleSize, boolean playerP
		{
			combatants.clear();
			updatingCombatants = true;
			ModMain.pp.sendToServer(new BattleQueryPacket(battleID,(short) 1));
		}
		update(playerPhase, turnChoiceReceived);
	}
public void receiveCombatant(CombatantInfo combatant)
			if(combatants.size() == serverBattleSize)
			{
				updatingCombatants = false;
				ModMain.pp.sendToServer(new BattleQueryPacket(battleID,(short) 0));
			}
		}
	}
public void drawScreen(int par1, int par2, float par3) {
		super.drawScreen(par1, par2, par3);
		
		if(info[0] != "")
			Minecraft.getMinecraft().fontRenderer.drawString(info[0], width/2 - Minecraft.getMinecraft().fontRenderer.getStringWidth(info[0])/2, height - 90, 0xffffffff);
		if(info[1] != "")
			Minecraft.getMinecraft().fontRenderer.drawString(info[1], width/2 - Minecraft.getMinecraft().fontRenderer.getStringWidth(info[1])/2, height - 80, 0xffffffff);
		
		if(!turnChoiceSent)
		{
else if(timer > 6)
			
			String timerString = "Time left: " + formatString + (timer / 2);
			
			Minecraft.getMinecraft().fontRenderer.drawString(timerString, width/2 - Minecraft.getMinecraft().fontRenderer.getStringWidth(timerString)/2, 10, 0xffffffff);
		}
		
		updateTick--;
		if(updateTick==0)
		{
			ModMain.pp.sendToServer(new BattleQueryPacket(battleID,(short) 0));
			updateTick = updateWaitTime;
		}
	}
public void drawCombatants()
	 */
	private void drawCombatant(CombatantInfo combatant, int x, int y, int color)
	{
		int nameLength = Minecraft.getMinecraft().fontRenderer.getStringWidth(combatant.name);
		String name = ScorePlayerTeam.formatPlayerName(Minecraft.getMinecraft().theWorld.getScoreboard().getPlayersTeam(combatant.name), combatant.name);
		if(combatantButton)
		{
private void drawCombatant(CombatantInfo combatant, int x, int y, int color)
		}
		else
		{
			Minecraft.getMinecraft().fontRenderer.drawString(name, x - nameLength/2, y, color);
		}
		
		//Draw Health
protected void actionPerformed(GuiButton button) {//actionPerformed(GuiButton bu
		case 2: //flee
			player.type = Type.FLEE;
			player.target = player.id;
			ModMain.pp.sendToServer(new BattleCommandPacket(battleID, player));
			turnChoiceSent = true;
			break;
		case 3: //attack menu
protected void actionPerformed(GuiButton button) {//actionPerformed(GuiButton bu
		case 5: //attack
			player.target = ((IDSelectionButton)button).entityID;
			player.type = Type.ATTACK;
			ModMain.pp.sendToServer(new BattleCommandPacket(battleID, player));
			turnChoiceSent = true;
			break;
		case 6: //change weapon
protected void actionPerformed(GuiButton button) {//actionPerformed(GuiButton bu
			
			player.type = Type.CHANGE_WEAPON;
			player.target = player.id;
			ModMain.pp.sendToServer(new BattleCommandPacket(battleID, player));
			turnChoiceSent = true;
			break;
		case 7: //dodge/counter menu
protected void actionPerformed(GuiButton button) {//actionPerformed(GuiButton bu
		case 8: //dodge/counter
			player.target = ((IDSelectionButton)button).entityID;
			player.type = Type.DODGE_COUNTER;
			ModMain.pp.sendToServer(new BattleCommandPacket(battleID, player));
			turnChoiceSent = true;
			break;
		default: break;
public ItemSelectionButton(int buttonID, int x, int y, int width, int height, St
	public void drawButton(Minecraft par1Minecraft, int par2, int par3) {
		if(this.visible)
		{
			this.field_146123_n = par2 >= this.xPosition && par3 >= this.yPosition && par2 < this.xPosition + this.width && par3 < this.yPosition + this.height;
			if(this.field_146123_n) //If mouse is hovering over button
			{
				drawRect(this.xPosition, this.yPosition, this.xPosition + this.width, this.yPosition + this.height, 0x80ffffff);
			}
    "modid": "mod_BurnedKirbyTurnBasedMinecraft",
    "name": "BurnedKirby's Turn-Based Minecraft",
    "description": "Puts RPG style turn-based combat into Minecraft!",
    "version": "0.3.2",
    "mcversion": "1.7.10-10.13.0.1180",
    "url": "https://github.com/BurnedKirby/Minecraft-Turn-Based-Battle-Mod",
    "authors": [ "BurnedKirby" ],
    "credits": "Created by BurnedKirby",
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void run() {
        try {
            run0();
        } finally {
            componentRegistry.removeTests();
            performanceStatsCollector.logDetailedPerformanceInfo(testSuite.getDurationSeconds());
        }
private void run0() {
                coordinatorParameters.getLastTestPhaseToSync());

        echoer.echo("Starting TestSuite");
        logTestSuiteDuration(parallel);

        for (TestData testData : componentRegistry.getTests()) {
            int testIndex = testData.getTestIndex();
private void run0() {
        echoTestSuiteEnd(testCount, started);
    }

    private void logTestSuiteDuration(boolean isParallel) {
        int testDuration = testSuite.getDurationSeconds();
        if (testDuration > 0) {
            echoer.echo("Running time per test: %!s(MISSING)", secondsToHuman(testDuration));
import org.apache.log4j.Logger;

import java.util.Collection;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public void addListener(int testIndex, TestPhaseListener listener) {
        listenerMap.put(testIndex, listener);
    }

    public void updatePhaseCompletion(int testIndex, TestPhase testPhase, SimulatorAddress workerAddress) {
        TestPhaseListener listener = listenerMap.get(testIndex);
        if (listener == null) {
package com.hazelcast.simulator;

import java.util.concurrent.Callable;
import java.util.concurrent.Future;
import java.util.concurrent.FutureTask;
import org.junit.Before;
import org.junit.Test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

public class TestPhaseListenersTest {

public void testGetListeners() {
    }

    @Test
    public void testAddListener() {
        UnitTestPhaseListener listener = new UnitTestPhaseListener();

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import javax.sound.sampled.BooleanControl;
import javax.sound.sampled.Clip;
import javax.sound.sampled.FloatControl;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.UnsupportedAudioFileException;

 * @author Matthias Tavasszy
 *
 */
public class Sound {

	/**
	 * indicates whether there is an audio device or not.
public final void play() {
	 *            loops
	 */
	public final void loop(final int n) {
		try {
			clip = null;

			try {
				audiostream = AudioSystem.getAudioInputStream(f);
				clip = AudioSystem.getClip();
				clip.open(audiostream);
				FloatControl gainControl = (FloatControl) clip
						.getControl(FloatControl.Type.MASTER_GAIN);
				BooleanControl muteControl = (BooleanControl) clip
						.getControl(BooleanControl.Type.MUTE);
				if (volume == 0) {
					muteControl.setValue(true);
				} else {
					muteControl.setValue(false);
					gainControl.setValue((float) (Math.log(volume / 100d)
							/ Math.log(10.0) * 20.0));

				}
				clip.loop(n);
			} catch (UnsupportedAudioFileException | IOException
					| LineUnavailableException e) {
				e.printStackTrace();
public final void setVolume(final float vol) {
			}
		}
	}
}
	@Before
	public final void setup() {
		snd = new Sound("res/Screaming_ducks.wav");
		snd2 = new Sound("res/Screaming_ducks.wav", 5);
	}

	/**
public final void stopLoopTest2() {
	}

	/**
	 * volumeCapTest: tests if the volume cap works.
	 */
	@Test
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	protected int anchorY;
	private boolean isShowing;
	private boolean isHiding;
	private boolean isFabLaidOut;
	private boolean hideSheetAfterSheetIsShown;

	// Listeners
public boolean onTouch(View view, MotionEvent motionEvent) {
				.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
					@Override
					public void onGlobalLayout() {
						// Initialize FAB anchor when the FAB view is laid out
						if (!isFabLaidOut) {
							updateFabAnchor();
							isFabLaidOut = true;
						}
					}
				});
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				</annotation>
			</attribute>

			<attribute name="use-cdp-discovery" type="boolean"
				use="optional" default="true">
				<annotation>
     */
    int getThreads();


    /**
     * <p>getInitialSleepTime</p>
public int getThreads() {
        if (m_config.hasThreads()) return m_config.getThreads();
        return 5;
    }

    /**
     * <p>saveXml</p>
public boolean scheduleNodeCollection(int nodeid) {
    }

    public boolean runSingleSnmpCollection(final int nodeId) {
            final Node node = m_queryMgr.getSnmpNode(nodeId);

            for (final NodeDiscovery snmpColl : getSnmpCollections(node)) {
                if (snmpColl instanceof NodeDiscoveryBridgeTopology)
                    continue;
                snmpColl.setScheduler(m_scheduler);
                snmpColl.run();
            }

            return true;
    }

    public boolean runTopologyDiscovery(final int nodeId) {
        final Node node = m_queryMgr.getSnmpNode(nodeId);

        for (final NodeDiscovery snmpColl : getSnmpCollections(node)) {
            if (snmpColl instanceof NodeDiscoveryBridgeTopology) {
                snmpColl.setScheduler(m_scheduler);
                snmpColl.run();
                return true;
public long getRescanInterval() {
            return m_linkdConfig.getRescanInterval(); 
    }

}
public String getName() {
        return "BridgeLinkDiscovery";
    }

}
public void addUpdatedBFT(Bridge bridge, List<BridgeMacLink> notYetParsedBFTMap)

    public NodeDiscoveryBridgeTopology(EnhancedLinkd linkd, Node node) {
        super(linkd, node);
        setInitialSleepTime(linkd.getInitialSleepTime()+180000);
    }

    @Override
    public void run() {
        if (!m_linkd.getQueryManager().hasUpdatedBft(getNodeId())) {
            LOG.info("run: node: {}, without updated bft. Rescheduling");
            reschedule();
            return;
        }
        
        Date now = new Date();
                
        Set<String> incomingSet = new HashSet<String>();
private Integer goUp(SharedSegment down,Bridge bridge, int level) {
            }
        return goUp(up, bridge,++level);
    }
}

public void setPackageName(String pkg) {

	/**
	 * This method is used to unschedule a ready runnable in the system.
	 * The runnuble is removed from all queue interval where is found.
	 *
	 * @param runnable
	 *            The element to remove from queue intervals.
	 */
	public synchronized void unschedule(ReadyRunnable runnable) {
	    LOG.debug("unschedule: Removing all {}", runnable.getInfo());
		
		boolean done = false;
		synchronized(m_queues) {
		  Iterator<Long> iter = m_queues.keySet().iterator();
		  while (iter.hasNext() && !done) {
		
			Long key = iter.next();
			unschedule(runnable, key.longValue());
public String getName() {
	 * the runnable queues for ready objects and then enqueuing them into the
	 * thread pool for execution.
	 */
        @Override
	public void run() {

		synchronized (this) {
			m_status = RUNNING;
		}

		LOG.debug("run: scheduler running");

		// Loop until a fatal exception occurs or until
		// the thread is interrupted.
		//
		for (;;) {
			// block if there is nothing in the queue(s)
			// When something is added to the queue it
			// signals us to wakeup
			//
			synchronized (this) {
				if (m_status != RUNNING && m_status != PAUSED
						&& m_status != PAUSE_PENDING
						&& m_status != RESUME_PENDING) {
				    LOG.debug("run: status = {}, time to exit", m_status);
					break;
				}

				if (m_scheduled == 0) {
					try {
					    LOG.debug("run: no interfaces scheduled, waiting...");
						wait();
					} catch (InterruptedException ex) {
						break;
					}
				}
			}

			// cycle through the queues checking for
			// what's ready to run. The queues are keyed
			// by the interval, but the mapped elements
			// are peekable fifo queues.
			//
			int runned = 0;
			synchronized (m_queues) {
				// get an iterator so that we can cycle
				// through the queue elements.
				//
				Iterator<Long> iter = m_queues.keySet().iterator();
				while (iter.hasNext()) {
					// Peak for Runnable objects until
					// there are no more ready runnables
					//
					// Also, only go through each queue once!
					// if we didn't add a count then it would
					// be possible to starve other queues.
					//
					Long key = iter.next();
					PeekableFifoQueue<ReadyRunnable> in = m_queues.get(key);
					if (in.isEmpty()) {
						continue;
					}
					ReadyRunnable readyRun = null;
					int maxLoops = in.size();
					do {
						try {
							readyRun = in.peek();
							if (readyRun != null && readyRun.isReady()) {
							    LOG.debug("run: found ready runnable {}", readyRun.getInfo());

								// Pop the interface/readyRunnable from the
								// queue for execution.
								//
								in.remove();

								// Add runnable to the execution queue
								m_runner.execute(readyRun);
								++runned;
							}
						} catch (InterruptedException ex) {
							return; // jump all the way out
						}
					} while (readyRun != null && readyRun.isReady()
							&& --maxLoops > 0);

				}
				
			}

			// Wait for 1 second if there were no runnables
			// executed during this loop, otherwise just
			// start over.
			//
			synchronized (this) {
				m_scheduled -= runned;
				if (runned == 0) {
					try {
						wait(1000);
					} catch (InterruptedException ex) {
						break; // exit for loop
					}
				}
			}

		} // end for(;;)

		LOG.debug("run: scheduler exiting, state = STOPPED");
		synchronized (this) {
			m_status = STOPPED;
		}

	} // end run
	
}
public void testNms7918STCASW01BftCollection() throws Exception {
            printBridgeMacLink(link);
        }

        assertTrue(m_linkd.runTopologyDiscovery(stcasw01.getId()));

        assertEquals(0,m_bridgeBridgeLinkDao.countAll());
        assertEquals(0,m_bridgeMacLinkDao.countAll());
public void testNms7918SAMASW01BftCollection() throws Exception {
            printBridgeMacLink(link);
        }

        assertTrue(m_linkd.runTopologyDiscovery(samasw01.getId()));

        assertEquals(0,m_bridgeBridgeLinkDao.countAll());
        assertEquals(0,m_bridgeMacLinkDao.countAll());
public void testNms7918ASW01BftCollection() throws Exception {
            printBridgeMacLink(link);
        }

        assertTrue(m_linkd.runTopologyDiscovery(asw01.getId()));

        assertEquals(0,m_bridgeBridgeLinkDao.countAll());
        assertEquals(0,m_bridgeMacLinkDao.countAll());
public void testNms7918() throws Exception {
        m_linkdConfig.getConfiguration().setUseOspfDiscovery(false);
        m_linkdConfig.getConfiguration().setUseLldpDiscovery(false);
        m_linkdConfig.getConfiguration().setUseIsisDiscovery(false);
        assertTrue(!m_linkdConfig.useLldpDiscovery());
        assertTrue(!m_linkdConfig.useCdpDiscovery());
        assertTrue(!m_linkdConfig.useOspfDiscovery());
public void testNms7918() throws Exception {
        assertEquals(0,m_bridgeMacLinkDao.countAll());
        
        assertTrue(m_linkd.runTopologyDiscovery(asw01.getId()));
        assertEquals(3,m_bridgeElementDao.countAll());
        assertEquals(0,m_bridgeStpLinkDao.countAll());
        assertEquals(2,m_bridgeBridgeLinkDao.countAll());
        assertEquals(91,m_bridgeMacLinkDao.countAll());

        assertTrue(m_linkd.runTopologyDiscovery(samasw01.getId()));
        assertTrue(m_linkd.runTopologyDiscovery(stcasw01.getId()));
        assertEquals(3,m_bridgeElementDao.countAll());
        assertEquals(0,m_bridgeStpLinkDao.countAll());
        assertEquals(2,m_bridgeBridgeLinkDao.countAll());
        assertEquals(91,m_bridgeMacLinkDao.countAll());

        for (BridgeBridgeLink bblink : m_bridgeBridgeLinkDao.findAll()) {
            printBridgeBridgeLink(bblink);
public void testNms7918TwoSteps() throws Exception {
        m_linkdConfig.getConfiguration().setUseOspfDiscovery(false);
        m_linkdConfig.getConfiguration().setUseLldpDiscovery(false);
        m_linkdConfig.getConfiguration().setUseIsisDiscovery(false);
        assertTrue(!m_linkdConfig.useLldpDiscovery());
        assertTrue(!m_linkdConfig.useCdpDiscovery());
        assertTrue(!m_linkdConfig.useOspfDiscovery());
public void testNms7918TwoSteps() throws Exception {
        assertEquals(1,m_bridgeBridgeLinkDao.countAll());
        assertEquals(67,m_bridgeMacLinkDao.countAll());

        assertTrue(m_linkd.runTopologyDiscovery(samasw01.getId()));
        assertTrue(m_linkd.runSingleSnmpCollection(stcasw01.getId()));
        assertTrue(m_linkd.runTopologyDiscovery(stcasw01.getId()));
        assertEquals(3,m_bridgeElementDao.countAll());
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

package connect.four.gui;

import connect.four.*;
import connect.four.board.*;
import connect.four.player.*;
import java.awt.Color;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.Timer;

public class GamePanel extends javax.swing.JPanel implements
		ScoreChart.Listener
{
	
	GUI gui;
	static final long GLOW_START_TIME = (int) System.currentTimeMillis();
	static final int PLAY_TIME = 1500;
	boolean falling;
	int columnNum;
	int turnNum;
	int whoPlayed;
	int newDrawPos;
	int newColumnNum;
	Player[] players;
	Game game;
	GUIPiece[] pieces;
	Board board;
	boolean isComputerEnabled;
	boolean justWon;
	
	public GamePanel(GUI gui, boolean isComputerEnabled)
	{
		// whoPlayed = 1;
		players = new Player[2];
		players[0] = new GUIPlayer(gui.getPlayer1Name(), this);
		this.isComputerEnabled = isComputerEnabled;
public GamePanel(GUI gui, boolean isComputerEnabled)
		game.registerListener(this);
		justWon = false;
		
		initNewGame();
	}
	
	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	@SuppressWarnings("unchecked")
	// <editor-fold defaultstate="collapsed"
	// desc="Generated Code">//GEN-BEGIN:initComponents
	private void initComponents()
	{
		
		player1NameBox = new javax.swing.JLabel();
		currentWins = new javax.swing.JLabel();
		pNameDisplay = new javax.swing.JLabel();
		turnDisplay = new javax.swing.JLabel();
		col1 = new javax.swing.JPanel();
		col2 = new javax.swing.JPanel();
		col3 = new javax.swing.JPanel();
		col4 = new javax.swing.JPanel();
		col5 = new javax.swing.JPanel();
		col6 = new javax.swing.JPanel();
		topGlass = new javax.swing.JPanel();
		col7 = new javax.swing.JPanel();
		player2NameBox = new javax.swing.JLabel();
		bgImage = new javax.swing.JLabel();
		
		setBackground(new java.awt.Color(0, 0, 0));
		setPreferredSize(new java.awt.Dimension(1280, 800));
		addMouseListener(new java.awt.event.MouseAdapter() {
			public void mouseClicked(java.awt.event.MouseEvent evt)
			{
				formMouseClicked(evt);
			}
		});
		setLayout(null);
		
		player1NameBox.setFont(new java.awt.Font("Lucida Grande", 0, 18)); // NOI18N
		player1NameBox.setForeground(new java.awt.Color(255, 255, 255));
		player1NameBox.setText("player 1");
		add(player1NameBox);
		player1NameBox.setBounds(1070, 40, 210, 40);
		
		currentWins.setFont(new java.awt.Font("Lucida Grande", 0, 18)); // NOI18N
		currentWins.setForeground(new java.awt.Color(255, 255, 255));
		currentWins.setText("CURRENT WINS");
		add(currentWins);
		currentWins.setBounds(1070, 0, 200, 40);
		
		pNameDisplay.setFont(new java.awt.Font("Lucida Grande", 0, 18)); // NOI18N
		pNameDisplay.setForeground(new java.awt.Color(255, 255, 255));
		pNameDisplay.setText("jLabel2");
		add(pNameDisplay);
		pNameDisplay.setBounds(1070, 210, 200, 40);
		
		turnDisplay.setFont(new java.awt.Font("Lucida Grande", 0, 18)); // NOI18N
		turnDisplay.setForeground(new java.awt.Color(255, 255, 255));
		turnDisplay.setText("jLabel2");
		add(turnDisplay);
		turnDisplay.setBounds(1070, 150, 200, 40);
		
		col1.setBackground(new java.awt.Color(102, 102, 102));
		col1.setOpaque(false);
		col1.addMouseListener(new java.awt.event.MouseAdapter() {
			public void mouseClicked(java.awt.event.MouseEvent evt)
			{
				col1MouseClicked(evt);
			}
			
			public void mouseExited(java.awt.event.MouseEvent evt)
			{
				col1MouseExited(evt);
			}
			
			public void mouseEntered(java.awt.event.MouseEvent evt)
			{
				col1MouseEntered(evt);
			}
		});
		col1.setLayout(null);
		add(col1);
		col1.setBounds(0, 0, 310, 740);
		
		col2.setBackground(new java.awt.Color(102, 102, 102));
		col2.setOpaque(false);
		col2.addMouseListener(new java.awt.event.MouseAdapter() {
			public void mouseClicked(java.awt.event.MouseEvent evt)
			{
				col2MouseClicked(evt);
			}
			
			public void mouseExited(java.awt.event.MouseEvent evt)
			{
				col2MouseExited(evt);
			}
			
			public void mouseEntered(java.awt.event.MouseEvent evt)
			{
				col2MouseEntered(evt);
			}
		});
		col2.setLayout(null);
		add(col2);
		col2.setBounds(320, 0, 80, 740);
		
		col3.setBackground(new java.awt.Color(102, 102, 102));
		col3.setOpaque(false);
		col3.addMouseListener(new java.awt.event.MouseAdapter() {
			public void mouseClicked(java.awt.event.MouseEvent evt)
			{
				col3MouseClicked(evt);
			}
			
			public void mouseExited(java.awt.event.MouseEvent evt)
			{
				col3MouseExited(evt);
			}
			
			public void mouseEntered(java.awt.event.MouseEvent evt)
			{
				col3MouseEntered(evt);
			}
		});
		col3.setLayout(null);
		add(col3);
		col3.setBounds(410, 10, 80, 740);
		
		col4.setBackground(new java.awt.Color(102, 102, 102));
		col4.setOpaque(false);
		col4.addMouseListener(new java.awt.event.MouseAdapter() {
			public void mouseClicked(java.awt.event.MouseEvent evt)
			{
				col4MouseClicked(evt);
			}
			
			public void mouseExited(java.awt.event.MouseEvent evt)
			{
				col4MouseExited(evt);
			}
			
			public void mouseEntered(java.awt.event.MouseEvent evt)
			{
				col4MouseEntered(evt);
			}
		});
		col4.setLayout(null);
		add(col4);
		col4.setBounds(500, -10, 80, 740);
		
		col5.setBackground(new java.awt.Color(102, 102, 102));
		col5.setOpaque(false);
		col5.addMouseListener(new java.awt.event.MouseAdapter() {
			public void mouseClicked(java.awt.event.MouseEvent evt)
			{
				col5MouseClicked(evt);
			}
			
			public void mouseExited(java.awt.event.MouseEvent evt)
			{
				col5MouseExited(evt);
			}
			
			public void mouseEntered(java.awt.event.MouseEvent evt)
			{
				col5MouseEntered(evt);
			}
		});
		col5.setLayout(null);
		add(col5);
		col5.setBounds(590, 0, 80, 740);
		
		col6.setBackground(new java.awt.Color(102, 102, 102));
		col6.setOpaque(false);
		col6.addMouseListener(new java.awt.event.MouseAdapter() {
			public void mouseClicked(java.awt.event.MouseEvent evt)
			{
				col6MouseClicked(evt);
			}
			
			public void mouseExited(java.awt.event.MouseEvent evt)
			{
				col6MouseExited(evt);
			}
			
			public void mouseEntered(java.awt.event.MouseEvent evt)
			{
				col6MouseEntered(evt);
			}
		});
		col6.setLayout(null);
		add(col6);
		col6.setBounds(680, -30, 80, 740);
		
		topGlass.setBackground(new java.awt.Color(102, 102, 102));
		topGlass.setOpaque(false);
		topGlass.addMouseListener(new java.awt.event.MouseAdapter() {
			public void mouseClicked(java.awt.event.MouseEvent evt)
			{
				topGlassMouseClicked(evt);
			}
			
			public void mouseExited(java.awt.event.MouseEvent evt)
			{
				topGlassMouseExited(evt);
			}
			
			public void mouseEntered(java.awt.event.MouseEvent evt)
			{
				topGlassMouseEntered(evt);
			}
		});
		topGlass.setLayout(null);
		
		col7.setBackground(new java.awt.Color(102, 102, 102));
		col7.setOpaque(false);
		col7.addMouseListener(new java.awt.event.MouseAdapter() {
			public void mouseClicked(java.awt.event.MouseEvent evt)
			{
				col7MouseClicked(evt);
			}
			
			public void mouseExited(java.awt.event.MouseEvent evt)
			{
				col7MouseExited(evt);
			}
			
			public void mouseEntered(java.awt.event.MouseEvent evt)
			{
				col7MouseEntered(evt);
			}
		});
		col7.setLayout(null);
		topGlass.add(col7);
		col7.setBounds(770, 0, 300, 740);
		
		player2NameBox.setFont(new java.awt.Font("Lucida Grande", 0, 18)); // NOI18N
		player2NameBox.setForeground(new java.awt.Color(255, 255, 255));
		player2NameBox.setText("player 1");
		topGlass.add(player2NameBox);
public void mouseEntered(java.awt.event.MouseEvent evt)
		add(topGlass);
		topGlass.setBounds(0, 0, 1280, 800);
		
		bgImage.setIcon(new javax.swing.ImageIcon(getClass().getResource(
				"/board.png"))); // NOI18N
		bgImage.setText("jLabel1");
		bgImage.setIgnoreRepaint(true);
		add(bgImage);
		bgImage.setBounds(0, 150, 1070, 590);
	}// </editor-fold>//GEN-END:initComponents
	
	private void col1MouseEntered(java.awt.event.MouseEvent evt)
	{// GEN-FIRST:event_col1MouseEntered
		calcNewPos(0);
		calcWidth(0);
	}// GEN-LAST:event_col1MouseEntered
	
	private void col1MouseExited(java.awt.event.MouseEvent evt)
	{// GEN-FIRST:event_col1MouseExited
	
	}// GEN-LAST:event_col1MouseExited
	
	private void col2MouseExited(java.awt.event.MouseEvent evt)
	{// GEN-FIRST:event_col2MouseExited
	
	}// GEN-LAST:event_col2MouseExited
	
	private void col2MouseEntered(java.awt.event.MouseEvent evt)
	{// GEN-FIRST:event_col2MouseEntered
		calcNewPos(1);
		calcWidth(1);
	}// GEN-LAST:event_col2MouseEntered
	
	private void col4MouseExited(java.awt.event.MouseEvent evt)
	{// GEN-FIRST:event_col4MouseExited
		// TODO add your handling code here:
	}// GEN-LAST:event_col4MouseExited
	
	private void col4MouseEntered(java.awt.event.MouseEvent evt)
	{// GEN-FIRST:event_col4MouseEntered
		calcNewPos(3);
		calcWidth(3);
	}// GEN-LAST:event_col4MouseEntered
	
	private void col5MouseExited(java.awt.event.MouseEvent evt)
	{// GEN-FIRST:event_col5MouseExited
		// TODO add your handling code here:
	}// GEN-LAST:event_col5MouseExited
	
	private void col5MouseEntered(java.awt.event.MouseEvent evt)
	{// GEN-FIRST:event_col5MouseEntered
		calcNewPos(4);
		calcWidth(4);
	}// GEN-LAST:event_col5MouseEntered
	
	private void col6MouseExited(java.awt.event.MouseEvent evt)
	{// GEN-FIRST:event_col6MouseExited
		// TODO add your handling code here:
	}// GEN-LAST:event_col6MouseExited
	
	private void col6MouseEntered(java.awt.event.MouseEvent evt)
	{// GEN-FIRST:event_col6MouseEntered
		calcNewPos(5);
		calcWidth(5);
	}// GEN-LAST:event_col6MouseEntered
	
	private void col7MouseExited(java.awt.event.MouseEvent evt)
	{// GEN-FIRST:event_col7MouseExited
		// TODO add your handling code here:
	}// GEN-LAST:event_col7MouseExited
	
	private void col7MouseEntered(java.awt.event.MouseEvent evt)
	{// GEN-FIRST:event_col7MouseEntered
		calcNewPos(6);
		calcWidth(6);
	}// GEN-LAST:event_col7MouseEntered
	
	private void col3MouseExited(java.awt.event.MouseEvent evt)
	{// GEN-FIRST:event_col3MouseExited
		// TODO add your handling code here:
	}// GEN-LAST:event_col3MouseExited
	
	private void col3MouseEntered(java.awt.event.MouseEvent evt)
	{// GEN-FIRST:event_col3MouseEntered
		calcNewPos(2);
		calcWidth(2);
	}// GEN-LAST:event_col3MouseEntered
	
	private void formMouseClicked(java.awt.event.MouseEvent evt)
	{// GEN-FIRST:event_formMouseClicked
	
	}// GEN-LAST:event_formMouseClicked
	
	private void col1MouseClicked(java.awt.event.MouseEvent evt)
	{// GEN-FIRST:event_col1MouseClicked
		if (game.getCurrentPlayer() != players[1] || !isComputerEnabled)
			turn();
	}// GEN-LAST:event_col1MouseClicked
	
	private void col2MouseClicked(java.awt.event.MouseEvent evt)
	{// GEN-FIRST:event_col2MouseClicked
		if (game.getCurrentPlayer() != players[1] || !isComputerEnabled)
			turn();
	}// GEN-LAST:event_col2MouseClicked
	
	private void col3MouseClicked(java.awt.event.MouseEvent evt)
	{// GEN-FIRST:event_col3MouseClicked
		if (game.getCurrentPlayer() != players[1] || !isComputerEnabled)
			turn();
	}// GEN-LAST:event_col3MouseClicked
	
	private void col4MouseClicked(java.awt.event.MouseEvent evt)
	{// GEN-FIRST:event_col4MouseClicked
		if (game.getCurrentPlayer() != players[1] || !isComputerEnabled)
			turn();
	}// GEN-LAST:event_col4MouseClicked
	
	private void col6MouseClicked(java.awt.event.MouseEvent evt)
	{// GEN-FIRST:event_col6MouseClicked
		if (game.getCurrentPlayer() != players[1] || !isComputerEnabled)
			turn();
	}// GEN-LAST:event_col6MouseClicked
	
	private void col7MouseClicked(java.awt.event.MouseEvent evt)
	{// GEN-FIRST:event_col7MouseClicked
		if (game.getCurrentPlayer() != players[1] || !isComputerEnabled)
			turn();
	}// GEN-LAST:event_col7MouseClicked
	
	private void col5MouseClicked(java.awt.event.MouseEvent evt)
	{// GEN-FIRST:event_col5MouseClicked
		if (game.getCurrentPlayer() != players[1] || !isComputerEnabled)
			turn();
	}// GEN-LAST:event_col5MouseClicked
	
	private void topGlassMouseClicked(java.awt.event.MouseEvent evt)
	{// GEN-FIRST:event_topGlassMouseClicked
		// TODO add your handling code here:
	}// GEN-LAST:event_topGlassMouseClicked
	
	private void topGlassMouseExited(java.awt.event.MouseEvent evt)
	{// GEN-FIRST:event_topGlassMouseExited
		// TODO add your handling code here:
	}// GEN-LAST:event_topGlassMouseExited
	
	private void topGlassMouseEntered(java.awt.event.MouseEvent evt)
	{// GEN-FIRST:event_topGlassMouseEntered
		// TODO add your handling code here:
	}// GEN-LAST:event_topGlassMouseEntered
	
	void dropPiece()
	{
public void actionPerformed(ActionEvent e)
				long duration = System.currentTimeMillis() - startTime;
				float progress = (float) duration / (float) PLAY_TIME;
				
				if (progress > 1f)
				{
					progress = 1f;
					((Timer) (e.getSource())).stop();
					falling = false;
					System.out.println("Piece fell.");
else if (game.getCurrentPlayer() == players[1])
					}
					turnUp();
				}
				y = y + (int) Math.round((destination - startY) * progress);
				pieces[turnNum].setLocation(x, y);
				if (y == getTargetY())
				{
					((Timer) (e.getSource())).stop();
					falling = false;
					System.out.println("Piece fell.");
					if (!isComputerEnabled)
					{
						GUIPlayer player = (GUIPlayer) game.getCurrentPlayer();
						player.getBoard().play(getColumnNum(), player);
					}
					else
					{
						if (game.getCurrentPlayer() == players[0])
						{
							GUIPlayer player = (GUIPlayer) game
									.getCurrentPlayer();
							player.getBoard().play(getColumnNum(), player);
						}
						else if (game.getCurrentPlayer() == players[1])
						{
							GUIWrapperPlayer player = (GUIWrapperPlayer) game
									.getCurrentPlayer();
							player.getBoard().play(getColumnNum(), player);
						}
					}
					
					turnUp();
				}
			}
		});
		timer.start();
void calcNewPos(int columnEntered)
		
		newDrawPos = xPos;
		newColumnNum = columnEntered;
		
	}
	
	void turnUp()
void turnUp()
			if (falling == false)
			{
				// move piece to top glass, for glow.
				glow(pieces[turnNum]);
				
				turnNum += 1;
				
void initNewGame()
	{
		turnNum = 0;
		columnNum = 0;
		whoPlayed = 1;
		falling = false;
		pieces = new GUIPiece[43];
		pieces[turnNum] = new GUIPiece(turnNum);
else if (game.getCurrentPlayer() == players[1])
					topGlass.remove(piece);
				}
			}
			initNewGame();
			gui.addGameOver();
			justWon = true;
		}
	}
	
	void glow(GUIPiece currentPiece)
	{
		final GUIPiece cP = currentPiece;
		topGlass.add(cP);
		Timer timer = new Timer(100, new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e)
			{
				long tick = GLOW_START_TIME - System.currentTimeMillis();
				tick = (-1 * tick / 100);
				// System.out.println(tick%!)(MISSING);
				cP.setIcon(cP.getGlow((int) tick %!)(MISSING));
				topGlass.invalidate();
				topGlass.revalidate();
				topGlass.repaint();
			}
			
		});
		timer.setRepeats(true);
		timer.setCoalesce(true);
		timer.start();
	}
	
	// Variables declaration - do not modify//GEN-BEGIN:variables
	private javax.swing.JLabel bgImage;
	private javax.swing.JPanel col1;
	private javax.swing.JPanel col2;
	private javax.swing.JPanel col3;
	private javax.swing.JPanel col4;
	private javax.swing.JPanel col5;
	private javax.swing.JPanel col6;
	private javax.swing.JPanel col7;
	private javax.swing.JLabel currentWins;
	private javax.swing.JLabel pNameDisplay;
	private javax.swing.JLabel player1NameBox;
	private javax.swing.JLabel player2NameBox;
	private javax.swing.JPanel topGlass;
	private javax.swing.JLabel turnDisplay;
	// End of variables declaration//GEN-END:variables
	
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void call() {
                    }
                }
            };
            mas.set(schedule(recursiveAction, initialDelay, unit));
            return mas;
        }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

package org.elasticsearch.index.cache;

import org.apache.lucene.index.IndexReader;
import org.elasticsearch.ElasticsearchException;
import org.elasticsearch.cluster.ClusterChangedEvent;
import org.elasticsearch.cluster.ClusterService;
public void close() throws ElasticsearchException {
        }
    }

    public void clear(IndexReader reader) {
        filterCache.clear(reader);
        docSetCache.clear(reader);
    }

    public void clear(String reason) {
        filterCache.clear(reason);
        queryParserCache.clear();
import com.google.common.cache.RemovalListener;
import com.google.common.cache.Weigher;
import org.apache.lucene.index.AtomicReaderContext;
import org.apache.lucene.index.SegmentReader;
import org.apache.lucene.search.DocIdSet;
import org.apache.lucene.search.Filter;
import org.elasticsearch.common.Nullable;
import org.elasticsearch.common.Strings;
import org.elasticsearch.common.inject.Inject;
import org.elasticsearch.common.lucene.docset.DocIdSets;
import org.elasticsearch.common.lucene.search.CachedFilter;
import org.elasticsearch.common.lucene.search.NoCacheFilter;
import java.io.IOException;
import java.util.concurrent.ConcurrentMap;

public class WeightedFilterCache extends AbstractIndexComponent implements FilterCache, SegmentReader.CoreClosedListener {

    final IndicesFilterCache indicesFilterCache;
    IndexService indexService;
public void close() throws ElasticsearchException {
    }

    @Override
    public void clear(String reason) {
        logger.debug("full cache clear, reason [{}]", reason);
        for (Object readerKey : seenReaders.keySet()) {
public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws
                    Boolean previous = cache.seenReaders.putIfAbsent(context.reader().getCoreCacheKey(), Boolean.TRUE);
                    if (previous == null) {
                        // we add a core closed listener only, for non core IndexReaders we rely on clear being called (percolator for example)
                        if (context.reader() instanceof SegmentReader) {
                            ((SegmentReader) context.reader()).addCoreClosedListener(cache);
                        }
                    }
                }
                // we can't pass down acceptedDocs provided, because we are caching the result, and acceptedDocs
public int hashCode() {
            return readerKey().hashCode() + 31 * filterKey.hashCode();
        }
    }
}
        void onUnload(FieldMapper.Names fieldNames, FieldDataType fieldDataType, boolean wasEvicted, long sizeInBytes);
    }

    /**
     * The resident field data cache is a *per field* cache that keeps all the values in memory.
     */

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Maps;
import org.apache.lucene.index.IndexReader;
import org.elasticsearch.ElasticsearchIllegalArgumentException;
import org.elasticsearch.common.collect.MapBuilder;
import org.elasticsearch.common.collect.Tuple;
import org.elasticsearch.index.service.IndexService;
import org.elasticsearch.index.settings.IndexSettings;
import org.elasticsearch.indices.fielddata.breaker.CircuitBreakerService;
import org.elasticsearch.indices.fielddata.cache.IndicesFieldDataCache;
import org.elasticsearch.indices.fielddata.cache.IndicesFieldDataCacheListener;

public void clearField(String fieldName) {
        }
    }

    public void clear(IndexReader reader) {
        synchronized (loadedFieldData) {
            for (IndexFieldData<?> indexFieldData : loadedFieldData.values()) {
                indexFieldData.clear(reader);
            }
            for (IndexFieldDataCache cache : fieldDataCaches.values()) {
                cache.clear(reader);
            }
        }
    }

    public void onMappingUpdate() {
        // synchronize to make sure to not miss field data instances that are being loaded
        synchronized (loadedFieldData) {
public void onMappingUpdate() {
        }
    }

    public <IFD extends IndexFieldData<?>> IFD getForField(FieldMapper<?> mapper) {
        final FieldMapper.Names fieldNames = mapper.names();
        final FieldDataType type = mapper.fieldDataType();
public void onMappingUpdate() {
                            cache = new IndexFieldDataCache.Soft(logger, indexService, fieldNames, type, indicesFieldDataCacheListener);
                        } else if ("node".equals(cacheType)) {
                            cache = indicesFieldDataCache.buildIndexFieldDataCache(indexService, index, fieldNames, type);
                        } else {
                            throw new ElasticsearchIllegalArgumentException("cache type not supported [" + cacheType + "] for field [" + fieldNames.fullName() + "]");
                        }
public void onMappingUpdate() {
        return (IFD) fieldData;
    }

}
import org.elasticsearch.index.codec.docvaluesformat.DocValuesFormatProvider;
import org.elasticsearch.index.codec.postingsformat.PostingsFormatProvider;
import org.elasticsearch.index.fielddata.FieldDataType;
import org.elasticsearch.index.fielddata.IndexFieldDataService;
import org.elasticsearch.index.mapper.core.AbstractFieldMapper;
import org.elasticsearch.index.query.QueryParseContext;
import org.elasticsearch.index.similarity.SimilarityProvider;
public static Loading parse(String loading, Loading defaultValue) {

    Filter termsFilter(List values, @Nullable QueryParseContext context);

    Filter termsFilter(IndexFieldDataService fieldData, List values, @Nullable QueryParseContext context);

    Query rangeQuery(Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, @Nullable QueryParseContext context);

import org.elasticsearch.index.codec.postingsformat.PostingsFormatProvider;
import org.elasticsearch.index.codec.postingsformat.PostingsFormatService;
import org.elasticsearch.index.fielddata.FieldDataType;
import org.elasticsearch.index.fielddata.IndexFieldDataService;
import org.elasticsearch.index.mapper.*;
import org.elasticsearch.index.mapper.internal.AllFieldMapper;
import org.elasticsearch.index.mapper.object.ObjectMapper;
public Filter termsFilter(List values, @Nullable QueryParseContext context) {
     * A terms filter based on the field data cache
     */
    @Override
    public Filter termsFilter(IndexFieldDataService fieldDataService, List values, @Nullable QueryParseContext context) {
        // create with initial size large enough to avoid rehashing
        ObjectOpenHashSet<BytesRef> terms =
                new ObjectOpenHashSet<>((int) (values.size() * (1 + ObjectOpenHashSet.DEFAULT_LOAD_FACTOR)));
import org.elasticsearch.index.codec.docvaluesformat.DocValuesFormatProvider;
import org.elasticsearch.index.codec.postingsformat.PostingsFormatProvider;
import org.elasticsearch.index.fielddata.FieldDataType;
import org.elasticsearch.index.fielddata.IndexFieldDataService;
import org.elasticsearch.index.fielddata.IndexNumericFieldData;
import org.elasticsearch.index.mapper.*;
import org.elasticsearch.index.query.QueryParseContext;
public Filter rangeFilter(Object lowerTerm, Object upperTerm, boolean includeLow
    }

    @Override
    public Filter rangeFilter(IndexFieldDataService fieldData, Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, @Nullable QueryParseContext context) {
        return NumericRangeFieldDataFilter.newByteRange((IndexNumericFieldData) fieldData.getForField(this),
                lowerTerm == null ? null : parseValue(lowerTerm),
                upperTerm == null ? null : parseValue(upperTerm),
                includeLower, includeUpper);
import org.elasticsearch.index.codec.docvaluesformat.DocValuesFormatProvider;
import org.elasticsearch.index.codec.postingsformat.PostingsFormatProvider;
import org.elasticsearch.index.fielddata.FieldDataType;
import org.elasticsearch.index.fielddata.IndexFieldDataService;
import org.elasticsearch.index.fielddata.IndexNumericFieldData;
import org.elasticsearch.index.mapper.*;
import org.elasticsearch.index.mapper.core.LongFieldMapper.CustomLongNumericField;
public Filter rangeFilter(Object lowerTerm, Object upperTerm, boolean includeLow
    }

    @Override
    public Filter rangeFilter(IndexFieldDataService fieldData, Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, @Nullable QueryParseContext context) {
        return rangeFilter(fieldData, lowerTerm, upperTerm, includeLower, includeUpper, context, false);
    }

    public Filter rangeFilter(IndexFieldDataService fieldData, Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, @Nullable QueryParseContext context, boolean explicitCaching) {
        boolean cache = explicitCaching;
        Long lowerVal = null;
        Long upperVal = null;
public Filter rangeFilter(IndexFieldDataService fieldData, Object lowerTerm, Obj
        }

        Filter filter =  NumericRangeFieldDataFilter.newLongRange(
            (IndexNumericFieldData<?>) fieldData.getForField(this), lowerVal,upperVal, includeLower, includeUpper
        );
        if (!cache) {
            // We don't cache range filter if `now` date expression is used and also when a compound filter wraps
import org.elasticsearch.index.codec.docvaluesformat.DocValuesFormatProvider;
import org.elasticsearch.index.codec.postingsformat.PostingsFormatProvider;
import org.elasticsearch.index.fielddata.FieldDataType;
import org.elasticsearch.index.fielddata.IndexFieldDataService;
import org.elasticsearch.index.fielddata.IndexNumericFieldData;
import org.elasticsearch.index.mapper.*;
import org.elasticsearch.index.query.QueryParseContext;
public Filter rangeFilter(Double lowerTerm, Double upperTerm, boolean includeLow
    }

    @Override
    public Filter rangeFilter(IndexFieldDataService fieldData, Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, @Nullable QueryParseContext context) {
        return NumericRangeFieldDataFilter.newDoubleRange((IndexNumericFieldData) fieldData.getForField(this),
                lowerTerm == null ? null : parseDoubleValue(lowerTerm),
                upperTerm == null ? null : parseDoubleValue(upperTerm),
                includeLower, includeUpper);
import org.elasticsearch.index.codec.docvaluesformat.DocValuesFormatProvider;
import org.elasticsearch.index.codec.postingsformat.PostingsFormatProvider;
import org.elasticsearch.index.fielddata.FieldDataType;
import org.elasticsearch.index.fielddata.IndexFieldDataService;
import org.elasticsearch.index.fielddata.IndexNumericFieldData;
import org.elasticsearch.index.mapper.*;
import org.elasticsearch.index.query.QueryParseContext;
public Filter rangeFilter(Object lowerTerm, Object upperTerm, boolean includeLow
    }

    @Override
    public Filter rangeFilter(IndexFieldDataService fieldData, Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, @Nullable QueryParseContext context) {
        return NumericRangeFieldDataFilter.newFloatRange((IndexNumericFieldData) fieldData.getForField(this),
                lowerTerm == null ? null : parseValue(lowerTerm),
                upperTerm == null ? null : parseValue(upperTerm),
                includeLower, includeUpper);
import org.elasticsearch.index.codec.docvaluesformat.DocValuesFormatProvider;
import org.elasticsearch.index.codec.postingsformat.PostingsFormatProvider;
import org.elasticsearch.index.fielddata.FieldDataType;
import org.elasticsearch.index.fielddata.IndexFieldDataService;
import org.elasticsearch.index.fielddata.IndexNumericFieldData;
import org.elasticsearch.index.mapper.*;
import org.elasticsearch.index.query.QueryParseContext;
public Filter rangeFilter(Object lowerTerm, Object upperTerm, boolean includeLow
    }

    @Override
    public Filter rangeFilter(IndexFieldDataService fieldData, Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, @Nullable QueryParseContext context) {
        return NumericRangeFieldDataFilter.newIntRange((IndexNumericFieldData) fieldData.getForField(this),
                lowerTerm == null ? null : parseValue(lowerTerm),
                upperTerm == null ? null : parseValue(upperTerm),
                includeLower, includeUpper);
import org.elasticsearch.index.codec.docvaluesformat.DocValuesFormatProvider;
import org.elasticsearch.index.codec.postingsformat.PostingsFormatProvider;
import org.elasticsearch.index.fielddata.FieldDataType;
import org.elasticsearch.index.fielddata.IndexFieldDataService;
import org.elasticsearch.index.fielddata.IndexNumericFieldData;
import org.elasticsearch.index.mapper.*;
import org.elasticsearch.index.query.QueryParseContext;
public Filter rangeFilter(Object lowerTerm, Object upperTerm, boolean includeLow
    }

    @Override
    public Filter rangeFilter(IndexFieldDataService fieldData, Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, @Nullable QueryParseContext context) {
        return NumericRangeFieldDataFilter.newLongRange((IndexNumericFieldData) fieldData.getForField(this),
                lowerTerm == null ? null : parseLongValue(lowerTerm),
                upperTerm == null ? null : parseLongValue(upperTerm),
                includeLower, includeUpper);
import org.elasticsearch.index.analysis.NamedAnalyzer;
import org.elasticsearch.index.codec.docvaluesformat.DocValuesFormatProvider;
import org.elasticsearch.index.codec.postingsformat.PostingsFormatProvider;
import org.elasticsearch.index.fielddata.IndexFieldDataService;
import org.elasticsearch.index.fielddata.IndexNumericFieldData;
import org.elasticsearch.index.mapper.*;
import org.elasticsearch.index.mapper.internal.AllFieldMapper;
public Filter termFilter(Object value, @Nullable QueryParseContext context) {
    /**
     * A range filter based on the field data cache.
     */
    public abstract Filter rangeFilter(IndexFieldDataService fieldData, Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, @Nullable QueryParseContext context);

    /**
     * A terms filter based on the field data cache for numeric fields.
     */
    @Override
    public Filter termsFilter(IndexFieldDataService fieldDataService, List values, @Nullable QueryParseContext context) {
        IndexNumericFieldData fieldData = fieldDataService.getForField(this);
        if (fieldData.getNumericType().isFloatingPoint()) {
            // create with initial size large enough to avoid rehashing
import org.elasticsearch.index.codec.docvaluesformat.DocValuesFormatProvider;
import org.elasticsearch.index.codec.postingsformat.PostingsFormatProvider;
import org.elasticsearch.index.fielddata.FieldDataType;
import org.elasticsearch.index.fielddata.IndexFieldDataService;
import org.elasticsearch.index.fielddata.IndexNumericFieldData;
import org.elasticsearch.index.mapper.*;
import org.elasticsearch.index.query.QueryParseContext;
public Filter rangeFilter(Object lowerTerm, Object upperTerm, boolean includeLow
    }

    @Override
    public Filter rangeFilter(IndexFieldDataService fieldData, Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, @Nullable QueryParseContext context) {
        return NumericRangeFieldDataFilter.newShortRange((IndexNumericFieldData) fieldData.getForField(this),
                lowerTerm == null ? null : parseValue(lowerTerm),
                upperTerm == null ? null : parseValue(upperTerm),
                includeLower, includeUpper);
import org.elasticsearch.index.codec.docvaluesformat.DocValuesFormatProvider;
import org.elasticsearch.index.codec.postingsformat.PostingsFormatProvider;
import org.elasticsearch.index.fielddata.FieldDataType;
import org.elasticsearch.index.fielddata.IndexFieldDataService;
import org.elasticsearch.index.fielddata.IndexNumericFieldData;
import org.elasticsearch.index.mapper.*;
import org.elasticsearch.index.mapper.core.FloatFieldMapper;
public Filter rangeFilter(Object lowerTerm, Object upperTerm, boolean includeLow
    }

    @Override
    public Filter rangeFilter(IndexFieldDataService fieldData, Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, @Nullable QueryParseContext context) {
        return NumericRangeFieldDataFilter.newFloatRange((IndexNumericFieldData) fieldData.getForField(this),
                lowerTerm == null ? null : parseValue(lowerTerm),
                upperTerm == null ? null : parseValue(upperTerm),
                includeLower, includeUpper);
import org.elasticsearch.index.codec.docvaluesformat.DocValuesFormatProvider;
import org.elasticsearch.index.codec.postingsformat.PostingsFormatProvider;
import org.elasticsearch.index.fielddata.FieldDataType;
import org.elasticsearch.index.fielddata.IndexFieldDataService;
import org.elasticsearch.index.fielddata.IndexNumericFieldData;
import org.elasticsearch.index.mapper.*;
import org.elasticsearch.index.mapper.core.LongFieldMapper.CustomLongNumericField;
public Filter rangeFilter(Object lowerTerm, Object upperTerm, boolean includeLow
    }

    @Override
    public Filter rangeFilter(IndexFieldDataService fieldData, Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, @Nullable QueryParseContext context) {
        return NumericRangeFieldDataFilter.newLongRange((IndexNumericFieldData) fieldData.getForField(this),
                lowerTerm == null ? null : parseValue(lowerTerm),
                upperTerm == null ? null : parseValue(upperTerm),
                includeLower, includeUpper);
import org.apache.lucene.queries.TermFilter;
import org.apache.lucene.search.Query;
import org.apache.lucene.util.BytesRef;
import org.elasticsearch.ElasticsearchException;
import org.elasticsearch.common.bytes.BytesReference;
import org.elasticsearch.common.inject.Inject;
    private final PercolateTypeListener percolateTypeListener = new PercolateTypeListener();
    private final AtomicBoolean realTimePercolatorEnabled = new AtomicBoolean(false);

    @Inject
    public PercolatorQueriesRegistry(ShardId shardId, @IndexSettings Settings indexSettings, IndexQueryParserService queryParserService,
                                     ShardIndexingService indexingService, IndicesLifecycle indicesLifecycle, MapperService mapperService,
Query parsePercolatorDocument(String id, BytesReference source) {
    }

    private Query parseQuery(String type, BytesReference querySource, XContentParser parser) {
        if (type == null) {
            if (parser != null) {
                return queryParserService.parse(parser).query();
            } else {
                return queryParserService.parse(querySource).query();
            }
        }

        String[] previousTypes = QueryParseContext.setTypesWithPrevious(new String[]{type});
        try {
            if (parser != null) {
                return queryParserService.parse(parser).query();
            } else {
                return queryParserService.parse(querySource).query();
            }
        } finally {
            QueryParseContext.setTypes(previousTypes);
        }
    }

public Filter parse(QueryParseContext parseContext) throws IOException, QueryPar
        if ("indexed".equals(type)) {
            filter = IndexedGeoBoundingBoxFilter.create(topLeft, bottomRight, geoMapper);
        } else if ("memory".equals(type)) {
            IndexGeoPointFieldData<?> indexFieldData = parseContext.fieldData().getForField(mapper);
            filter = new InMemoryGeoBoundingBoxFilter(topLeft, bottomRight, indexFieldData);
        } else {
            throw new QueryParsingException(parseContext.index(), "geo bounding box type [" + type + "] not supported, either 'indexed' or 'memory' are allowed");
public Filter parse(QueryParseContext parseContext) throws IOException, QueryPar
        GeoPointFieldMapper geoMapper = ((GeoPointFieldMapper) mapper);


        IndexGeoPointFieldData<?> indexFieldData = parseContext.fieldData().getForField(mapper);
        Filter filter = new GeoDistanceFilter(point.lat(), point.lon(), distance, geoDistance, indexFieldData, geoMapper, optimizeBbox);
        if (cache) {
            filter = parseContext.cacheFilter(filter, cacheKey);
public Filter parse(QueryParseContext parseContext) throws IOException, QueryPar
        }
        GeoPointFieldMapper geoMapper = ((GeoPointFieldMapper) mapper);

        IndexGeoPointFieldData<?> indexFieldData = parseContext.fieldData().getForField(mapper);
        Filter filter = new GeoDistanceRangeFilter(point, from, to, includeLower, includeUpper, geoDistance, geoMapper, indexFieldData, optimizeBbox);
        if (cache) {
            filter = parseContext.cacheFilter(filter, cacheKey);
public Filter parse(QueryParseContext parseContext) throws IOException, QueryPar
            throw new QueryParsingException(parseContext.index(), "field [" + fieldName + "] is not a geo_point field");
        }

        IndexGeoPointFieldData<?> indexFieldData = parseContext.fieldData().getForField(mapper);
        Filter filter = new GeoPolygonFilter(indexFieldData, shell.toArray(new GeoPoint[shell.size()]));
        if (cache) {
            filter = parseContext.cacheFilter(filter, cacheKey);
public Filter parse(QueryParseContext parseContext) throws IOException, QueryPar
        }

        Filter parentFilter = parseContext.cacheFilter(parentDocMapper.typeFilter(), null);
        ParentChildIndexFieldData parentChildIndexFieldData = parseContext.fieldData().getForField(parentFieldMapper);

        Query childrenQuery;
        if (minChildren > 1 || maxChildren > 0) {
public Query parse(QueryParseContext parseContext) throws IOException, QueryPars

        Query query;
        Filter parentFilter = parseContext.cacheFilter(parentDocMapper.typeFilter(), null);
        ParentChildIndexFieldData parentChildIndexFieldData = parseContext.fieldData().getForField(parentFieldMapper);
        if (minChildren > 1 || maxChildren > 0 || scoreType != ScoreType.NONE) {
            query = new ChildrenQuery(parentChildIndexFieldData, parentType, childType, parentFilter, innerQuery, scoreType, minChildren,
                    maxChildren, shortCircuitParentDocSet, nonNestedDocsFilter);
public Filter parse(QueryParseContext parseContext) throws IOException, QueryPar
            ParentFieldMapper parentFieldMapper = documentMapper.parentFieldMapper();
            if (parentFieldMapper.active()) {
                DocumentMapper parentTypeDocumentMapper = parseContext.mapperService().documentMapper(parentFieldMapper.type());
                parentChildIndexFieldData = parseContext.fieldData().getForField(parentFieldMapper);
                if (parentTypeDocumentMapper == null) {
                    // Only add this, if this parentFieldMapper (also a parent)  isn't a child of another parent.
                    parentTypes.add(parentFieldMapper.type());
public Query parse(QueryParseContext parseContext) throws IOException, QueryPars
        for (DocumentMapper documentMapper : parseContext.mapperService()) {
            ParentFieldMapper parentFieldMapper = documentMapper.parentFieldMapper();
            if (parentFieldMapper.active()) {
                parentChildIndexFieldData = parseContext.fieldData().getForField(parentFieldMapper);
                DocumentMapper parentTypeDocumentMapper = parseContext.mapperService().documentMapper(parentFieldMapper.type());
                if (parentTypeDocumentMapper == null) {
                    // Only add this, if this parentFieldMapper (also a parent)  isn't a child of another parent.
public ParsedQuery parse(byte[] source, int offset, int length) throws Elasticse
    }

    public ParsedQuery parse(BytesReference source) throws ElasticsearchException {
        XContentParser parser = null;
        try {
            parser = XContentFactory.xContent(source).createParser(source);
            return parse(cache.get(), parser);
        } catch (QueryParsingException e) {
            throw e;
        } catch (Exception e) {
public ParsedQuery parse(String source) throws QueryParsingException {
        XContentParser parser = null;
        try {
            parser = XContentFactory.xContent(source).createParser(source);
            return parse(cache.get(), parser);
        } catch (QueryParsingException e) {
            throw e;
        } catch (Exception e) {
public ParsedQuery parse(String source) throws QueryParsingException {
    }

    public ParsedQuery parse(XContentParser parser) {
        try {
            return parse(cache.get(), parser);
        } catch (IOException e) {
            throw new QueryParsingException(index, "Failed to parse", e);
        }
public ParsedQuery parseQuery(BytesReference source) {
        throw new QueryParsingException(index(), "Required query is missing");
    }

    private ParsedQuery parse(QueryParseContext parseContext, XContentParser parser) throws IOException, QueryParsingException {
        parseContext.reset(parser);
        try {
            if (strict) {
public Filter parse(QueryParseContext parseContext) throws IOException, QueryPar
        if (!(mapper instanceof NumberFieldMapper)) {
            throw new QueryParsingException(parseContext.index(), "Field [" + fieldName + "] is not a numeric type");
        }
        Filter filter = ((NumberFieldMapper) mapper).rangeFilter(parseContext.fieldData(), from, to, includeLower, includeUpper, parseContext);

        if (cache) {
            filter = parseContext.cacheFilter(filter, cacheKey);
import org.elasticsearch.common.xcontent.XContentParser;
import org.elasticsearch.index.Index;
import org.elasticsearch.index.analysis.AnalysisService;
import org.elasticsearch.index.cache.IndexCache;
import org.elasticsearch.index.cache.filter.support.CacheKeyFilter;
import org.elasticsearch.index.engine.IndexEngine;
import org.elasticsearch.index.fielddata.IndexFieldDataService;
import org.elasticsearch.index.mapper.FieldMapper;
import org.elasticsearch.index.mapper.FieldMappers;
import org.elasticsearch.index.mapper.MapperService;
public static void removeTypes() {

    private EnumSet<ParseField.Flag> parseFlags = ParseField.EMPTY_FLAGS;


    public QueryParseContext(Index index, IndexQueryParserService indexQueryParser) {
        this.index = index;
        this.indexQueryParser = indexQueryParser;
    }

    public  void parseFlags(EnumSet<ParseField.Flag> parseFlags) {
public Similarity searchSimilarity() {
        return indexQueryParser.similarityService != null ? indexQueryParser.similarityService.similarity() : null;
    }

    public IndexCache indexCache() {
        return indexQueryParser.indexCache;
    }

    public IndexFieldDataService fieldData() {
        return indexQueryParser.fieldDataService;
    }

    public String defaultField() {
public Filter cacheFilter(Filter filter, @Nullable CacheKeyFilter.Key cacheKey)
        if (filter == null) {
            return null;
        }
        if (this.propagateNoCache || filter instanceof NoCacheFilter) {
            return filter;
        }
        if (cacheKey != null) {
public Filter cacheFilter(Filter filter, @Nullable CacheKeyFilter.Key cacheKey)
        return indexQueryParser.indexCache.filter().cache(filter);
    }

    public void addNamedFilter(String name, Filter filter) {
        namedFilters.put(name, filter);
    }
public SearchLookup lookup() {
            return current.lookup();
        }
        if (lookup == null) {
            lookup = new SearchLookup(mapperService(), fieldData(), null);
        }
        return lookup;
    }
public Query parse(QueryParseContext parseContext) throws IOException, QueryPars
        }

        qpSettings.queryTypes(parseContext.queryTypes());
        Query query = parseContext.indexCache().queryParserCache().get(qpSettings);
        if (query != null) {
            if (queryName != null) {
                parseContext.addNamedQuery(queryName, query);
public Query parse(QueryParseContext parseContext) throws IOException, QueryPars
            if (query instanceof BooleanQuery) {
                Queries.applyMinimumShouldMatch((BooleanQuery) query, qpSettings.minimumShouldMatch());
            }
            parseContext.indexCache().queryParserCache().put(qpSettings, query);
            if (queryName != null) {
                parseContext.addNamedQuery(queryName, query);
            }
public Filter parse(QueryParseContext parseContext) throws IOException, QueryPar
                        throw new QueryParsingException(parseContext.index(), "[range] filter field [" + fieldName + "] is not a numeric type");
                    }
                    if (mapper instanceof DateFieldMapper) {
                        filter = ((DateFieldMapper) mapper).rangeFilter(parseContext.fieldData(), from, to, includeLower, includeUpper, parseContext, explicitlyCached);
                    } else {
                        filter = ((NumberFieldMapper) mapper).rangeFilter(parseContext.fieldData(), from, to, includeLower, includeUpper, parseContext);
                    }
                } else {
                    throw new QueryParsingException(parseContext.index(), "[range] filter doesn't support [" + execution + "] execution");
public Filter parse(QueryParseContext parseContext) throws IOException, QueryPar
                    return Queries.MATCH_NO_FILTER;
                }

                filter = fieldMapper.termsFilter(parseContext.fieldData(), terms, parseContext);
                if (cache != null && cache) {
                    filter = parseContext.cacheFilter(filter, cacheKey);
                }
public Query parse(QueryParseContext parseContext) throws IOException, QueryPars
        innerQuery.setBoost(boost);
        // wrap the query with type query
        innerQuery = new XFilteredQuery(innerQuery, parseContext.cacheFilter(childDocMapper.typeFilter(), null));
        ParentChildIndexFieldData parentChildIndexFieldData = parseContext.fieldData().getForField(parentFieldMapper);
        TopChildrenQuery query = new TopChildrenQuery(parentChildIndexFieldData, innerQuery, childType, parentType, scoreType, factor, incrementalFactor, parseContext.cacheRecycler(), nonNestedDocsFilter);
        if (queryName != null) {
            parseContext.addNamedFilter(queryName, new CustomQueryWrappingFilter(query));

package org.elasticsearch.index.query.functionscore;

import com.sun.swing.internal.plaf.metal.resources.metal;
import org.apache.lucene.index.AtomicReaderContext;
import org.apache.lucene.search.ComplexExplanation;
import org.apache.lucene.search.Explanation;
import org.elasticsearch.index.query.functionscore.gauss.GaussDecayFunctionBuilder;
import org.elasticsearch.index.query.functionscore.gauss.GaussDecayFunctionParser;
import org.elasticsearch.search.MultiValueMode;
import org.elasticsearch.search.aggregations.metrics.InternalNumericMetricsAggregation;
import org.elasticsearch.search.internal.SearchContext;

import java.io.IOException;
private AbstractDistanceScoreFunction parseNumberVariable(String fieldName, XCon
            throw new ElasticsearchParseException("Both " + DecayFunctionBuilder.SCALE + "and " + DecayFunctionBuilder.ORIGIN
                    + " must be set for numeric fields.");
        }
        IndexNumericFieldData<?> numericFieldData = parseContext.fieldData().getForField(mapper);
        return new NumericFieldDataScoreFunction(origin, scale, decay, offset, getDecayFunction(), numericFieldData, mode);
    }

private AbstractDistanceScoreFunction parseGeoVariable(String fieldName, XConten
        }
        double scale = DistanceUnit.DEFAULT.parse(scaleString, DistanceUnit.DEFAULT);
        double offset = DistanceUnit.DEFAULT.parse(offsetString, DistanceUnit.DEFAULT);
        IndexGeoPointFieldData<?> indexFieldData = parseContext.fieldData().getForField(mapper);
        return new GeoFieldDataScoreFunction(origin, scale, decay, offset, getDecayFunction(), indexFieldData, mode);

    }
private AbstractDistanceScoreFunction parseDateVariable(String fieldName, XConte
        double scale = val.getMillis();
        val = TimeValue.parseTimeValue(offsetString, TimeValue.timeValueHours(24));
        double offset = val.getMillis();
        IndexNumericFieldData<?> numericFieldData = parseContext.fieldData().getForField(dateFieldMapper);
        return new NumericFieldDataScoreFunction(origin, scale, decay, offset, getDecayFunction(), numericFieldData, mode);
    }

/**
 * Class that returns a breaker that never breaks
 */
public class DummyCircuitBreakerService implements CircuitBreakerService {

    private final ESLogger logger = Loggers.getLogger(DummyCircuitBreakerService.class);

    private final MemoryCircuitBreaker breaker = new MemoryCircuitBreaker(new ByteSizeValue(Long.MAX_VALUE), 0.0, logger);

    public DummyCircuitBreakerService() {}

    @Override
    public MemoryCircuitBreaker getBreaker() {
import org.elasticsearch.action.search.SearchType;
import org.elasticsearch.cache.recycler.CacheRecycler;
import org.elasticsearch.cache.recycler.PageCacheRecycler;
import org.elasticsearch.common.lease.Releasable;
import org.elasticsearch.common.lease.Releasables;
import org.elasticsearch.common.text.StringText;
import org.elasticsearch.common.util.BigArrays;
public SearchLookup lookup() {

    @Override
    protected void doClose() {
        try (Releasable releasable = Releasables.wrap(engineSearcher, docSearcher)) {
            if (docSearcher != null) {
                IndexReader indexReader = docSearcher.reader();
                fieldDataService.clear(indexReader);
                indexService.cache().clear(indexReader);
            }
        }
    }

    @Override
import org.elasticsearch.index.mapper.ContentPath;
import org.elasticsearch.index.mapper.Mapper.BuilderContext;
import org.elasticsearch.index.mapper.core.LongFieldMapper;
import org.elasticsearch.indices.fielddata.breaker.DummyCircuitBreakerService;

import java.util.Random;

public static void main(String[] args) throws Exception {
            indexWriter.close();

            final DirectoryReader dr = DirectoryReader.open(dir);
            final IndexFieldDataService fds = new IndexFieldDataService(new Index("dummy"), new DummyCircuitBreakerService());
            final LongFieldMapper mapper = new LongFieldMapper.Builder(fieldName).build(new BuilderContext(null, new ContentPath(1)));
            final IndexNumericFieldData<AtomicNumericFieldData> fd = fds.getForField(mapper);
            final long start = System.nanoTime();
import org.elasticsearch.index.settings.IndexSettingsModule;
import org.elasticsearch.index.similarity.SimilarityModule;
import org.elasticsearch.indices.InvalidAliasNameException;
import org.elasticsearch.indices.fielddata.breaker.CircuitBreakerService;
import org.elasticsearch.indices.fielddata.breaker.DummyCircuitBreakerService;
import org.elasticsearch.indices.query.IndicesQueriesModule;
import org.elasticsearch.script.ScriptModule;
import org.elasticsearch.test.ElasticsearchTestCase;
public static IndexQueryParserService newIndexQueryParserService(Settings settin
                    @Override
                    protected void configure() {
                        bind(ClusterService.class).toProvider(Providers.of((ClusterService) null));
                        bind(CircuitBreakerService.class).to(DummyCircuitBreakerService.class);
                    }
                }
        ).createInjector();
/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.elasticsearch.index.cache.filter;

import org.apache.lucene.document.Document;
import org.apache.lucene.document.Field;
import org.apache.lucene.document.TextField;
import org.apache.lucene.index.*;
import org.apache.lucene.queries.TermFilter;
import org.apache.lucene.search.ConstantScoreQuery;
import org.apache.lucene.search.Filter;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.MatchAllDocsQuery;
import org.apache.lucene.store.Directory;
import org.apache.lucene.store.RAMDirectory;
import org.elasticsearch.common.lucene.Lucene;
import org.elasticsearch.common.lucene.search.XConstantScoreQuery;
import org.elasticsearch.common.lucene.search.XFilteredQuery;
import org.elasticsearch.index.Index;
import org.elasticsearch.index.cache.filter.none.NoneFilterCache;
import org.elasticsearch.test.ElasticsearchTestCase;
import org.junit.Test;

import java.io.IOException;

import static org.elasticsearch.common.settings.ImmutableSettings.Builder.EMPTY_SETTINGS;
import static org.hamcrest.Matchers.equalTo;

/**
 *
 */
public class FilterCacheTests extends ElasticsearchTestCase {


    @Test
    public void testNoCache() throws Exception {
        verifyCache(new NoneFilterCache(new Index("test"), EMPTY_SETTINGS));
    }

    private void verifyCache(FilterCache filterCache) throws Exception {
        Directory dir = new RAMDirectory();
        IndexWriter indexWriter = new IndexWriter(dir, new IndexWriterConfig(Lucene.VERSION, Lucene.STANDARD_ANALYZER));
        DirectoryReader reader = DirectoryReader.open(indexWriter, true);

        for (int i = 0; i < 100; i++) {
            Document document = new Document();
            document.add(new TextField("id", Integer.toString(i), Field.Store.YES));
            indexWriter.addDocument(document);
        }

        reader = refreshReader(reader);
        IndexSearcher searcher = new IndexSearcher(reader);
        assertThat(Lucene.count(searcher, new ConstantScoreQuery(filterCache.cache(new TermFilter(new Term("id", "1"))))), equalTo(1l));
        assertThat(Lucene.count(searcher, new XFilteredQuery(new MatchAllDocsQuery(), filterCache.cache(new TermFilter(new Term("id", "1"))))), equalTo(1l));

        indexWriter.deleteDocuments(new Term("id", "1"));
        reader = refreshReader(reader);
        searcher = new IndexSearcher(reader);
        TermFilter filter = new TermFilter(new Term("id", "1"));
        Filter cachedFilter = filterCache.cache(filter);
        long constantScoreCount = filter == cachedFilter ? 0 : 1;
        // sadly, when caching based on cacheKey with NRT, this fails, that's why we have DeletionAware one
        assertThat(Lucene.count(searcher, new ConstantScoreQuery(cachedFilter)), equalTo(constantScoreCount));
        assertThat(Lucene.count(searcher, new XConstantScoreQuery(cachedFilter)), equalTo(0l));
        assertThat(Lucene.count(searcher, new XFilteredQuery(new MatchAllDocsQuery(), cachedFilter)), equalTo(0l));

        indexWriter.close();
    }

    private DirectoryReader refreshReader(DirectoryReader reader) throws IOException {
        IndexReader oldReader = reader;
        reader = DirectoryReader.openIfChanged(reader);
        if (reader != oldReader) {
            oldReader.close();
        }
        return reader;
    }
}
import org.elasticsearch.index.settings.IndexSettingsModule;
import org.elasticsearch.index.similarity.SimilarityModule;
import org.elasticsearch.indices.fielddata.breaker.CircuitBreakerService;
import org.elasticsearch.indices.fielddata.breaker.DummyCircuitBreakerService;
import org.elasticsearch.test.ElasticsearchLuceneTestCase;
import org.junit.Before;
import org.junit.Test;
private static CodecService createCodecService(Settings settings) {
                .add(new AbstractModule() {
                    @Override
                    protected void configure() {
                        bind(CircuitBreakerService.class).to(DummyCircuitBreakerService.class);
                    }
                })
                .createInjector();
import org.elasticsearch.index.mapper.*;
import org.elasticsearch.index.mapper.Mapper.BuilderContext;
import org.elasticsearch.indices.fielddata.breaker.CircuitBreakerService;
import org.elasticsearch.indices.fielddata.breaker.DummyCircuitBreakerService;
import org.elasticsearch.indices.fielddata.cache.IndicesFieldDataCache;
import org.elasticsearch.indices.fielddata.cache.IndicesFieldDataCacheListener;
import org.elasticsearch.test.ElasticsearchTestCase;
protected boolean hasDocValues() {

    @Before
    public void setup() throws Exception {
        CircuitBreakerService circuitBreakerService = new DummyCircuitBreakerService();
        indicesFieldDataCache = new IndicesFieldDataCache(
                ImmutableSettings.Builder.EMPTY_SETTINGS,
                new IndicesFieldDataCacheListener(circuitBreakerService)
        );
        ifdService = new IndexFieldDataService(new Index("test"), circuitBreakerService, indicesFieldDataCache);
        MapperService mapperService = MapperTestUtils.newMapperService(ifdService.index(), ImmutableSettings.Builder.EMPTY_SETTINGS);
        ifdService.setIndexService(new StubIndexService(mapperService));
        // LogByteSizeMP to preserve doc ID order
public void testTermsEnum() throws Exception {
    public void testGlobalOrdinalsGetRemovedOnceIndexReaderCloses() throws Exception {
        fillExtendedMvSet();
        refreshReader();
        FieldDataType fieldDataType = new FieldDataType("string", ImmutableSettings.builder().put("global_values", "fixed"));
        IndexFieldData.WithOrdinals ifd = getForField(fieldDataType, "value");
        IndexFieldData.WithOrdinals globalOrdinals = ifd.loadGlobal(topLevelReader);
        assertThat(ifd.loadGlobal(topLevelReader), sameInstance(globalOrdinals));
import org.elasticsearch.index.mapper.*;
import org.elasticsearch.index.mapper.Mapper.BuilderContext;
import org.elasticsearch.index.mapper.core.*;
import org.elasticsearch.indices.fielddata.breaker.DummyCircuitBreakerService;
import org.elasticsearch.test.ElasticsearchTestCase;
import org.elasticsearch.test.index.service.StubIndexService;


    @SuppressWarnings("unchecked")
    public void testGetForFieldDefaults() {
        final IndexFieldDataService ifdService = new IndexFieldDataService(new Index("test"), new DummyCircuitBreakerService());
        MapperService mapperService = MapperTestUtils.newMapperService(ifdService.index(), ImmutableSettings.Builder.EMPTY_SETTINGS);
        ifdService.setIndexService(new StubIndexService(mapperService));
        for (boolean docValues : Arrays.asList(true, false)) {
public void testGetForFieldDefaults() {

    @SuppressWarnings("unchecked")
    public void testByPassDocValues() {
        final IndexFieldDataService ifdService = new IndexFieldDataService(new Index("test"), new DummyCircuitBreakerService());
        MapperService mapperService = MapperTestUtils.newMapperService(ifdService.index(), ImmutableSettings.Builder.EMPTY_SETTINGS);
        ifdService.setIndexService(new StubIndexService(mapperService));
        final BuilderContext ctx = new BuilderContext(null, new ContentPath(1));
public void testByPassDocValues() {
    }

    public void testChangeFieldDataFormat() throws Exception {
        final IndexFieldDataService ifdService = new IndexFieldDataService(new Index("test"), new DummyCircuitBreakerService());
        MapperService mapperService = MapperTestUtils.newMapperService(ifdService.index(), ImmutableSettings.Builder.EMPTY_SETTINGS);
        ifdService.setIndexService(new StubIndexService(mapperService));
        final BuilderContext ctx = new BuilderContext(null, new ContentPath(1));
import org.elasticsearch.index.similarity.SimilarityLookupService;
import org.elasticsearch.indices.analysis.IndicesAnalysisModule;
import org.elasticsearch.indices.analysis.IndicesAnalysisService;
import org.elasticsearch.indices.fielddata.breaker.DummyCircuitBreakerService;

/**
 *
public static MapperService newMapperService() {
    }

    public static MapperService newMapperService(Index index, Settings indexSettings) {
        return new MapperService(index, indexSettings, new Environment(), newAnalysisService(), new IndexFieldDataService(index, new DummyCircuitBreakerService()),
                new PostingsFormatService(index), new DocValuesFormatService(index), newSimilarityLookupService());
    }

import org.elasticsearch.index.settings.IndexSettingsModule;
import org.elasticsearch.index.similarity.SimilarityModule;
import org.elasticsearch.indices.fielddata.breaker.CircuitBreakerService;
import org.elasticsearch.indices.fielddata.breaker.DummyCircuitBreakerService;
import org.elasticsearch.indices.query.IndicesQueriesModule;
import org.elasticsearch.script.ScriptModule;
import org.elasticsearch.search.internal.SearchContext;
public static void setupQueryParser() throws IOException {
                    @Override
                    protected void configure() {
                        bind(ClusterService.class).toProvider(Providers.of((ClusterService) null));
                        bind(CircuitBreakerService.class).to(DummyCircuitBreakerService.class);
                    }
                }
        ).createInjector();
import org.elasticsearch.index.settings.IndexSettingsModule;
import org.elasticsearch.index.similarity.SimilarityModule;
import org.elasticsearch.indices.fielddata.breaker.CircuitBreakerService;
import org.elasticsearch.indices.fielddata.breaker.DummyCircuitBreakerService;
import org.elasticsearch.indices.query.IndicesQueriesModule;
import org.elasticsearch.script.ScriptModule;
import org.elasticsearch.test.ElasticsearchTestCase;
public static void setupQueryParser() throws IOException {
                    @Override
                    protected void configure() {
                        bind(ClusterService.class).toProvider(Providers.of((ClusterService) null));
                        bind(CircuitBreakerService.class).to(DummyCircuitBreakerService.class);
                    }
                }
        ).createInjector();
import org.elasticsearch.index.settings.IndexSettingsModule;
import org.elasticsearch.index.similarity.SimilarityModule;
import org.elasticsearch.indices.fielddata.breaker.CircuitBreakerService;
import org.elasticsearch.indices.fielddata.breaker.DummyCircuitBreakerService;
import org.elasticsearch.indices.query.IndicesQueriesModule;
import org.elasticsearch.script.ScriptModule;
import org.elasticsearch.test.ElasticsearchTestCase;
public void setup() throws IOException {
                    @Override
                    protected void configure() {
                        bind(ClusterService.class).toProvider(Providers.of((ClusterService) null));
                        bind(CircuitBreakerService.class).to(DummyCircuitBreakerService.class);
                    }
                }
        ).createInjector();
import org.elasticsearch.index.query.functionscore.FunctionScoreModule;
import org.elasticsearch.index.settings.IndexSettingsModule;
import org.elasticsearch.index.similarity.SimilarityModule;
import org.elasticsearch.indices.fielddata.breaker.CircuitBreakerService;
import org.elasticsearch.indices.fielddata.breaker.DummyCircuitBreakerService;
import org.elasticsearch.indices.query.IndicesQueriesModule;
import org.elasticsearch.script.ScriptModule;
import org.elasticsearch.test.ElasticsearchTestCase;
public void testCustomInjection() {
                    @Override
                    protected void configure() {
                        bind(ClusterService.class).toProvider(Providers.of((ClusterService) null));
                        bind(CircuitBreakerService.class).to(DummyCircuitBreakerService.class);
                    }
                }
        ).createInjector();
import org.elasticsearch.index.query.functionscore.FunctionScoreModule;
import org.elasticsearch.index.settings.IndexSettingsModule;
import org.elasticsearch.index.similarity.SimilarityModule;
import org.elasticsearch.indices.fielddata.breaker.CircuitBreakerService;
import org.elasticsearch.indices.fielddata.breaker.DummyCircuitBreakerService;
import org.elasticsearch.indices.query.IndicesQueriesModule;
import org.elasticsearch.script.ScriptModule;
import org.elasticsearch.test.ElasticsearchTestCase;
public void testCustomInjection() {
                    @Override
                    protected void configure() {
                        bind(ClusterService.class).toProvider(Providers.of((ClusterService) null));
                        bind(CircuitBreakerService.class).to(DummyCircuitBreakerService.class);
                    }
                }
        ).createInjector();
import org.elasticsearch.index.query.functionscore.FunctionScoreModule;
import org.elasticsearch.index.settings.IndexSettingsModule;
import org.elasticsearch.index.similarity.SimilarityModule;
import org.elasticsearch.indices.fielddata.breaker.CircuitBreakerService;
import org.elasticsearch.indices.fielddata.breaker.DummyCircuitBreakerService;
import org.elasticsearch.indices.query.IndicesQueriesModule;
import org.elasticsearch.script.ScriptModule;
import org.elasticsearch.test.ElasticsearchTestCase;
public void processXContentFilterParsers(XContentFilterParsersBindings bindings)
                    @Override
                    protected void configure() {
                        bind(ClusterService.class).toProvider(Providers.of((ClusterService) null));
                        bind(CircuitBreakerService.class).to(DummyCircuitBreakerService.class);
                    }
                }
        ).createInjector();
import com.carrotsearch.hppc.DoubleOpenHashSet;
import com.carrotsearch.hppc.LongOpenHashSet;
import com.carrotsearch.hppc.ObjectOpenHashSet;
import org.apache.lucene.analysis.standard.StandardAnalyzer;
import org.apache.lucene.document.*;
import org.apache.lucene.index.*;
import org.elasticsearch.index.mapper.core.LongFieldMapper;
import org.elasticsearch.index.mapper.core.NumberFieldMapper;
import org.elasticsearch.index.mapper.core.StringFieldMapper;
import org.elasticsearch.indices.fielddata.breaker.DummyCircuitBreakerService;
import org.elasticsearch.search.internal.SearchContext;
import org.elasticsearch.test.ElasticsearchTestCase;
import org.elasticsearch.test.index.service.StubIndexService;
 */
public class FieldDataTermsFilterTests extends ElasticsearchTestCase {

    protected IndexFieldDataService ifdService;
    protected IndexWriter writer;
    protected AtomicReader reader;
public void setup() throws Exception {
                .build(new Mapper.BuilderContext(null, new ContentPath(1)));

        // create index and fielddata service
        ifdService = new IndexFieldDataService(new Index("test"), new DummyCircuitBreakerService());
        MapperService mapperService = MapperTestUtils.newMapperService(ifdService.index(), ImmutableSettings.Builder.EMPTY_SETTINGS);
        ifdService.setIndexService(new StubIndexService(mapperService));
        writer = new IndexWriter(new RAMDirectory(),
                new IndexWriterConfig(Lucene.VERSION, new StandardAnalyzer(Lucene.VERSION)));

public void testBytes() throws Exception {
        // filter from mapper
        result.clear(0, size);
        assertThat(result.cardinality(), equalTo(0));
        result.or(strMapper.termsFilter(ifdService, cTerms, null)
                .getDocIdSet(reader.getContext(), reader.getLiveDocs()).iterator());
        assertThat(result.cardinality(), equalTo(docs.size()));
        for (int i = 0; i < reader.maxDoc(); i++) {
public void testLongs() throws Exception {
        // filter from mapper
        result.clear(0, size);
        assertThat(result.cardinality(), equalTo(0));
        result.or(lngMapper.termsFilter(ifdService, cTerms, null)
                .getDocIdSet(reader.getContext(), reader.getLiveDocs()).iterator());
        assertThat(result.cardinality(), equalTo(docs.size()));
        for (int i = 0; i < reader.maxDoc(); i++) {
public void testDoubles() throws Exception {
        // filter from mapper
        result.clear(0, size);
        assertThat(result.cardinality(), equalTo(0));
        result.or(dblMapper.termsFilter(ifdService, cTerms, null)
                .getDocIdSet(reader.getContext(), reader.getLiveDocs()).iterator());
        assertThat(result.cardinality(), equalTo(docs.size()));
        for (int i = 0; i < reader.maxDoc(); i++) {
import org.elasticsearch.index.search.nested.NonNestedDocsFilter;
import org.elasticsearch.index.service.IndexService;
import org.elasticsearch.indices.cache.filter.IndicesFilterCache;
import org.elasticsearch.indices.fielddata.breaker.DummyCircuitBreakerService;
import org.elasticsearch.node.settings.NodeSettingsService;
import org.elasticsearch.search.internal.ContextIndexSearcher;
import org.elasticsearch.search.internal.SearchContext;
static SearchContext createSearchContext(String indexName, String parentType, St
        final BigArrays bigArrays = new BigArrays(ImmutableSettings.EMPTY, pageCacheRecycler);
        Settings settings = ImmutableSettings.EMPTY;
        MapperService mapperService = MapperTestUtils.newMapperService(index, settings);
        IndexFieldDataService indexFieldDataService = new IndexFieldDataService(index, new DummyCircuitBreakerService());
        final IndexService indexService = new StubIndexService(mapperService);
        indexFieldDataService.setIndexService(indexService);
        // Id_cache is now registered as document type listener, so we can add mappings.
import org.elasticsearch.index.mapper.MapperServiceModule;
import org.elasticsearch.index.settings.IndexSettingsModule;
import org.elasticsearch.indices.fielddata.breaker.CircuitBreakerService;
import org.elasticsearch.indices.fielddata.breaker.DummyCircuitBreakerService;
import org.elasticsearch.test.ElasticsearchTestCase;
import org.junit.Test;

private static SimilarityService similarityService(Settings settings) {
                .add(new AbstractModule() {
                    @Override
                    protected void configure() {
                        bind(CircuitBreakerService.class).to(DummyCircuitBreakerService.class);
                    }
                })
                .createInjector();
public void percolateNonMatchingConstantScoreQuery() throws Exception {
                        .startObject("doc").field("message", "A new bonsai tree ").endObject()
                        .endObject())
                .execute().actionGet();
        assertThat(percolate.getFailedShards(), equalTo(0));
        assertMatchCount(percolate, 0l);
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			<insertSuper>onUpdate</insertSuper>
		</class>
		<class id="net.minecraft.tileentity.TileEntity">
			<addMethod return="java.lang.String"
								 name="toString"
								 code="return super.toString() + &quot; x,y,z: &quot; + l + &quot;, &quot; + m + &quot;, &quot; + n;"/>
			<addAll fromClass="me.nallar.patched.PatchTileEntity"/>
		</class>
		<class id="net.minecraft.entity.EntityTracker">
			<replaceMethodCall newMethod="getTEWithLoad" method="^class:World^.^method:World/getBlockTileEntity^">ticketsLoaded(Ljava.util.List;L^class:World^;)V</replaceMethodCall>
			<replaceMethodCall newMethod="getBlockIdWithLoad" method="^class:World^.^method:World/getBlockId^">ticketsLoaded(Ljava.util.List;L^class:World^;I)Ljava.util.List;</replaceMethodCall>
		</class>
	</buildCraftFactory>
	<buildCraftTransport>
		<class id="buildcraft.transport.TileGenericPipe">
package me.nallar.patched;

import me.nallar.tickthreading.patcher.Declare;
import me.nallar.tickthreading.util.concurrent.NativeMutex;
import net.minecraft.inventory.ICrafting;
public void sendTile() {
			p.updateTile(this);
		}
	}
}
package me.nallar.patched.entity;

import net.minecraft.block.Block;
import net.minecraft.block.material.Material;
import net.minecraft.entity.item.EntityItem;
public void onUpdate() {
	}

	@Override
	protected void func_85054_d() {
		for (Object o : this.worldObj.getEntitiesWithinAABB(EntityItem.class, this.boundingBox.expand(mergeRadius, mergeRadius, mergeRadius))) {
			EntityItem var2 = (EntityItem) o;
protected void func_85054_d() {
	public boolean combineItems(EntityItem other) {
		if (other == this) {
			return false;
		} else if (other.isEntityAlive() && this.isEntityAlive()) {
			ItemStack thisStack = this.getEntityItem();
			ItemStack otherStack = other.getEntityItem();

public boolean combineItems(EntityItem other) {
			} else if (thisStack.stackSize + otherStack.stackSize > thisStack.getMaxStackSize()) {
				return false;
			} else {
				thisStack.stackSize += otherStack.stackSize;
				this.delayBeforeCanPickup = Math.max(other.delayBeforeCanPickup, this.delayBeforeCanPickup);
				this.age = Math.min(other.age, this.age);
				this.func_92058_a(thisStack);
				other.setDead();
				return true;
			}
		} else {
			return false;
		}
	}
}
public String getName() {

	@Override
	public boolean isBlockNormalCube(int x, int y, int z) {
		int id = getBlockIdWithoutLoad(x, y, z);
		if (id == -1) {
			return false;
		}
		Block block = Block.blocksList[id];
		return block != null && block.isBlockNormalCube(this, x, y, z);
	}
public void removeEntity(Entity entity) {

			entity.setDead();

			// The next instanceof, somehow, seems to throw NPEs. I don't even. :(
			// http://pastebin.com/zqDPsUjz
			if (entity instanceof EntityPlayer) {
				if (playerEntities == null) {
					// The world has been unloaded and cleaned already, so we can't remove the player entity.
public void removeEntity(Entity entity) {
				this.updateAllPlayersSleepingFlag();
			}
		} catch (Exception e) {
			Log.severe("Exception removing a player entity", e);
		}
	}

public int getBlockId(int x, int y, int z) {
	public int getBlockIdWithoutLoad(int x, int y, int z) {
		if (x >= -30000000 && z >= -30000000 && x < 30000000 && z < 30000000 && y >= 0 && y < 256) {
			try {
				Chunk chunk = ((ChunkProviderServer) chunkProvider).getChunkIfExists(x >> 4, z >> 4);
				return chunk == null ? -1 : chunk.getBlockID(x & 15, y, z & 15);
			} catch (Throwable t) {
				Log.severe("Exception getting block ID in " + Log.pos(this, x, y, z), t);
public synchronized List getNoteBlockEvents() {
		return noteBlockEvents;
	}

	public boolean safeToGenerate() {
		return theChunkProviderServer.safeToGenerate();
	}
import me.nallar.tickthreading.util.MappingUtil;
import net.minecraft.server.MinecraftServer;
import net.minecraft.server.gui.GuiLogOutputHandler;
import net.minecraft.world.World;
import net.minecraft.world.WorldServer;

public static String name(World world) {
		return world.getName();
	}

	public static String toString(Object o) {
		String deobfuscatedName = MappingUtil.debobfuscate(o.getClass().getName());
		return "c " + deobfuscatedName + ' ' + o.toString();
	}

	public static void log(Level level, Throwable throwable, String s) {
private static String toString(ThreadInfo threadInfo, boolean name) {
		if (threadInfo.isInNative()) {
			sb.append(" (in native)");
		}
		sb.append('\n');
		for (int i = 0; i < stackTrace.length; i++) {
			String steString = stackTrace[i].toString();
			sb.append("\tat ").append(steString);
			sb.append('\n');
			if (i == 0 && threadInfo.getLockInfo() != null) {
private static String toString(ThreadInfo threadInfo, boolean name) {
		}
		sb.append('\n');
		String ret = sb.toString();
		return (ret.contains("at java.util.concurrent.LinkedBlockingQueue.take(Unknown Source)\n" +
				"\tat me.nallar.tickthreading.minecraft.ThreadManager$1.run(ThreadManager.java:\n")) ? null : ret;
	}

	public static void checkForLeakedThreadManagers() {
import me.nallar.tickthreading.util.TableFormatter;
import me.nallar.tickthreading.util.VersionUtil;
import net.minecraft.command.ServerCommandManager;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.item.Item;
import net.minecraftforge.common.DimensionManager;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.event.ForgeSubscribe;
import net.minecraftforge.event.entity.player.PlayerInteractEvent;
import net.minecraftforge.event.world.WorldEvent;

public void onPlayerInteract(PlayerInteractEvent event) {
		}
	}

	public TickManager getManager(World world) {
		return managers.get(world);
	}
public void doTick() {
					tileEntitiesIterator.remove();
					manager.add(tileEntity, false);
					if (hashCode != 0) {
						Log.fine("A tile entity is in the wrong TickRegion - was it moved by a player, or did something bug out?"
								+ "\n entity: " + Log.toString(tileEntity) + " at x,y,z:" + xPos + ',' + tileEntity.yCoord + ',' + zPos
								+ "\n Region: " + toString()
								+ "\n World: " + Log.name(tileEntity.worldObj));
					}
				}
				continue;
public void doTick() {
				if (tileEntity.isInvalid()) {
					tileEntitiesIterator.remove();
					manager.removed(tileEntity);
					//Log.fine("Removed tile entity: " + xPos + ", " + tileEntity.yCoord + ", " + zPos + "\ttype:" + tileEntity.getClass().toString());
					if (chunkProvider.chunkExists(xPos >> 4, zPos >> 4)) {
						Chunk chunk = world.getChunkFromChunkCoords(xPos >> 4, zPos >> 4);
						if (chunk != null) {
							chunk.cleanChunkBlockTileEntity(xPos, tileEntity.yCoord, zPos);
						}
					}
				} else if (tileEntity.worldObj != null && chunkProvider.chunkExists(xPos >> 4, zPos >> 4)) {
					tileEntity.tickTT();
				}
			} catch (Throwable throwable) {
				Log.severe("Exception ticking TileEntity " + Log.toString(tileEntity) + " at x,y,z:" + xPos + ',' + tileEntity.yCoord + ',' + zPos
						+ "\n World: " + Log.name(tileEntity.worldObj), throwable);
			} finally {
				if (xMinusLock != null) {
					xMinusLock.unlock();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private IdMatchers() {
    }

    public static <T> Matcher<Id<T>> newMatcher(final Id<T> id) {
        return newKeyMatcher(id);
    }

    public static <T> IdMatcher<T> newKeyMatcher(final Id<T> id) {
        requireNonNull(id, "id");
        return new IdMatcher<T>() {

            <artifactId>mockito-all</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
import org.javabits.yar.Id;
import org.javabits.yar.Registration;

import static org.javabits.yar.IdMatchers.newKeyMatcher;

/**
 * @author Romain Gilles
        // If an instance of the requested service has been registered, this call will trigger the
        // listener's supplierChanged event with the current value of the service.
        // This is how the supplier instance obtains the initial value of the service.
        Registration<T> registration = registry.addSupplierListener(newKeyMatcher(id), supplier);
        // preserve a reference to the registration to avoid gc and let the caller decides when listener can be gc.
        supplier.setSelfRegistration(registration);
        return supplier;
/*
 * Copyright 2013 Romain Gilles
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package org.javabits.yar.guice;

import com.google.common.base.FinalizableReferenceQueue;
import com.google.common.base.FinalizableWeakReference;
import org.javabits.yar.*;

import javax.annotation.Nullable;
import java.lang.ref.WeakReference;
import java.util.IdentityHashMap;

import static org.javabits.yar.SupplierEvent.Type.ADD;
import static org.javabits.yar.SupplierEvent.Type.REMOVE;

/**
 * TODO comment
 * Date: 2/20/13
 * Time: 7:04 PM
 *
 * @author Romain Gilles
 */
class WatcherRegistration<T> extends FinalizableWeakReference<Watcher<T>> implements Pair<IdMatcher<T>, Watcher<T>>, org.javabits.yar.Registration<T> {

    private final IdMatcher<T> left;
    private final Watcher<T> right;
    private final Registry registry;


    static <T> WatcherRegistration<T> newWatcherRegistration(IdMatcher<T> leftValue, SupplierListener supplierListener, FinalizableReferenceQueue referenceQueue, Registry registry) {
        return new WatcherRegistration<>(leftValue, new SupplierWatcherToSupplierListenerAdapter<T>(supplierListener), referenceQueue, registry);
    }

    @SuppressWarnings("unchecked")
    static <T> WatcherRegistration<T> newWatcherRegistration(IdMatcher<T> leftValue, Watcher<T> rightValue, FinalizableReferenceQueue referenceQueue, Registry registry) {
        return new WatcherRegistration(leftValue, new WatcherDecorator<>(rightValue), referenceQueue, registry);
    }

    WatcherRegistration(IdMatcher<T> leftValue, Watcher<T> rightValue, FinalizableReferenceQueue referenceQueue, Registry registry) {
        super(rightValue, referenceQueue);
        left = leftValue;
        right = rightValue;
        this.registry = registry;

    @Override
    public void finalizeReferent() {
        registry.removeWatcher(this);
    }

public String toString() {
    }

    private static class SupplierWatcherToSupplierListenerAdapter<T> implements Watcher<T> {
        private final SupplierListener supplierListener;

        public SupplierWatcherToSupplierListenerAdapter(SupplierListener supplierListener) {
            this.supplierListener = supplierListener;
        }

        @Nullable
        @Override
        public Supplier<T> add(Supplier<T> supplier) {
            supplierListener.supplierChanged(new SupplierEvent(ADD, supplier));
            return supplier;
        }

        @Override
        public void remove(Supplier<T> supplier) {
            supplierListener.supplierChanged(new SupplierEvent(REMOVE, supplier));
        }

        @Override
        public String toString() {
            return "SupplierWatcherToSupplierListenerAdapter{" +
                    "supplierListener=" + supplierListener +
                    '}';
        }
    }
public String get() {
                return "test";
            }
        });
        registry.addWatcher(IdMatchers.newKeyMatcher(stringId), new Watcher<String>() {
            @Nullable
            @Override
            public org.javabits.yar.Supplier<String> add(org.javabits.yar.Supplier<String> element) {
        <logback-classic.version>0.9.20</logback-classic.version>
        <pax-url-aether.version>1.5.2</pax-url-aether.version>
        <mockito-all.version>1.9.5</mockito-all.version>
    </properties>


                <scope>test</scope>
            </dependency>
            <dependency>
                <groupId>ch.qos.logback</groupId>
                <artifactId>logback-classic</artifactId>
                <version>${logback-classic.version}</version>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public boolean handleEvent(StateEvent event) throws InternalException, OverloadE
                // Action: Send CC initial answer, reserve units, start Tcc
                // New State: OPEN
                if (isSuccess(resultCode)) {
                  startTcc(answer.getValidityTimeAvp());
                  newState = ServerCCASessionState.OPEN;
                }
                // Current State: IDLE
public boolean handleEvent(StateEvent event) throws InternalException, OverloadE
                  // Event: CC update request received and successfully processed
                  // Action: Send CC update answer, debit used units, reserve new units, restart Tcc
                  // New State: OPEN
                  startTcc(answer.getValidityTimeAvp());
                }
                else {
                  // Current State: OPEN
private void startTcc(Avp validityAvp) {
      tccTimeout = 2 * context.getDefaultValidityTime();
    }

    if (sessionData.getTccTimerId() != null) {
      stopTcc(true);
      //tccFuture = super.scheduler.schedule(new TccScheduledTask(this), defaultValue, TimeUnit.SECONDS);
public boolean handleEvent(StateEvent event) throws InternalException, OverloadE
                  // New State: IDLE

                  // It's a failure, we wait for Tcc to fire -- FIXME: Alexandre: Should we?
                }
              }
              catch (AvpDataException e) {
                throw new InternalException(e);
              }
              dispatchEvent(localEvent.getAnswer());
              break;
            case RECEIVED_TERMINATE:
              listener.doCreditControlRequest(this, (GxCreditControlRequest) localEvent.getRequest());
public boolean handleEvent(StateEvent event) throws InternalException, OverloadE
                // Action: Send CC initial answer, reserve units, start Tcc
                // New State: OPEN
                if (isSuccess(resultCode)) {
                  startTcc(answer.getValidityTimeAvp());
                  newState = ServerRoSessionState.OPEN;
                }
                // Current State: IDLE
public boolean handleEvent(StateEvent event) throws InternalException, OverloadE
                  // Event: CC update request received and successfully processed
                  // Action: Send CC update answer, debit used units, reserve new units, restart Tcc
                  // New State: OPEN
                  startTcc(answer.getValidityTimeAvp());
                }
                else {
                  // Current State: OPEN
public void timeoutExpired(Request request) {
  }

  private void startTcc(Avp validityAvp) {
    // There is no Validity-Time
    //long tccTimeout;
    //
    //if(validityAvp != null) {
    //  try {
    //    tccTimeout = 2 * validityAvp.getUnsigned32();
    //  }
    //  catch (AvpDataException e) {
    //    logger.debug("Unable to retrieve Validity-Time AVP value, using default.", e);
    //    tccTimeout = 2 * context.getDefaultValidityTime();
    //  }
    //}
    //else {
    //  tccTimeout = 2 * context.getDefaultValidityTime();
    //}
    //
    //if(tccTimerId != null) {
    //  stopTcc(true);
    //  //tccFuture = super.scheduler.schedule(new TccScheduledTask(this), defaultValue, TimeUnit.SECONDS);
    //  tccTimerId = super.timerFacility.schedule(this.sessionId, TCC_TIMER_NAME, tccTimeout * 1000);
    //  // FIXME: this accepts Future!
    //  context.sessionSupervisionTimerReStarted(this, null);
    //}
    //else {
    //  //tccFuture = super.scheduler.schedule(new TccScheduledTask(this), defaultValue, TimeUnit.SECONDS);
    //  tccTimerId = super.timerFacility.schedule(this.sessionId, TCC_TIMER_NAME, tccTimeout * 1000);
    //  //FIXME: this accepts Future!
    //  context.sessionSupervisionTimerStarted(this, null);
    //}
    //super.sessionDataSource.updateSession(this);
  }

  /*
else if (timerName.equals(TCC_TIMER_NAME)) {
  }

  private void stopTcc(boolean willRestart) {
    Serializable tccTimerId = sessionData.getTccTimerId();
    if (tccTimerId != null) {
      // tccFuture.cancel(false);
      super.timerFacility.cancel(tccTimerId);
      // ScheduledFuture f = tccFuture;
      sessionData.setTccTimerId(null);
      if (!willRestart) {
        context.sessionSupervisionTimerStopped(this, null);
      }
public boolean handleEvent(StateEvent event) throws InternalException, OverloadE
                  // Action: Send AA update answer with Result-Code != SUCCESS
                  // New State: IDLE
                  // It's a failure, we wait for Tcc to fire -- FIXME: Alexandre: Should we?
                }
              }
              catch (AvpDataException e) {
public boolean handleEvent(StateEvent event) throws InternalException, OverloadE
                  // Action: Send AA update answer with Result-Code != SUCCESS
                  // New State: IDLE
                  // It's a failure, we wait for Tcc to fire -- FIXME: Alexandre: Should we?
                }
              }
              catch (AvpDataException e) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public Disposable schedule(Runnable task, long delay, TimeUnit unit) {
			try {
				Future<?> f;
				if (delay <= 0L) {
					f = exec.submit(task);
				}
				else {
					f = exec.schedule(sr, delay, unit);
 */
package reactor.core.scheduler;

import java.time.Duration;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;

import org.junit.Test;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * @author Stephane Maldini
public void smokeTestInterval() {
			s.dispose();
		}
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public Disposable schedule(Runnable task, long delay, TimeUnit unit) {
			try {
				Future<?> f;
				if (delay <= 0L) {
					f = exec.submit(task);
				}
				else {
					f = exec.schedule(sr, delay, unit);
 */
package reactor.core.scheduler;

import java.time.Duration;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;

import org.junit.Test;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * @author Stephane Maldini
public void smokeTestInterval() {
			s.dispose();
		}
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void onCreate(Bundle savedInstanceState) {
        if (!Utils.isEmulator()) {

            mGoogleApiClient = new GoogleApiClient.Builder(this)
                    .addConnectionCallbacks(this)
                    .addOnConnectionFailedListener(this)
                    .addApi(Plus.API)
                    .addApi(Games.API)
                    .addApi(AppStateManager.API)
public void onCreate(Bundle savedInstanceState) {
    protected void onStart() {
        super.onStart();

        if (PrefUtils.isSignedIn(this)) {
            mGoogleApiClient.connect();
        }
protected void onStart() {
    protected void onStop() {
        super.onStop();

        if (PrefUtils.isSignedIn(this) && mGoogleApiClient.isConnected()) {
            mGoogleApiClient.disconnect();
        }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public class WidgetManager {
    private static final Logger LOG = LoggerFactory.getLogger(WidgetManager.class);

    private List<IViewContribution> m_viewContributors = new CopyOnWriteArrayList<IViewContribution>();
    private List<WidgetUpdateListener> m_listeners = new CopyOnWriteArrayList<WidgetUpdateListener>();
    
    private Comparator<IViewContribution> TITLE_COMPARATOR = new Comparator<IViewContribution>() {
        @Override
public int compare(final IViewContribution o1, final IViewContribution o2) {
    public WidgetManager() {}
    
    public void addUpdateListener(final WidgetUpdateListener listener) {
        LOG.info("Adding WidgetUpdateListener {} to WidgetManager {}", listener, this);
        synchronized (m_listeners) {
            m_listeners.add(listener);
            updateWidgetListeners();
        }
    }

    public void removeUpdateListener(final WidgetUpdateListener listener) {
        LOG.info("Removing WidgetUpdateListener {} from WidgetManager {}", listener, this);
        synchronized (m_listeners) {
            m_listeners.remove(listener);
        }
public int widgetCount() {
     * @return List<IViewContribution>
     */
    public List<IViewContribution> getWidgets(){
        final List<IViewContribution> widgets = new ArrayList<IViewContribution>();
        widgets.addAll(m_viewContributors);
        // Sort the widgets by their title
        Collections.sort(widgets, TITLE_COMPARATOR);
import com.vaadin.server.Page.UriFragmentChangedEvent;
import com.vaadin.server.Page.UriFragmentChangedListener;
import com.vaadin.server.RequestHandler;
import com.vaadin.server.ThemeResource;
import com.vaadin.server.VaadinRequest;
import com.vaadin.server.VaadinResponse;
public TopologyUI(CommandManager commandManager, HistoryManager historyManager,

	@Override
    protected void init(final VaadinRequest request) {
        try {
            m_headerHtml = getHeader(((VaadinServletRequest) request).getHttpServletRequest());
        } catch (final Exception e) {
private void applyHistory(String username, String fragment) {
     * @param widgetManager The WidgetManager.
     */
    private void updateWidgetView(WidgetManager widgetManager) {
        if (m_layout != null) {
            synchronized (m_layout) {
                m_layout.removeAllComponents();
                if(widgetManager.widgetCount() == 0) {
                    m_layout.addComponent(m_treeMapSplitPanel);
                } else {
                    VerticalSplitPanel bottomLayoutBar = new VerticalSplitPanel();
                    bottomLayoutBar.setFirstComponent(m_treeMapSplitPanel);
                    // Split the screen 70%!t(MISSING)op, 30%!b(MISSING)ottom
                    bottomLayoutBar.setSplitPosition(70, Unit.PERCENTAGE);
                    bottomLayoutBar.setSizeFull();
                    bottomLayoutBar.setSecondComponent(getTabSheet(widgetManager, this));
                    m_layout.addComponent(bottomLayoutBar);
                    updateTabVisibility();
                }
                m_layout.markAsDirty();
            }
        }
    }

    /**
public WidgetManager getWidgetManager() {
    }

    public void setWidgetManager(WidgetManager widgetManager) {
        if(m_widgetManager != null) {
            m_widgetManager.removeUpdateListener(this);
        }
        m_widgetManager = widgetManager;
        m_widgetManager.addUpdateListener(this);
    }

    @Override
    public void widgetListUpdated(WidgetManager widgetManager) {
        if(!isClosing()) {
            if(widgetManager == m_widgetManager) {
                updateWidgetView(widgetManager);
            }
        }
    }

http://www.osgi.org/xmlns/blueprint-ext/v1.1.0 http://aries.apache.org/schemas/b
    </reference-list>
    
    <bean id="widgetManager" class="org.opennms.features.topology.api.WidgetManager" />
    <bean id="treeWidgetManager" class="org.opennms.features.topology.api.WidgetManager" />
    
    <reference-list interface="org.opennms.features.topology.api.IViewContribution" availability="optional" filter="(location=bottom)">
        <reference-listener bind-method="onBind" unbind-method="onUnbind" ref="widgetManager"/>
    </reference-list>
    
    <!--<reference-list interface="org.opennms.features.topology.api.IViewContribution" availability="optional" filter="(location=left)">
        <reference-listener bind-method="onBind" unbind-method="onUnbind" ref="treeWidgetManager"/>
    </reference-list>-->
    
    <service interface="org.osgi.service.cm.ManagedService" >
        <service-properties>
            <entry key="service.pid" value="org.opennms.features.topology.app.menu"/>
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;

import org.opennms.core.criteria.CriteriaBuilder;
import org.opennms.core.criteria.restrictions.Restrictions;
import org.springframework.transaction.support.TransactionCallbackWithoutResult;
import org.springframework.transaction.support.TransactionOperations;

import com.github.wolfie.refresher.Refresher;

/**
 * @author Marcus Hellberg (marcus@vaadin.com)
 */
public class MapWidgetComponent extends NodeMapComponent implements GeoAssetProvider {

    private class DynamicUpdateRefresher implements Refresher.RefreshListener{
        private static final long serialVersionUID = 801233170298353060L;

        @Override
        public void refresh(Refresher refresher) {
            refreshView();
        }
    }

    private static final long serialVersionUID = -6364929103619363239L;
    private static final Logger LOG = LoggerFactory.getLogger(MapWidgetComponent.class);

    private final ScheduledExecutorService m_executor = Executors.newScheduledThreadPool(1, new ThreadFactory() {
        @Override public Thread newThread(final Runnable runnable) {
            return new Thread(runnable, "NodeMapUpdater-Thread");
        }
    });

    private NodeDao m_nodeDao;
    private AssetRecordDao m_assetDao;
    private AlarmDao m_alarmDao;
    private GeocoderService m_geocoderService;
    private TransactionOperations m_transaction;
    private Boolean m_aclsEnabled = false;

    private Map<Integer,NodeEntry> m_activeNodes = new HashMap<Integer,NodeEntry>();

    public NodeDao getNodeDao() {
        return m_nodeDao;
public void setTransactionOperations(final TransactionOperations tx) {
        m_transaction = tx;
    }

    public void init() {
        m_executor.scheduleWithFixedDelay(new Runnable() {
            @Override public void run() {
                refreshNodeData();
            }
        }, 0, 5, TimeUnit.MINUTES);
        checkAclsEnabled();
        setupAutoRefresher();
    }

    private void checkAclsEnabled() {
        String aclsPropValue = System.getProperty("org.opennms.web.aclsEnabled");
        m_aclsEnabled = aclsPropValue != null && aclsPropValue.equals("true");
    }

    public void setupAutoRefresher(){
        Refresher refresher = new Refresher();
        refresher.setRefreshInterval(5000); //Pull every two seconds for view updates
        refresher.addListener(new DynamicUpdateRefresher());
        addExtension(refresher);
    }

    public void refresh() {
        refreshView();
    }

    @Override
public void refresh() {
        return nodes;
    }

    private void refreshView() {
        if(m_aclsEnabled) {
            Map<Integer, String> nodes = getNodeDao().getAllLabelsById();

private void refreshView() {
        }
    }

    private void refreshNodeData() {
        if (getNodeDao() == null) {
            LOG.warn("No node DAO!  Can't refresh node data.");
            return;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;

import org.opennms.features.topology.api.HasExtraComponents;
import org.opennms.features.topology.api.VerticesUpdateManager.VerticesUpdateEvent;
import com.vaadin.annotations.Theme;
import com.vaadin.annotations.Title;
import com.vaadin.server.Page;
import com.vaadin.server.VaadinRequest;
import com.vaadin.ui.AbsoluteLayout;
import com.vaadin.ui.Alignment;
})
public class NodeMapsApplication extends UI {
    private static final Logger LOG = LoggerFactory.getLogger(NodeMapsApplication.class);
    // private static final int REFRESH_INTERVAL = 5 * 60 * 1000;
    private static final int REFRESH_INTERVAL = 10 * 1000;
    private VerticalLayout m_rootLayout;
    private VerticalLayout m_layout;

    private AlarmTable m_alarmTable;
    private NodeTable m_nodeTable;

    public void setHeaderProvider(final OnmsHeaderProvider headerProvider) {
        m_headerProvider = headerProvider;
    }
public void setNodeTable(final NodeTable table) {
    }

    private void updateWidgetView() {
        if (m_layout != null) {
            synchronized (m_layout) {
                m_layout.removeAllComponents();

                final VerticalSplitPanel bottomLayoutBar = new VerticalSplitPanel();
                bottomLayoutBar.setFirstComponent(m_mapWidgetComponent);

                // Split the screen 70%!t(MISSING)op, 30%!b(MISSING)ottom
                bottomLayoutBar.setSplitPosition(70, Unit.PERCENTAGE);
                bottomLayoutBar.setSizeFull();
                bottomLayoutBar.setSecondComponent(getTabSheet());
                m_layout.addComponent(bottomLayoutBar);
                m_layout.markAsDirty();
            }
        } else {
            LOG.warn("updateWidgetView() called, but there's no layout yet!");
        }
    }

    /**
protected void init(final VaadinRequest vaadinRequest) {
        createMapPanel(searchString, maxClusterRadius);
        createRootLayout();
        addRefresher();
    }

    private void createMapPanel(final String searchString, final int maxClusterRadius) {
private void closeQuietly(InputStream is) {
    private void addRefresher() {
        final Refresher refresher = new Refresher();
        refresher.setRefreshInterval(REFRESH_INTERVAL);
        addExtension(refresher);
    }

		</cm:default-properties>
	</cm:property-placeholder>

	<bean id="mapWidget" class="org.opennms.features.vaadin.nodemaps.internal.MapWidgetComponent" scope="prototype" init-method="init">
		<property name="nodeDao" ref="nodeDao" />
		<property name="assetRecordDao" ref="assetDao" />
		<property name="alarmDao" ref="alarmDao" />
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    private final ReadWriteLock lock = new ReentrantReadWriteLock();

    private static class SubmittedTask {
        public final GWCTask task;

public void dispatchTasks(GWCTask[] tasks) {
                Future<GWCTask> future = threadPool.submit(new MTSeeder(task));
                this.currentPool.put(taskId, new SubmittedTask(task, future));
            }
        } finally {
            lock.writeLock().unlock();
        }
private long stateCode(STATE state) {
    private void drain() {
        lock.writeLock().lock();
        try {
            threadPool.purge();
            for (Iterator<Entry<Long, SubmittedTask>> it = this.currentPool.entrySet().iterator(); it
                    .hasNext();) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void reset(final boolean keepGlobals) {

        clearUpdateListeners();

        profiler.reset();
        
        analyzed = false;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public final void execute()
        } catch (final Exception e) {
          throw new MojoExecutionException("Exception in onAfterExecute", e);
        }
      }
    }
  }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    private static final String TAG = "PostListActivity";

    private List<Post> mPosts;
    private PostAdapter mPostAdapter;

    private Handler mHandler;
    private static final int REFRESH_FREQUENCY = 10 * 60 * 1000;  // milliseconds

    @InjectView(R.id.toolbar)
protected void onCreate(Bundle savedInstanceState) {
        // initialize post list UI
        UserPrefs prefs = UserPrefs.getInstance(this);
        String blogUrl = prefs.getString(UserPrefs.Key.BLOG_URL);
        mPosts = new ArrayList<>();
        mPostAdapter = new PostAdapter(this, mPosts, blogUrl, getPicasso(), v -> {
            int pos = mPostList.getChildLayoutPosition(v);
            if (pos == RecyclerView.NO_POSITION) return;
protected void onCreate(Bundle savedInstanceState) {
        int vSpace = getResources().getDimensionPixelOffset(R.dimen.padding_default_card_v);
        mPostList.addItemDecoration(new SpaceItemDecoration(hSpace, vSpace));

        mHandler = new Handler(Looper.getMainLooper());

        getBus().post(new LoadUserEvent(false));
        getBus().post(new LoadBlogSettingsEvent(false));
        getBus().post(new LoadPostsEvent(false));
public void onPostCreatedEvent(PostCreatedEvent event) {
    private void scheduleDataRefresh() {
        // cancel already-scheduled refresh event
        cancelDataRefresh();
        mHandler.postDelayed(this::refreshData, REFRESH_FREQUENCY);
    }

    private void cancelDataRefresh() {
        mHandler.removeCallbacks(this::refreshData);
    }

    private void refreshData() {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public V put(K key, V value)
        }

        boolean containsKey = this.delegate.containsKey(key);
        V put = this.delegate.put(key, value);
        if (containsKey)
        {
            this.inverse.delegate.removeKey(put);
        }
        this.inverse.delegate.put(value, key);
        return put;
    }
public V forcePut(K key, V value)
        }

        boolean containsKey = this.delegate.containsKey(key);
        V put = this.delegate.put(key, value);
        if (containsKey)
        {
            this.inverse.delegate.removeKey(put);
        }
        K oldKey = this.inverse.delegate.put(value, key);
        if (containsValue)
        {
            this.delegate.removeKey(oldKey);
        }
        return put;
    }

/*
 * Copyright (c) 2015 Goldman Sachs.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompany this distribution.

import org.eclipse.collections.impl.map.mutable.UnifiedMap;
import org.eclipse.collections.impl.test.Verify;
import org.junit.Assert;
import org.junit.Test;

public void withKeysValues()
        Assert.assertSame(map, map44);
        Assert.assertSame(map3, map4);
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import com.intellij.execution.ui.ConsoleViewContentType;
import com.intellij.openapi.components.AbstractProjectComponent;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.EmptyRunnable;
import com.intellij.openapi.wm.ToolWindow;
import com.intellij.openapi.wm.ToolWindowManager;
public void printMessage(String message, ConsoleViewContentType contentType) {
    public void attachConsoleViewToProcess(ProcessHandler processHandler) {
        consoleViewImpl.attachToProcess(processHandler);
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void onSeriesSelected(Series series, boolean isEvent)
        mSeriesId = series.getSeriesId();
        mSeriesDate = series.getSeriesDate();

        new OpenSeriesTask().execute(isEvent);
    }

    @Override
    public void onCreateNewSeries(boolean isEvent)
    {
        new AddSeriesTask().execute();
    }

    /**
public boolean isQuickSeries()
    /**
     * Loads game data related to seriesId and displays it in a new GameFragment instance.
     */
    private class OpenSeriesTask
            extends AsyncTask<Boolean, Void, Object[]>
    {

        @Override
        protected Object[] doInBackground(Boolean... isEvent)
        {
            long[] gameId = new long[mNumberOfGames];
            //noinspection CheckStyle
            long[] frameId = new long[mNumberOfGames * 10];
            boolean[] gameLocked = new boolean[mNumberOfGames];
            boolean[] manualScore = new boolean[mNumberOfGames];
            byte[] matchPlay = new byte[mNumberOfGames];

            SQLiteDatabase database =
                    DatabaseHelper.getInstance(MainActivity.this).getReadableDatabase();
            String rawSeriesQuery = "SELECT "
                    + "game." + GameEntry._ID + " AS gid, "
                    + GameEntry.COLUMN_IS_LOCKED + ", "
public boolean isQuickSeries()
                    + " ON gid=" + FrameEntry.COLUMN_GAME_ID
                    + " WHERE " + GameEntry.COLUMN_SERIES_ID + "=?"
                    + " ORDER BY gid, fid";
            String[] rawSeriesArgs = {String.valueOf(mSeriesId)};

            int currentGame = -1;
            long currentGameId = -1;
public boolean isQuickSeries()
        @Override
        protected void onPostExecute(Object[] params)
        {
            long[] gameIds = (long[]) params[0];
            long[] frameIds = (long[]) params[1];
            boolean[] gameLocked = (boolean[]) params[2];
            boolean[] manualScore = (boolean[]) params[3];
            byte[] matchPlay = (byte[]) params[4];
            mIsEventMode = (boolean) params[5];

            GameFragment gameFragment = GameFragment.newInstance(gameIds, frameIds, gameLocked,
                    manualScore, matchPlay);
            startFragmentTransaction(gameFragment, (isEventMode()
                    ? Constants.FRAGMENT_LEAGUES
                    : Constants.FRAGMENT_SERIES), Constants.FRAGMENT_GAME);
        }
protected void onPostExecute(Object[] params)
    /**
     * Creates a new series in the database and displays it in a new instance of GameFragment.
     */
    private class AddSeriesTask
            extends AsyncTask<Void, Void, Object[]>
    {

        @Override
        protected Object[] doInBackground(Void... params)
        {
            long seriesId = -1;
            long[] gameId = new long[mNumberOfGames];
            //noinspection CheckStyle
            long[] frameId = new long[mNumberOfGames * 10];

            SQLiteDatabase database =
                    DatabaseHelper.getInstance(MainActivity.this).getReadableDatabase();
            SimpleDateFormat dateFormat =
                    new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.CANADA);
            String seriesDate = dateFormat.format(new Date());
protected void onPostExecute(Object[] params)
            {
                ContentValues values = new ContentValues();
                values.put(SeriesEntry.COLUMN_SERIES_DATE, seriesDate);
                values.put(SeriesEntry.COLUMN_LEAGUE_ID, mLeagueId);
                seriesId = database.insert(SeriesEntry.TABLE_NAME, null, values);

                for (byte i = 0; i < mNumberOfGames; i++)
                {
                    values = new ContentValues();
                    values.put(GameEntry.COLUMN_GAME_NUMBER, i + 1);
protected void onPostExecute(Object[] params)
                database.endTransaction();
            }

            mSeriesId = seriesId;
            mSeriesDate = DataFormatter.formattedDateToPrettyCompact(seriesDate);
            return new Object[]{gameId, frameId};
        }

        @Override
        protected void onPostExecute(Object[] params)
        {
            long[] gameIds = (long[]) params[0];
            long[] frameIds = (long[]) params[1];
            mIsEventMode = false;

            GameFragment gameFragment = GameFragment.newInstance(
                    gameIds,
                    frameIds,
                    new boolean[mNumberOfGames],
                    new boolean[mNumberOfGames],
                    new byte[mNumberOfGames]);
            startFragmentTransaction(
                    gameFragment,
                    (isQuickSeries()
                            ? Constants.FRAGMENT_BOWLERS
                            : Constants.FRAGMENT_SERIES),
                    Constants.FRAGMENT_GAME);
protected void onCreate(Bundle savedInstanceState)
            return;
        }

        setupViewPager();
    }

public void destroyItem(ViewGroup container, int position, Object object)
    @Override
    public Fragment getItem(int position)
    {
        if (position < TutorialFragment.TUTORIAL_TOTAL_PAGES)
            return TutorialFragment.newInstance(position);
        else
            return RegisterFragment.newInstance(true);
    }

    @Override
    public int getCount()
    {
        return TutorialFragment.TUTORIAL_TOTAL_PAGES;
    }

    /**
private LoadBowlerAndRecentTask(BowlerFragment fragment)
        protected List<Bowler> doInBackground(Void... params)
        {
            //Method exits if fragment gets detached before reaching this call
            if (mFragment.get() == null || mFragment.get().getActivity() == null)
                return null;

            WeakReference<MainActivity> mainActivity
                    = new WeakReference<>((MainActivity) mFragment.get().getActivity());

            MainActivity.waitForSaveThreads(mainActivity);

            SQLiteDatabase database =
                    DatabaseHelper.getInstance(mainActivity.get()).getReadableDatabase();
            List<Bowler> listBowlers = new ArrayList<>();

            SharedPreferences preferences =
                    PreferenceManager.getDefaultSharedPreferences(mainActivity.get());
            boolean includeEvents = preferences.getBoolean(Constants.KEY_INCLUDE_EVENTS, true);
            boolean includeOpen = preferences.getBoolean(Constants.KEY_INCLUDE_OPEN, true);

private LoadBowlerAndRecentTask(BowlerFragment fragment)
            cursor.close();

            //If a recent bowler exists, their name and league is loaded to be used for quick series
            if (mFragment.get().mRecentBowlerId > -1 && mFragment.get().mRecentLeagueId > -1)
            {
                String rawRecentQuery = "SELECT "
                        + BowlerEntry.COLUMN_BOWLER_NAME + ", "
private LoadBowlerAndRecentTask(BowlerFragment fragment)
                        + " WHERE bowler." + BowlerEntry._ID + "=? "
                        + "AND league." + LeagueEntry._ID + "=?";
                String[] rawRecentArgs = new String[]{
                        String.valueOf(mFragment.get().mRecentBowlerId),
                        String.valueOf(mFragment.get().mRecentLeagueId)
                };

                cursor = database.rawQuery(rawRecentQuery, rawRecentArgs);
                if (cursor.moveToFirst())
                {
                    mFragment.get().mRecentBowlerName = cursor.getString(
                            cursor.getColumnIndex(BowlerEntry.COLUMN_BOWLER_NAME));
                    mFragment.get().mRecentLeagueName = cursor.getString(
                            cursor.getColumnIndex(LeagueEntry.COLUMN_LEAGUE_NAME));
                    mFragment.get().mRecentNumberOfGames = (byte) cursor.getInt(
                            cursor.getColumnIndex(LeagueEntry.COLUMN_NUMBER_OF_GAMES));
                }
                else
                {
                    mFragment.get().mRecentBowlerId = -1;
                    mFragment.get().mRecentLeagueId = -1;
                }
                cursor.close();
            }

            //If a custom bowler is set, their name and league is loaded to be used for quick series
            if (mFragment.get().mQuickBowlerId > -1 && mFragment.get().mQuickLeagueId > -1)
            {
                String rawRecentQuery = "SELECT "
                        + BowlerEntry.COLUMN_BOWLER_NAME + ", "
private LoadBowlerAndRecentTask(BowlerFragment fragment)
                        + " WHERE bowler." + BowlerEntry._ID + "=?"
                        + "AND league." + LeagueEntry._ID + "=?";
                String[] rawRecentArgs = new String[]{
                        String.valueOf(mFragment.get().mQuickBowlerId),
                        String.valueOf(mFragment.get().mQuickLeagueId)
                };

                cursor = database.rawQuery(rawRecentQuery, rawRecentArgs);
                if (cursor.moveToFirst())
                {
                    mFragment.get().mQuickBowlerName = cursor.getString(
                            cursor.getColumnIndex(BowlerEntry.COLUMN_BOWLER_NAME));
                    mFragment.get().mQuickLeagueName = cursor.getString(
                            cursor.getColumnIndex(LeagueEntry.COLUMN_LEAGUE_NAME));
                    mFragment.get().mQuickNumberOfGames = (byte) cursor.getInt(
                            cursor.getColumnIndex(LeagueEntry.COLUMN_NUMBER_OF_GAMES));
                }
                else
                {
                    mFragment.get().mQuickBowlerId = -1;
                    mFragment.get().mQuickLeagueId = -1;
                }
                cursor.close();
            }
private LoadBowlerAndRecentTask(BowlerFragment fragment)
        @Override
        protected void onPostExecute(List<Bowler> listBowlers)
        {
            if (listBowlers == null)
                return;

            if (mFragment.get() != null)
            {
                mFragment.get().mListBowlers.addAll(listBowlers);
                mFragment.get().mAdapterBowlers.notifyDataSetChanged();
            }
        }
    }

private OpenBowlerLeaguesTask(BowlerFragment fragment)
        @Override
        protected Bowler doInBackground(Integer... position)
        {
            if (mFragment.get() == null || mFragment.get().getActivity() == null)
                return null;

            Bowler bowler = mFragment.get().mListBowlers.get(position[0]);

            //Updates date which bowler was last accessed in database
            SQLiteDatabase database =
                    DatabaseHelper.getInstance(mFragment.get().getActivity()).getWritableDatabase();
            SimpleDateFormat dateFormat =
                    new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.CANADA);
            ContentValues values = new ContentValues();
protected Bowler doInBackground(Integer... position)
        @Override
        protected void onPostExecute(Bowler result)
        {
            if (result == null || mFragment.get() == null)
                return;

            //Creates new instance of LeagueEventFragment for bowler
            mFragment.get().mBowlerSelectedListener.onBowlerSelected(result, true, false);
        }
    }

private NewBowlerTask(BowlerFragment fragment)
        @Override
        protected Bowler doInBackground(Bowler... bowler)
        {
            if (mFragment.get() == null || mFragment.get().getActivity() == null)
                return null;

            bowler[0].setBowlerId(-1);
            SQLiteDatabase database =
                    DatabaseHelper.getInstance(mFragment.get().getActivity()).getWritableDatabase();
            SimpleDateFormat dateFormat =
                    new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.CANADA);
            String currentDate = dateFormat.format(new Date());
protected Bowler doInBackground(Bowler... bowler)
        @Override
        protected void onPostExecute(Bowler newBowler)
        {
            /*
             * Adds the new bowler information to the corresponding lists
             * and displays them in the recycler view
             */
            if (mFragment.get() != null && newBowler.getBowlerId() != -1)
            {
                mFragment.get().mListBowlers.add(0, newBowler);
                mFragment.get().mAdapterBowlers.notifyItemInserted(0);
                mFragment.get().mRecyclerViewBowlers.scrollToPosition(0);
            }
        }
    }
private OpenLeagueEventSeriesTask(LeagueEventFragment fragment)
        @Override
        protected Pair<LeagueEvent, Series> doInBackground(Integer... position)
        {
            if (mFragment.get() == null || mFragment.get().getActivity() == null)
                return null;
            LeagueEvent selectedLeagueEvent = mFragment.get().mListLeaguesEvents.get(position[0]);
            boolean isEvent = selectedLeagueEvent.getLeagueEventName().substring(0, 1).equals("E");

            SQLiteDatabase database =
                    DatabaseHelper.getInstance(mFragment.get().getActivity()).getWritableDatabase();
            SimpleDateFormat dateFormat =
                    new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.CANADA);
            String currentDate = dateFormat.format(new Date());
private OpenLeagueEventSeriesTask(LeagueEventFragment fragment)
        @Override
        protected void onPostExecute(Pair<LeagueEvent, Series> result)
        {
            if (mFragment.get() == null || mFragment.get().getActivity() == null)
                return;

            boolean isEvent = result.second.getSeriesId() >= 0;
protected void onPostExecute(Pair<LeagueEvent, Series> result)
                 * displaying the event's corresponding series
                 */

                mFragment.get().mLeagueSelectedListener.onLeagueSelected(result.first, false);
                mFragment.get().mSeriesListener.onSeriesSelected(result.second, true);
            }
            else
            {
                /*
                 * If a league was selected, creates an instance of SeriesActivity
                 * to display all available series in the league
                 */
                long bowlerId = ((MainActivity) mFragment.get().getActivity()).getBowlerId();

                if (!result.first.getLeagueEventName().equals(Constants.NAME_OPEN_LEAGUE))
                {
                    mFragment.get()
                            .getActivity()
                            .getSharedPreferences(Constants.PREFS, Context.MODE_PRIVATE)
                            .edit()
                            .putLong(Constants.PREF_RECENT_LEAGUE_ID,
protected void onPostExecute(Pair<LeagueEvent, Series> result)
                            .apply();
                }

                mFragment.get().mLeagueSelectedListener.onLeagueSelected(result.first, true);
            }
        }
    }
private LoadLeaguesEventsTask(LeagueEventFragment fragment)
        @Override
        protected List<LeagueEvent> doInBackground(Void... params)
        {
            if (mFragment.get() == null || mFragment.get().getActivity() == null)
                return null;

            MainActivity.waitForSaveThreads(new WeakReference<>((MainActivity) mFragment.get()
                    .getActivity()));

            SQLiteDatabase database =
                    DatabaseHelper.getInstance(mFragment.get().getActivity()).getReadableDatabase();
            List<LeagueEvent> listLeagueEvents = new ArrayList<>();

            String rawLeagueEventQuery = "SELECT "
private LoadLeaguesEventsTask(LeagueEventFragment fragment)
                    + " GROUP BY lid"
                    + " ORDER BY " + LeagueEntry.COLUMN_DATE_MODIFIED + " DESC";

            long bowlerId = ((MainActivity) mFragment.get().getActivity()).getBowlerId();
            Cursor cursor = database.rawQuery(rawLeagueEventQuery,
                    new String[]{String.valueOf(bowlerId)});
            if (cursor.moveToFirst())
private LoadLeaguesEventsTask(LeagueEventFragment fragment)
        @SuppressWarnings("unchecked")
        protected void onPostExecute(List<LeagueEvent> listLeagueEvents)
        {
            if (mFragment.get() == null)
                return;

            mFragment.get().mListLeaguesEvents.addAll(listLeagueEvents);
            mFragment.get().mAdapterLeagueEvents.notifyDataSetChanged();
        }
    }

private AddNewLeagueEventTask(LeagueEventFragment fragment)
        @Override
        protected LeagueEvent doInBackground(LeagueEvent... leagueEvent)
        {
            if (mFragment.get() == null || mFragment.get().getActivity() == null)
                return null;

            leagueEvent[0].setLeagueEventId(-1);
            long bowlerId = ((MainActivity) mFragment.get().getActivity()).getBowlerId();

            SQLiteDatabase database =
                    DatabaseHelper.getInstance(mFragment.get().getActivity()).getWritableDatabase();
            SimpleDateFormat dateFormat =
                    new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.CANADA);
            String currentDate = dateFormat.format(new Date());
protected LeagueEvent doInBackground(LeagueEvent... leagueEvent)
        @Override
        protected void onPostExecute(LeagueEvent result)
        {
            if (result != null && result.getLeagueEventId() != -1 && mFragment.get() != null)
            {
                mFragment.get().mListLeaguesEvents.add(0, result);
                mFragment.get().mAdapterLeagueEvents.notifyItemInserted(0);
                mFragment.get().mRecyclerViewLeagueEvents.scrollToPosition(0);
            }
        }
    }
private LoadSeriesTask(SeriesFragment fragment)
        @Override
        protected List<Series> doInBackground(Void... params)
        {
            if (mFragment.get() == null || mFragment.get().getActivity() == null)
                return null;

            MainActivity.waitForSaveThreads(new WeakReference<>((MainActivity) mFragment.get()
                    .getActivity()));

            SQLiteDatabase database =
                    DatabaseHelper.getInstance(mFragment.get().getActivity()).getReadableDatabase();
            List<Series> listSeries = new ArrayList<>();

            String rawSeriesQuery = "SELECT "
private LoadSeriesTask(SeriesFragment fragment)
                    + " ORDER BY " + SeriesEntry.COLUMN_SERIES_DATE + " DESC, "
                    + GameEntry.COLUMN_GAME_NUMBER;
            String[] rawSeriesArgs = {
                    String.valueOf(((MainActivity) mFragment.get()
                            .getActivity()).getLeagueId())
            };

            Cursor cursor = database.rawQuery(rawSeriesQuery, rawSeriesArgs);
private LoadSeriesTask(SeriesFragment fragment)
        @SuppressWarnings("unchecked")
        protected void onPostExecute(List<Series> listSeries)
        {
            if (mFragment.get() == null || mFragment.get().getActivity() == null)
                return;

            mFragment.get().mListSeries.addAll(listSeries);
            mFragment.get().mAdapterSeries.notifyDataSetChanged();
        }
    }

import android.content.SharedPreferences;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.os.AsyncTask;
import android.os.Bundle;
import android.preference.PreferenceManager;
import android.support.v4.app.Fragment;

import com.github.mikephil.charting.charts.LineChart;

import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import ca.josephroque.bowlingcompanion.Constants;
import ca.josephroque.bowlingcompanion.MainActivity;
import ca.josephroque.bowlingcompanion.R;
public void updateTheme()
    }

    /**
     * Loads data from the database and calculates relevant stats depending on which type of stats
     * are being loaded.
     */
    /*private class LoadStatsGraphTask
            extends AsyncTask<Byte, Void, List<?>[]>
    {

        @Override
        protected void onPreExecute()
        {
            mLineChartStats.clear();
        }

        @Override
        protected List<?>[] doInBackground(Byte... statsToLoad)
        {
            MainActivity mainActivity = (MainActivity) getActivity();
            MainActivity.waitForSaveThreads(mainActivity);

            final byte toLoad = statsToLoad[0];
            Cursor cursor;
            int[][] statValues;
            List<String> listStatHeaders = new ArrayList<>();
            List<List<AbstractMap.SimpleEntry<String, String>>> listStatNamesAndValues =
                    new ArrayList<>();

            prepareListData(mainActivity, toLoad, listStatHeaders, listStatNamesAndValues);
            statValues = new int[listStatHeaders.size()][];
            for (int i = 0; i < statValues.length; i++)
                statValues[i] = new int[listStatNamesAndValues.get(i).size()];

            switch (toLoad)
            {
                case StatsFragment.LOADING_BOWLER_STATS:
                    numberOfGeneralDetails = 1;
                    cursor = getBowlerOrLeagueCursor(false);
                    break;
                case StatsFragment.LOADING_LEAGUE_STATS:
                    numberOfGeneralDetails = 2;
                    listStatNamesAndValues.get(mStatsGeneral).add(1,
                            new AbstractMap.SimpleEntry<>("League/Event",
                                    mainActivity.getLeagueName()));
                    cursor = getBowlerOrLeagueCursor(true);
                    break;
                case StatsFragment.LOADING_SERIES_STATS:
                    numberOfGeneralDetails = 3;
                    listStatNamesAndValues.get(mStatsGeneral).add(1,
                            new AbstractMap.SimpleEntry<>("League/Event",
                                    mainActivity.getLeagueName()));
                    listStatNamesAndValues.get(mStatsGeneral).add(2,
                            new AbstractMap.SimpleEntry<>("Date", mainActivity.getSeriesDate()));
                    cursor = getSeriesCursor();
                    break;
                case StatsFragment.LOADING_GAME_STATS:
                    numberOfGeneralDetails = 4;
                    listStatNamesAndValues.get(mStatsGeneral).add(1,
                            new AbstractMap.SimpleEntry<>("League/Event",
                                    mainActivity.getLeagueName()));
                    listStatNamesAndValues.get(mStatsGeneral).add(2,
                            new AbstractMap.SimpleEntry<>("Date", mainActivity.getSeriesDate()));
                    listStatNamesAndValues.get(mStatsGeneral).add(3,
                            new AbstractMap.SimpleEntry<>("Game #",
                                    String.valueOf(mainActivity.getGameNumber())));
                    cursor = getGameCursor();
                    break;
                default:
                    throw new IllegalArgumentException("invalid value for toLoad: " + toLoad
                            + ". must be between 0 and 3 (inclusive)");
            }

            *//**
             * Passes through rows in cursor and updates stats which
             * are affected as each frame is analyzed
             *//*

            final byte numberOfGames = (toLoad >= StatsFragment.LOADING_LEAGUE_STATS
                    ? mainActivity.getNumberOfGames()
                    : 20);
            int totalShotsAtMiddle = 0;
            int spareChances = 0;
            int seriesTotal = 0;
            int[] totalByGame = new int[numberOfGames];
            int[] countByGame = new int[numberOfGames];
            if (cursor.moveToFirst())
            {
                while (!cursor.isAfterLast())
                {
                    byte frameNumber = (byte) cursor.getInt(
                            cursor.getColumnIndex(Contract.FrameEntry.COLUMN_FRAME_NUMBER));
                    if (toLoad != StatsFragment.LOADING_GAME_STATS && frameNumber == 1)
                    {
                        short gameScore =
                                cursor.getShort(cursor.getColumnIndex(Contract.GameEntry.COLUMN_SCORE));
                        byte gameNumber = (byte) cursor.getInt(
                                cursor.getColumnIndex(Contract.GameEntry.COLUMN_GAME_NUMBER));

                        totalByGame[gameNumber - 1] += gameScore;
                        countByGame[gameNumber - 1]++;

                        byte matchResults = (byte) (cursor.getInt(
                                cursor.getColumnIndex(Contract.GameEntry.COLUMN_MATCH_PLAY)));
                        if (matchResults > 0)
                            statValues[mStatsMatch][matchResults - 1]++;

                        if (statValues[mStatsOverall][Constants.STAT_HIGH_SINGLE] < gameScore)
                        {
                            statValues[mStatsOverall][Constants.STAT_HIGH_SINGLE] = gameScore;
                        }
                        statValues[mStatsOverall][Constants.STAT_TOTAL_PINS] += gameScore;
                        statValues[mStatsOverall][Constants.STAT_NUMBER_OF_GAMES]++;

                        if (gameNumber == 1)
                        {
                            if (statValues[mStatsOverall][Constants.STAT_HIGH_SERIES] < seriesTotal)
                                statValues[mStatsOverall][Constants.STAT_HIGH_SERIES] = seriesTotal;
                            seriesTotal = gameScore;
                        }
                        else
                            seriesTotal += gameScore;
                    }

                    boolean gameIsManual =
                            (cursor.getInt(cursor.getColumnIndex(Contract.GameEntry.COLUMN_IS_MANUAL))
                                    == 1);
                    if (gameIsManual)
                    {
                        cursor.moveToNext();
                        continue;
                    }
                    boolean frameAccessed =
                            (cursor.getInt(cursor.getColumnIndex(Contract.FrameEntry.COLUMN_IS_ACCESSED))
                                    == 1);
                    if (toLoad == StatsFragment.LOADING_GAME_STATS && !frameAccessed)
                        break;

                    String frameFouls =
                            cursor.getString(cursor.getColumnIndex(Contract.FrameEntry.COLUMN_FOULS));
                    String[] ballStrings = {
                            cursor.getString(cursor.getColumnIndex(Contract.FrameEntry.COLUMN_PIN_STATE[0])),
                            cursor.getString(cursor.getColumnIndex(Contract.FrameEntry.COLUMN_PIN_STATE[1])),
                            cursor.getString(
                                    cursor.getColumnIndex(Contract.FrameEntry.COLUMN_PIN_STATE[2]))
                    };
                    boolean[][] pinState = new boolean[3][5];

                    for (byte i = 0; i < 5; i++)
                    {
                        pinState[0][i] = ballStrings[0].charAt(i) == '1';
                        pinState[1][i] = ballStrings[1].charAt(i) == '1';
                        pinState[2][i] = ballStrings[2].charAt(i) == '1';
                    }
                    for (byte i = 1; i <= 3; i++)
                    {
                        if (frameFouls.contains(String.valueOf(i)))
                            statValues[mStatsFouls][0]++;
                    }

                    if (frameNumber == Constants.NUMBER_OF_FRAMES)
                    {
                        totalShotsAtMiddle++;
                        int ballValue = getFirstBallValue(pinState[0]);
                        if (ballValue != -1)
                            statValues[mStatsGeneral][Constants.STAT_MIDDLE_HIT]++;
                        increaseFirstBallStat(ballValue, statValues, 0);
                        if (ballValue < 5 && ballValue != Constants.BALL_VALUE_STRIKE)
                            spareChances++;

                        if (ballValue != 0)
                        {
                            if (Arrays.equals(pinState[1], Constants.FRAME_PINS_DOWN))
                            {
                                statValues[mStatsGeneral][Constants.STAT_SPARE_CONVERSIONS]++;
                                increaseFirstBallStat(ballValue, statValues, 1);

                                if (ballValue >= 5)
                                    spareChances++;
                            }
                            else
                            {
                                statValues[mStatsPins][Constants.STAT_PINS_LEFT] +=
                                        countPinsLeftStanding(pinState[2]);
                            }
                        }
                        else
                        {
                            totalShotsAtMiddle++;
                            ballValue = getFirstBallValue(pinState[1]);
                            if (ballValue != -1)
                                statValues[mStatsGeneral][Constants.STAT_MIDDLE_HIT]++;
                            increaseFirstBallStat(ballValue, statValues, 0);

                            if (ballValue != 0)
                            {
                                if (Arrays.equals(pinState[2], Constants.FRAME_PINS_DOWN))
                                {
                                    statValues[mStatsGeneral][Constants.STAT_SPARE_CONVERSIONS]++;
                                    increaseFirstBallStat(ballValue, statValues, 1);

                                    if (ballValue >= 5)
                                        spareChances++;
                                }
                                else
                                {
                                    statValues[mStatsPins][Constants.STAT_PINS_LEFT] +=
                                            countPinsLeftStanding(pinState[2]);
                                }
                            }
                            else
                            {
                                totalShotsAtMiddle++;
                                ballValue = getFirstBallValue(pinState[2]);
                                if (ballValue != -1)
                                    statValues[mStatsGeneral][Constants.STAT_MIDDLE_HIT]++;
                                increaseFirstBallStat(ballValue, statValues, 0);

                                if (ballValue != 0)
                                {
                                    statValues[mStatsPins][Constants.STAT_PINS_LEFT] +=
                                            countPinsLeftStanding(pinState[2]);
                                }
                            }
                        }
                    }
                    else
                    {
                        totalShotsAtMiddle++;
                        int ballValue = getFirstBallValue(pinState[0]);
                        if (ballValue != -1)
                            statValues[mStatsGeneral][Constants.STAT_MIDDLE_HIT]++;
                        increaseFirstBallStat(ballValue, statValues, 0);

                        if (ballValue < 5 && ballValue != Constants.BALL_VALUE_STRIKE)
                            spareChances++;

                        if (ballValue != 0)
                        {
                            if (Arrays.equals(pinState[1], Constants.FRAME_PINS_DOWN))
                            {
                                statValues[mStatsGeneral][Constants.STAT_SPARE_CONVERSIONS]++;
                                increaseFirstBallStat(ballValue, statValues, 1);

                                if (ballValue >= 5)
                                    spareChances++;
                            }
                            else
                            {
                                statValues[mStatsPins][Constants.STAT_PINS_LEFT] +=
                                        countPinsLeftStanding(pinState[2]);
                            }
                        }
                    }

                    cursor.moveToNext();
                }
            }

            if (toLoad != StatsFragment.LOADING_GAME_STATS)
            {
                if (statValues[mStatsOverall][Constants.STAT_HIGH_SERIES] < seriesTotal)
                    statValues[mStatsOverall][Constants.STAT_HIGH_SERIES] = seriesTotal;

                if (toLoad != StatsFragment.LOADING_SERIES_STATS)
                {
                    for (byte i = 0; i < numberOfGames; i++)
                        statValues[mStatsGameAverage][i] = (countByGame[i] > 0)
                                ? totalByGame[i] / countByGame[i]
                                : 0;
                }

                if (statValues[mStatsOverall][Constants.STAT_NUMBER_OF_GAMES] > 0)
                {
                    statValues[mStatsOverall][Constants.STAT_AVERAGE] =
                            statValues[mStatsOverall][Constants.STAT_TOTAL_PINS]
                                    / statValues[mStatsOverall][Constants.STAT_NUMBER_OF_GAMES];
                    statValues[mStatsPins][Constants.STAT_PINS_AVERAGE] =
                            statValues[mStatsPins][Constants.STAT_PINS_LEFT]
                                    / statValues[mStatsOverall][Constants.STAT_NUMBER_OF_GAMES];
                }
            }
            cursor.close();
            setGeneralAndDetailedStatValues(listStatNamesAndValues, statValues, totalShotsAtMiddle,
                    spareChances, numberOfGeneralDetails, toLoad);

            return new List<?>[]{listStatHeaders, listStatNamesAndValues};

            return null;
        }

        @Override
        protected void onPostExecute(List<?>[] result)
        {

        }
    }*/

    /**
     * Returns a cursor from database to load either bowler or league stats.
     *
     * @param shouldGetLeagueStats if true, league stats will be loaded. Bowler stats will be loaded

import android.app.Activity;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.graphics.Bitmap;
import android.media.MediaScannerConnection;
import android.net.Uri;
import android.os.AsyncTask;
import android.util.Log;
import android.widget.Toast;

import java.io.IOException;
import java.io.OutputStream;

import ca.josephroque.bowlingcompanion.R;

public void onClick(DialogInterface dialog, int which)
                        if (selectedItem == 0)
                            saveSeriesToDevice(activity, seriesId);
                        else
                            shareSeries(activity, seriesId);
                        dialog.dismiss();
                    }
                })
public void onClick(DialogInterface dialog, int which)
     * Creates a task to save an image of the series to the device and prompt the user
     * to share it with another service.
     *
     * @param activity parent activity for the dialog
     * @param seriesId id of the series to share
     */
    private static void shareSeries(Activity activity, long seriesId)
    {
        new ShareSeriesTask().execute(activity, seriesId);
    }

    /**
public void onScanCompleted(String path, Uri uri)
    /**
     * Creates an image for the series and prompts user to share it.
     */
    private static class ShareSeriesTask extends AsyncTask<Object, Void, Object[]>
    {
        @SuppressWarnings("UnusedAssignment") //image set to null to free memory
        @Override
        public Object[] doInBackground(Object... params)
        {
            Activity activity = (Activity) params[0];
            long seriesId = (Long) params[1];
            Bitmap image = ImageUtils.createImageFromSeries(activity, seriesId);
            Uri imageUri = ImageUtils.insertImage(activity.getContentResolver(),
                    image,
                    String.valueOf(System.currentTimeMillis()),
                    "Series: " + seriesId);
public void onScanCompleted(String path, Uri uri)
            OutputStream outStream = null;
            try
            {
                outStream = activity.getContentResolver()
                        .openOutputStream(imageUri);
                image.compress(Bitmap.CompressFormat.JPEG, 100, outStream);
                image.recycle();
public void onScanCompleted(String path, Uri uri)
            }

            shareIntent.putExtra(Intent.EXTRA_STREAM, imageUri);
            return new Object[]{activity, shareIntent};
        }

        @Override
        public void onPostExecute(Object[] params)
        {
            Activity activity = (Activity) params[0];
            Intent shareIntent = (Intent) params[1];

            activity.startActivity(Intent.createChooser(shareIntent, "Share Image"));
        }
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
