def keyStore = 'shootoff_cs.jks'
def keyAlias = 'cscert'
def tsaURL = 'http://timestamp.comodoca.com/rfc3161'


repositories {
    mavenCentral()
    // Next 2 are used for tts
dependencies {
    }
    
    //OpenCV
	compile 'org.openpnp:opencv:2.4.11-1'

    testCompile group: 'junit', name: 'junit', version: '4.+'
    testCompile group: 'org.hamcrest', name: 'hamcrest-core', version: '1.+'
	private final Configuration config;
	private Optional<Bounds> projectionBounds = Optional.empty();

	private boolean isStreaming = true;
	private boolean isDetecting = true;
	private boolean shownBrightnessWarning = false;
	private boolean cropFeedToProjection = false;
	private boolean limitDetectProjection = false;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import java.io.File;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
	private final CamerasSupervisor camerasSupervisor;
	private final ObservableList<ShotEntry> shotEntries;
	private final ImageView background = new ImageView();
	private final List<Shot> shots = new ArrayList<Shot>();
	private final List<Group> targets = new ArrayList<Group>();
	
	private ProgressIndicator progress;
public CanvasManager(Group canvasGroup, Configuration config, CamerasSupervisor
		this.config = config;
		this.camerasSupervisor = camerasSupervisor;
		this.shotEntries = shotEntries;
	
		this.background.setOnMouseClicked((event) -> {
				toggleTargetSelection(Optional.empty());
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
dependencies {
    compile 'com.jcraft:jzlib:1.1.3'
    compile 'com.nineoldandroids:library:2.4.0'
    compile 'com.jcraft:jzlib:1.1.3'
    compile 'org.igniterealtime.smack:smack-android:4.1.0-rc1'
    compile 'org.igniterealtime.smack:smack-core:4.1.0-rc1'
    compile 'org.igniterealtime.smack:smack-tcp:4.1.0-rc1'
    compile 'org.igniterealtime.smack:smack-extensions:4.1.0-rc1'

    googleplayCompile 'com.google.android.gms:play-services-base:6.5.87'
}
import org.jivesoftware.smack.provider.ProviderManager;
import org.jivesoftware.smack.roster.Roster;
import org.jivesoftware.smack.roster.RosterEntry;
import org.jivesoftware.smack.roster.packet.RosterPacket;
import org.jivesoftware.smack.util.StringUtils;
import org.jivesoftware.smackx.caps.packet.CapsExtension;
    public static final String ACTION_CONNECTED = "org.kontalk.action.CONNECTED";

    /**
     * Broadcasted when a presence stanza is received.
     * Send this intent to broadcast presence.
     * Send this intent with type="probe" to request a presence in the roster.
else if (ACTION_REGENERATE_KEYPAIR.equals(action)) {

            else if (ACTION_IMPORT_KEYPAIR.equals(action)) {
                // zip file with keys
                Uri file = (Uri) intent.getParcelableExtra(EXTRA_KEYPACK);
                // passphrase to decrypt files
                String passphrase = intent.getStringExtra(EXTRA_PASSPHRASE);
                beginKeyPairImport(file, passphrase);
else if (ACTION_ROSTER.equals(action) || ACTION_ROSTER_MATCH.equals(action)) {
                }
            }

            else if (ACTION_PRESENCE.equals(action)) {
                if (canConnect && isConnected) {
                    final String id = intent.getStringExtra(EXTRA_PACKET_ID);
else if (ACTION_PRESENCE.equals(action)) {

                    if ("probe".equals(type)) {
                        // probing is actually looking into the roster
                        Roster roster = Roster.getInstanceFor(mConnection);

                        if (to == null) {
                            for (RosterEntry entry : roster.getEntries()) {
else if (ACTION_PUBLICKEY.equals(action)) {
                    }
                    else {
                        // request public keys for the whole roster
                        Collection<RosterEntry> buddies = Roster.getInstanceFor(mConnection).getEntries();
                        for (RosterEntry buddy : buddies) {
                            if (isRosterEntrySubscribed(buddy)) {
                                PublicKeyPublish p = new PublicKeyPublish();
private void discovery() {
        info.setTo(mServer.getNetwork());

        PacketFilter filter = new PacketIDFilter(info.getStanzaId());
        mConnection.addPacketListener(new DiscoverInfoListener(this), filter);
        sendPacket(info);
    }

    /** Requests the roster. */
    private void roster() {
        Roster.getInstanceFor(mConnection);
    }

    /** Sends our initial presence. */
private void sendPendingSubscriptionReplies() {
        c.close();
    }

    private boolean isRosterEntrySubscribed(RosterEntry entry) {
        return (entry != null && (entry.getType() == RosterPacket.ItemType.to || entry.getType() == RosterPacket.ItemType.both) &&
            entry.getStatus() != RosterPacket.ItemStatus.SUBSCRIPTION_PENDING);
public static void requestConnectionStatus(final Context context) {
        context.startService(i);
    }

    public static void requestVCard(final Context context, String to) {
        Intent i = new Intent(context, MessageCenterService.class);
        i.setAction(MessageCenterService.ACTION_VCARD);
else if (MessageCenterService.ACTION_CONNECTED.equals(action)) {
                        mComposeSent = false;
                        // reset available resources list
                        mAvailableResources.clear();

                        // probe presence
                        presenceSubscribe();
                    }
else if (MessageCenterService.ACTION_MESSAGE.equals(action)) {
            IntentFilter filter = new IntentFilter();
            filter.addAction(MessageCenterService.ACTION_PRESENCE);
            filter.addAction(MessageCenterService.ACTION_CONNECTED);
            filter.addAction(MessageCenterService.ACTION_MESSAGE);

            mLocalBroadcastManager.registerReceiver(mPresenceReceiver, filter);

            // request connection status
            MessageCenterService.requestConnectionStatus(getActivity());
        }
    }

buildscript {
allprojects {
    repositories {
        jcenter()
    }
}
Subproject commit 5134766fc35c220acc427d9c146943b6dea80439
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import co.cask.cdap.api.ServiceDiscoverer;
import co.cask.cdap.app.program.Program;
import co.cask.cdap.common.conf.Constants;
import co.cask.cdap.common.discovery.EndpointStrategy;
import co.cask.cdap.common.discovery.RandomEndpointStrategy;
import org.apache.twill.common.Cancellable;
import org.apache.twill.common.Threads;
import org.apache.twill.discovery.Discoverable;
import org.apache.twill.discovery.DiscoveryServiceClient;
import org.apache.twill.discovery.ServiceDiscovered;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.MalformedURLException;
import java.net.URL;
import java.util.NoSuchElementException;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.TimeUnit;
import javax.annotation.Nullable;

/**
 * An abstract implementation of {@link ServiceDiscoverer}.
 */
public abstract class AbstractServiceDiscoverer implements ServiceDiscoverer {

  private static final Logger LOG = LoggerFactory.getLogger(AbstractServiceDiscoverer.class);

  protected String namespaceId;
  protected String applicationId;

public AbstractServiceDiscoverer(Program program) {

  @Override
  public URL getServiceURL(final String applicationId, final String serviceId) {
    ServiceDiscovered serviceDiscovered = getDiscoveryServiceClient().discover(String.format("service.%!s(MISSING).%!s(MISSING).%!s(MISSING)",
                                                                                             namespaceId,
                                                                                             applicationId,
                                                                                             serviceId));
    EndpointStrategy endpointStrategy = new RandomEndpointStrategy(serviceDiscovered);
    Discoverable discoverable = endpointStrategy.pick();
    if (discoverable != null) {
      return createURL(discoverable, applicationId, serviceId);
    }

    final SynchronousQueue<URL> discoverableQueue = new SynchronousQueue<URL>();
    Cancellable discoveryCancel = serviceDiscovered.watchChanges(new ServiceDiscovered.ChangeListener() {
      @Override
      public void onChange(ServiceDiscovered serviceDiscovered) {
        try {
          URL url = createURL(serviceDiscovered.iterator().next(), applicationId, serviceId);
          discoverableQueue.offer(url);
        } catch (NoSuchElementException e) {
          LOG.debug("serviceDiscovered is empty");
        }
      }
    }, Threads.SAME_THREAD_EXECUTOR);

    try {
      URL url = discoverableQueue.poll(1, TimeUnit.SECONDS);
      if (url == null) {
        LOG.debug("Discoverable endpoint not found for appID: {}, serviceID: {}.", applicationId, serviceId);
      }
      return url;
    } catch (InterruptedException e) {
      LOG.error("Exception raised when discovering endpoint for {}/{}", applicationId, serviceId, e);
      return null;
    } finally {
      discoveryCancel.cancel();
    }
  }

  @Override
  public URL getServiceURL(String serviceId) {
    return getServiceURL(applicationId, serviceId);
  }

  private URL createURL(@Nullable Discoverable discoverable, String applicationId, String serviceId) {
    if (discoverable == null) {
      return null;
    }
    String hostName = discoverable.getSocketAddress().getHostName();
    int port = discoverable.getSocketAddress().getPort();
    String path = String.format("http://%!s(MISSING):%!d(MISSING)%!s(MISSING)/namespaces/%!s(MISSING)/apps/%!s(MISSING)/services/%!s(MISSING)/methods/", hostName, port,
                                Constants.Gateway.API_VERSION_3, namespaceId, applicationId, serviceId);
    try {
      return new URL(path);
    } catch (MalformedURLException e) {
      LOG.error("Got exception while creating serviceURL", e);
      return null;
    }
  }

  /**
   * @return the {@link DiscoveryServiceClient} for Service Discovery
   */
package co.cask.cdap.test.internal;

import co.cask.cdap.common.conf.Constants;
import co.cask.cdap.common.discovery.EndpointStrategy;
import co.cask.cdap.common.discovery.RandomEndpointStrategy;
import co.cask.cdap.proto.ServiceInstances;
import co.cask.cdap.test.AbstractServiceManager;
import co.cask.cdap.test.ServiceManager;
import com.google.common.base.Preconditions;
import com.google.common.base.Throwables;
import org.apache.twill.common.Cancellable;
import org.apache.twill.common.Threads;
import org.apache.twill.discovery.Discoverable;
import org.apache.twill.discovery.DiscoveryServiceClient;
import org.apache.twill.discovery.ServiceDiscovered;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.MalformedURLException;
import java.net.URL;
import java.util.NoSuchElementException;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.TimeUnit;
import javax.annotation.Nullable;

/**
 * A default implementation of {@link ServiceManager}.
 */
public class DefaultServiceManager extends AbstractServiceManager {
  private static final Logger LOG = LoggerFactory.getLogger(DefaultServiceManager.class);

  private final DefaultApplicationManager.ProgramId serviceId;
  private final String accountId;
public URL getServiceURL() {

  @Override
  public URL getServiceURL(long timeout, TimeUnit timeoutUnit) {
    ServiceDiscovered serviceDiscovered = discoveryServiceClient.discover(String.format("service.%!s(MISSING).%!s(MISSING).%!s(MISSING)",
                                                                                        accountId,
                                                                                        applicationId,
                                                                                        serviceName));
    EndpointStrategy endpointStrategy = new RandomEndpointStrategy(serviceDiscovered);
    Discoverable discoverable = endpointStrategy.pick();
    if (discoverable != null) {
      return createURL(discoverable, applicationId, serviceName);
    }

    final SynchronousQueue<URL> discoverableQueue = new SynchronousQueue<URL>();
    Cancellable discoveryCancel = serviceDiscovered.watchChanges(new ServiceDiscovered.ChangeListener() {
      @Override
      public void onChange(ServiceDiscovered serviceDiscovered) {
        try {
          URL url = createURL(serviceDiscovered.iterator().next(), applicationId, serviceName);
          discoverableQueue.offer(url);
        } catch (NoSuchElementException e) {
          LOG.debug("serviceDiscovered is empty");
        }
      }
    }, Threads.SAME_THREAD_EXECUTOR);

    try {
      URL url = discoverableQueue.poll(timeout, timeoutUnit);
      if (url == null) {
        LOG.debug("Discoverable endpoint not found for appID: {}, serviceName: {}.", applicationId, serviceName);
      }
      return url;
    } catch (InterruptedException e) {
      LOG.error("Got exception: ", e);
      return null;
    } finally {
      discoveryCancel.cancel();
    }
  }

  private URL createURL(@Nullable Discoverable discoverable, String applicationId, String serviceName) {
    if (discoverable == null) {
      return null;
    }
    String hostName = discoverable.getSocketAddress().getHostName();
    int port = discoverable.getSocketAddress().getPort();
    String path = String.format("http://%!s(MISSING):%!d(MISSING)%!s(MISSING)/namespaces/%!s(MISSING)/apps/%!s(MISSING)/services/%!s(MISSING)/methods/", hostName, port,
                                Constants.Gateway.API_VERSION_3, accountId, applicationId, serviceName);
    try {
      return new URL(path);
    } catch (MalformedURLException e) {
      LOG.error("Got exception while creating serviceURL", e);
      return null;
    }
  }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 */
package rx.internal.operators;

import rx.Observable;
import rx.Producer;
import rx.Subscriber;
public void onNext(T t) {

            @Override
            public void setProducer(final Producer producer) {
                child.setProducer(new Producer() {

                    @Override
                    public void request(long n) {
                        if (n == Long.MAX_VALUE) {
                            // infinite so leave it alone
                            producer.request(n);
                        } else if (n > 0) {
                            // add the skip num to the requested amount, since we'll skip everything and then emit to the buffer downstream
                            producer.request(n + (toSkip - skipped));
                        }
                    }
                });
            }

        };
 */
package rx.internal.operators;

import static org.mockito.Matchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

import org.junit.Test;

import rx.Observable;
import rx.Observer;
import rx.internal.operators.OperatorSkip;

public class OperatorSkipTest {

public void testSkipError() {
        verify(observer, never()).onCompleted();

    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void showFPSWarning(double fps) {
	
	private Label brightnessDiagnosticWarning = null;
	private final static int brightnessDiagnosticLengthMS = 1000;
	private boolean showingBrightnessWarning = false;
	public void showBrightnessWarning() {
		if (!showingBrightnessWarning)
		{
public void run() {

	private Label motionDiagnosticWarning = null;
	private final static int motionDiagnosticLengthMS = 1000;
	private boolean showingMotionDiagnosticWarning = false;
	public void showMotionWarning() {
		if (!showingMotionDiagnosticWarning)
		{
public void startCalibration() {
		arenaStage.getScene().setOnMouseExited(null);
	}
	
	private boolean showingCursorWarning = false;
	@Override
	public void calibrated(CanvasManager feedCanvasManager) {
		setCalibrationMessageVisible(false);
public boolean isCalibrating()
	
	
	private Label manualCalibrationRequestMessage = null; 
	private boolean showingManualCalibrationRequestMessage = false;
	private void showManualCalibrationRequestMessage()
	{
		if (showingManualCalibrationRequestMessage)
private void removeManualCalibrationRequestMessage()
	}

	private Label fullScreenRequestMessage = null; 
	private boolean showingFullScreenRequestMessage = false;
	private void showFullScreenRequest()
	{
		if (showingFullScreenRequestMessage)
private void cancelAutoCalibrationTimer()
	}
	
	private Label autoCalibrationMessage = null; 
	private boolean showingAutoCalibrationMessage = false;
	private void showAutoCalibrationMessage()
	{
		logger.trace("showAutoCalibrationMessage - showingAutoCalibrationMessage {} autoCalibrationMessage {}", showingAutoCalibrationMessage, autoCalibrationMessage);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void run() {
                if (retrying) {
                    listener.onFailure(new MasterNotDiscoveredException());
                } else {
                    clusterService.add(request.masterNodeTimeout(), new TimeoutClusterStateListener() {
                        @Override
                        public void postAdded() {
public String executor() {
                public void handleException(final TransportException exp) {
                    if (exp.unwrapCause() instanceof ConnectTransportException) {
                        // we want to retry here a bit to see if a new master is elected
                        clusterService.add(request.masterNodeTimeout(), new TimeoutClusterStateListener() {
                            @Override
                            public void postAdded() {
                                ClusterState clusterStateV2 = clusterService.state();
                                if (!clusterState.nodes().masterNodeId().equals(clusterStateV2.nodes().masterNodeId())) {
                                    // master changes while adding the listener, try here
                                    clusterService.remove(this);
                                    innerExecute(request, listener, false);
                                }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public CameraManager(Camera webcam, CameraErrorView cameraErrorView, CameraView
		this.cameraView.setCameraManager(this);

		initDetector(new VideoStreamer());
		
		if (NativeShotDetector.loadNativeShotDetector()) {
			logger.debug("Using native shot detection");

public void setFeedResolution(int width, int height) {
		feedWidth = width;
		feedHeight = height;
	}
	
	// Used by click-to-shoot and tests to inject a shot via the shot detector
	public void injectShot(Color color, double x, double y, boolean scaleShot) {
		shotDetector.addShot(color, x, y, scaleShot);
public boolean isDetecting() {
	}

	public void setProjectionBounds(final Bounds projectionBounds) {
		this.projectionBounds = Optional.ofNullable(projectionBounds);
	}

	public void setCropFeedToProjection(final boolean cropFeed) {
private void streamCameraFrames() {
			if (currentFrame == null) continue;
			currentFrame = processFrame(currentFrame);

			if (cropFeedToProjection && projectionBounds.isPresent()) {
				Bounds b = projectionBounds.get();

				currentFrame = currentFrame.getSubimage((int) b.getMinX(), (int) b.getMinY(), (int) b.getWidth(),
						(int) b.getHeight());
			}

			if (recordingShots) {
private void streamCameraFrames() {

	protected BufferedImage processFrame(BufferedImage currentFrame) {
		frameCount++;
		
		if (isAutoCalibrating.get() && ((getFrameCount() %!M(MISSING)ath.min(getFPS(), 3)) == 0)) {
			
			acm.processFrame(currentFrame);
			return currentFrame;
		}

		Mat matFrameBGR = Camera.bufferedImageToMat(currentFrame);
		Mat submatFrameBGR = null;

		if (cameraAutoCalibrated && projectionBounds.isPresent()) {
			if (acm != null) {
				// MUST BE IN BGR pixel format.
				matFrameBGR = acm.undistortFrame(matFrameBGR);
			}

			submatFrameBGR = matFrameBGR.submat((int) projectionBounds.get().getMinY(),
					(int) projectionBounds.get().getMaxY(), (int) projectionBounds.get().getMinX(),
					(int) projectionBounds.get().getMaxX());

			if (recordingCalibratedArea) {
				BufferedImage image = ConverterFactory.convertToType(Camera.matToBufferedImage(submatFrameBGR),
protected BufferedImage processFrame(BufferedImage currentFrame) {
			}
		}

		if ((isLimitingDetectionToProjection() || isCroppingFeedToProjection()) && getProjectionBounds().isPresent()) {
			if (submatFrameBGR == null) submatFrameBGR = matFrameBGR.submat((int) projectionBounds.get().getMinY(),
					(int) projectionBounds.get().getMaxY(), (int) projectionBounds.get().getMinX(),
					(int) projectionBounds.get().getMaxX());

			shotDetector.processFrame(submatFrameBGR, isDetecting.get());
		} else {
protected void autoCalibrateSuccess(Bounds arenaBounds, Optional<Dimension2D> pa
		if (isAutoCalibrating.get() && cameraCalibrationListener != null) {
			isAutoCalibrating.set(false);

			logger.debug("autoCalibrateSuccess {} {} {} {} paper {}", (int) arenaBounds.getMinX(), (int) arenaBounds.getMinY(),
					(int) arenaBounds.getWidth(), (int) arenaBounds.getHeight(), paperDims.isPresent());

			cameraAutoCalibrated = true;
			cameraCalibrationListener.calibrate(arenaBounds, paperDims, false);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 */
package de.cismet.cids.custom.reports.verdis;

import org.apache.log4j.Logger;

import org.krysalis.barcode4j.BarcodeDimension;

import java.text.NumberFormat;

import de.cismet.cids.dynamics.CidsBean;

import de.cismet.cismap.commons.BoundingBox;
import de.cismet.cismap.commons.Crs;
import de.cismet.cismap.commons.XBoundingBox;
import de.cismet.cismap.commons.gui.MappingComponent;
import de.cismet.cismap.commons.gui.layerwidget.ActiveLayerModel;
import de.cismet.cismap.commons.raster.wms.simple.SimpleWMS;
public boolean isReadyToProceed() {
    /**
     * DOCUMENT ME!
     *
     * @param  map  DOCUMENT ME!
     */
    protected abstract void loadFeaturesInMap(final MappingComponent map);

    /**
     * DOCUMENT ME!
     */
    protected void loadMap() {
        final SimpleWMS s = new SimpleWMS(new SimpleWmsGetMapUrl(

                    // "http://s10221.wuppertal-intra.de:7098/alkis/services?&VERSION=1.1.1&REQUEST=GetMap&BBOX=<cismap:boundingBox>&WIDTH=<cismap:width>&HEIGHT=<cismap:height>&SRS=EPSG:31466&FORMAT=image/png&TRANSPARENT=TRUE&BGCOLOR=0xF0F0F0&EXCEPTIONS=application/vnd.ogc.se_xml&LAYERS=algw&STYLES=default"));
                    "http://S102w484:8399/arcgis/services/WuNDa-ALKIS-Hintergrund/MapServer/WMSServer?&VERSION=1.1.1&REQUEST=GetMap&BBOX=<cismap:boundingBox>&WIDTH=<cismap:width>&HEIGHT=<cismap:height>&SRS=EPSG:31466&FORMAT=image/png&TRANSPARENT=FALSE&BGCOLOR=0xF0F0F0&EXCEPTIONS=application/vnd.ogc.se_xml&LAYERS=2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19&STYLES=default,default,default,default,default,default,default,default,default,default,default,default,default,default,default,default,default,default"));
        final MappingComponent map = new MappingComponent(false);

        final ActiveLayerModel mappingModel = new ActiveLayerModel();
        s.addRetrievalListener(new RetrievalListener() {

                @Override
                public void retrievalStarted(final RetrievalEvent e) {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug("start map retrieval for feb report");
                    }
                }

                @Override
                public void retrievalProgress(final RetrievalEvent e) {
                }

                @Override
                public void retrievalComplete(final RetrievalEvent e) {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug("map retrieval for feb report complete");
                    }
                    new Thread() {

                        @Override
                        public void run() {
                            try {
                                try {
                                    Thread.sleep(500);
                                } catch (InterruptedException ex) {
                                }
                                final java.awt.Image img = map.getCamera()
                                            .toImage(map.getWidth(), map.getHeight(), new Color(255, 255, 255, 0));
                                final BufferedImage bi = new BufferedImage(
                                        img.getWidth(null),
                                        img.getHeight(null),
                                        BufferedImage.TYPE_INT_RGB);
                                final Graphics2D g2 = bi.createGraphics();
                                // Draw img into bi so we can write it to file.
                                g2.drawImage(img, 0, 0, null);
                                g2.dispose();
                                if (LOG.isDebugEnabled()) {
                                    LOG.debug("bi size (h/w): " + bi.getHeight() + "/" + bi.getWidth());
                                }
                                mapImage = bi;
                            } catch (Exception ex) {
                                LOG.error("error while creating mapImage", ex);
                            }
                        }
                    }.start();
                }

                @Override
                public void retrievalAborted(final RetrievalEvent e) {
                    LOG.fatal(
                        "map retrieval for feb report aborted: "
                                + e.getErrorType() // NOI18N
                                + " Errors: "      // NOI18N
                                + e.getErrors()
                                + " Cause: "
                                + e.getRetrievedObject()); // NOI18N
//                    mapError = true;
                }

                @Override
                public void retrievalError(final RetrievalEvent e) {
                    LOG.fatal("map retrieval error for feb report: " + e.getErrorType() + " " + e.toString());
                    mapError = true;
                }
            });
        // disable internal layer widget
        map.setInternalLayerWidgetAvailable(false);
        mappingModel.setSrs(new Crs("EPSG:31466", "", "", true, true));
        mappingModel.addHome(new XBoundingBox(
                579146.311157169,
                5679930.726695932,
                2579645.8713909937,
                5680274.612347874,
                "EPSG:31466",
                true));
        // set the model
        map.setMappingModel(mappingModel);
        final int mapDPI = Integer.parseInt(NbBundle.getMessage(
                    EBReportBean.class,
                    "FEBReportBean.mapDPI"));
        final int factor = mapDPI / 72;
        map.setSize(mapWidth * factor, mapHeight * factor);
        // initial positioning of the map
        map.setAnimationDuration(0);
        map.gotoInitialBoundingBox();

        map.unlock();

        loadFeaturesInMap(map);

        final double oldScale = map.getScaleDenominator();
        final BoundingBox bbox = map.getBoundingBoxFromScale(oldScale);
        final double realWorldWidthInMeter = bbox.getWidth();

        map.zoomToFeatureCollection();
        final double newScale;

        if (scaleDenominator != null) {
            newScale = scaleDenominator;
        } else {
            final double roundScale = getReportScaleDenom(map.getBoundingBoxFromScale(map.getScaleDenominator())
                            .getWidth());
            newScale = Math.round((roundScale / 100) + 0.5d) * 100;
        }
        map.gotoBoundingBoxWithHistory(map.getBoundingBoxFromScale(
                getMapScaleDenom(newScale, oldScale, realWorldWidthInMeter)));

        // lets calculate the correct scale for the printed report
        final double so = getReportScaleDenom(map.getBoundingBoxFromScale(map.getScaleDenominator()).getWidth());
        scale = "1:" + NumberFormat.getIntegerInstance().format(so);

        map.setInteractionMode(MappingComponent.SELECT);
        mappingModel.addLayer(s);
    }

    /**
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;

import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedList;

import de.cismet.cids.dynamics.CidsBean;

import de.cismet.cismap.commons.features.DefaultXStyledFeature;
import de.cismet.cismap.commons.gui.MappingComponent;
import de.cismet.cismap.commons.gui.piccolo.CustomFixedWidthStroke;
import de.cismet.cismap.commons.gui.piccolo.FeatureAnnotationSymbol;
public boolean isReadyToProceed() {
    }

    @Override
    protected void loadFeaturesInMap(final MappingComponent map) {
        final List<CidsBean> flaechen = (List<CidsBean>)getKassenzeichenBean().getProperty(
                KassenzeichenPropertyConstants.PROP__FLAECHEN);
        final FlaecheFeatureRenderer fr = new FlaecheFeatureRenderer();
protected void loadFeaturesInMap(final MappingComponent map) {
            }
            final Geometry g = (Geometry)b.getProperty(FlaechePropertyConstants.PROP__FLAECHENINFO + "."
                            + FlaecheninfoPropertyConstants.PROP__GEOMETRIE + "." + "geo_field");
            final String flaechenbez = (String)b.getProperty(FlaechePropertyConstants.PROP__FLAECHENBEZEICHNUNG);
            final DefaultXStyledFeature dsf = new DefaultXStyledFeature(
                    null,
                    "",
                    "",
                    null,
                    new CustomFixedWidthStroke(2f, map));
            dsf.setGeometry(g);
            final Color c = (Color)fr.getFillingStyle();
            final Color c2;
            c2 = new Color(c.getRed(), c.getGreen(), c.getBlue(), FLAECHE_TRANSPARENCY);
            dsf.setFillingPaint(c2);
            dsf.setLinePaint(Color.RED);
            map.getFeatureCollection().addFeature(dsf);
        }
        for (final CidsBean b : flaechen) {
            try {
protected void loadFeaturesInMap(final MappingComponent map) {
                        "",
                        "",
                        null,
                        new CustomFixedWidthStroke(2f, map));
                dsf.setGeometry(xg);
                dsf.setPrimaryAnnotation(flaechenbez);
                dsf.setPrimaryAnnotationJustification(JLabel.RIGHT_ALIGNMENT);
                dsf.setPrimaryAnnotationPaint(Color.decode("#1a008b"));
                final BufferedImage bi = new BufferedImage(10, 10, BufferedImage.TYPE_INT_ARGB);
                // final Graphics2D graphics = (Graphics2D)bi.getGraphics();
                // graphics.setColor(Color.orange);
                // graphics.fillOval(0, 0, 10, 10);
                final FeatureAnnotationSymbol symb = new FeatureAnnotationSymbol(bi);
                symb.setSweetSpotX(0.5);
                symb.setSweetSpotY(0.5);
                dsf.setIconImage(new ImageIcon(bi));
                dsf.setAutoScale(true);
                dsf.setPrimaryAnnotationFont(new Font("SansSerif", Font.PLAIN, (int)((fontSize * 1.5) + 0.5)));
                dsf.setFeatureAnnotationSymbol(symb);
                map.getFeatureCollection().addFeature(dsf);

                final PNode annotationNode = map.getPFeatureHM().get(dsf).getPrimaryAnnotationNode();
                final PBounds bounds = annotationNode.getBounds();
                bounds.x = -20;
                bounds.y = -20;
                annotationNode.setBounds(bounds);
            }
        }
    }

    //~ Inner Classes ----------------------------------------------------------
import java.awt.Color;
import java.awt.Font;

import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;

import de.cismet.cids.dynamics.CidsBean;

import de.cismet.cismap.commons.features.DefaultXStyledFeature;
import de.cismet.cismap.commons.gui.MappingComponent;
import de.cismet.cismap.commons.gui.piccolo.CustomFixedWidthStroke;

public boolean isReadyToProceed() {
    }

    @Override
    protected void loadFeaturesInMap(final MappingComponent map) {
        final FrontFeatureRenderer fr = new FrontFeatureRenderer();
        final Collection<CidsBean> fronten = (List<CidsBean>)getKassenzeichenBean().getProperty(
                KassenzeichenPropertyConstants.PROP__FRONTEN);
protected void loadFeaturesInMap(final MappingComponent map) {
                final Color c2;
                c2 = new Color(c.getRed(), c.getGreen(), c.getBlue(), FRONT_TRANSPARENCY);
                dsf.setLinePaint(c2);
                final CustomFixedWidthStroke ls2 = new CustomFixedWidthStroke(25, map);
                dsf.setLineSytle(ls2);
                dsf.setPrimaryAnnotation(Integer.toString(frontNummer));
                dsf.setPrimaryAnnotationPaint(Color.RED);
                dsf.setAutoScale(true);
                dsf.setPrimaryAnnotationFont(new Font("SansSerif", Font.PLAIN, fontSize));
                map.getFeatureCollection().addFeature(dsf);
            }
        }
    }

    /**
private void initComponents() {
        jPanel1 = new javax.swing.JPanel();
        jToolBar1 = new javax.swing.JToolBar();
        cmdMemory = new javax.swing.JButton();
        exceptionNotificationStatusPanel = new de.cismet.tools.gui.exceptionnotification.ExceptionNotificationStatusPanel();
        tobVerdis = new javax.swing.JToolBar();
        cmdEditMode = new javax.swing.JButton();
        cmdCancel = new javax.swing.JButton();
private void initComponents() {
        cmdTest.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        cmdTest.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        cmdTest.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdTestActionPerformed(evt);
            }
        });

        cmdTest2.setText("Test Clipboard Load");
        cmdTest2.setFocusable(false);
        cmdTest2.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        cmdTest2.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        cmdTest2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdTest2ActionPerformed(evt);
            }
        });

        simpleMemoryMonitoringToolbarWidget1.startTimer();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle(getTitle());
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowOpened(java.awt.event.WindowEvent evt) {
                formWindowOpened(evt);
            }
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
            public void windowClosed(java.awt.event.WindowEvent evt) {
                formWindowClosed(evt);
            }
        });
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyTyped(java.awt.event.KeyEvent evt) {
                formKeyTyped(evt);
            }
            public void keyPressed(java.awt.event.KeyEvent evt) {
                formKeyPressed(evt);
            }
            public void keyReleased(java.awt.event.KeyEvent evt) {
                formKeyReleased(evt);
            }
        });

        jPanel1.setLayout(new java.awt.GridBagLayout());

public void keyReleased(java.awt.event.KeyEvent evt) {
        cmdMemory.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        cmdMemory.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        cmdMemory.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdMemoryActionPerformed(evt);
            }
        });
        jToolBar1.add(cmdMemory);

        exceptionNotificationStatusPanel.setMaximumSize(new java.awt.Dimension(34, 34));
public void actionPerformed(java.awt.event.ActionEvent evt) {
        tobVerdis.setMinimumSize(new java.awt.Dimension(667, 33));
        tobVerdis.setPreferredSize(new java.awt.Dimension(691, 35));

        cmdEditMode.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/toolbar/editmode.png"))); // NOI18N
        cmdEditMode.setToolTipText("Editormodus");
        cmdEditMode.setEnabled(false);
        cmdEditMode.setFocusPainted(false);
        cmdEditMode.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdEditModeActionPerformed(evt);
            }
        });
        tobVerdis.add(cmdEditMode);

        cmdCancel.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/toolbar/cancel.png"))); // NOI18N
        cmdCancel.setToolTipText("Änderungen abbrechen");
        cmdCancel.setFocusPainted(false);
        cmdCancel.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdCancelActionPerformed(evt);
            }
        });
        tobVerdis.add(cmdCancel);

        cmdOk.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/toolbar/ok.png"))); // NOI18N
        cmdOk.setToolTipText("Änderungen annehmen");
        cmdOk.setFocusPainted(false);
        cmdOk.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdOkActionPerformed(evt);
            }
        });
        tobVerdis.add(cmdOk);

        cmdDeleteKassenzeichen.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/toolbar/deleteKassenzeichen.png"))); // NOI18N
        cmdDeleteKassenzeichen.setToolTipText("Kassenzeichen löschen");
        cmdDeleteKassenzeichen.setEnabled(false);
        cmdDeleteKassenzeichen.setFocusPainted(false);
        cmdDeleteKassenzeichen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdDeleteKassenzeichenActionPerformed(evt);
            }
        });
        tobVerdis.add(cmdDeleteKassenzeichen);

        cmdNewKassenzeichen.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/toolbar/newKassenzeichen.png"))); // NOI18N
        cmdNewKassenzeichen.setToolTipText("Neues Kassenzeichen");
        cmdNewKassenzeichen.setFocusPainted(false);
        cmdNewKassenzeichen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdNewKassenzeichenActionPerformed(evt);
            }
        });
        tobVerdis.add(cmdNewKassenzeichen);

        cmdNextKassenzeichenWithoutGeom.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/toolbar/next_kassenzeichen_without_geometries.png"))); // NOI18N
        cmdNextKassenzeichenWithoutGeom.setToolTipText("Nächstes Kassenzeichen ohne allgemeine Geometrien");
        cmdNextKassenzeichenWithoutGeom.setFocusable(false);
        cmdNextKassenzeichenWithoutGeom.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        cmdNextKassenzeichenWithoutGeom.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        cmdNextKassenzeichenWithoutGeom.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdNextKassenzeichenWithoutGeomActionPerformed(evt);
            }
        });
        tobVerdis.add(cmdNextKassenzeichenWithoutGeom);

        cmdSAPCheck.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/toolbar/goto_kassenzeichen_sap.png"))); // NOI18N
        cmdSAPCheck.setToolTipText("SAP Check");
        cmdSAPCheck.setContentAreaFilled(false);
        cmdSAPCheck.setFocusable(false);
        cmdSAPCheck.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        cmdSAPCheck.setSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/toolbar/goto_kassenzeichen_sap_selected.png"))); // NOI18N
        cmdSAPCheck.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        cmdSAPCheck.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdSAPCheckActionPerformed(evt);
            }
        });
        tobVerdis.add(cmdSAPCheck);

        jSeparator6.setOrientation(javax.swing.SwingConstants.VERTICAL);
        jSeparator6.setMaximumSize(new java.awt.Dimension(2, 32767));
        tobVerdis.add(jSeparator6);

        cmdCut.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/toolbar/cutFl.png"))); // NOI18N
        cmdCut.setToolTipText("Fläche ausschneiden");
        cmdCut.setEnabled(false);
        cmdCut.setFocusPainted(false);
        cmdCut.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdCutActionPerformed(evt);
            }
        });
        tobVerdis.add(cmdCut);

        cmdCopy.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/toolbar/copyFl.png"))); // NOI18N
        cmdCopy.setToolTipText("Fläche kopieren (Teileigentum erzeugen)");
        cmdCopy.setEnabled(false);
        cmdCopy.setFocusPainted(false);
        cmdCopy.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdCopyActionPerformed(evt);
            }
        });
        tobVerdis.add(cmdCopy);

        cmdPaste.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/toolbar/pasteFl.png"))); // NOI18N
        cmdPaste.setToolTipText("Fläche einfügen");
        cmdPaste.setEnabled(false);
        cmdPaste.setFocusPainted(false);
        cmdPaste.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdPasteActionPerformed(evt);
            }
        });
        tobVerdis.add(cmdPaste);

        jSeparator4.setOrientation(javax.swing.SwingConstants.VERTICAL);
        jSeparator4.setMaximumSize(new java.awt.Dimension(2, 32767));
        tobVerdis.add(jSeparator4);

        cmdRefreshEnumeration.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/toolbar/refreshEnum.png"))); // NOI18N
        cmdRefreshEnumeration.setToolTipText("Alle Flächen neu nummerieren");
        cmdRefreshEnumeration.setEnabled(false);
        cmdRefreshEnumeration.setFocusPainted(false);
        cmdRefreshEnumeration.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdRefreshEnumerationActionPerformed(evt);
            }
        });
        tobVerdis.add(cmdRefreshEnumeration);

        cmdRecalculateArea.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/toolbar/recalculateArea.png"))); // NOI18N
        cmdRecalculateArea.setToolTipText("Neuberechnung der Flächen");
        cmdRecalculateArea.setFocusPainted(false);
        cmdRecalculateArea.setFocusable(false);
        cmdRecalculateArea.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        cmdRecalculateArea.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        cmdRecalculateArea.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdRecalculateAreaActionPerformed(evt);
            }
        });
        tobVerdis.add(cmdRecalculateArea);
        tobVerdis.add(jSeparator12);

        jSeparator7.setOrientation(javax.swing.SwingConstants.VERTICAL);
        jSeparator7.setMaximumSize(new java.awt.Dimension(2, 32767));
        tobVerdis.add(jSeparator7);

        cmdAdd.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/titlebars/add.png"))); // NOI18N
        cmdAdd.setEnabled(false);
        cmdAdd.setFocusable(false);
        cmdAdd.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        cmdAdd.setRolloverIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/titlebars/add2.png"))); // NOI18N
        cmdAdd.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        cmdAdd.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdAddActionPerformed(evt);
            }
        });
        tobVerdis.add(cmdAdd);

        cmdRemove.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/titlebars/remove.png"))); // NOI18N
        cmdRemove.setEnabled(false);
        cmdRemove.setFocusable(false);
        cmdRemove.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        cmdRemove.setRolloverIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/titlebars/remove2.png"))); // NOI18N
        cmdRemove.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        cmdRemove.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdRemoveActionPerformed(evt);
            }
        });
        tobVerdis.add(cmdRemove);

        cmdUndo.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/titlebars/undo.png"))); // NOI18N
        cmdUndo.setEnabled(false);
        cmdUndo.setFocusable(false);
        cmdUndo.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        cmdUndo.setRolloverIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/titlebars/undo2.png"))); // NOI18N
        cmdUndo.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        cmdUndo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdUndoActionPerformed(evt);
            }
        });
        tobVerdis.add(cmdUndo);
        tobVerdis.add(jSeparator13);

        cmdPdf.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/toolbar/pdf.png"))); // NOI18N
        cmdPdf.setToolTipText("Drucken");
        cmdPdf.setFocusPainted(false);
        cmdPdf.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdPdfActionPerformed(evt);
            }
        });
        tobVerdis.add(cmdPdf);

        cmdWorkflow.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/toolbar/workflow.png"))); // NOI18N
        cmdWorkflow.setToolTipText("Workflow");
        cmdWorkflow.setEnabled(false);
        cmdWorkflow.setFocusPainted(false);
        cmdWorkflow.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdWorkflowActionPerformed(evt);
            }
        });
        tobVerdis.add(cmdWorkflow);

        jSeparator3.setOrientation(javax.swing.SwingConstants.VERTICAL);
        jSeparator3.setMaximumSize(new java.awt.Dimension(2, 32767));
        tobVerdis.add(jSeparator3);

        cmdInfo.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/toolbar/info.png"))); // NOI18N
        cmdInfo.setToolTipText("Versionsanzeige");
        cmdInfo.setFocusPainted(false);
        cmdInfo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdInfoActionPerformed(evt);
            }
        });
        tobVerdis.add(cmdInfo);

        jSeparator8.setOrientation(javax.swing.SwingConstants.VERTICAL);
        jSeparator8.setMaximumSize(new java.awt.Dimension(2, 32767));
        tobVerdis.add(jSeparator8);

        cmdLagisCrossover.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/toolbar/lagisCrossover.png"))); // NOI18N
        cmdLagisCrossover.setToolTipText("Öffne zugehöriges Flurstück in LagIS");
        cmdLagisCrossover.setFocusPainted(false);
        cmdLagisCrossover.setFocusable(false);
        cmdLagisCrossover.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        cmdLagisCrossover.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        cmdLagisCrossover.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdLagisCrossoverActionPerformed(evt);
            }
        });
        tobVerdis.add(cmdLagisCrossover);

        btnHistory.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/toolbar/history.png"))); // NOI18N
        btnHistory.setToolTipText("öffne Kassenzeichen-Verlauf");
        btnHistory.setFocusPainted(false);
        btnHistory.setFocusable(false);
        btnHistory.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        btnHistory.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        btnHistory.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnHistoryActionPerformed(evt);
            }
        });
        tobVerdis.add(btnHistory);

        btnTimeRecovery.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/toolbar/recovery.png"))); // NOI18N
        btnTimeRecovery.setToolTipText("Kassenzeichen-Wiederherstellung");
        btnTimeRecovery.setFocusPainted(false);
        btnTimeRecovery.setFocusable(false);
        btnTimeRecovery.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        btnTimeRecovery.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        btnTimeRecovery.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnTimeRecoveryActionPerformed(evt);
            }
        });
        tobVerdis.add(btnTimeRecovery);
        try {
            btnTimeRecovery.setVisible(SessionManager.getConnection().getConfigAttr(SessionManager.getSession().getUser(), "grundis.timerecovery.dialog") != null);
        } catch (final Exception ex) {
            LOG.error("error while checking for grundis.timerecovery.dialog", ex);
            btnTimeRecovery.setVisible(false);
        }

        cmdDownloads.setAction(new DownloadManagerAction(this));
        cmdDownloads.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/toolbar/download.png"))); // NOI18N
        cmdDownloads.setFocusPainted(false);
        cmdDownloads.setFocusable(false);
        cmdDownloads.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        cmdDownloads.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        tobVerdis.add(cmdDownloads);

        cmdFortfuehrung.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/toolbar/fortfuehrung.png"))); // NOI18N
        cmdFortfuehrung.setToolTipText("Fortführung");
        cmdFortfuehrung.setFocusable(false);
        cmdFortfuehrung.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        cmdFortfuehrung.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        cmdFortfuehrung.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdFortfuehrungActionPerformed(evt);
            }
        });
        try {
            cmdFortfuehrung.setVisible(SessionManager.getConnection().getConfigAttr(SessionManager.getSession().getUser(), "grundis.fortfuehrungsanlaesse.dialog") != null);
        } catch (final Exception ex) {
            LOG.error("error while checking for grundis.fortfuehrungsanlaesse.dialog", ex);
            cmdFortfuehrung.setVisible(false);
        }
        tobVerdis.add(cmdFortfuehrung);

        cmdGrundbuchblattSuche.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/toolbar/BPlan.png"))); // NOI18N
        cmdGrundbuchblattSuche.setToolTipText("Kassenzeichensuche über Buchungsblatt");
        cmdGrundbuchblattSuche.setFocusPainted(false);
        cmdGrundbuchblattSuche.setFocusable(false);
        cmdGrundbuchblattSuche.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        cmdGrundbuchblattSuche.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        cmdGrundbuchblattSuche.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdGrundbuchblattSucheActionPerformed(evt);
            }
        });
        tobVerdis.add(cmdGrundbuchblattSuche);

        cmdArbeitspakete.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/workdone.png"))); // NOI18N
        cmdArbeitspakete.setToolTipText("Arbeitspakete verwalten");
        cmdArbeitspakete.setFocusable(false);
        cmdArbeitspakete.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        cmdArbeitspakete.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        cmdArbeitspakete.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdArbeitspaketeActionPerformed(evt);
            }
        });
        try {
            cmdFortfuehrung.setVisible(SessionManager.getConnection().getConfigAttr(SessionManager.getSession().getUser(), "grundis.fortfuehrungsanlaesse.dialog") != null);
        } catch (final Exception ex) {
            LOG.error("error while checking for grundis.fortfuehrungsanlaesse.dialog", ex);
            cmdFortfuehrung.setVisible(false);
        }
        tobVerdis.add(cmdArbeitspakete);
        try {
            cmdArbeitspakete.setVisible(SessionManager.getConnection().getConfigAttr(SessionManager.getSession().getUser(), "grundis.arbeitspaketemanager.dialog") != null);
        } catch (final Exception ex) {
            LOG.error("error while checking for grundis.fortfuehrungsanlaesse.dialog", ex);
            cmdArbeitspakete.setVisible(false);
        }

        cmdAbfrageeditor.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/gui/table-export.png"))); // NOI18N
        cmdAbfrageeditor.setToolTipText("Abfragen-Export (nach CSV)");
        cmdAbfrageeditor.setFocusable(false);
        cmdAbfrageeditor.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        cmdAbfrageeditor.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        cmdAbfrageeditor.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdAbfrageeditorActionPerformed(evt);
            }
        });
        try {
            cmdFortfuehrung.setVisible(SessionManager.getConnection().getConfigAttr(SessionManager.getSession().getUser(), "grundis.fortfuehrungsanlaesse.dialog") != null);
        } catch (final Exception ex) {
            LOG.error("error while checking for grundis.abfragennachcsv.dialog", ex);
            cmdFortfuehrung.setVisible(false);
        }
        tobVerdis.add(cmdAbfrageeditor);
        try {
            cmdAbfrageeditor.setVisible(SessionManager.getConnection().getConfigAttr(SessionManager.getSession().getUser(), "grundis.arbeitspaketemanager.dialog") != null);
        } catch (final Exception ex) {
            LOG.error("error while checking for grundis.abfragennachcsv.dialog", ex);
            cmdAbfrageeditor.setVisible(false);
        }

        cmdVeranlagungsdatei.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/gui/reports-stack.png"))); // NOI18N
        cmdVeranlagungsdatei.setToolTipText("Erzeugung Veranlagungsdatei planen");
        cmdVeranlagungsdatei.setFocusable(false);
        cmdVeranlagungsdatei.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        cmdVeranlagungsdatei.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        cmdVeranlagungsdatei.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdVeranlagungsdateiActionPerformed(evt);
            }
        });
        tobVerdis.add(cmdVeranlagungsdatei);
        try {
            cmdVeranlagungsdatei.setVisible(SessionManager.getConnection().getConfigAttr(SessionManager.getSession().getUser(), "csa://veranlagungsdatei") != null);
        } catch (final Exception ex) {
            LOG.error("error while checking for csa://veranlagungsdatei", ex);
            cmdVeranlagungsdatei.setVisible(false);
        }

        cmdOpenInD3.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/toolbar/d.3.png"))); // NOI18N
        cmdOpenInD3.setToolTipText("in d.3 öffnen");
        cmdOpenInD3.setFocusPainted(false);
        cmdOpenInD3.setFocusable(false);
        cmdOpenInD3.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        cmdOpenInD3.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        cmdOpenInD3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdOpenInD3ActionPerformed(evt);
            }
        });
        tobVerdis.add(cmdOpenInD3);

        gridBagConstraints = new java.awt.GridBagConstraints();
public void actionPerformed(java.awt.event.ActionEvent evt) {
        menFile.setText("Datei");
        menFile.add(jSeparator9);

        mniSaveLayout.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK));
        mniSaveLayout.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/titlebars/layout.png"))); // NOI18N
        mniSaveLayout.setText("Aktuelles Layout speichern");
        mniSaveLayout.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mniSaveLayoutActionPerformed(evt);
            }
        });
        menFile.add(mniSaveLayout);

        mniLoadLayout.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_MASK));
        mniLoadLayout.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/titlebars/layout.png"))); // NOI18N
        mniLoadLayout.setText("Layout laden");
        mniLoadLayout.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mniLoadLayoutActionPerformed(evt);
            }
        });
        menFile.add(mniLoadLayout);
        menFile.add(jSeparator10);

        mniClose.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_F4, java.awt.event.InputEvent.ALT_MASK));
        mniClose.setText("Beenden");
        mniClose.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnuExitActionPerformed(evt);
            }
        });
        menFile.add(mniClose);

        jMenuBar1.add(menFile);
public void actionPerformed(java.awt.event.ActionEvent evt) {

        mnuEditMode.setText("In den Editormodus wechseln");
        mnuEditMode.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnuEditModeActionPerformed(evt);
            }
        });
        menEdit.add(mnuEditMode);

        mnuNewKassenzeichen.setText("Neues Kassenzeichen");
        mnuNewKassenzeichen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnuNewKassenzeichenActionPerformed(evt);
            }
        });
        menEdit.add(mnuNewKassenzeichen);

        mnuRenameCurrentKZ.setText("Aktuelles Kassenzeichen umbenennen");
        mnuRenameCurrentKZ.setEnabled(false);
        mnuRenameCurrentKZ.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnuRenameCurrentKZActionPerformed(evt);
            }
        });
        menEdit.add(mnuRenameCurrentKZ);

        mnuRenameAnyKZ.setText("Beliebiges Kassenzeichen umbenennen");
        mnuRenameAnyKZ.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnuRenameAnyKZActionPerformed(evt);
            }
        });
        menEdit.add(mnuRenameAnyKZ);

        jMenuBar1.add(menEdit);

        menExtras.setMnemonic('E');
        menExtras.setText("Extras");

        mniOptions.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/titlebars/tooloptions.png"))); // NOI18N
        mniOptions.setText("Optionen");
        mniOptions.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mniOptionsActionPerformed(evt);
            }
        });
        menExtras.add(mniOptions);
        menExtras.add(sepOptions);

        mnuChangeUser.setText("User wechseln");
        mnuChangeUser.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnuChangeUserActionPerformed(evt);
            }
        });
        menExtras.add(mnuChangeUser);

        jMenuItem1.setText("WindowManagementTool");
        jMenuItem1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem1ActionPerformed(evt);
            }
        });
        menExtras.add(jMenuItem1);

        jMenuBar1.add(menExtras);

        menWindows.setMnemonic('F');
        menWindows.setText("Fenster");
        menWindows.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menWindowsActionPerformed(evt);
            }
        });

        mniKassenzeichen.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_1, java.awt.event.InputEvent.CTRL_MASK));
        mniKassenzeichen.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/titlebars/kassenzeichen.png"))); // NOI18N
        mniKassenzeichen.setMnemonic('L');
        mniKassenzeichen.setText("Kassenzeichen");
        mniKassenzeichen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mniKassenzeichenActionPerformed(evt);
            }
        });
        menWindows.add(mniKassenzeichen);

        mniKassenzeichen1.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_2, java.awt.event.InputEvent.CTRL_MASK));
        mniKassenzeichen1.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/titlebars/kassenzeichen.png"))); // NOI18N
        mniKassenzeichen1.setMnemonic('L');
        mniKassenzeichen1.setText("Kassenzeichen-Liste");
        mniKassenzeichen1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mniKassenzeichen1ActionPerformed(evt);
            }
        });
        menWindows.add(mniKassenzeichen1);

        mniSummen.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_3, java.awt.event.InputEvent.CTRL_MASK));
        mniSummen.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/titlebars/sum.png"))); // NOI18N
        mniSummen.setMnemonic('C');
        mniSummen.setText("Summen");
        mniSummen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mniSummenActionPerformed(evt);
            }
        });
        menWindows.add(mniSummen);

        mniKanalanschluss.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_4, java.awt.event.InputEvent.CTRL_MASK));
        mniKanalanschluss.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/titlebars/pipe.png"))); // NOI18N
        mniKanalanschluss.setMnemonic('F');
        mniKanalanschluss.setText("Kanalanschluss");
        mniKanalanschluss.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mniKanalanschlussActionPerformed(evt);
            }
        });
        menWindows.add(mniKanalanschluss);
        menWindows.add(jSeparator11);

        mniKarte.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_7, java.awt.event.InputEvent.CTRL_MASK));
        mniKarte.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/titlebars/flaechen.png"))); // NOI18N
        mniKarte.setMnemonic('S');
        mniKarte.setText("Karte");
        mniKarte.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mniKarteActionPerformed(evt);
            }
        });
        menWindows.add(mniKarte);

        mniTabelle.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_8, java.awt.event.InputEvent.CTRL_MASK));
        mniTabelle.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/titlebars/flaechen.png"))); // NOI18N
        mniTabelle.setMnemonic('T');
        mniTabelle.setText("Tabellenansicht");
        mniTabelle.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mniTabelleActionPerformed(evt);
            }
        });
        menWindows.add(mniTabelle);

        mniDetails.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_9, java.awt.event.InputEvent.CTRL_MASK));
        mniDetails.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/titlebars/flaechen.png"))); // NOI18N
        mniDetails.setMnemonic('D');
        mniDetails.setText("Details");
        mniDetails.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mniDetailsActionPerformed(evt);
            }
        });
        menWindows.add(mniDetails);

        mniResetWindowLayout.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_R, java.awt.event.InputEvent.CTRL_MASK));
        mniResetWindowLayout.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/verdis/res/images/titlebars/layout.png"))); // NOI18N
        mniResetWindowLayout.setText("Fensteranordnung zurücksetzen");
        mniResetWindowLayout.setToolTipText("Standard Fensteranordnung wiederherstellen");
        mniResetWindowLayout.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mniResetWindowLayoutActionPerformed(evt);
            }
        });
        menWindows.add(mniResetWindowLayout);

        jMenuBar1.add(menWindows);
public void actionPerformed(java.awt.event.ActionEvent evt) {
        mnuInfo.setMnemonic('I');
        mnuInfo.setText("Info");
        mnuInfo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnuInfoActionPerformed(evt);
            }
        });
        menHelp.add(mnuInfo);

        jMenuBar1.add(menHelp);
public void actionPerformed(java.awt.event.ActionEvent evt) {

        setSize(new java.awt.Dimension(1261, 868));
        setLocationRelativeTo(null);
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Inserting Docking Window functionalty (Sebastian) 24.07.07.
     *
     * @param  evt  DOCUMENT ME!
     */
    private void menWindowsActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menWindowsActionPerformed
// TODO add your handling code here:
    }//GEN-LAST:event_menWindowsActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void mniResetWindowLayoutActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mniResetWindowLayoutActionPerformed
        setupDefaultLayout();
    }//GEN-LAST:event_mniResetWindowLayoutActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void mniKanalanschlussActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mniKanalanschlussActionPerformed
        showOrHideView(vKanaldaten);
    }//GEN-LAST:event_mniKanalanschlussActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void mniSummenActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mniSummenActionPerformed
        showOrHideView(vSummen);
    }//GEN-LAST:event_mniSummenActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void mniKassenzeichenActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mniKassenzeichenActionPerformed
        showOrHideView(vKassenzeichen);
    }//GEN-LAST:event_mniKassenzeichenActionPerformed

    /**
     * Inserting Docking Window functionalty (Sebastian) 24.07.07.
     *
     * @param  evt  DOCUMENT ME!
     */
    private void mniLoadLayoutActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mniLoadLayoutActionPerformed
        final JFileChooser fc = new JFileChooser(DIRECTORYPATH_VERDIS);
        fc.setFileFilter(new FileFilter() {

public String getDescription() {
                LOG.error("error while loading layout", ex);
            }
        }
    }//GEN-LAST:event_mniLoadLayoutActionPerformed

    /**
     * Inserting Docking Window functionalty (Sebastian) 24.07.07.
     *
     * @param  evt  DOCUMENT ME!
     */
    private void mniSaveLayoutActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mniSaveLayoutActionPerformed
        final JFileChooser fc = new JFileChooser(DIRECTORYPATH_VERDIS);
        fc.setFileFilter(new FileFilter() {

public String getDescription() {
                saveLayout(name + ".layout");
            }
        }
    }//GEN-LAST:event_mniSaveLayoutActionPerformed

    /**
     * TODO Bundle Inserting Docking Window functionalty (Sebastian) 24.07.07.
public void setKanalTitleForeground(final Color foreground) {
     *
     * @param  evt  DOCUMENT ME!
     */
    private void mnuChangeUserActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnuChangeUserActionPerformed
        formWindowOpened(null);
    }//GEN-LAST:event_mnuChangeUserActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void mnuNewKassenzeichenActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnuNewKassenzeichenActionPerformed
        cmdNewKassenzeichenActionPerformed(null);
    }//GEN-LAST:event_mnuNewKassenzeichenActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void mnuEditModeActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnuEditModeActionPerformed
        cmdEditModeActionPerformed(null);
    }//GEN-LAST:event_mnuEditModeActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void mnuExitActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnuExitActionPerformed
        dispose();
    }//GEN-LAST:event_mnuExitActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void formWindowOpened(final java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowOpened
    }//GEN-LAST:event_formWindowOpened

    /**
     * DOCUMENT ME!
private static boolean handleLoginStatus(final JXLoginPane.Status status,
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdRefreshEnumerationActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdRefreshEnumerationActionPerformed
        regenFlaechenTabellenPanel.reEnumerateFlaechen();
    }//GEN-LAST:event_cmdRefreshEnumerationActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdPdfActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdPdfActionPerformed
        if (kassenzeichenBean != null) {
            final EBGeneratorDialog.Mode ebMode;
            if (CidsAppBackend.Mode.SR.equals(CidsAppBackend.getInstance().getMode())) {
public void run() {
                    }
                });
        }
    }//GEN-LAST:event_cmdPdfActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdDeleteKassenzeichenActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdDeleteKassenzeichenActionPerformed
        deleteKassenzeichen();
    }//GEN-LAST:event_cmdDeleteKassenzeichenActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdPasteActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdPasteActionPerformed
        final AbstractClipboard clipboard = getCurrentClipboard();
        if (clipboard != null) {
            clipboard.storeToFile();
            clipboard.paste();
        }
    }//GEN-LAST:event_cmdPasteActionPerformed

    /**
     * DOCUMENT ME!
public AbstractClipboard getCurrentClipboard() {
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdCutActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdCutActionPerformed
        final AbstractClipboard clipboard = getCurrentClipboard();
        if (clipboard != null) {
            clipboard.cut();
        }
    }//GEN-LAST:event_cmdCutActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DCUMENT ME!
     */
    private void cmdInfoActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdInfoActionPerformed
//        String info="Verdis Plugin\n"
//                + "cismet GmbH\n\n"
//                + de.cismet.verdis.Version.getVersion()+"\n"
private void cmdInfoActionPerformed(final java.awt.event.ActionEvent evt) {//GEN
            about = d;
        }
        StaticSwingTools.showDialog(about);
    }//GEN-LAST:event_cmdInfoActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void mnuInfoActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnuInfoActionPerformed
        cmdInfoActionPerformed(null);
    }//GEN-LAST:event_mnuInfoActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void formKeyReleased(final java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyReleased
        // TODO add your handling code here:
    }//GEN-LAST:event_formKeyReleased

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void formKeyPressed(final java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyPressed

        if ((evt.getKeyCode() == KeyEvent.VK_F1) && evt.isControlDown()) {
        }
        // TODO add your handling code here:
    }//GEN-LAST:event_formKeyPressed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void formKeyTyped(final java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyTyped
    }//GEN-LAST:event_formKeyTyped

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DCUMENT ME!
     */
    private void cmdWorkflowActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdWorkflowActionPerformed
    }//GEN-LAST:event_cmdWorkflowActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void formWindowClosing(final java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        LOG.info("formWindowClosing");
        if (editMode && !kassenzeichenPanel.isEmpty()) {
            if (changesPending()) {
private void formWindowClosing(final java.awt.event.WindowEvent evt) {//GEN-FIRS
            }
        }
        closeAllConnections();
    }//GEN-LAST:event_formWindowClosing

    /**
     * DOCUMENT ME!
private void closeAllConnections() {
     *
     * @param  evt  DOCUMENT ME!
     */
    private void formWindowClosed(final java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosed
    }//GEN-LAST:event_formWindowClosed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdNewKassenzeichenActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdNewKassenzeichenActionPerformed
        if (!readonly) {
            if (changesPending()) {
                final int answer = JOptionPane.showConfirmDialog(
private void cmdNewKassenzeichenActionPerformed(final java.awt.event.ActionEvent
                newKassenzeichen();
            }
        }
    }//GEN-LAST:event_cmdNewKassenzeichenActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdOkActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdOkActionPerformed
        if (changesPending()) {
            saveKassenzeichenAndAssessement();
        }
    }//GEN-LAST:event_cmdOkActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdCancelActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdCancelActionPerformed
        if (changesPending()) {
            final int answer = JOptionPane.showConfirmDialog(
                    this,
protected void done() {
                    kassenzeichenPanel.refresh();
                }
            }.execute();
    }//GEN-LAST:event_cmdCancelActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdEditModeActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdEditModeActionPerformed
        if (!readonly) {
            WaitDialog.getInstance().showDialog();
            new SwingWorker<Boolean, Void>() {
protected void done() {
                    }
                }.execute();
        }
    }//GEN-LAST:event_cmdEditModeActionPerformed

    /**
     * DOCUMENT ME!
public boolean acquireLocks() {
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdCopyActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdCopyActionPerformed
        final AbstractClipboard clipboard = clipboards.get(CidsAppBackend.getInstance().getMode());
        if (clipboard != null) {
            clipboard.storeToFile();
            clipboard.copy();
        }
    }//GEN-LAST:event_cmdCopyActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdTestActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdTestActionPerformed
    }//GEN-LAST:event_cmdTestActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdTest2ActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdTest2ActionPerformed
    }//GEN-LAST:event_cmdTest2ActionPerformed

    /**
     * ToDo Threading and Progressbar.
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdLagisCrossoverActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdLagisCrossoverActionPerformed
        try {
            final JDialog dialog = new JDialog(this, "", true);
            final PopupLagisCrossoverPanel lcp = new PopupLagisCrossoverPanel(CidsAppBackend.getInstance()
private void cmdLagisCrossoverActionPerformed(final java.awt.event.ActionEvent e
            LOG.error("Crossover: Fehler im LagIS Crossover", ex);
            // ToDo Meldung an Benutzer
        }
    }//GEN-LAST:event_cmdLagisCrossoverActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void mnuRenameCurrentKZActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnuRenameCurrentKZActionPerformed
        if (!readonly) {
            if (editMode) {
                if (changesPending()) {
protected void done() {
                renameCurrentKassenzeichen();
            }
        }
    }//GEN-LAST:event_mnuRenameCurrentKZActionPerformed

    /**
     * DOCUMENT ME!
public void releaseLocks() {
     *
     * @param  evt  DOCUMENT ME!
     */
    private void mniKarteActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mniKarteActionPerformed
        showOrHideView(vKarte);
    }//GEN-LAST:event_mniKarteActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void mniTabelleActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mniTabelleActionPerformed
        switch (CidsAppBackend.getInstance().getMode()) {
            case REGEN: {
                showOrHideView(vTabelleRegen);
private void mniTabelleActionPerformed(final java.awt.event.ActionEvent evt) {//
            }
            break;
        }
    }//GEN-LAST:event_mniTabelleActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void mniDetailsActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mniDetailsActionPerformed
        switch (CidsAppBackend.getInstance().getMode()) {
            case REGEN: {
                showOrHideView(vDetailsRegen);
private void mniDetailsActionPerformed(final java.awt.event.ActionEvent evt) {//
            }
            break;
        }
    }//GEN-LAST:event_mniDetailsActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void jMenuItem1ActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem1ActionPerformed
        DeveloperUtil.createWindowLayoutFrame("Momentanes Layout", rootWindow).setVisible(true);
    }//GEN-LAST:event_jMenuItem1ActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void btnHistoryActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnHistoryActionPerformed
        final HistoryPanel historyPan = new HistoryPanel();
        historyPan.setCidsBean(kassenzeichenBean);

private void btnHistoryActionPerformed(final java.awt.event.ActionEvent evt) {//
        dial.setContentPane(historyPan);
        dial.setSize(800, 600);
        StaticSwingTools.showDialog(dial);
    }//GEN-LAST:event_btnHistoryActionPerformed

    /**
     * DOCUMENT ME!
public static void transformToDefaultCrsNeeded(Geometry geom) {
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdAddActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdAddActionPerformed
        if (!CidsAppBackend.getInstance().getMode().equals(CidsAppBackend.Mode.ALLGEMEIN)) {
            final CidsBeanTable cidsBeanTable = getCurrentCidsbeanTable();
            if (cidsBeanTable != null) {
                cidsBeanTable.addNewBean();
            }
        }
    }//GEN-LAST:event_cmdAddActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdRemoveActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdRemoveActionPerformed
        if (!CidsAppBackend.getInstance().getMode().equals(CidsAppBackend.Mode.ALLGEMEIN)) {
            final CidsBeanTable cidsBeanTable = getCurrentCidsbeanTable();
            if (cidsBeanTable != null) {
                cidsBeanTable.removeSelectedBeans();
            }
        }
    }//GEN-LAST:event_cmdRemoveActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdUndoActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdUndoActionPerformed
        final CidsBeanTable cidsBeanTable = getCurrentCidsbeanTable();
        if (cidsBeanTable != null) {
            cidsBeanTable.restoreSelectedBeans();
        }
    }//GEN-LAST:event_cmdUndoActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DCUMENT ME!
     */
    private void mniOptionsActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mniOptionsActionPerformed
        final OptionsDialog od = new OptionsDialog(this, true);
        StaticSwingTools.showDialog(od);
    }//GEN-LAST:event_mniOptionsActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCMENT ME!
     */
    private void cmdFortfuehrungActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdFortfuehrungActionPerformed
        StaticSwingTools.showDialog(FortfuehrungsanlaesseDialog.getInstance());
    }//GEN-LAST:event_cmdFortfuehrungActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DCUMENT ME!
     */
    private void cmdNextKassenzeichenWithoutGeomActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdNextKassenzeichenWithoutGeomActionPerformed
        final Integer kassenzeichennummer8;
        if (getCidsBean() != null) {
            kassenzeichennummer8 = (Integer)getCidsBean().getProperty(
private void cmdNextKassenzeichenWithoutGeomActionPerformed(final java.awt.event
        } catch (final ConnectionException ex) {
            LOG.error("error while executing next kassenzeichensearch", ex);
        }
    }//GEN-LAST:event_cmdNextKassenzeichenWithoutGeomActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdGrundbuchblattSucheActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdGrundbuchblattSucheActionPerformed
        StaticSwingTools.showDialog(GrundbuchblattSucheDialog.getInstance());
    }//GEN-LAST:event_cmdGrundbuchblattSucheActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void mniKassenzeichen1ActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mniKassenzeichen1ActionPerformed
        showOrHideView(vKassenzeichenList);
    }//GEN-LAST:event_mniKassenzeichen1ActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdSAPCheckActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdSAPCheckActionPerformed
        if (cmdSAPCheck.isSelected()) {
            sapClipboardListener.gainOwnership();
        }
    }//GEN-LAST:event_cmdSAPCheckActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdMemoryActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdMemoryActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_cmdMemoryActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdRecalculateAreaActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdRecalculateAreaActionPerformed
        if (isInEditMode()) {
            regenFlaechenTabellenPanel.recalculateAreaOfFlaechen();
        }
    }//GEN-LAST:event_cmdRecalculateAreaActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdArbeitspaketeActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdArbeitspaketeActionPerformed
        ArbeitspaketeManagerPanel.getInstance().loadArbeitspakete();
        StaticSwingTools.showDialog(ArbeitspaketeManagerPanel.getInstance().getDialog());
    }//GEN-LAST:event_cmdArbeitspaketeActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdAbfrageeditorActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdAbfrageeditorActionPerformed
        StaticSwingTools.showDialog(abfrageDialog);
    }//GEN-LAST:event_cmdAbfrageeditorActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdVeranlagungsdateiActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdVeranlagungsdateiActionPerformed
        VeranlagungsdateiScheduleDialog.getInstance().pack();
        StaticSwingTools.showDialog(VeranlagungsdateiScheduleDialog.getInstance());
    }//GEN-LAST:event_cmdVeranlagungsdateiActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void btnTimeRecoveryActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnTimeRecoveryActionPerformed
        if (editMode) {
            StaticSwingTools.showDialog(timeRecoveryPanel.getDialog());
        } else {
protected void done() {
                    }.execute();
            }
        }
    }//GEN-LAST:event_btnTimeRecoveryActionPerformed

    /**
     * DOCUMENT ME!
     *
     * @param  evt  DOCUMENT ME!
     */
    private void cmdOpenInD3ActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdOpenInD3ActionPerformed
        if (kassenzeichenBean != null) {
            final String kz = getCidsBean().getProperty(
                    KassenzeichenPropertyConstants.PROP__KASSENZEICHENNUMMER).toString();
private void cmdOpenInD3ActionPerformed(final java.awt.event.ActionEvent evt) {/
                            e);
            }
        }
    }//GEN-LAST:event_cmdOpenInD3ActionPerformed

    /**
     * DOCUMENT ME!
protected void done() {
     *
     * @param  evt  DOCUMENT ME!
     */
    private void mnuRenameAnyKZActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnuRenameAnyKZActionPerformed
        showRenameKassenzeichen(false);
    }//GEN-LAST:event_mnuRenameAnyKZActionPerformed

    /**
     * DOCUMENT ME!
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public static void updateMessagesNotification(Context context, boolean isNew) {
        }

        // is there a peer to not notify for?
        if (sPaused != null) {
            query += " AND " + CommonColumns.PEER + " <> ? AND " +
                Groups.GROUP_JID + " <> ?";
            args = new String[] { sPaused, sPaused };
        }

        // TODO we need the group subject to correctly notify group messages (e.g. alice @ team: hey buddy!)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public SavedRevision update(DocumentUpdater updater) throws CouchbaseLiteExcepti

        int lastErrorCode = Status.UNKNOWN;
        do {
            UnsavedRevision newRev = createRevision();
            if (updater.update(newRev) == false) {
                break;
public SavedRevision update(DocumentUpdater updater) throws CouchbaseLiteExcepti

        } while (lastErrorCode == Status.CONFLICT);
        return null;

    }


else if (currentRevision != null && internalRevision.getRevId().equals(currentRe
        }
        String revId = row.getDocumentRevisionId();
        if (currentRevision == null || revIdGreaterThanCurrent(revId)) {
            Map<String, Object> properties = row.getDocumentProperties();
            if (properties != null) {
                RevisionInternal rev = new RevisionInternal(properties);
                currentRevision = new SavedRevision(this, rev);
            }
        }
     }

    /**
     * @exclude
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	protected final Configuration config;
	protected Optional<Bounds> projectionBounds = Optional.empty();

	protected AtomicBoolean isStreaming = new AtomicBoolean(true);
	protected AtomicBoolean isDetecting = new AtomicBoolean(true);
	protected AtomicBoolean isCalibrating = new AtomicBoolean(false);
	protected boolean shownBrightnessWarning = false;
	protected boolean cropFeedToProjection = false;
	protected boolean limitDetectProjection = false;

	protected Optional<Integer> minimumShotDimension = Optional.empty();

public long getCurrentFrameTimestamp() {
	private double webcamFPS = DEFAULT_FPS;
	private boolean showedFPSWarning = false;

	protected AutoCalibrationManager acm = null;
	protected boolean isAutoCalibrating = false;
	public boolean cameraAutoCalibrated = false;

	protected final DeduplicationProcessor deduplicationProcessor = new DeduplicationProcessor(this);
	protected final ArenaMaskManager arenaMaskManager;
public void stopRecordingCalibratedArea() {
	}

	protected class Detector extends MediaListenerAdapter implements Runnable {

		@Override
		public void run() {
			if (webcam.isPresent()) {
private void streamCameraFrames() {
	protected BufferedImage processFrame(BufferedImage currentFrame) {
		frameCount++;

		if (isAutoCalibrating) {
			acm.processFrame(currentFrame);
			return currentFrame;
		}

		Mat matFrameBGR = Camera.bufferedImageToMat(currentFrame);
		Mat matFrameHSV = new Mat();

		if (cameraAutoCalibrated && projectionBounds.isPresent()) {
			if (acm != null) {
protected BufferedImage processFrame(BufferedImage currentFrame) {
				videoWriterCalibratedArea.encodeVideo(0, frame);
			}

			if (isAutoCalibrating || isDetecting()) Imgproc.cvtColor(matFrameBGR, matFrameHSV, Imgproc.COLOR_BGR2HSV);

			if (Configuration.USE_ARENA_MASK) arenaMaskManager.updateAvgLums(submatFrame);

protected BufferedImage processFrame(BufferedImage currentFrame) {
			}

		} else {
			if (isAutoCalibrating || isDetecting()) Imgproc.cvtColor(matFrameBGR, matFrameHSV, Imgproc.COLOR_BGR2HSV);
		}

		shotDetectionManager.processFrame(matFrameHSV, matFrameBGR, isDetecting.get());
public void showMotionWarning() {
	private void fireAutoCalibration() {
		acm.reset();
		acm.setCallback(new Callback<Void, Void>() {

			@Override
			public Void call(Void param) {
				autoCalibrateSuccess(acm.getBoundsResult(), acm.getFrameDelayResult());
public Void call(Void param) {
	}

	protected void autoCalibrateSuccess(Bounds bounds, long delay) {
		if (isAutoCalibrating && cameraCalibrationListener != null) {
			isAutoCalibrating = false;

			logger.debug("autoCalibrateSuccess {} {} {} {}", (int) bounds.getMinX(), (int) bounds.getMinY(),
					(int) bounds.getWidth(), (int) bounds.getHeight());
protected void autoCalibrateSuccess(Bounds bounds, long delay) {

	public void enableAutoCalibration(boolean calculateFrameDelay) {
		acm = new AutoCalibrationManager(this, calculateFrameDelay);
		isAutoCalibrating = true;
		cameraAutoCalibrated = false;
		// Turns off using mask
		shotDetectionManager.setArenaMaskManager(null);
public void enableAutoCalibration(boolean calculateFrameDelay) {
	}

	public void disableAutoCalibration() {
		isAutoCalibrating = false;
	}

	public void setArenaBackground(String resourceFilename) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private double weight(long t) {
     * a linear pass over whatever data structure is being used."
     */
    private void rescale(long now, long next) {
        if (nextScaleTime.compareAndSet(next, now + RESCALE_THRESHOLD)) {
            lockForRescale();
            try {
                final long oldStartTime = startTime;
                this.startTime = currentTimeInSeconds();
                final double scalingFactor = exp(-alpha * (startTime - oldStartTime));
private void rescale(long now, long next) {

                // make sure the counter is in sync with the number of stored samples.
                count.set(values.size());
            } finally {
                unlockForRescale();
            }
        }
    }

package com.codahale.metrics;

import org.junit.Test;
import java.util.concurrent.TimeUnit;

import static org.assertj.core.api.Assertions.assertThat;

public void longPeriodsOfInactivityShouldNotCorruptSamplingState() {
    }

    @Test
    public void spotLift() {
        final ManualClock clock = new ManualClock();
        final ExponentiallyDecayingReservoir reservoir = new ExponentiallyDecayingReservoir(1000,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 */
public class ServiceTypes {

  public static ServiceType get(Record record) {
    load();

    String type = record.getType();
public static ServiceType get(Record record) {
    }
  }

  private static void load() {
    synchronized (ServiceTypes.class) {
      if (types == null || !types.iterator().hasNext()) {
        types = ServiceLoader.load(ServiceType.class);
      }
    }
  }

  public static Iterator<ServiceType> all() {
    load();
    return types.iterator();
  }

  private static ServiceLoader<ServiceType> types;

  public static ServiceType get(String type) {
    load();
    for (ServiceType next : types) {
      if (next.name().equalsIgnoreCase(type)) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Service that marks the completion of the bootstrap process
 */
public interface BootstrapComplete {

     * Creates a container using a set of arguments
     * @param options   The {@link CreateContainerOptions} that will be used to build the container.
     * @return          A set of {@link CreateContainerMetadata}, which contains information about the created container.
     * @throws Exception
     */
    M create(O options, CreationStateListener listener) throws Exception;

    /**
     * Start the container
     * @param container
     * @throws Exception
     */
    void start(Container container);

    /**
     * Stop the container
     * @param container
     * @throws Exception
     */
    void stop(Container container);

    /**
     * Destroy the container
     * @param container
     * @throws Exception
     */
    void destroy(Container container);


    /**
     * Returns the options
     * @return
     */
    Class<O> getOptionsType();
    Class<M> getMetadataType();


import org.apache.felix.scr.annotations.Reference;
import org.apache.felix.scr.annotations.Service;

@Component(immediate = true)
@Service({ BootstrapComplete.class })
public final class BootstrapCompleteService extends AbstractComponent implements BootstrapComplete {
            OSGI-INF/io.fabric8.service.ContainerPlaceholderResolver.xml,
            OSGI-INF/io.fabric8.service.EncryptedPropertyResolver.xml,
            OSGI-INF/io.fabric8.service.EnvPlaceholderResolver.xml,
            OSGI-INF/io.fabric8.service.FabricMBeanRegistrationListener.xml,
            OSGI-INF/io.fabric8.service.FabricServiceImpl.xml,
            OSGI-INF/io.fabric8.service.PortPlaceholderResolver.xml,
            <artifactId>jasypt</artifactId>
        </dependency>
        <dependency>
            <groupId>org.mvel</groupId>
            <artifactId>mvel2</artifactId>
        </dependency>
import io.fabric8.api.Container;
import io.fabric8.api.CreateEnsembleOptions;
import io.fabric8.api.DataStoreRegistrationHandler;
import io.fabric8.api.FabricException;
import io.fabric8.api.FabricService;
import io.fabric8.api.ServiceLocator;
import io.fabric8.api.ZooKeeperClusterBootstrap;
import io.fabric8.api.jcip.ThreadSafe;
import io.fabric8.api.scr.AbstractComponent;
import org.apache.felix.scr.annotations.Property;
import org.apache.felix.scr.annotations.Reference;
import org.apache.felix.scr.annotations.Service;
import org.osgi.framework.Bundle;
import org.osgi.framework.BundleContext;
import org.osgi.framework.BundleException;
public void create(CreateEnsembleOptions options) {
        assertValid();
        try {
            // Wait for bootstrap to be complete
            ServiceLocator.awaitService(bundleContext, BootstrapComplete.class);

            LOGGER.info("Create fabric with: {}", options);

public void create(CreateEnsembleOptions options) {
            startBundles(options);

            long startTime = System.currentTimeMillis();
            createHandler.waitForContainerAlive(name, syscontext, options.getBootstrapTimeout());

            if (options.isWaitForProvision() && options.isAgentEnabled()) {
                long currentTime = System.currentTimeMillis();
                createHandler.waitForSuccessfulDeploymentOf(name, syscontext, options.getBootstrapTimeout() - (currentTime - startTime));
            }
        } catch (RuntimeException rte) {
            throw rte;
private void waitForContainerAlive(String containerName, BundleContext syscontex
            System.out.println(String.format("Waiting for container: %!s(MISSING)", containerName));

            Exception lastException = null;
            long startedAt = System.currentTimeMillis();
            while (!Thread.interrupted() && System.currentTimeMillis() < startedAt + timeout) {
                ServiceReference<FabricService> sref = syscontext.getServiceReference(FabricService.class);
                FabricService fabricService = sref != null ? syscontext.getService(sref) : null;
                try {
                    Container container = fabricService != null ? fabricService.getContainer(containerName) : null;
                    if (container != null && container.isAlive()) {
                        return;
                    } else {
                        Thread.sleep(500);
                    }
                } catch (InterruptedException ex) {
                    Thread.currentThread().interrupt();
import io.fabric8.api.scr.Configurer;
import io.fabric8.api.scr.ValidatingReference;
import io.fabric8.api.scr.support.ConfigInjection;
import org.apache.felix.scr.annotations.Activate;
import org.apache.felix.scr.annotations.Component;
import org.apache.felix.scr.annotations.Deactivate;
import org.jboss.gravia.runtime.spi.PropertiesProvider;
import org.jboss.gravia.runtime.spi.SubstitutionPropertiesProvider;
import org.jboss.gravia.runtime.spi.SystemPropertiesProvider;

import java.util.Dictionary;
import java.util.Enumeration;
public Object getProperty(String key) {
            }

            @Override
            public Object getProperty(String key, Object defaultValue) {
                Object value = null;
                for (PropertiesProvider p : propertiesProviders) {
 */
package io.fabric8.service.child;

import io.fabric8.api.Constants;
import io.fabric8.api.Container;
import io.fabric8.api.ContainerAutoScaler;
import io.fabric8.utils.AuthenticationUtils;
import io.fabric8.utils.Ports;
import io.fabric8.zookeeper.ZkDefs;
import org.apache.felix.scr.annotations.Activate;
import org.apache.felix.scr.annotations.Component;
import org.apache.felix.scr.annotations.Deactivate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;

import static io.fabric8.utils.Ports.mapPortToRange;

@ThreadSafe
@Component(name = "io.fabric8.container.provider.child", label = "Fabric8 Child Container Provider", immediate = true, metatype = false)
@Service(ContainerProvider.class)
@Properties(
        @Property(name = "fabric.container.protocol", value = ChildContainerProvider.SCHEME)
)
    static final String SCHEME = "child";

    @Reference(referenceInterface = FabricService.class)
    private final ValidatingReference<FabricService> fabricService = new ValidatingReference<FabricService>();

    @Reference(referenceInterface = ProcessControllerFactory.class, cardinality = ReferenceCardinality.OPTIONAL_UNARY,
            policy = ReferencePolicy.DYNAMIC, bind = "bindProcessControllerFactory", unbind = "unbindProcessControllerFactory")
    private ProcessControllerFactory processControllerFactory;

    @Activate
    void activate() {
void deactivate() {

    @Override
    public CreateChildContainerOptions.Builder newBuilder() {
        return CreateChildContainerOptions.builder();
    }

    @Override
    public CreateChildContainerMetadata create(final CreateChildContainerOptions options, final CreationStateListener listener) throws Exception {
        assertValid();

        ChildContainerController controller = createController(options);
        return controller.create(options, listener);
    }

    @Override
    public void start(final Container container) {
        getContainerController(container).start(container);
    }

    @Override
    public void stop(final Container container) {
        getContainerController(container).stop(container);
    }

    @Override
    public void destroy(final Container container) {
        getContainerController(container).destroy(container);
    }

public String getScheme() {

    @Override
    public Class<CreateChildContainerOptions> getOptionsType() {
        return CreateChildContainerOptions.class;
    }

    @Override
    public Class<CreateChildContainerMetadata> getMetadataType() {
        return CreateChildContainerMetadata.class;
    }

    @Override
    public ContainerAutoScaler createAutoScaler() {
        return new ChildAutoScaler(this);
    }

    protected ChildContainerController createController(CreateChildContainerOptions options) throws Exception {
        ChildContainerController answer = null;
        boolean isJavaContainer = ChildContainers.isJavaContainer(getFabricService(), options);
        boolean isProcessContainer = ChildContainers.isProcessContainer(getFabricService(), options);
        ProcessControllerFactory factory = processControllerFactory;
        if (factory != null) {
            answer = factory.createController(options);
        } else if (isJavaContainer || isProcessContainer) {
protected ChildContainerController createController(CreateChildContainerOptions
        return answer;
    }

    protected ChildContainerController getContainerController(Container container) {
        assertValid();
        ChildContainerController answer = null;
        try {
            ProcessControllerFactory factory = processControllerFactory;
            if (factory != null) {
                answer = factory.getControllerForContainer(container);
            }
protected ChildContainerController getContainerController(Container container) {
        return answer;
    }

    protected ChildContainerController createKarafContainerController() {
        return new ChildContainerController() {
            @Override
            public CreateChildContainerMetadata create(final CreateChildContainerOptions options, final CreationStateListener listener) {
private static String collectionAsString(Collection<String> value) {
        return sb.toString();
    }

    void bindFabricService(FabricService fabricService) {
        this.fabricService.bind(fabricService);
    }

    void unbindFabricService(FabricService fabricService) {
        this.fabricService.unbind(fabricService);
    }


    void bindProcessControllerFactory(ProcessControllerFactory processControllerFactory) {
        this.processControllerFactory = processControllerFactory;
    }

    void unbindProcessControllerFactory(ProcessControllerFactory processControllerFactory) {
        this.processControllerFactory = null;
    }
}
        <geronimo-ws-metadata.version>1.1.3</geronimo-ws-metadata.version>
        <geronimo-atinject.version>1.0</geronimo-atinject.version>
        <gitective-version>0.9.9</gitective-version>
        <gravia-version>1.1.0.Beta34</gravia-version>
        <groovy-version>2.3.3</groovy-version>
        <guava-version>15.0</guava-version>
        <guava.osgi.version.clean>15.0</guava.osgi.version.clean>
package io.fabric8.portable.runtime.tomcat;

import io.fabric8.api.RuntimeProperties;
import org.jboss.gravia.container.tomcat.support.TomcatPropertiesProvider;
import org.jboss.gravia.runtime.spi.CompositePropertiesProvider;
import org.jboss.gravia.runtime.spi.EnvPropertiesProvider;
import org.jboss.gravia.runtime.spi.PropertiesProvider;
import org.jboss.gravia.runtime.spi.SubstitutionPropertiesProvider;
import org.jboss.gravia.runtime.spi.SystemPropertiesProvider;

import javax.servlet.ServletContext;

/**
 * The Fabric {@link PropertiesProvider}
 */
public class FabricPropertiesProvider  implements PropertiesProvider {


    private final PropertiesProvider delegate;

    public FabricPropertiesProvider(ServletContext servletContext) {
        delegate = new SubstitutionPropertiesProvider(
                new CompositePropertiesProvider(
                        new TomcatPropertiesProvider(servletContext),
                        new SystemPropertiesProvider(),
                        new EnvPropertiesProvider(RuntimeProperties.DEFAULT_ENV_PREFIX)
                )
        );
    }

    @Override
    public Object getProperty(String key) {
        return delegate.getProperty(key);
    }

    @Override
    public Object getProperty(String key, Object defaultValue) {
        return delegate.getProperty(key, defaultValue);
    }
    <modelVersion>4.0.0</modelVersion>

    <groupId>io.fabric8.runtime</groupId>
    <artifactId>embedded</artifactId>
    <name>Fabric8 :: Runtime :: Embedded</name>
    <packaging>bundle</packaging>

            io.fabric8.runtime.embedded.registration,
            io.fabric8.utils;-split-package:=first
        </fuse.osgi.private.pkg>

        <fuse.osgi.service.component>
            <!-- Use explicit file locations because there is no support for wildcard resource discovery in non-osgi environments -->
            OSGI-INF/io.fabric8.runtime.embedded.registration.EmbeddedContainerRegistration.xml,
import io.fabric8.api.FabricService;
import io.fabric8.api.ZooKeeperClusterBootstrap;
import io.fabric8.runtime.itests.support.CommandSupport;
import io.fabric8.runtime.itests.support.ServiceLocator;

import java.io.InputStream;

import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.arquillian.osgi.StartLevelAware;
import org.jboss.gravia.Constants;
import org.jboss.gravia.resource.ManifestBuilder;
import org.jboss.gravia.runtime.RuntimeLocator;
import org.jboss.gravia.runtime.RuntimeType;
import org.jboss.osgi.metadata.OSGiManifestBuilder;
import org.jboss.shrinkwrap.api.Archive;
import org.jboss.shrinkwrap.api.asset.Asset;
import org.jboss.gravia.itests.support.AnnotatedContextListener;
import org.jboss.gravia.itests.support.ArchiveBuilder;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import io.fabric8.api.FabricService;
import io.fabric8.api.ZooKeeperClusterBootstrap;
import io.fabric8.runtime.itests.support.CommandSupport;
import io.fabric8.runtime.itests.support.ServiceLocator;
import io.fabric8.utils.Base64Encoder;
import io.fabric8.utils.PasswordEncoder;

import org.jboss.gravia.resource.ManifestBuilder;
import org.jboss.gravia.runtime.RuntimeLocator;
import org.jboss.gravia.runtime.RuntimeType;
import org.jboss.osgi.metadata.OSGiManifestBuilder;
import org.jboss.shrinkwrap.api.Archive;
import org.jboss.shrinkwrap.api.asset.Asset;
import io.fabric8.api.Container;
import io.fabric8.api.FabricService;
import io.fabric8.runtime.itests.support.CommandSupport;
import io.fabric8.runtime.itests.support.ServiceLocator;
import io.fabric8.utils.Base64Encoder;
import io.fabric8.utils.PasswordEncoder;

import org.jboss.arquillian.junit.Arquillian;
import org.jboss.arquillian.osgi.StartLevelAware;
import org.jboss.gravia.Constants;
import org.jboss.gravia.resource.ManifestBuilder;
import org.jboss.gravia.runtime.RuntimeLocator;
import org.jboss.gravia.runtime.RuntimeType;
import org.jboss.osgi.metadata.OSGiManifestBuilder;
import org.jboss.shrinkwrap.api.Archive;
import org.jboss.shrinkwrap.api.asset.Asset;
import org.jboss.gravia.itests.support.AnnotatedContextListener;
import org.jboss.gravia.itests.support.ArchiveBuilder;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.jboss.gravia.runtime.ModuleContext;
import org.jboss.gravia.runtime.RuntimeLocator;
import org.jboss.gravia.runtime.RuntimeType;
import org.junit.Assert;

/**

import org.jboss.gravia.runtime.ModuleContext;
import org.jboss.gravia.runtime.RuntimeLocator;

public abstract class ContainerBuilder<T extends ContainerBuilder, B extends CreateContainerBasicOptions.Builder> {

 */
package io.fabric8.runtime.itests.support;

import io.fabric8.api.*;

import java.util.HashSet;
import java.util.Set;

import org.jboss.gravia.runtime.ModuleContext;
import org.jboss.gravia.runtime.RuntimeLocator;

public class Provision {

/**
 *  Copyright 2005-2014 Red Hat, Inc.
 *
 *  Red Hat licenses this file to you under the Apache License, version
 *  2.0 (the "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *  implied.  See the License for the specific language governing
 *  permissions and limitations under the License.
 */
package io.fabric8.runtime.itests.support;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

import org.jboss.gravia.runtime.Filter;
import org.jboss.gravia.runtime.ModuleContext;
import org.jboss.gravia.runtime.RuntimeLocator;
import org.jboss.gravia.runtime.ServiceReference;
import org.jboss.gravia.runtime.ServiceTracker;
import org.junit.Assert;

public final class ServiceLocator {

	public static final Long DEFAULT_TIMEOUT = 60000L;

	private ServiceLocator() {
		//Utility Class
	}

    public static <T> T getService(Class<T> type) {
        ModuleContext moduleContext = RuntimeLocator.getRequiredRuntime().getModuleContext();
        ServiceReference<T> sref = moduleContext.getServiceReference(type);
        return sref != null ? moduleContext.getService(sref) : null;
    }

    public static <T> T getService(ModuleContext moduleContext, Class<T> type) {
        ServiceReference<T> sref = moduleContext.getServiceReference(type);
        return sref != null ? moduleContext.getService(sref) : null;
    }

    public static <T> T getRequiredService(Class<T> type) {
        T service = getService(RuntimeLocator.getRequiredRuntime().getModuleContext(), type);
        Assert.assertNotNull("Service available: " + type.getName(), service);
        return service;
    }

    public static <T> T getRequiredService(ModuleContext moduleContext, Class<T> type) {
        T service = getService(moduleContext, type);
        Assert.assertNotNull("Service available: " + type.getName(), service);
        return service;
    }

    public static <T> T awaitService(Class<T> type) {
        ModuleContext moduleContext = RuntimeLocator.getRequiredRuntime().getModuleContext();
        return awaitService(moduleContext, type, null, DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS);
    }

    public static <T> T awaitService(ModuleContext moduleContext, Class<T> type) {
        return awaitService(moduleContext, type, null, DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS);
    }

    public static <T> T awaitService(Class<T> type, String filterspec) {
        ModuleContext moduleContext = RuntimeLocator.getRequiredRuntime().getModuleContext();
        return awaitService(moduleContext, type, filterspec, DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS);
    }

    public static <T> T awaitService(Class<T> type, String filterspec, long timeout, TimeUnit unit) {
        ModuleContext moduleContext = RuntimeLocator.getRequiredRuntime().getModuleContext();
        return awaitService(moduleContext, type, filterspec, timeout, unit);
    }

    public static <T> T awaitService(final ModuleContext moduleContext, Class<T> type, String filterspec, long timeout, TimeUnit unit) {

        final CountDownLatch latch = new CountDownLatch(1);
        final AtomicReference<T> serviceRef = new AtomicReference<T>();
        final Filter srvfilter = filterspec != null ? moduleContext.createFilter(filterspec) : null;
        ServiceTracker<T, T> tracker = new ServiceTracker<T, T>(moduleContext, type, null) {
            @Override
            public T addingService(ServiceReference<T> sref) {
                T service = super.addingService(sref);
                if (srvfilter == null || srvfilter.match(sref)) {
                    serviceRef.set(moduleContext.getService(sref));
                    latch.countDown();
                }
                return service;
            }
        };
        tracker.open();
        try {
            if (!latch.await(timeout, unit)) {
                throw new RuntimeException("Cannot obtain service: " + srvfilter);
            }
            return serviceRef.get();
        } catch (InterruptedException ex) {
            throw new IllegalStateException();
        } finally {
            tracker.close();
        }
	}
}

import org.jboss.gravia.runtime.ModuleContext;
import org.jboss.gravia.runtime.RuntimeLocator;

/**
 * A {@link java.util.concurrent.Callable} that waits for the {@link io.fabric8.api.Container} to get created.
import org.apache.karaf.admin.Instance;
import org.jboss.gravia.runtime.ModuleContext;
import org.jboss.gravia.runtime.RuntimeLocator;

/**
 * A {@link java.util.concurrent.Callable} that waits for the {@link io.fabric8.api.Container} to get created.
    <name>Fabric8 :: Runtime :: Integration Tests :: Embedded</name>

    <properties>
        <runtime.id>root</runtime.id>
        <runtime.home>${project.build.directory}/home</runtime.home>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>io.fabric8</groupId>
            <artifactId>fabric-api</artifactId>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>io.fabric8.runtime</groupId>
        </dependency>
        <dependency>
            <groupId>io.fabric8.runtime</groupId>
            <artifactId>embedded</artifactId>
            <version>${project.version}</version>
        </dependency>
        <dependency>
        </dependency>
        <dependency>
            <groupId>io.fabric8</groupId>
            <artifactId>fabric-zookeeper</artifactId>
            <version>${project.version}</version>
            <scope>provided</scope>
                            <target>
                                <mkdir dir="${runtime.home}"/>
                                <copy todir="${runtime.home}" overwrite="true">
                                    <fileset dir="${basedir}/src/test/etc/home" />
                                </copy>
                            </target>
                        </configuration>
                                    <version>${project.version}</version>
                                </artifactItem>
                                <artifactItem>
                                    <groupId>io.fabric8.runtime</groupId>
                                    <artifactId>embedded</artifactId>
                                    <version>${project.version}</version>
                                </artifactItem>
                            </artifactItems>
                <configuration>
                    <argLine>${surefire.system.args}</argLine>
                    <failIfNoTests>false</failIfNoTests>
                    <workingDirectory>${runtime.home}</workingDirectory>
                    <systemPropertyVariables>
                        <!--felix.cm.loglevel>3</felix.cm.loglevel-->
                        <basedir>${basedir}</basedir>
                        <log4j.configuration>file://${basedir}/src/test/resources/logging.properties</log4j.configuration>
                        <runtime.home>${runtime.home}</runtime.home>
                        <runtime.home>${runtime.home}</runtime.home>
                        <runtime.data>${runtime.home}/data</runtime.data>
                        <runtime.conf>${runtime.home}/conf</runtime.conf>
                        <runtime.id>${runtime.id}</runtime.id>
                        <profiles.auto.import.path>${runtime.home}/fabric/import</profiles.auto.import.path>
                    </systemPropertyVariables>
                </configuration>
            </plugin>

# #L%!
(MISSING)###

ds.loglevel=4





import io.fabric8.api.CreateEnsembleOptions;
import io.fabric8.git.GitService;
import io.fabric8.runtime.itests.support.ServiceLocator;
import io.fabric8.zookeeper.bootstrap.BootstrapConfiguration;

import io.fabric8.test.fabric.runtime.embedded.support.AbstractEmbeddedTest;
import org.jboss.arquillian.junit.Arquillian;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;

import io.fabric8.api.Constants;
import io.fabric8.api.Container;
import io.fabric8.api.ContainerProvider;
import io.fabric8.api.CreateEnsembleOptions;
import io.fabric8.api.CreateEnsembleOptions.Builder;
import io.fabric8.api.DataStore;
import io.fabric8.api.FabricService;
import io.fabric8.api.PortService;
import io.fabric8.api.ZooKeeperClusterBootstrap;
import io.fabric8.git.GitService;
import io.fabric8.runtime.itests.support.ServiceLocator;
import io.fabric8.utils.PasswordEncoder;

import java.util.Dictionary;

import org.apache.curator.framework.CuratorFramework;
import io.fabric8.test.fabric.runtime.embedded.support.AbstractEmbeddedTest;
import org.jboss.arquillian.junit.Arquillian;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
 */
public abstract class AbstractEmbeddedTest {

    private static String[] moduleNames = new String[] { "fabric-boot-commands",
            "fabric-core", "fabric-git", "fabric-zookeeper", "embedded" };

    @BeforeClass
    public static void beforeClass() throws Exception {
public static Module installAndStartModule(ClassLoader classLoader, Resource res
    }

    private static File getModuleFile(String modname) {
        return new File("system/modules/" + modname + ".jar").getAbsoluteFile();
    }
}
#  permissions and limitations under the License.
#

org.jboss.gravia.runtime.storage=target/runtime
org.jboss.gravia.runtime.storage.clean=onFirstInit

org.jboss.gravia.runtime.configurations.dir=${basedir}/target/home/conf/
 
# Root logger option
log4j.rootLogger=DEBUG, file, console
 
# Direct log messages to a log file
log4j.appender.file=org.apache.log4j.FileAppender
log4j.appender.file.File=data/log/gravia.log
log4j.appender.file.append=false
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=%!d(MISSING){yyyy-MM-dd HH:mm:ss} %!p(MISSING) [%!c(MISSING)] (%!t(MISSING)) - %!m(MISSING)%!n(MISSING)
log4j.appender.file.Threshold=DEBUG
 
# Direct log messages to console
log4j.appender.console=org.apache.log4j.ConsoleAppender
import io.fabric8.runtime.itests.support.ContainerBuilder;
import io.fabric8.runtime.itests.support.FabricEnsembleSupport;
import io.fabric8.runtime.itests.support.Provision;
import io.fabric8.runtime.itests.support.ServiceLocator;
import io.fabric8.runtime.itests.support.ServiceProxy;

import java.io.InputStream;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.arquillian.osgi.StartLevelAware;
import org.jboss.gravia.Constants;
import org.jboss.gravia.resource.ManifestBuilder;
import org.jboss.gravia.runtime.ModuleContext;
import org.jboss.gravia.runtime.RuntimeLocator;
import org.jboss.gravia.runtime.RuntimeType;
import org.jboss.osgi.metadata.OSGiManifestBuilder;
import org.jboss.shrinkwrap.api.Archive;
import org.jboss.shrinkwrap.api.asset.Asset;
import org.jboss.gravia.itests.support.AnnotatedContextListener;
import org.jboss.gravia.itests.support.ArchiveBuilder;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import io.fabric8.runtime.itests.support.CommandSupport;
import io.fabric8.runtime.itests.support.FabricEnsembleSupport;
import io.fabric8.runtime.itests.support.Provision;
import io.fabric8.runtime.itests.support.ServiceLocator;
import io.fabric8.runtime.itests.support.ServiceProxy;

import java.io.InputStream;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.arquillian.osgi.StartLevelAware;
import org.jboss.gravia.Constants;
import org.jboss.gravia.resource.ManifestBuilder;
import org.jboss.gravia.runtime.ModuleContext;
import org.jboss.gravia.runtime.RuntimeLocator;
import org.jboss.gravia.runtime.RuntimeType;
import org.jboss.osgi.metadata.OSGiManifestBuilder;
import org.jboss.shrinkwrap.api.Archive;
import org.jboss.shrinkwrap.api.asset.Asset;
import org.jboss.gravia.itests.support.AnnotatedContextListener;
import org.jboss.gravia.itests.support.ArchiveBuilder;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.osgi.service.cm.ConfigurationAdmin;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void setWakeupAlarm() {
            getApplicationContext(), 0, getStartIntent(this),
            PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_ONE_SHOT);

        mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,
                SystemClock.elapsedRealtime() + delay, pi);
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void onLocation(Location location) {
                            Intent reply = new Intent(MISSIONS_BY_TAXON_RESULT);
                            mApp.setServiceResult(MISSIONS_BY_TAXON_RESULT, null);
                            reply.putExtra(IS_SHARED_ON_APP, true);
                            sendBroadcast(reply);
                            return;
                        }
public void onLocation(Location location) {
                        Intent reply = new Intent(MISSIONS_BY_TAXON_RESULT);
                        mApp.setServiceResult(MISSIONS_BY_TAXON_RESULT, missions);
                        reply.putExtra(IS_SHARED_ON_APP, true);
                        sendBroadcast(reply);
                    }
                });
public void onReceive(Context context, Intent intent) {
                return;
            }

            loadMissions(INaturalistService.MISSIONS_BY_TAXON_RESULT);
            refreshViewState();
        }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public VBox getButtonsPane() {
		return buttonsContainer;
	}
	
	public void selectCameraView(CameraView cameraView) {
		cameraTabPane.getSelectionModel().select(camerasSupervisor.getCameraViews().indexOf(cameraView));
	}
import com.shootoff.gui.LocatedImage;
import com.shootoff.gui.MirroredCanvasManager;
import com.shootoff.gui.Resetter;
import com.shootoff.gui.controller.ShootOFFController;
import com.shootoff.targets.Target;
import com.shootoff.util.TimerPool;
public ProjectorArenaPane(Configuration config, CanvasManager canvasManager) {
	}

	public ProjectorArenaPane(Stage arenaStage, Stage shootOffStage, Pane trainingExerciseContainer,
			Configuration config, Resetter resetter) {
		this.config = config;

		arenaCanvasGroup = new Group();
public ProjectorArenaPane(Stage arenaStage, Stage shootOffStage, Pane trainingEx
		this.arenaStage = arenaStage;
		this.trainingExerciseContainer = trainingExerciseContainer;
		
		canvasManager = new MirroredCanvasManager(arenaCanvasGroup, config, resetter, "arena", null, this);

		this.setPrefSize(640, 480);
		
public void startArena() {
		if (arenaPane == null) {
			final Stage arenaStage = new Stage();

			arenaPane = new ProjectorArenaPane(arenaStage, shootOffStage, trainingExerciseContainer, config, resetter);
			
			// Prepare calibrating manager up front so that we can switch
			// to the arena tab when it's ready (otherwise
public void startArena() {
			// Mirror panes so that anything that happens to one also
			// happens to the other
			final ProjectorArenaPane arenaTabPane = new ProjectorArenaPane(arenaStage, shootOffStage, trainingExerciseContainer,
					config, resetter); 
			cameraViews.addCameraView("Arena", new ScrollPane(arenaTabPane), arenaTabPane.getCanvasManager(), true);
			
			arenaTabPane.prefWidthProperty().bind(arenaPane.prefWidthProperty());
public void addShotTimerColumn(String name, int width) {
	public void setShotTimerColumnText(final String name, final String value) {
		if (shotTimerTable != null && shotTimerTable.getItems() != null) {
			Runnable shotTimerColumnTextSetter = () -> {
				shotTimerTable.getItems().get(shotTimerTable.getItems().size() - 1).setExerciseValue(name, value);
			};
			
import com.shootoff.camera.CameraManager;
import com.shootoff.camera.CameraView;
import com.shootoff.gui.CanvasManager;

import javafx.scene.Node;

public interface CameraViews {
	Node getSelectedCameraContainer();
	
	void selectCameraView(CameraView cameraView);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
var jas = jas || {};
 * This is the function called by the google api client when gapi is loaded
 */
function initializeEndpoint() {
    if (window.endpointInitialize) window.endpointInitialize();
}

(function (j) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import org.graylog2.plugin.lifecycles.Lifecycle;
import org.graylog2.radio.bindings.RadioBindings;
import org.graylog2.radio.bindings.RadioInitializerBindings;
import org.graylog2.shared.NodeRunner;
import org.graylog2.shared.ServerStatus;
import org.graylog2.shared.bindings.GuiceInstantiationService;
public static void main(String[] args) {

        serverStatus.setLifecycle(Lifecycle.STARTING);

        final ServiceManager serviceManager = injector.getInstance(ServiceManager.class);
        final ServiceManagerListener serviceManagerListener = injector.getInstance(ServiceManagerListener.class);
        serviceManager.addListener(serviceManagerListener, MoreExecutors.sameThreadExecutor());

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.inject.AbstractModule;
import com.google.inject.TypeLiteral;
import com.google.inject.assistedinject.FactoryModuleBuilder;
import com.google.inject.multibindings.Multibinder;
import com.google.inject.util.Providers;
import com.ning.http.client.AsyncHttpClient;
import org.graylog2.jersey.container.netty.SecurityContextFactory;
import javax.ws.rs.container.ContainerResponseFilter;
import javax.ws.rs.container.DynamicFeature;
import javax.ws.rs.ext.ExceptionMapper;

/**
 * @author Dennis Oelkers <dennis@torch.sh>
private void bindSingletons() {
        serverStatus.addCapability(ServerStatus.Capability.RADIO);
        bind(ServerStatus.class).toInstance(serverStatus);
        bind(InputRegistry.class).toProvider(RadioInputRegistryProvider.class);
    }

    private void bindProviders() {

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.ning.http.client.AsyncHttpClient;
import com.ning.http.client.Response;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public static void ping(AsyncHttpClient client, URI server, URI ourUri, String r
        private final URI serverUri;
        private final URI ourUri;

        public Pinger(AsyncHttpClient httpClient, String nodeId, URI ourUri, URI serverUri) {
            this.httpClient = httpClient;
            this.nodeId = nodeId;
            this.ourUri = ourUri;
            this.serverUri = serverUri;
        }
import com.beust.jcommander.internal.Lists;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.ning.http.client.AsyncHttpClient;
import com.ning.http.client.Response;
import org.graylog2.plugin.configuration.Configuration;
import org.graylog2.plugin.configuration.ConfigurationException;
import org.graylog2.shared.inputs.NoSuchInputTypeException;
import org.graylog2.shared.rest.resources.system.inputs.requests.RegisterInputRequest;
import org.joda.time.DateTime;

import javax.ws.rs.core.UriBuilder;
import java.io.IOException;
 * @author Lennart Koopmann <lennart@torch.sh>
 */
public class RadioInputRegistry extends InputRegistry {
    protected final ObjectMapper mapper = new ObjectMapper();
    protected final AsyncHttpClient httpclient;
    protected final URI serverUrl;
protected MessageInput getMessageInput(InputSummaryResponse isr) {
        try {
            input = this.create(isr.type);

            // Add all standard fields.
            input.initialize(new Configuration(isr.configuration));
            input.setTitle(isr.title);
            input.setCreatorUserId(isr.creatorUserId);
            input.setPersistId(isr.id);
            input.setCreatedAt(new DateTime(isr.createdAt));
            input.setGlobal(isr.global);

            input.checkConfiguration();
        } catch (NoSuchInputTypeException e) {
            LOG.warn("Cannot launch persisted input. No such type [{}]. Error: {}", isr.type, e);
            return null;
public void unregisterInCluster(MessageInput input) throws ExecutionException, I

        List<InputSummaryResponse> response;
        try {
            Future<Response> f = httpclient.prepareGet(uriBuilder.build().toString()).execute();

            Response r = f.get();

            if (r.getStatusCode() != 200) {
                throw new RuntimeException("Expected HTTP response [200] for list of persisted input but got [" + r.getStatusCode() + "].");
            }
            response = mapper.readValue(r.getResponseBody(), PersistedInputsResponse.class).inputs;
        } catch (IOException e) {
            LOG.error("Unable to get persisted inputs: ", e);
            return result;
public void unregisterInCluster(MessageInput input) throws ExecutionException, I
        for (InputSummaryResponse isr : response) {
            final MessageInput messageInput = getMessageInput(isr);
            if (messageInput != null) {
                messageInput.setPersistId(isr.id);
                result.add(messageInput);
            }
        }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import org.codehaus.plexus.util.FileUtils;
import org.codehaus.plexus.util.IOUtil;

/**
 * @author Denis Cabasson
 * @modifiedBy Qiuliang Tang
     */
    private String password;

    static class CapabilityDirectory {
        public String name;

public void directoryWalkFinished() {
                            final StringBuilder builder = new StringBuilder();
                            try {
                                final ChangeLogScmResult clScmResult = FeaturesReport.this.log(useCase.packageFile,
                                        null);
                                for (final ChangeSet aChangeSet : clScmResult.getChangeLog().getChangeSets()) {
                                    builder.append("\n");
                                    builder.append("Updated from revision ");
public void verbatim_() {
    private File featuresDirectory;

    /**
     * @parameter expression="${project.build.directory}/generated-site/apt"
     * @required
     */
    private File generatedSiteDirectory;

    /**
     * @parameter expression="${basedir}"
     * @required
     * @readonly
public void verbatim_() {

    private final Map<String, String> personas = new HashMap<String, String>();

    private ConfluenceSoapClient confluenceClient;

    @Override
    protected void executeReport(final Locale locale) throws MavenReportException {
protected void executeReport(final Locale locale) throws MavenReportException {
                    confluenceSpaceKey, confluenceUrl);
        }

        if (this.featuresDirectory.exists() && this.featuresDirectory.isDirectory()) {
            final List<String> allIncludes = new ArrayList<String>();
            allIncludes.add("**/package.apt");
protected Boolean generateFeaturePage(final String parentPageTitle, final File f
            }

            // Add revision information
            final ChangeLogScmResult clScmResult = this.log(featureFile, fromVersion);
            if (!clScmResult.getChangeLog().getChangeSets().isEmpty()) { // we have changes
                                                                         // since last version!
                this.getLog().debug("Changes have occured since last Scm Revision");
private ScmRepository getScmRepository(final File file) throws ScmException {
        return repository;
    }

    private ChangeLogScmResult log(final File file, final ScmVersion fromVersion) throws MojoExecutionException {
        final ChangeLogScmResult changeLog;
        try {
            this.getLog().debug("File to generate the changeset : " + file);
            this.getLog().debug("From version : " + fromVersion);
            final ScmRepository repository = this.getScmRepository(file);

            changeLog = this.scmManager.changeLog(repository,
                    new ScmFileSet(new File(file.getParent()), new File(file.getName())), fromVersion, null);
        } catch (final Exception e) {
            throw new MojoExecutionException("Cannot get the branch information from the scm repository : \n"
                    + e.getLocalizedMessage(), e);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import android.view.KeyEvent;
import android.view.View;
import android.widget.Toast;
import co.storyroll.MainApplication;
import co.storyroll.R;
import co.storyroll.base.GcmActivity;
import co.storyroll.model.Profile;
import co.storyroll.util.ServerUtility;
import com.androidquery.auth.BasicHandle;
import com.androidquery.auth.FacebookHandle;
import com.androidquery.callback.AbstractAjaxCallback;
import com.androidquery.callback.AjaxStatus;
import com.google.analytics.tracking.android.Fields;
import com.google.android.gms.gcm.GoogleCloudMessaging;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.json.JSONException;
import org.json.JSONObject;

public void authFacebookSSO(){

        // TODO: refactor
        // hack here
        AbstractAjaxCallback.setSSF( SSLSocketFactory.getSocketFactory() );
		aq.auth(facebookHandle).progress(R.id.progress).ajax(facebookGraphUrl, JSONObject.class, this, "facebookProfileCb");
	}
	
public void facebookProfileCb(String url, JSONObject json, AjaxStatus status) {

        // TODO: refactor
        // hack pt2: restore SSL Factory
        AbstractAjaxCallback.setSSF(MainApplication.getSocketFactory());

    	if (isAjaxErrorThenReport(status)) return;
            
package co.storyroll.activity;

import android.content.ComponentName;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.util.Log;
import android.view.View;
import android.widget.Toast;
import co.storyroll.MainApplication;
import co.storyroll.R;
import co.storyroll.base.MenuActivity;
import co.storyroll.model.Profile;
import co.storyroll.util.PrefUtility;
import co.storyroll.util.ServerUtility;
import com.androidquery.auth.FacebookHandle;
import com.androidquery.callback.AbstractAjaxCallback;
import com.androidquery.callback.AjaxCallback;
import com.androidquery.callback.AjaxStatus;
import com.bugsense.trace.BugSenseHandler;
import com.google.analytics.tracking.android.Fields;
import org.apache.http.HttpEntity;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.entity.ContentType;
import org.apache.http.entity.mime.MultipartEntityBuilder;
import org.json.JSONException;
protected void onCreate(Bundle state) {
		
		Log.v(LOGTAG, "onCreate");
		setContentView(R.layout.activity_profile);
		
		// Fields set on a tracker persist for all hits, until they are
	    // overridden or cleared by assignment to null.
	    getGTracker().set(Fields.SCREEN_NAME, SCREEN_NAME);
public void initAvatar() {
		if (!avatarChangeStarted && !avatarChangeCompleted) 
		{
			// do we have SR avatar?
			if (!TextUtils.isEmpty(profile.getAvatarUrl())) {
				Log.v(LOGTAG, "loading avatar from SR");

				aq.id(R.id.avatar).image(profile.getAvatarUrl(),
						false, false, 0, R.drawable.ic_avatar_default);

else if (profile.isAuthFacebook())

                // TODO: refactor
                // hack here
                AbstractAjaxCallback.setSSF(SSLSocketFactory.getSocketFactory());

				String tb = ImageUtility.getFbProfileTb(handle);
				aq.id(R.id.avatar).image(tb);

                // TODO: refactor
                // hack pt2: restore SSL Factory
                AbstractAjaxCallback.setSSF(MainApplication.getSocketFactory());
			}
		}
		
protected boolean updateProfileGeneral(String url, JSONObject json, AjaxStatus s
        	// upload avatar
    		if (avatarChangeCompleted) 
    		{
                doUploadAvatar(profile.email);
    	        
    		}
    		else {
    			nextActivity();
protected boolean updateProfileGeneral(String url, JSONObject json, AjaxStatus s
        return true;
	}

    private void doUploadAvatar(String email){
        File file = new File(AppUtility.getAppWorkingDir(this)+File.separator+"avatar.jpg");

//        Map params = new HashMap();
//        params.put("file", file);
//        params.put("uuid", email);
//        aq.progress(R.id.progress).ajax(
//                PrefUtility.getApiUrl(ServerUtility.API_AVATAR_SET, null),
//                params, JSONObject.class, this, "setAvatarCb");

        HttpEntity reqEntity = MultipartEntityBuilder.create()
                .addBinaryBody("file", file, APPLICATION_OCTET_STREAM, "avatar.jpg")
                .addTextBody("uuid", email, ContentType.TEXT_PLAIN).build();


        aq.auth(basicHandle).progress(R.id.progress).post(PrefUtility.getApiUrl(ServerUtility.API_AVATAR_SET),
                reqEntity, JSONObject.class, new AjaxCallback<JSONObject>() {

                    @Override
                    public void callback(String url, JSONObject json, AjaxStatus status) {
                        Log.v(LOGTAG, "callback: json=" + json == null ? "null" : json.toString());
                        setAvatarCb(url, json, status);
                    }
                });
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void execute() {
        LOG.info("Calculating ranges for index {}.", indexName);
        try {
            final Map<String, Object> range;
            if (deflector.getCurrentActualTargetIndex().equals(indexName))
                range = calculateRange(indexName);
            else
                range = getDeflectorIndexRange(indexName);

            final IndexRange indexRange = indexRangeService.create(range);
            indexRangeService.destroy(indexName);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void renderPlatforms(GraphicsContext painter) {
  }
  
  private void renderFruits(GraphicsContext painter) {
    for (Fruit current : game.getCurrentLevel().getFruits()) {
      painter.drawImage(new Image(Constants.FRUIT_SPRITE),  current.getPosition().getX(),
          current.getPosition().getY());
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
package net.kuujo.vertigo.component.impl;

import java.util.ArrayList;
import java.util.List;

import net.kuujo.vertigo.VertigoException;
import net.kuujo.vertigo.message.MessageId;
import net.kuujo.vertigo.output.OutputCollector;
import net.kuujo.vertigo.output.impl.DefaultOutputCollector;
import net.kuujo.vertigo.context.ComponentContext;
import net.kuujo.vertigo.context.InstanceContext;
import net.kuujo.vertigo.context.NetworkContext;
import net.kuujo.vertigo.coordinator.heartbeat.HeartbeatEmitter;
import net.kuujo.vertigo.coordinator.heartbeat.impl.DefaultHeartbeatEmitter;
import net.kuujo.vertigo.hooks.ComponentHook;
import net.kuujo.vertigo.hooks.InputHook;
import net.kuujo.vertigo.hooks.OutputHook;
import org.vertx.java.core.eventbus.EventBus;
import org.vertx.java.core.eventbus.Message;
import org.vertx.java.core.impl.DefaultFutureResult;
import org.vertx.java.core.json.JsonObject;
import org.vertx.java.core.logging.Logger;
import org.vertx.java.core.logging.impl.LoggerFactory;
  protected final String instanceId;
  protected final String address;
  protected final String networkAddress;
  protected final HeartbeatEmitter heartbeat;
  protected final InputCollector input;
  protected final OutputCollector output;
  protected final List<ComponentHook> hooks = new ArrayList<>();

  private InputHook inputHook = new InputHook() {
    @Override
protected AbstractComponent(Vertx vertx, Container container, InstanceContext<T>
    this.address = context.componentContext().address();
    NetworkContext networkContext = context.componentContext().networkContext();
    networkAddress = networkContext.address();
    heartbeat = new DefaultHeartbeatEmitter(vertx);
    input = new DefaultInputCollector(vertx, container, context, acker);
    output = new DefaultOutputCollector(vertx, container, context, acker);
    for (ComponentHook hook : context.<ComponentContext<?>>componentContext().hooks()) {
private void hookStart() {
    }
  }

  @Override
  @SuppressWarnings("unchecked")
  public T declareSchema(MessageSchema schema) {
private void setup(Handler<AsyncResult<Void>> doneHandler) {
      future.setHandler(doneHandler);
    }

    setupHeartbeat(new Handler<AsyncResult<Void>>() {
      @Override
      public void handle(AsyncResult<Void> result) {
        if (result.failed()) {
          future.setFailure(result.cause());
        }
        else {
          acker.start(new Handler<AsyncResult<Void>>() {
            @Override
            public void handle(AsyncResult<Void> result) {
              if (result.failed()) {
                future.setFailure(result.cause());
              }
              else {
                output.start(new Handler<AsyncResult<Void>>() {
                  @Override
                  public void handle(AsyncResult<Void> result) {
                    if (result.failed()) {
                      future.setFailure(result.cause());
                    }
                    else {
                      input.start(new Handler<AsyncResult<Void>>() {
                        @Override
                        public void handle(AsyncResult<Void> result) {
                          if (result.failed()) {
                            future.setFailure(result.cause());
                          }
                          else {
                            ready(new Handler<AsyncResult<Void>>() {
                              @Override
                              public void handle(AsyncResult<Void> result) {
                                if (result.failed()) {
                                  future.setFailure(result.cause());
                                }
                                else {
                                  future.setResult(null);
                                }
                              }
                            });
                          }
                        }
                      });
public void handle(AsyncResult<Void> result) {
  }

  /**
   * Sets up the heartbeat.
   */
  private void setupHeartbeat(Handler<AsyncResult<Void>> doneHandler) {
    final Future<Void> future = new DefaultFutureResult<Void>();
    if (doneHandler != null) {
      future.setHandler(doneHandler);
    }

    eventBus.sendWithTimeout(networkAddress, new JsonObject().putString("action", "register").putString("address", address), 10000, new Handler<AsyncResult<Message<String>>>() {
      @Override
      public void handle(AsyncResult<Message<String>> result) {
        if (result.succeeded()) {
          String heartbeatAddress = result.result().body();
          heartbeat.setAddress(heartbeatAddress);
          heartbeat.setInterval(context.componentContext().heartbeatInterval());
          heartbeat.start();
          future.setResult(null);
        }
        else {
          future.setFailure(new VertigoException("Failed to fetch heartbeat address from network."));
        }
      }
    });
  }

  /**
   * Indicates to the network that the component is ready.
   */
  private void ready(Handler<AsyncResult<Void>> doneHandler) {
    final Future<Void> future = new DefaultFutureResult<Void>();
    if (doneHandler != null) {
      future.setHandler(doneHandler);
    }

    eventBus.send(networkAddress, new JsonObject().putString("action", "ready").putString("id", instanceId), new Handler<Message<Void>>() {
      @Override
      public void handle(Message<Void> message) {
        future.setResult(null);
      }
    });
  }
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;

import net.kuujo.vertigo.auditor.AuditorVerticle;
import net.kuujo.vertigo.context.ComponentContext;
import net.kuujo.vertigo.context.InstanceContext;
import net.kuujo.vertigo.context.ModuleContext;
import net.kuujo.vertigo.context.NetworkContext;
import net.kuujo.vertigo.context.VerticleContext;
import net.kuujo.vertigo.coordinator.heartbeat.HeartbeatMonitor;
import net.kuujo.vertigo.coordinator.heartbeat.impl.DefaultHeartbeatMonitor;
import net.kuujo.vertigo.events.Events;
import net.kuujo.vertigo.serializer.SerializationException;

  protected Events events;
  protected Map<String, String> deploymentMap = new HashMap<>();
  protected Map<String, InstanceContext<?>> contextMap = new HashMap<>();
  protected Map<String, HeartbeatMonitor> heartbeats = new HashMap<>();
  protected Set<String> instances = new HashSet<>();
  protected Map<String, Message<JsonObject>> ready = new HashMap<>();
  protected Set<String> auditorDeploymentIds = new HashSet<>();

  @Override
public void handle(Message<JsonObject> message) {
    String action = getMandatoryString("action", message);
    if (action != null) {
      switch (action) {
        case "register":
          doRegister(message);
          break;
        case "unregister":
          doUnregister(message);
          break;
        case "shutdown":
          doShutdown(message);
          break;
        case "redeploy":
          doRedeployAll(message);
          break;
        case "ready":
          doReady(message);
          break;
        default:
          sendError(message, String.format("Invalid action %!s(MISSING).", action));
          break;
public void handle(AsyncResult<String> result) {
  }

  /**
   * Creates a unique heartbeat address.
   */
  private String createHeartbeatAddress() {
    return UUID.randomUUID().toString();
  }

  /**
   * Registers a heartbeat.
   */
  private void doRegister(Message<JsonObject> message) {
    final String address = getMandatoryString("address", message);
    if (logger.isDebugEnabled()) {
      logger.debug(String.format("Registering heartbeat: %!s(MISSING)", address));
    }
    String heartbeatAddress = createHeartbeatAddress();
    HeartbeatMonitor monitor = new DefaultHeartbeatMonitor(heartbeatAddress, vertx);
    monitor.listen(new Handler<String>() {
      @Override
      public void handle(String heartbeatAddress) {
        if (heartbeats.containsKey(address)) {
          heartbeats.remove(address);
          doRedeploy(address);
        }
      }
    });
    heartbeats.put(address, monitor);
    message.reply(heartbeatAddress);
  }

  /**
   * Unregisters a heartbeat.
   */
  private void doUnregister(Message<JsonObject> message) {
    final String address = getMandatoryString("address", message);
    if (logger.isDebugEnabled()) {
      logger.debug(String.format("Unregistering heartbeat: %!s(MISSING)", address));
    }
    if (heartbeats.containsKey(address)) {
      HeartbeatMonitor monitor = heartbeats.get(address);
      monitor.unlisten();
      heartbeats.remove(address);
    }
    doRedeploy(address);
  }

  /**
   * Redeploys a worker.
   */
  private void doRedeploy(final String id) {
    if (deploymentMap.containsKey(id)) {
      if (logger.isDebugEnabled()) {
        logger.debug(String.format("Redeploying %!s(MISSING)", id));
      }
      String deploymentID = deploymentMap.get(id);
      undeployVerticle(deploymentID, new Handler<AsyncResult<Void>>() {
        @Override
        public void handle(AsyncResult<Void> result) {
          deploymentMap.remove(id);
          if (contextMap.containsKey(id)) {
            final InstanceContext<?> context = contextMap.get(id);

            JsonObject config;
            try {
              config = InstanceContext.toJson(context);
            }
            catch (SerializationException e) {
              logger.error(String.format("Failed to deploy %!s(MISSING) instance %!s(MISSING).", context.componentContext().address(), context.address()));
              return;
            }

            if (context.componentContext().isModule()) {
              deployModule(context.<ModuleContext>componentContext().module(), config, new Handler<AsyncResult<String>>() {
                @Override
                public void handle(AsyncResult<String> result) {
                  if (result.succeeded()) {
                    deploymentMap.put(context.address(), result.result());
                  }
                  else {
                    logger.error(String.format("Failed to deploy %!s(MISSING) instance %!s(MISSING).", context.componentContext().address(), context.address()));
                  }
                }
              });
            }
            else if (context.componentContext().isVerticle()) {
              if (context.<VerticleContext>componentContext().isWorker()) {
                deployWorkerVerticle(context.<VerticleContext>componentContext().main(), config, context.<VerticleContext>componentContext().isMultiThreaded(), new Handler<AsyncResult<String>>() {
                  @Override
                  public void handle(AsyncResult<String> result) {
                    if (result.succeeded()) {
                      deploymentMap.put(context.address(), result.result());
                    }
                    else {
                      logger.error(String.format("Failed to deploy %!s(MISSING) instance %!s(MISSING).", context.componentContext().address(), context.address()));
                    }
                  }
                });
              }
              else {
                deployVerticle(context.<VerticleContext>componentContext().main(), config, new Handler<AsyncResult<String>>() {
                  @Override
                  public void handle(AsyncResult<String> result) {
                    if (result.succeeded()) {
                      deploymentMap.put(context.address(), result.result());
                    }
                    else {
                      logger.error(String.format("Failed to deploy %!s(MISSING) instance %!s(MISSING).", context.componentContext().address(), context.address()));
                    }
                  }
                });
              }
            }
          }
        }
      });
    }
  }

  /**
   * Shuts down the network.
   */
  private void doShutdown(final Message<JsonObject> message) {
public void handle(AsyncResult<Void> result) {
  }

  /**
   * Redeploys the entire network.
   */
  private void doRedeployAll(final Message<JsonObject> message) {
    new RecursiveDeployer(context).undeploy(new Handler<AsyncResult<Void>>() {
      @Override
      public void handle(AsyncResult<Void> result) {
        new RecursiveDeployer(context).deploy(new Handler<AsyncResult<Void>>() {
          @Override
          public void handle(AsyncResult<Void> result) {
            message.reply(result.succeeded());
          }
        });
      }
    });
  }

  /**
   * Indicates that a component instance is ready.
   */
  private void doReady(Message<JsonObject> message) {
    String id = getMandatoryString("id", message);
    if (id != null) {
      ready.put(id, message);
      if (logger.isDebugEnabled()) {
        logger.debug(String.format("%!s(MISSING) is ready", id));
      }
      InstanceContext<?> context = contextMap.get(id);
      events.trigger(Events.Component.Start.class, context.componentContext().address(), context);
      if (ready.size() == instances.size()) {
        if (logger.isInfoEnabled()) {
          logger.info("Starting components");
        }
        events.trigger(Events.Network.Start.class, this.context.address(), this.context);
        for (Message<JsonObject> replyMessage : ready.values()) {
          replyMessage.reply();
        }
      }
    }
  }

  /**
   * Recursively deploys all network components.
   *
   * @author Jordan Halterman
/*
 * Copyright 2013 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.kuujo.vertigo.coordinator.heartbeat;

/**
 * A heartbeat emitter.
 *
 * @author Jordan Halterman
 */
public interface HeartbeatEmitter {

  /**
   * Sets the heartbeat emitter address.
   *
   * @param address
   *   The address to which to emit heartbeats.
   * @return
   *   The heartbeat emitter instance.
   */
  HeartbeatEmitter setAddress(String address);

  /**
   * Gets the heartbeat address.
   *
   * @return
   *   The heartbeat address.
   */
  String getAddress();

  /**
   * Sets the heartbeat interval.
   *
   * @param interval
   *   The heartbeat interval. This is the interval at which heartbeats will
   *   be emitted.
   * @return
   *   The heartbeat emitter instance.
   */
  HeartbeatEmitter setInterval(long interval);

  /**
   * Gets the heartbeat interval.
   *
   * @return
   *   The heartbeat interval.
   */
  long getInterval();

  /**
   * Starts emitting heartbeats at an address.
   */
  void start();

  /**
   * Stops emitting heartbeats to an address.
   */
  void stop();

}
/*
 * Copyright 2013 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.kuujo.vertigo.coordinator.heartbeat;

import org.vertx.java.core.Handler;

/**
 * A heartbeat monitor.
 *
 * @author Jordan Halterman
 */
public interface HeartbeatMonitor {

  /**
   * Sets the heartbeat monitor address.
   *
   * @param address
   *   The address at which to monitor for heartbeats.
   * @return
   *   The called monitor instance.
   */
  HeartbeatMonitor setAddress(String address);

  /**
   * Gets the heartbeat monitor address.
   *
   * @return
   *   The heartbeat monitor address.
   */
  String getAddress();

  /**
   * Sets the required heartbeat interval.
   *
   * @param interval
   *   The required heartbeat interval. If this interval is reached between any
   *   heartbeat then the heartbeat will be considered failed.
   * @return
   *   The called monitor instance.
   */
  HeartbeatMonitor setRequiredInterval(long interval);

  /**
   * Returns the required heartbeat interval.
   *
   * @return
   *   The required heartbeat interval.
   */
  long getRequiredInterval();

  /**
   * Starts monitoring heartbeats at the given address.
   *
   * @param failHandler
   *   A handler to be invoked if heartbeats fail.
   */
  void listen(Handler<String> failHandler);

  /**
   * Stops monitoring heartbeats at the given address.
   */
  void unlisten();

}
/*
 * Copyright 2013 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.kuujo.vertigo.coordinator.heartbeat.impl;

import net.kuujo.vertigo.coordinator.heartbeat.HeartbeatEmitter;

import org.vertx.java.core.Handler;
import org.vertx.java.core.Vertx;
import org.vertx.java.core.eventbus.EventBus;

/**
 * Default heartbeat emitter implementation.
 *
 * @author Jordan Halterman
 */
public class DefaultHeartbeatEmitter implements HeartbeatEmitter {
  private String address;
  private Vertx vertx;
  private EventBus eventBus;
  private long interval = 1000;
  private long timerID;

  public DefaultHeartbeatEmitter(Vertx vertx) {
    this.vertx = vertx;
    this.eventBus = vertx.eventBus();
  }

  public DefaultHeartbeatEmitter(String address, Vertx vertx) {
    this.address = address;
    this.vertx = vertx;
    this.eventBus = vertx.eventBus();
  }

  @Override
  public HeartbeatEmitter setAddress(String address) {
    this.address = address;
    return this;
  }

  @Override
  public String getAddress() {
    return address;
  }

  @Override
  public HeartbeatEmitter setInterval(long interval) {
    this.interval = interval;
    return this;
  }

  @Override
  public long getInterval() {
    return interval;
  }

  @Override
  public void start() {
    timerID = vertx.setPeriodic(interval, new Handler<Long>() {
      @Override
      public void handle(Long event) {
        eventBus.send(address, true);
      }
    });
  }

  @Override
  public void stop() {
    if (timerID != 0) {
      vertx.cancelTimer(timerID);
    }
  }

}
/*
 * Copyright 2013 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.kuujo.vertigo.coordinator.heartbeat.impl;

import net.kuujo.vertigo.coordinator.heartbeat.HeartbeatMonitor;

import org.vertx.java.core.Handler;
import org.vertx.java.core.Vertx;
import org.vertx.java.core.eventbus.EventBus;
import org.vertx.java.core.eventbus.Message;

/**
 * Default heartbeat monitor implementation.
 *
 * @author Jordan Halterman
 */
public class DefaultHeartbeatMonitor implements HeartbeatMonitor {
  private String address;
  private Vertx vertx;
  private EventBus eventBus;
  private long interval = 5000;
  private AddressMonitor currentMonitor;

  public DefaultHeartbeatMonitor(Vertx vertx) {
    this.vertx = vertx;
    this.eventBus = vertx.eventBus();
  }

  public DefaultHeartbeatMonitor(String address, Vertx vertx) {
    this.address = address;
    this.vertx = vertx;
    this.eventBus = vertx.eventBus();
  }

  @Override
  public HeartbeatMonitor setAddress(String address) {
    this.address = address;
    return this;
  }

  @Override
  public String getAddress() {
    return address;
  }

  @Override
  public HeartbeatMonitor setRequiredInterval(long interval) {
    this.interval = interval;
    return this;
  }

  @Override
  public long getRequiredInterval() {
    return interval;
  }

  @Override
  public void listen(Handler<String> timeoutHandler) {
    if (currentMonitor != null) {
      currentMonitor.stop();
    }
    currentMonitor = new AddressMonitor(address, timeoutHandler);
    currentMonitor.start();
  }

  @Override
  public void unlisten() {
    if (currentMonitor != null) {
      currentMonitor.stop();
      currentMonitor = null;
    }
  }

  /**
  * A monitor on a single address.
  */
  private class AddressMonitor {
    private String address;
    private Handler<String> timeoutHandler;
    private long timerID;

    private Handler<Message<Boolean>> handler = new Handler<Message<Boolean>>() {
      @Override
      public void handle(Message<Boolean> message) {
        resetTimer();
      }
    };

    public AddressMonitor(String address, Handler<String> timeoutHandler) {
      this.address = address;
      this.timeoutHandler = timeoutHandler;
    }

    /**
    * Starts the monitor.
    */
    private void start() {
      eventBus.registerHandler(address, handler);
    }

    /**
    * Stops the monitor.
    */
    private void stop() {
      eventBus.unregisterHandler(address, handler);
      if (timerID != 0) {
        vertx.cancelTimer(timerID);
      }
    }

    /**
    * Resets the monitor timer.
    */
    private void resetTimer() {
      // First, cancel the old timer.
      if (timerID != 0) {
        vertx.cancelTimer(timerID);
      }
      // Then, create a new timer that triggers the timeoutHandler if called.
      timerID = vertx.setTimer(interval, new Handler<Long>() {
        @Override
        public void handle(Long event) {
          eventBus.unregisterHandler(address, handler);
          timeoutHandler.handle(address);
        }
      });
    }
  }

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import co.cask.cdap.common.conf.PropertyUpdater;
import co.cask.cdap.common.io.Codec;
import co.cask.cdap.common.io.Locations;
import co.cask.cdap.data2.transaction.stream.AbstractStreamFileAdmin;
import co.cask.cdap.data2.transaction.stream.StreamAdmin;
import co.cask.cdap.data2.transaction.stream.StreamConfig;
import co.cask.cdap.internal.io.SchemaTypeAdapter;
import com.google.common.base.Charsets;
import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.base.Preconditions;
import com.google.common.base.Supplier;
import com.google.common.base.Suppliers;
import com.google.common.io.CharStreams;
import com.google.common.util.concurrent.AbstractIdleService;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.gson.GsonBuilder;
import org.apache.twill.common.Cancellable;
import org.apache.twill.common.Threads;
import org.apache.twill.filesystem.Location;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public Integer apply(StreamProperty property) {
  }

  @Override
  public ListenableFuture<Long> changeTTL(final StreamConfig streamConfig, final long newTTL) {
    return Futures.transform(propertyStore.get().update(streamConfig.getName(), new PropertyUpdater<StreamProperty>() {
      @Override
      public ListenableFuture<StreamProperty> apply(@Nullable final StreamProperty property) {
        final SettableFuture<StreamProperty> resultFuture = SettableFuture.create();
public Integer apply(StreamProperty property) {
          @Override
          public void run() {
            try {
              int currentGeneration = (property == null) ?
                StreamUtils.getGeneration(streamConfig) :
                property.getGeneration();
              int currentThreshold = (property == null) ?
                streamConfig.getNotificationThresholdMB() :
                property.getThreshold();

              StreamConfig newConfig = new StreamConfig(streamConfig.getName(), streamConfig.getPartitionDuration(),
                                                        streamConfig.getIndexInterval(), newTTL,
                                                        streamConfig.getLocation(),
                                                        streamConfig.getFormat(),
                                                        currentThreshold);
              saveConfig(newConfig);
              resultFuture.set(new StreamProperty(currentGeneration, newTTL, currentThreshold));
            } catch (IOException e) {
              resultFuture.setException(e);
public Long apply(StreamProperty property) {
  }

  @Override
  public ListenableFuture<Integer> changeThreshold(final StreamConfig streamConfig, final int newThreshold) {
    return Futures.transform(propertyStore.get().update(streamConfig.getName(), new PropertyUpdater<StreamProperty>() {
      @Override
      public ListenableFuture<StreamProperty> apply(@Nullable final StreamProperty property) {
        final SettableFuture<StreamProperty> resultFuture = SettableFuture.create();
public Long apply(StreamProperty property) {
          @Override
          public void run() {
            try {
              int currentGeneration = (property == null) ?
                StreamUtils.getGeneration(streamConfig) :
                property.getGeneration();
              long currentTTL = (property == null) ?
                streamConfig.getTTL() :
                property.getTTL();

              StreamConfig newConfig = new StreamConfig(streamConfig.getName(), streamConfig.getPartitionDuration(),
                                                        streamConfig.getIndexInterval(), currentTTL,
                                                        streamConfig.getLocation(),
                                                        streamConfig.getFormat(),
                                                        newThreshold);
              saveConfig(newConfig);
              resultFuture.set(new StreamProperty(currentGeneration, currentTTL, newThreshold));
            } catch (IOException e) {
              resultFuture.setException(e);
protected final void shutDown() throws Exception {
  protected abstract void doShutDown() throws Exception;

  /**
   * Overwrites a stream config file.
   *
   * @param config The new configuration.
   */
  private void saveConfig(StreamConfig config) throws IOException {
    Location configLocation = config.getLocation().append(AbstractStreamFileAdmin.CONFIG_FILE_NAME);
    Location tempLocation = configLocation.getTempFile("tmp");
    try {
      CharStreams.write(GSON.toJson(config), CharStreams.newWriterSupplier(
        Locations.newOutputSupplier(tempLocation), Charsets.UTF_8));

      Preconditions.checkState(tempLocation.renameTo(configLocation) != null,
                               "Rename {} to {} failed", tempLocation, configLocation);
    } finally {
      if (tempLocation.exists()) {
        tempLocation.delete();
      }
    }
  }

  /**
   * Object for holding property value in the property store.
   */
  private static final class StreamProperty {
  /**
   * Changes the TTL of the given stream.
   *
   * @param streamConfig stream configuration
   * @param ttl the new TTL
   * @return A future that will be completed when the update of TTL is done. The future result will carry
   *         the TTL updated by this method.
   */
  ListenableFuture<Long> changeTTL(StreamConfig streamConfig, long ttl);

  /**
   * Changes the notification threshold of the given stream.
   *
   * @param streamConfig stream configuration
   * @param threshold the new notification threshold
   * @return A future that will be completed when the update of threshold is done. The future result will carry
   *         the threshold updated by this method.
   */
  ListenableFuture<Integer> changeThreshold(StreamConfig streamConfig, int threshold);

  /**
   * Receives event for changes in stream properties.
public void updateConfig(StreamConfig config) throws IOException {
                                  "(can only update ttl, format or threshold)",
                                config.getName());

    if (originalConfig.getTTL() != config.getTTL()) {
      // This call will also save the config
      streamCoordinatorClient.changeTTL(originalConfig, config.getTTL());
    }
    if (originalConfig.getNotificationThresholdMB() != config.getNotificationThresholdMB()) {
      // This call will also save the config
      streamCoordinatorClient.changeThreshold(originalConfig, config.getNotificationThresholdMB());
    }
    if (!originalConfig.getFormat().equals(config.getFormat())) {
      saveConfig(config);
    }
  }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private boolean dontSendMultipart = false;
    SortedSet<Long> pendingSequences;
    Long maxPendingSequence;
    final Object changesLock = new Object();
    boolean doneBeginReplicating = false;
    List<RevisionInternal> queueChanges = new ArrayList<RevisionInternal>();
protected void goOffline() {
     */
    @InterfaceAudience.Private
    private void addPending(RevisionInternal revisionInternal) {
        long seq = revisionInternal.getSequence();
        pendingSequences.add(seq);
        if (seq > maxPendingSequence) {
            maxPendingSequence = seq;
        }
    }

private void addPending(RevisionInternal revisionInternal) {
     */
    @InterfaceAudience.Private
    private void removePending(RevisionInternal revisionInternal) {
        long seq = revisionInternal.getSequence();
        if (pendingSequences == null || pendingSequences.isEmpty()) {
            Log.w(Log.TAG_SYNC, "%!s(MISSING): removePending() called w/ rev: %!s(MISSING), but pendingSequences empty",
                    this, revisionInternal);
            if(revisionInternal.getBody()!=null)
                revisionInternal.getBody().release();
            return;
        }
        boolean wasFirst = (seq == pendingSequences.first());
        if (!pendingSequences.contains(seq)) {
            Log.w(Log.TAG_SYNC, "%!s(MISSING): removePending: sequence %!s(MISSING) not in set, for rev %!s(MISSING)",
                    this, seq, revisionInternal);
        }
        pendingSequences.remove(seq);
        if (wasFirst) {
            // If I removed the first pending sequence, can advance the checkpoint:
            long maxCompleted;
            if (pendingSequences.size() == 0) {
                maxCompleted = maxPendingSequence;
            } else {
                maxCompleted = pendingSequences.first();
                --maxCompleted;
            }
            setLastSequence(Long.toString(maxCompleted));
        }
        if (revisionInternal.getBody() != null)
            revisionInternal.getBody().release();
    }

    /**
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void configure() throws Exception {
         * queue.
         */
        from("jms:queue:OrdersQueue")
                .unmarshal(jaxbDataFormat)
                .to("jpa:Order")
                .choice()
                .when(simple("${body.quantity} > 10"))
                    .log("Order quantity is greater than 10 - rolling back transaction!")
limitations under the License.
        http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd">
    <persistence-unit name="camel">
        <jta-data-source>java:jboss/datasources/ExampleDS</jta-data-source>
        <class>org.wildfly.camel.examples.jms.transacted.model.Order</class>
        <properties>
            <property name="hibernate.hbm2ddl.auto" value="create-drop"/>
            <property name="hibernate.show_sql" value="true"/>
package org.wildfly.camel.test.activemq;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;

import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.container.test.api.RunAsClient;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.spec.WebArchive;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.wildfly.camel.test.common.http.HttpRequest;
import org.wildfly.camel.test.common.http.HttpRequest.HttpResponse;

@RunAsClient
@RunWith(Arquillian.class)
public class ActiveMQExampleTest {

    private File destination = new File(System.getProperty("jboss.home") + "/standalone/data/orders");

    @Deployment
    public static WebArchive createDeployment() {
        return ShrinkWrap.createFromZipFile(WebArchive.class, new File("target/examples/example-camel-activemq.war"));
    }

    @Before
    public void setUp() {
        destination.toPath().toFile().mkdirs();
    }

    @After
    public void tearDown() throws IOException {
        if (destination.toPath().toFile().exists()) {
            Files.walkFileTree(destination.toPath(), new SimpleFileVisitor<Path>() {
                @Override
                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                    Files.delete(file);
                    return FileVisitResult.CONTINUE;
                }

                @Override
                public FileVisitResult visitFileFailed(Path file, IOException exception) throws IOException {
                    exception.printStackTrace();
                    return FileVisitResult.CONTINUE;
                }

                @Override
                public FileVisitResult postVisitDirectory(Path dir, IOException exception) throws IOException {
                    if (exception == null) {
                        Files.delete(dir);
                    }
                    return FileVisitResult.CONTINUE;
                }
            });
        }
    }

    @Test
    public void testFileToActiveMQRoute() throws Exception {
        InputStream input = getClass().getResourceAsStream("/activemq/order.xml");
        Path targetPath = destination.toPath().resolve("order.xml");
        Files.copy(input, targetPath);
        input.close();

        // Give camel a chance to consume the test order file
        Thread.sleep(2000);

        HttpResponse result = HttpRequest.get(getEndpointAddress("/example-camel-activemq/orders")).getResponse();
        Assert.assertTrue(result.getBody().contains("UK: 1"));
    }

    private String getEndpointAddress(String contextPath) throws MalformedURLException {
        return "http://localhost:8080" + contextPath;
    }
}
package org.wildfly.camel.test.jms;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;

import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.container.test.api.RunAsClient;
import org.jboss.as.arquillian.container.ManagementClient;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.spec.WebArchive;
import org.junit.After;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.wildfly.camel.test.common.http.HttpRequest;
import org.wildfly.camel.test.common.http.HttpRequest.HttpResponse;
import org.wildfly.camel.test.common.utils.JMSUtils;

@RunAsClient
@RunWith(Arquillian.class)
@ServerSetup({ JMSExampleTest.JmsQueueSetup.class })
public class JMSExampleTest {

    private static String ORDERS_QUEUE = "OrdersQueue";
    private static String ORDERS_QUEUE_JNDI = "java:/jms/queue/OrdersQueue";
    private File destination = new File(System.getProperty("jboss.home") + "/standalone/data/orders");

    static class JmsQueueSetup implements ServerSetupTask {

public void tearDown(ManagementClient managementClient, String containerId) thro
        }
    }

    @Deployment
    public static WebArchive createDeployment() {
        return ShrinkWrap.createFromZipFile(WebArchive.class, new File("target/examples/example-camel-jms.war"));
    }

    @After
    public void tearDown () throws IOException {
        Files.walkFileTree(destination.toPath(), new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                Files.delete(file);
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult visitFileFailed(Path file, IOException exception) throws IOException {
                exception.printStackTrace();
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult postVisitDirectory(Path dir, IOException exception) throws IOException {
                if (exception == null) {
                    Files.delete(dir);
                }
                return FileVisitResult.CONTINUE;
            }
        });
    }

    @Test
    public void testFileToJmsRoute() throws Exception {
        InputStream input = getClass().getResourceAsStream("/jms/order.xml");
        Files.copy(input, destination.toPath().resolve("order.xml"));
        input.close();

        // Give camel a chance to consume the test order file
        Thread.sleep(2000);

        HttpResponse result = HttpRequest.get(getEndpointAddress("/example-camel-jms/orders")).getResponse();
        Assert.assertTrue(result.getBody().contains("UK: 1"));
    }

    private String getEndpointAddress(String contextPath) throws MalformedURLException {
        return "http://localhost:8080" + contextPath;
    }
}
 * limitations under the License.
 * #L%!
(MISSING) */
package org.wildfly.camel.test.jms;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;

import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.container.test.api.RunAsClient;
import org.jboss.as.arquillian.container.ManagementClient;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.spec.WebArchive;
import org.junit.After;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.wildfly.camel.test.common.http.HttpRequest;
import org.wildfly.camel.test.common.http.HttpRequest.HttpResponse;
import org.wildfly.camel.test.common.utils.JMSUtils;

@RunAsClient
@RunWith(Arquillian.class)
@ServerSetup({ TransactedJMSExampleTest.JmsQueueSetup.class })
public class TransactedJMSExampleTest {

    private static String ORDERS_QUEUE = "OrdersQueue";
    private static String ORDERS_QUEUE_JNDI = "java:/jms/queue/OrdersQueue";
    private File destination = new File(System.getProperty("jboss.home") + "/standalone/data/orders");

    static class JmsQueueSetup implements ServerSetupTask {

public void tearDown(ManagementClient managementClient, String containerId) thro
        }
    }

    @Deployment
    public static WebArchive createDeployment() {
        return ShrinkWrap.createFromZipFile(WebArchive.class, new File("target/examples/example-camel-jms-tx.war"));
    }

    @After
    public void tearDown () throws IOException {
        Files.walkFileTree(destination.toPath(), new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                Files.delete(file);
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult visitFileFailed(Path file, IOException exception) throws IOException {
                exception.printStackTrace();
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult postVisitDirectory(Path dir, IOException exception) throws IOException {
                if (exception == null) {
                    Files.delete(dir);
                }
                return FileVisitResult.CONTINUE;
            }
        });
    }

    @Test
    public void testFileToJmsRoute() throws Exception {
        InputStream input = getClass().getResourceAsStream("/jms/transacted/order.xml");
        Files.copy(input, destination.toPath().resolve("order.xml"));
        input.close();

        // Give camel a chance to consume the test order file
        Thread.sleep(2000);

        HttpResponse result = HttpRequest.get(getEndpointAddress("/example-camel-jms-tx/orders")).getResponse();

        Assert.assertTrue(result.getBody().contains("Test Product"));
    }

    private String getEndpointAddress(String contextPath) throws MalformedURLException {
        return "http://localhost:8080" + contextPath;
    }
}
package org.wildfly.camel.test.jpa;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;

import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.container.test.api.RunAsClient;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.spec.WebArchive;
import org.junit.After;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.wildfly.camel.test.common.http.HttpRequest;
import org.wildfly.camel.test.common.http.HttpRequest.HttpResponse;

@RunAsClient
@RunWith(Arquillian.class)
public class JPAExampleTest {

    private File destination = new File(System.getProperty("jboss.home") + "/standalone/data/customers");

    @Deployment
    public static WebArchive createDeployment() {
        return ShrinkWrap.createFromZipFile(WebArchive.class, new File("target/examples/example-camel-jpa.war"));
    }

    @After
    public void tearDown () throws IOException {
        Files.walkFileTree(destination.toPath(), new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                Files.delete(file);
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult visitFileFailed(Path file, IOException exception) throws IOException {
                exception.printStackTrace();
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult postVisitDirectory(Path dir, IOException exception) throws IOException {
                if (exception == null) {
                    Files.delete(dir);
                }
                return FileVisitResult.CONTINUE;
            }
        });
    }

    @Test
    public void testFileToJpaRoute() throws Exception {
        InputStream input = getClass().getResourceAsStream("/jpa/customer.xml");
        Files.copy(input, destination.toPath().resolve("customer.xml"));
        input.close();

        // Give camel a chance to consume the test customer file
        Thread.sleep(2000);

        HttpResponse result = HttpRequest.get(getEndpointAddress("/example-camel-jpa/customers")).getResponse();
        Assert.assertTrue(result.getBody().contains("John Doe"));
    }

    private String getEndpointAddress(String contextPath) throws MalformedURLException {
        return "http://localhost:8080" + contextPath;
    }
}
    <ord:productName>Test Product</ord:productName>
    <ord:productSku>Test</ord:productSku>
    <ord:quantity>1</ord:quantity>
</ord:order>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      <pax.exam.version>4.5.0</pax.exam.version>
      <pax.url.version>2.4.1</pax.url.version>
      <slf4j.version>1.7.12</slf4j.version>
      <felix.bundle.plugin.version>2.5.3</felix.bundle.plugin.version>
      <felix.version>5.0.0</felix.version>
   </properties>
         <version>${slf4j.version}</version>
      </dependency>
      <dependency>
         <groupId>org.slf4j</groupId>
         <artifactId>slf4j-simple</artifactId>
         <version>${slf4j.version}</version>
         <optional>true</optional>
      </dependency>
      <dependency>
         <groupId>org.mockito</groupId>
         <version>${hibernate.version}</version>
         <scope>provided</scope>
         <optional>true</optional>
      </dependency>
      <dependency>
         <groupId>io.dropwizard.metrics</groupId>
                  <argLine>${surefireArgLine}</argLine>
                  <!-- Skips unit tests if the value of skip.unit.tests property is true -->
                  <skipTests>${skip.unit.tests}</skipTests>
               </configuration>
            </plugin>


package com.zaxxer.hikari.pool;

import static com.zaxxer.hikari.util.ConcurrentBag.IConcurrentBagEntry.STATE_IN_USE;
import static com.zaxxer.hikari.util.ConcurrentBag.IConcurrentBagEntry.STATE_NOT_IN_USE;
import static com.zaxxer.hikari.util.ConcurrentBag.IConcurrentBagEntry.STATE_REMOVED;
import static com.zaxxer.hikari.util.UtilityElf.createThreadPoolExecutor;
import static com.zaxxer.hikari.util.UtilityElf.quietlySleep;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.SQLTransientConnectionException;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.FutureTask;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadLocalRandom;
import com.zaxxer.hikari.util.DefaultThreadFactory;
import com.zaxxer.hikari.util.SuspendResumeLock;

/**
 * This is the primary connection pool class that provides the basic
 * pooling behavior for HikariCP.

   private static final ClockSource clockSource = ClockSource.INSTANCE;

   private static final long ALIVE_BYPASS_WINDOW_MS = Long.getLong("com.zaxxer.hikari.aliveBypassWindowMs", TimeUnit.MILLISECONDS.toMillis(500));
   private static final long HOUSEKEEPING_PERIOD_MS = Long.getLong("com.zaxxer.hikari.housekeeping.periodMs", TimeUnit.SECONDS.toMillis(30));

   private static final int POOL_NORMAL = 0;
   private static final int POOL_SUSPENDED = 1;
public HikariPool(final HikariConfig config)
      this.addConnectionExecutor = createThreadPoolExecutor(config.getMaximumPoolSize(), "Hikari connection filler (pool " + poolName + ")", config.getThreadFactory(), new ThreadPoolExecutor.DiscardPolicy());
      this.closeConnectionExecutor = createThreadPoolExecutor(4, "Hikari connection closer (pool " + poolName + ")", config.getThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy());

      if (config.getScheduledExecutorService() == null) {
         ThreadFactory threadFactory = config.getThreadFactory() != null ? config.getThreadFactory() : new DefaultThreadFactory("Hikari housekeeper (pool " + poolName + ")", true);
         this.houseKeepingExecutorService = new ScheduledThreadPoolExecutor(1, threadFactory, new ThreadPoolExecutor.DiscardPolicy());
public void setHealthCheckRegistry(Object healthCheckRegistry)
   @Override
   public Future<Boolean> addBagItem()
   {
      FutureTask<Boolean> future = new FutureTask<>(new Runnable() {
         @Override
         public void run()
         {
            long sleepBackoff = 200L;
            final int minimumIdle = config.getMinimumIdle();
            final int maxPoolSize = config.getMaximumPoolSize();
            while (poolState == POOL_NORMAL && totalConnections.get() < maxPoolSize && getIdleConnections() <= minimumIdle && !addConnection()) {
               // If we got into the loop, addConnection() failed, so we sleep and retry
               quietlySleep(sleepBackoff);
               sleepBackoff = Math.min(connectionTimeout / 2, (long) (sleepBackoff * 1.3));
            }
         }
      }, true);

      addConnectionExecutor.execute(future);
      return future;
   }

   // ***********************************************************************
final void logPoolState(String... prefix)
    *
    * @param poolEntry the PoolBagEntry to release back to the pool
    */
   final void releaseConnection(final PoolEntry poolEntry)
   {
      metricsTracker.recordConnectionUsage(poolEntry);
public void run() {
   /**
    * Create and add a single connection to the pool.
    */
   private boolean addConnection()
   {
      // Speculative increment of totalConnections with expectation of success
      if (totalConnections.incrementAndGet() > config.getMaximumPoolSize()) {
         totalConnections.decrementAndGet(); // Pool is maxed out, so undo speculative increment of totalConnections
         //LOGGER.debug("{} - Cannot exceed maximum connections capacity: {}", poolName, config.getMaximumPoolSize());
         return true;
      }

      try {
         final PoolEntry poolEntry = newPoolEntry();
         connectionBag.add(poolEntry);

         final long maxLifetime = config.getMaxLifetime();
         if (maxLifetime > 0) {
public void run() {
         }

         LOGGER.debug("{} - Added connection {}", poolName, poolEntry.connection);
         return true;
      }
      catch (Exception e) {
         totalConnections.decrementAndGet(); // We failed, so undo speculative increment of totalConnections
         if (poolState == POOL_NORMAL) {
            LOGGER.debug("{} - Cannot acquire connection from data source", poolName, e);
         }
         return false;
      }
   }

private void initializeConnections()
   {
      if (config.isInitializationFailFast()) {
         try {
            if (!addConnection()) {
               throw getLastConnectionFailure();
            }

            final PoolEntry poolEntry = connectionBag.borrow(connectionTimeout, TimeUnit.MILLISECONDS);
            if (config.getMinimumIdle() == 0) {
               closeConnection(poolEntry, "Closing connection borrowed for validation.");
            }
            else {
               connectionBag.requite(poolEntry);
            }
         }
         catch (Throwable e) {
protected void update() {
   //                      Non-anonymous Inner-classes
   // ***********************************************************************

   /**
    * The house keeping task to retire idle connections.
    */
package com.zaxxer.hikari.pool;

import static com.zaxxer.hikari.util.UtilityElf.createInstance;
import static com.zaxxer.hikari.pool.ProxyConnection.DIRTY_BIT_CATALOG;
import static com.zaxxer.hikari.pool.ProxyConnection.DIRTY_BIT_READONLY;
import static com.zaxxer.hikari.pool.ProxyConnection.DIRTY_BIT_ISOLATION;
import static com.zaxxer.hikari.pool.ProxyConnection.DIRTY_BIT_AUTOCOMMIT;
import static com.zaxxer.hikari.pool.ProxyConnection.DIRTY_BIT_NETTIMEOUT;

import java.lang.management.ManagementFactory;
import java.sql.Connection;
   private final boolean isIsolateInternalQueries;
   private final AtomicReference<Throwable> lastConnectionFailure;

   private volatile boolean isValidChecked; 

   PoolBase(final HikariConfig config)
   {
void resetConnectionState(final Connection connection, final ProxyConnection pro
         setNetworkTimeout(connection, networkTimeout);
         resetBits |= DIRTY_BIT_NETTIMEOUT;
      }
      
      if (LOGGER.isDebugEnabled()) {
         LOGGER.debug("{} - Reset ({}) on connection {}", poolName, resetBits != 0 ? stringFromResetBits(resetBits) : "nothing", connection);
      }
   }
   
   void shutdownNetworkTimeoutExecutor()
   {
      if (netTimeoutExecutor != null && netTimeoutExecutor instanceof ThreadPoolExecutor) {
private void createNetworkTimeoutExecutor(final DataSource dataSource, final Str
         ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newCachedThreadPool(threadFactory);
         executor.allowCoreThreadTimeOut(true);
         executor.setKeepAliveTime(15, TimeUnit.SECONDS);
         netTimeoutExecutor = executor; 
      }
   }

private void setLoginTimeout(final DataSource dataSource, final long connectionT
   /**
    * This will create a string for debug logging. Given a set of "reset bits", this
    * method will return a concatenated string, for example:
    * 
    * Input : 0b00110
    * Output: "autoCommit, isolation"  
    *
    * @param bits a set of "reset bits"
    * @return a string of which states were reset
    */
   private String stringFromResetBits(final int bits)
   {
      final StringBuilder sb = new StringBuilder();
      for (int ndx = 0; ndx < RESET_STATES.length; ndx++) { 
         if ( (bits & (0b1 << ndx)) != 0) {
            sb.append(RESET_STATES[ndx]).append(", ");
         }
   private static final Logger LOGGER = LoggerFactory.getLogger(PoolEntry.class);

   static final Comparator<PoolEntry> LASTACCESS_COMPARABLE;
   Connection connection;
   long lastAccessed;
   long lastBorrowed;
         public int compare(final PoolEntry entryOne, final PoolEntry entryTwo) {
            return Long.compare(entryOne.lastAccessed, entryTwo.lastAccessed);
         }
      };      
   }

   PoolEntry(final Connection connection, final PoolBase pool, final boolean isReadOnly, final boolean isAutoCommit)
   {
      this.connection = connection;
      this.hikariPool = (HikariPool) pool;
      this.state = new AtomicInteger(STATE_NOT_IN_USE);
      this.lastAccessed = ClockSource.INSTANCE.currentTime();
      this.openStatements = new FastList<>(Statement.class, 16);
      this.isReadOnly = isReadOnly;
      this.isAutoCommit = isAutoCommit;
   }

   /**
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.zaxxer.hikari.util.ConcurrentBag.IConcurrentBagEntry;

import static com.zaxxer.hikari.util.ConcurrentBag.IConcurrentBagEntry.STATE_NOT_IN_USE;
import static com.zaxxer.hikari.util.ConcurrentBag.IConcurrentBagEntry.STATE_IN_USE;
import static com.zaxxer.hikari.util.ConcurrentBag.IConcurrentBagEntry.STATE_REMOVED;
import static com.zaxxer.hikari.util.ConcurrentBag.IConcurrentBagEntry.STATE_RESERVED;


   private final ThreadLocal<List> threadList;
   private final IBagStateListener listener;
   private volatile boolean closed;

   public interface IConcurrentBagEntry
    *
    * @param listener the IBagStateListener to attach to this bag
    */
   public ConcurrentBag(IBagStateListener listener)
   {
      this.listener = listener;
      this.weakThreadLocals = useWeakThreadLocals();

      this.sharedList = new CopyOnWriteArrayList<>();
      this.synchronizer = new QueuedSequenceSynchronizer();
      if (weakThreadLocals) {
         this.threadList = new ThreadLocal<>(); 
      }
      else {
         this.threadList = new ThreadLocal<List>() {
protected List initialValue()
   /**
    * The method will borrow a BagEntry from the bag, blocking for the
    * specified timeout if none are available.
    * 
    * @param timeout how long to wait before giving up, in units of unit
    * @param timeUnit a <code>TimeUnit</code> determining how to interpret the timeout parameter
    * @return a borrowed instance from the bag or null if a timeout occurs
    * @throws InterruptedException if interrupted while waiting
    */
   @SuppressWarnings("unchecked")
   public T borrow(long timeout, final TimeUnit timeUnit) throws InterruptedException
   {
      // Try the thread-local list first, if there are no blocked threads waiting already
      List<?> list = threadList.get();
      if (weakThreadLocals && list == null) {
         list = new ArrayList<>(16);
         threadList.set(list);
      }

      for (int i = list.size() - 1; i >= 0; i--) {
         final T bagEntry = (T) (weakThreadLocals ? ((WeakReference) list.remove(i)).get() : list.remove(i));
         if (bagEntry != null && bagEntry.compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) {
            return bagEntry;
         }
      }

      // Otherwise, scan the shared list ... for maximum of timeout
public T borrow(long timeout, final TimeUnit timeUnit) throws InterruptedExcepti
      final long startScan = System.nanoTime();
      final long originTimeout = timeout;
      long startSeq;
      do {
         do {
            startSeq = synchronizer.currentSequence();
            for (final T bagEntry : sharedList) {
               if (bagEntry.compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) {
                  return bagEntry;
               }
            }
         } while (startSeq < synchronizer.currentSequence());

         if (addItemFuture == null || addItemFuture.isDone()) {
            addItemFuture = listener.addBagItem();
         }

         timeout = originTimeout - Math.abs(System.nanoTime() - startScan);
      } while (timeout > 100_00L && synchronizer.waitUntilSequenceExceeded(startSeq, timeout));

      return null;
   }
public boolean remove(final T bagEntry)
      if (!removed && !closed) {
         LOGGER.warn("Attempt to remove an object from the bag that does not exist: {}", bagEntry);
      }
      return removed;
   }

public int getCount(final int state)
   /**
    * Get the total number of items in the bag.
    *
    * @return the number of items in the bag 
    */
   public int size()
   {
public void dumpState()
      }
   }

   /**
    * Determine whether to use WeakReferences based on whether there is a
    * custom ClassLoader implementation sitting between this class and the
package com.zaxxer.hikari.pool;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import org.junit.Test;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;

/**
 * @author Matthew Tambara (matthew.tambara@liferay.com)
 */
public class AddConnectionRaceConditionTest
{
   private HikariPool _hikariPool;

   // @Test
   public void testRaceCondition() throws Exception
   {
      HikariConfig config = new HikariConfig();
      config.setMinimumIdle(0);
      config.setMaximumPoolSize(10);
      config.setInitializationFailFast(false);
      config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

      // Initialize HikariPool with no initial connections and room to grow
      try (final HikariDataSource ds = new HikariDataSource(config)) {
         _hikariPool = TestElf.getPool(ds);

         ExecutorService threadPool = Executors.newFixedThreadPool(2);
         for (int i = 0; i < 100000; i++) {
            Future<Exception> submit1 = threadPool.submit(new Callable<Exception>() {
               /** {@inheritDoc} */
               @Override
               public Exception call() throws Exception
               {
                  Connection c2;
                  try {
                     c2 = _hikariPool.getConnection(5000);
                     ds.evictConnection(c2);
                  }
                  catch (SQLException e) {
                     return e;
                  }
                  return null;
               }
            });

            Future<Exception> submit2 = threadPool.submit(new Callable<Exception>() {
               /** {@inheritDoc} */
               @Override
               public Exception call() throws Exception
               {
                  Connection c2;
                  try {
                     c2 = _hikariPool.getConnection(5000);
                     ds.evictConnection(c2);
                  }
                  catch (SQLException e) {
                     return e;
                  }
                  return null;
               }
            });

            if (submit1.get() != null) {
               throw submit1.get();
            }
            if (submit2.get() != null) {
               throw submit2.get();
            }
         }
      }
      catch (Exception e) {
         throw e;
      }
   }
}
   @Test
   public void testAutoCommit() throws SQLException
   {
      HikariDataSource ds = new HikariDataSource();
      ds.setAutoCommit(true);
      ds.setMinimumIdle(1);
      ds.setMaximumPoolSize(1);
      ds.setConnectionTestQuery("VALUES 1");
      ds.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
      ds.addDataSourceProperty("user", "bar");
      ds.addDataSourceProperty("password", "secret");
      ds.addDataSourceProperty("url", "baf");
      ds.addDataSourceProperty("loginTimeout", "10");

      try {
         Connection connection = ds.getConnection();
         Connection unwrap = connection.unwrap(Connection.class);
         connection.setAutoCommit(false);
         connection.close();

         Assert.assertTrue(unwrap.getAutoCommit());
      }
      finally {
         ds.close();
      }
   }

   @Test
   public void testTransactionIsolation() throws SQLException
   {
      HikariDataSource ds = new HikariDataSource();
      ds.setTransactionIsolation("TRANSACTION_READ_COMMITTED");
      ds.setMinimumIdle(1);
      ds.setMaximumPoolSize(1);
      ds.setConnectionTestQuery("VALUES 1");
      ds.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

      try {
         Connection connection = ds.getConnection();
         Connection unwrap = connection.unwrap(Connection.class);
         connection.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
         connection.close();

         Assert.assertEquals(Connection.TRANSACTION_READ_COMMITTED, unwrap.getTransactionIsolation());
      }
      finally {
         ds.close();
      }
   }

public void testIsolation() throws Exception
   @Test
   public void testReadOnly() throws Exception
   {
      HikariDataSource ds = new HikariDataSource();
      ds.setCatalog("test");
      ds.setMinimumIdle(1);
      ds.setMaximumPoolSize(1);
      ds.setConnectionTestQuery("VALUES 1");
      ds.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

      try {
         Connection connection = ds.getConnection();
         Connection unwrap = connection.unwrap(Connection.class);
         connection.setReadOnly(true);
         connection.close();

         Assert.assertFalse(unwrap.isReadOnly());
      }
      finally {
         ds.close();
      }
   }

   @Test
   public void testCatalog() throws SQLException
   {
      HikariDataSource ds = new HikariDataSource();
      ds.setCatalog("test");
      ds.setMinimumIdle(1);
      ds.setMaximumPoolSize(1);
      ds.setConnectionTestQuery("VALUES 1");
      ds.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

      try {
         Connection connection = ds.getConnection();
         Connection unwrap = connection.unwrap(Connection.class);
         connection.setCatalog("other");
         connection.close();

         Assert.assertEquals("test", unwrap.getCatalog());
      }
      finally {
         ds.close();
      }
   }

   @Test
   public void testCommitTracking() throws SQLException
   {
      HikariDataSource ds = new HikariDataSource();
      ds.setAutoCommit(false);
      ds.setMinimumIdle(1);
      ds.setMaximumPoolSize(1);
      ds.setConnectionTestQuery("VALUES 1");
      ds.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

      try {
         Connection connection = ds.getConnection();

         Statement statement = connection.createStatement();
         statement.execute("SELECT something");
         Assert.assertTrue(TestElf.getConnectionCommitDirtyState(connection));

         connection.commit();
         Assert.assertFalse(TestElf.getConnectionCommitDirtyState(connection));

         statement.execute("SELECT something", Statement.NO_GENERATED_KEYS);
         Assert.assertTrue(TestElf.getConnectionCommitDirtyState(connection));

         connection.rollback();
         Assert.assertFalse(TestElf.getConnectionCommitDirtyState(connection));

         ResultSet resultSet = statement.executeQuery("SELECT something");
         Assert.assertTrue(TestElf.getConnectionCommitDirtyState(connection));

         connection.rollback(null);
         Assert.assertFalse(TestElf.getConnectionCommitDirtyState(connection));

         resultSet.updateRow();
         Assert.assertTrue(TestElf.getConnectionCommitDirtyState(connection));

         connection.close();
      }
      finally {
         ds.close();
      }
      
   }
}

public class IsolationTest
{
    @Test
    public void testIsolation() throws SQLException
    {
        HikariDataSource ds = new HikariDataSource();
        ds.setMinimumIdle(1);
        ds.setMaximumPoolSize(1);
        ds.setIsolateInternalQueries(true);
        ds.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

        try
        {
            Connection connection = ds.getConnection();
            connection.close();

            Connection connection2 = ds.getConnection();
            connection2.close();

            Assert.assertNotSame(connection, connection2);
            Assert.assertSame(connection.unwrap(Connection.class), connection2.unwrap(Connection.class));
        }
        finally
        {
            ds.close();
        }
    }

    @Test
    public void testNonIsolation() throws SQLException
    {
        HikariDataSource ds = new HikariDataSource();
        ds.setMinimumIdle(1);
        ds.setMaximumPoolSize(1);
        ds.setIsolateInternalQueries(false);
        ds.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

        try
        {
            Connection connection = ds.getConnection();
            connection.close();

            Connection connection2 = ds.getConnection();
            connection2.close();

            Assert.assertSame(connection.unwrap(Connection.class), connection2.unwrap(Connection.class));
        }
        finally
        {
            ds.close();
        }
    }
}
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import org.junit.Assert;
import org.junit.Test;
import org.slf4j.spi.LocationAwareLogger;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import com.zaxxer.hikari.pool.HikariPool;
import com.zaxxer.hikari.util.UtilityElf;

/**
public void testLeakDetection() throws Exception

      final HikariDataSource ds = new HikariDataSource(config);
      try {
         TestElf.setSlf4jLogLevel(HikariPool.class, LocationAwareLogger.DEBUG_INT);
         TestElf.getPool(ds).logPoolState();

         Connection connection = ds.getConnection();
public void testLeakDetection() throws Exception
         ps.close();
         String s = new String(baos.toByteArray());
         Assert.assertNotNull("Exception string was null", s);
         Assert.assertTrue("Expected exception to contain 'Apparent connection leak detected' but contains *" + s + "*", s.contains("Apparent connection leak detected"));
      }
      finally
      {
public void rampUpDownTest() throws SQLException, InterruptedException

        System.setProperty("com.zaxxer.hikari.housekeeping.periodMs", "250");

        HikariDataSource ds = new HikariDataSource(config);
        ds.setIdleTimeout(1000);

        Assert.assertSame("Totals connections not as expected", 5, TestElf.getPool(ds).getTotalConnections());

        Connection[] connections = new Connection[ds.getMaximumPoolSize()];
        for (int i = 0; i < connections.length; i++)
        {
            connections[i] = ds.getConnection();
        }

        Assert.assertSame("Totals connections not as expected", 60, TestElf.getPool(ds).getTotalConnections());

        for (Connection connection : connections)
        {
            connection.close();
        }

        Thread.sleep(2500);

        Assert.assertSame("Totals connections not as expected", 5, TestElf.getPool(ds).getTotalConnections());

        ds.close();
    }
}
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import com.zaxxer.hikari.mocks.StubConnection;
import com.zaxxer.hikari.pool.HikariPool;
import com.zaxxer.hikari.util.ClockSource;
import com.zaxxer.hikari.util.UtilityElf;

public void testShutdown1() throws SQLException
      Thread[] threads = new Thread[10];
      for (int i = 0; i < 10; i++) {
         threads[i] = new Thread() {
            public void run()
            {
               try {
public void testShutdown3() throws SQLException
      Assert.assertSame("StubConnection count not as expected", 0, StubConnection.count.get());

      StubConnection.slowCreate = false;
      
      HikariConfig config = new HikariConfig();
      config.setMinimumIdle(5);
      config.setMaximumPoolSize(5);
public void testThreadedShutdown() throws Exception
      for (int i = 0; i < 4; i++) {
         final HikariDataSource ds = new HikariDataSource(config);
         Thread t = new Thread() {
            public void run() {
               Connection connection = null;
               try {
public void run() {
            };
         };
         t.start();
   
         Thread t2 = new Thread() {
            public void run() {
               UtilityElf.quietlySleep(100);
               try {

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import org.junit.AfterClass;
import org.junit.Assert;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import com.zaxxer.hikari.pool.HikariPool;
import com.zaxxer.hikari.pool.PoolEntry;
import com.zaxxer.hikari.util.ConcurrentBag;
import com.zaxxer.hikari.util.ConcurrentBag.IBagStateListener;

public static void setup()
      config.setConnectionTestQuery("VALUES 1");
      config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

      ds = new HikariDataSource(config);      
      pool = TestElf.getPool(ds);
   }

public static void teardown()
   @Test
   public void testConcurrentBag() throws Exception
   {
      ConcurrentBag<PoolEntry> bag = new ConcurrentBag<PoolEntry>(new IBagStateListener() {
         @Override
         public Future<Boolean> addBagItem()
         {
            return new Future<Boolean>() {
               @Override
               public boolean isDone()
               {
                  return true;
               }
               
               @Override
               public boolean isCancelled()
               {
                  return false;
               }
               
               @Override
               public Boolean get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException
               {
                  return null;
               }
               
               @Override
               public Boolean get() throws InterruptedException, ExecutionException
               {
                  return true;
               }
               
               @Override
               public boolean cancel(boolean mayInterruptIfRunning)
               {
                  return false;
               }
            };
         }
      });
      Assert.assertEquals(0, bag.values(8).size());
public boolean cancel(boolean mayInterruptIfRunning)
      PoolEntry inuse = pool.newPoolEntry();
      bag.add(inuse);
      bag.borrow(2, TimeUnit.MILLISECONDS); // in use
      
      PoolEntry notinuse = pool.newPoolEntry();
      bag.add(notinuse); // not in use

public boolean cancel(boolean mayInterruptIfRunning)
      ByteArrayOutputStream baos = new ByteArrayOutputStream();
      PrintStream ps = new PrintStream(baos, true);
      TestElf.setSlf4jTargetStream(ConcurrentBag.class, ps);
      
      bag.requite(reserved);

      bag.remove(notinuse);
/**
 * 
 */
package com.zaxxer.hikari.pool;

 *
 */
public class TestConnectionCloseBlocking {
   private volatile boolean shouldSleep = true;

   @Test
   public void testConnectionCloseBlocking() throws SQLException {
public void testConnectionCloseBlocking() throws SQLException {
      config.setConnectionTimeout(1500);
      config.setDataSource(new CustomMockDataSource());

      HikariDataSource ds = new HikariDataSource(config);

      long start = ClockSource.INSTANCE.currentTime();
      try {
         Connection connection = ds.getConnection();
         connection.close();
         // Hikari only checks for validity for connections with lastAccess > 1000 ms so we sleep for 1001 ms to force
         // Hikari to do a connection validation which will fail and will trigger the connection to be closed
         UtilityElf.quietlySleep(1001);
         start = ClockSource.INSTANCE.currentTime();
         connection = ds.getConnection(); // on physical connection close we sleep 2 seconds
         Assert.assertTrue("Waited longer than timeout",
               (ClockSource.INSTANCE.elapsedMillis(start) < config.getConnectionTimeout()));
public void testConnectionCloseBlocking() throws SQLException {
               (ClockSource.INSTANCE.elapsedMillis(start) < config.getConnectionTimeout()));
      } finally {
         shouldSleep = false;
         ds.close();
      }
   }

import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import org.junit.Assert;
import org.junit.Test;

import com.sun.media.jfxmedia.logging.Logger;
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import com.zaxxer.hikari.mocks.StubConnection;
public void testConnectionRetries2() throws SQLException

         ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
         scheduler.schedule(new Runnable() {
            public void run()
            {
               stubDataSource.setThrowException(null);
public void testConnectionRetries3() throws SQLException

         ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);
         scheduler.schedule(new Runnable() {
            public void run()
            {
               try {
public void testConnectionRetries5() throws SQLException

         ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);
         scheduler.schedule(new Runnable() {
            public void run()
            {
               try {
public void testConnectionIdleFill() throws Exception
      HikariConfig config = new HikariConfig();
      config.setMinimumIdle(5);
      config.setMaximumPoolSize(10);
      config.setConnectionTimeout(1000);
      config.setValidationTimeout(1000);
      config.setConnectionTestQuery("VALUES 2");
      config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

public void testConnectionIdleFill() throws Exception
      ByteArrayOutputStream baos = new ByteArrayOutputStream();
      PrintStream ps = new PrintStream(baos, true);
      TestElf.setSlf4jTargetStream(HikariPool.class, ps);
      TestElf.setSlf4jLogLevel(HikariPool.class, Logger.DEBUG);

      boolean success = false;
      try (HikariDataSource ds = new HikariDataSource(config)) {
         Connection connection1 = ds.getConnection();
         Connection connection2 = ds.getConnection();
         Connection connection3 = ds.getConnection();
public void testConnectionIdleFill() throws Exception
         Connection connection6 = ds.getConnection();
         Connection connection7 = ds.getConnection();

         Thread.sleep(900);

         Assert.assertSame("Total connections not as expected", 10, TestElf.getPool(ds).getTotalConnections());
         Assert.assertSame("Idle connections not as expected", 3, TestElf.getPool(ds).getIdleConnections());
public void testConnectionIdleFill() throws Exception

         Assert.assertSame("Totals connections not as expected", 10, TestElf.getPool(ds).getTotalConnections());
         Assert.assertSame("Idle connections not as expected", 10, TestElf.getPool(ds).getIdleConnections());
         success = true;
      }
      finally {
         TestElf.setSlf4jLogLevel(HikariPool.class, Logger.INFO);
         System.getProperties().remove("com.zaxxer.hikari.housekeeping.periodMs");
         if (!success) {
            System.err.println(new String(baos.toByteArray()));
         }
      }
   }
}
import java.sql.SQLException;
import java.sql.Statement;
import java.util.concurrent.TimeUnit;

import org.junit.Assert;
import org.junit.Test;
import org.slf4j.spi.LocationAwareLogger;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import com.zaxxer.hikari.mocks.StubConnection;
import com.zaxxer.hikari.mocks.StubDataSource;
import com.zaxxer.hikari.mocks.StubStatement;
import com.zaxxer.hikari.pool.HikariPool;
import com.zaxxer.hikari.pool.HikariPool.PoolInitializationException;
import com.zaxxer.hikari.util.UtilityElf;

/**
 * System property testProxy can be one of:
 *    "com.zaxxer.hikari.JavaProxyFactory"
 *    "com.zaxxer.hikari.CglibProxyFactory"
 *    "com.zaxxer.hikari.JavassistProxyFactory"
 *
 * @author Brett Wooldridge
 */
public class TestConnections
{
   @Test
   public void testCreate() throws SQLException
   {
public void testCreate() throws SQLException
      config.setConnectionTestQuery("VALUES 1");
      config.setConnectionInitSql("SELECT 1");
      config.setReadOnly(true);
      config.setLeakDetectionThreshold(TimeUnit.SECONDS.toMillis(60));
      config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

      HikariDataSource ds = new HikariDataSource(config);
      ds.setLoginTimeout(10);
      Assert.assertSame(10, ds.getLoginTimeout());
      try {
         Assert.assertSame("Totals connections not as expected", 1, TestElf.getPool(ds).getTotalConnections());
         Assert.assertSame("Idle connections not as expected", 1, TestElf.getPool(ds).getIdleConnections());

public void testCreate() throws SQLException
         Assert.assertSame("Totals connections not as expected", 1, TestElf.getPool(ds).getTotalConnections());
         Assert.assertSame("Idle connections not as expected", 1, TestElf.getPool(ds).getIdleConnections());
      }
      finally {
         ds.close();
      }
   }

   @Test
public void testMaxLifetime() throws Exception
      HikariConfig config = new HikariConfig();
      config.setMinimumIdle(0);
      config.setMaximumPoolSize(1);
      config.setConnectionTestQuery("VALUES 1");
      config.setInitializationFailFast(false);
      config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

      System.setProperty("com.zaxxer.hikari.housekeeping.periodMs", "100");

      HikariDataSource ds = new HikariDataSource(config);

      try {
         System.clearProperty("com.zaxxer.hikari.housekeeping.periodMs");

         ds.setMaxLifetime(700);
public void testMaxLifetime() throws Exception
         Assert.assertSame("Post total connections not as expected", 1, TestElf.getPool(ds).getTotalConnections());
         Assert.assertSame("Post idle connections not as expected", 1, TestElf.getPool(ds).getIdleConnections());
      }
      finally {
         ds.close();
         System.getProperties().remove("com.zaxxer.hikari.housekeeping.periodMs");
      }
   }

   @Test
public void testMaxLifetime2() throws Exception
      HikariConfig config = new HikariConfig();
      config.setMinimumIdle(0);
      config.setMaximumPoolSize(1);
      config.setConnectionTestQuery("VALUES 1");
      config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

      HikariDataSource ds = new HikariDataSource(config);

      try {
         ds.setMaxLifetime(700);

         Assert.assertSame("Total connections not as expected", 0, TestElf.getPool(ds).getTotalConnections());
public void testMaxLifetime2() throws Exception
         Assert.assertSame("Post total connections not as expected", 1, TestElf.getPool(ds).getTotalConnections());
         Assert.assertSame("Post idle connections not as expected", 1, TestElf.getPool(ds).getIdleConnections());
      }
      finally {
         ds.close();
      }
   }

   @Test
public void testDoubleClose() throws Exception
      HikariConfig config = new HikariConfig();
      config.setMinimumIdle(1);
      config.setMaximumPoolSize(1);
      config.setConnectionTestQuery("VALUES 1");
      config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

      HikariDataSource ds = new HikariDataSource(config);
      try {
         Connection connection = ds.getConnection();
         connection.close();

public void testDoubleClose() throws Exception

         connection.close();
      }
      finally {
         ds.close();
      }
   }

   @Test
public void testEviction() throws Exception
      HikariConfig config = new HikariConfig();
      config.setMinimumIdle(0);
      config.setMaximumPoolSize(5);
      config.setConnectionTestQuery("VALUES 1");
      config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

      HikariDataSource ds = new HikariDataSource(config);
      try {
         Connection connection = ds.getConnection();

         Assert.assertEquals(1, TestElf.getPool(ds).getTotalConnections());
         ds.evictConnection(connection);
         Assert.assertEquals(0, TestElf.getPool(ds).getTotalConnections());
      }
      finally {
         ds.close();
      }
   }

   @Test
public void testBackfill() throws Exception
      config.setConnectionTestQuery("VALUES 1");
      config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

      HikariDataSource ds = new HikariDataSource(config);
      try {
         UtilityElf.quietlySleep(500);

         Assert.assertSame("Totals connections not as expected", 1, TestElf.getPool(ds).getTotalConnections());
public void testBackfill() throws Exception
            Assert.assertSame(SQLException.class, e.getClass());
         }

         // The connection will be ejected from the pool here
         connection.close();

         Assert.assertSame("Totals connections not as expected", 0, TestElf.getPool(ds).getTotalConnections());
         Assert.assertSame("Idle connections not as expected", 0, TestElf.getPool(ds).getIdleConnections());

public void testBackfill() throws Exception
         Assert.assertTrue("Totals connections not as expected", TestElf.getPool(ds).getTotalConnections() > 0);
         Assert.assertTrue("Idle connections not as expected", TestElf.getPool(ds).getIdleConnections() > 0);
      }
      finally {
         ds.close();
      }
   }

   @Test
public void testMaximumPoolLimit() throws Exception
      HikariConfig config = new HikariConfig();
      config.setMinimumIdle(1);
      config.setMaximumPoolSize(4);
      config.setConnectionTimeout(TimeUnit.MINUTES.toMillis(1));
      config.setInitializationFailFast(true);
      config.setConnectionTestQuery("VALUES 1");
      config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

      StubConnection.count.set(0);

      final HikariDataSource ds = new HikariDataSource(config);
      try {
         Thread[] threads = new Thread[20];
         for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(new Runnable() {
               public void run()
               {
                  try {
                     Connection connection = ds.getConnection();
                     quietlySleep(500);
                     connection.close();
                  }
                  catch (Exception e) {
                     e.printStackTrace();
                  }
               }
            });
public void run()
            threads[i].join();
         }

         Assert.assertEquals(4, StubConnection.count.get());
      }
      finally {
         ds.close();
      }
   }

   @Test
public void testOldDriver() throws Exception
      HikariConfig config = new HikariConfig();
      config.setMinimumIdle(1);
      config.setMaximumPoolSize(1);
      config.setConnectionTestQuery("VALUES 1");
      config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

      StubConnection.oldDriver = true;
      StubStatement.oldDriver = true;
      HikariDataSource ds = new HikariDataSource(config);
      try {
         quietlySleep(500);

         Connection connection = ds.getConnection();
public void testOldDriver() throws Exception
      finally {
         StubConnection.oldDriver = false;
         StubStatement.oldDriver = false;
         ds.close();
      }
   }

public void testSuspendResume() throws Exception
      HikariConfig config = new HikariConfig();
      config.setMinimumIdle(3);
      config.setMaximumPoolSize(3);
      config.setAllowPoolSuspension(true);
      config.setConnectionTestQuery("VALUES 1");
      config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

      TestElf.setSlf4jLogLevel(HikariPool.class, LocationAwareLogger.DEBUG_INT);

      final HikariDataSource ds = new HikariDataSource(config);
      try {
         HikariPool pool = TestElf.getPool(ds);
         while (pool.getTotalConnections() < 3) {
            quietlySleep(50);
         }

         Thread t = new Thread(new Runnable() {
            public void run()
            {
               try {
public void run()
         quietlySleep(500);
         Assert.assertEquals(1, pool.getIdleConnections());
      }
      finally {
         ds.close();
      }
   }

   @Test
public void testInitializationFailure() throws SQLException
      StubDataSource stubDataSource = new StubDataSource();
      stubDataSource.setThrowException(new SQLException("Connection refused"));

      HikariDataSource ds = new HikariDataSource();
      ds.setMinimumIdle(3);
      ds.setMaximumPoolSize(3);
      ds.setAllowPoolSuspension(true);
      ds.setConnectionTestQuery("VALUES 1");
      ds.setDataSource(stubDataSource);

      try (Connection c = ds.getConnection()) {
         Assert.fail("Initialization should have failed");
      }
      catch (PoolInitializationException e) {
         // passed
      }
      finally {
         ds.close();
      }
   }

import java.sql.Connection;
import java.util.HashMap;

import org.slf4j.LoggerFactory;
import org.slf4j.impl.SimpleLogger;

import com.zaxxer.hikari.pool.ProxyConnection;
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import com.zaxxer.hikari.pool.HikariPool;

/**
 * Utility methods for testing.
public final class TestElf
{
   private TestElf() {
      // default constructor   
   }

   public static HikariPool getPool(HikariDataSource ds)
public static boolean getConnectionCommitDirtyState(Connection connection)
      }
      catch (Exception e) {
         throw new RuntimeException(e);
      }      
   }

   public static void setConfigUnitTest(boolean unitTest)
public static void setConfigUnitTest(boolean unitTest)
      }
      catch (Exception e) {
         throw new RuntimeException(e);
      }      
   }

   public static void setSlf4jTargetStream(Class<?> clazz, PrintStream stream)
   {
      SimpleLogger simpleLogger = (SimpleLogger) LoggerFactory.getLogger(clazz);
      try {
         Field field = clazz.getClassLoader().loadClass("org.slf4j.impl.SimpleLogger").getDeclaredField("TARGET_STREAM");
         field.setAccessible(true);
         field.set(simpleLogger, stream);
      }
      catch (Exception e) {
         throw new RuntimeException(e);
      }
   }

   public static void setSlf4jLogLevel(Class<?> clazz, int logLevel)
   {
      SimpleLogger simpleLogger = (SimpleLogger) LoggerFactory.getLogger(clazz);
      try {
         Field field = clazz.getClassLoader().loadClass("org.slf4j.impl.SimpleLogger").getDeclaredField("currentLogLevel");
         field.setAccessible(true);
         field.setInt(simpleLogger, logLevel);
      }
      catch (Exception e) {
         throw new RuntimeException(e);
      }
   }
}
public void testMetricWait() throws SQLException
      config.setPoolName("test");
      config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

      HikariDataSource ds = new HikariDataSource(config);
      try {
         ds.getConnection().close();

         Timer timer = metricRegistry.getTimers(new MetricFilter() {
public boolean matches(String name, Metric metric)
         Assert.assertEquals(1, timer.getCount());
         Assert.assertTrue(timer.getMeanRate() > 0.0);
      }
      finally {
         ds.close();
      }
   }

   @Test
public void testMetricUsage() throws SQLException
      config.setPoolName("test");
      config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

      HikariDataSource ds = new HikariDataSource(config);
      try {
         Connection connection = ds.getConnection();
         UtilityElf.quietlySleep(250L);
         connection.close();
public boolean matches(String name, Metric metric)
         double seventyFifth = histo.getSnapshot().get75thPercentile();
         Assert.assertTrue("Seventy-fith percentile less than 250ms: " + seventyFifth, seventyFifth >= 250.0);
      }
      finally {
         ds.close();
      }
   }

   @Test
public void testHealthChecks() throws Exception
      config.setPoolName("test");
      config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
      config.addHealthCheckProperty("connectivityCheckTimeoutMs", "1000");
      config.addHealthCheckProperty("expected99thPercentileMs", "10");

      HikariDataSource ds = new HikariDataSource(config);
      try {
         UtilityElf.quietlySleep(TimeUnit.SECONDS.toMillis(2));

         Connection connection = ds.getConnection();
public void testHealthChecks() throws Exception
         Result slaResult = healthChecks.get("test.pool.Connection99Percent");
         Assert.assertTrue(slaResult.isHealthy());
      }
      finally {
         ds.close();
      }
   }

   @Test
public void testSetters1() throws Exception
      HikariDataSource ds = new HikariDataSource();
      ds.setMaximumPoolSize(1);
      ds.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
      
      MetricRegistry metricRegistry = new MetricRegistry();
      HealthCheckRegistry healthRegistry = new HealthCheckRegistry();

public void testSetters2() throws Exception
      HikariDataSource ds = new HikariDataSource();
      ds.setMaximumPoolSize(1);
      ds.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
      
      MetricRegistry metricRegistry = new MetricRegistry();
      HealthCheckRegistry healthRegistry = new HealthCheckRegistry();

public void testSetters2() throws Exception
         Assert.fail("Should not have been allowed to set registry after pool started");
      }
      catch (IllegalStateException ise) {
         
      }
      finally {
         ds.close();
public void validateIdleTimeoutExceedsLifetime()
      config.setMaxLifetime(TimeUnit.MINUTES.toMillis(2));
      config.setIdleTimeout(TimeUnit.MINUTES.toMillis(3));
      config.validate();
      Assert.assertTrue(new String(baos.toByteArray()).contains("greater than maxLifetime"));
   }

   @Test
public void validateBothDSAndDSName()
         config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
         config.setDataSource(new StubDataSource());
         config.validate();
         Assert.assertTrue(new String(baos.toByteArray()).contains("using dataSource"));
      }
      catch (IllegalStateException ise) {
         Assert.fail();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
protected Object executeCommand() throws Exception {
    }

    protected ActivitiPrintHandler findBPMPrintHandler() {
        ActivitiPrintHandler handler = null;
        List<ActivitiPrintHandler> hList = null;
        try {
            String filter = null; // add the filter here per process.
public class NetworkBuilder extends BuilderWithOptions<NetworkBuilder> {

    private String type = "default";
    private ImmutableSet.Builder<Rule> ingress = ImmutableSet.<Rule>builder();

    @Override
    protected NetworkBuilder getThis() {
    </bean>
    <service ref="checkSshPortIsOpen" auto-export="interfaces"/>

</blueprint>

public DefaultProviderConfig(
            .endpoint(endpoint)
            .accessKey(accessKey)
            .secretKey(secretKey)
            .option(ProviderOptions.CLOUDSTACK_ZONE_ID_OPTION, zoneId)
            .option(ProviderOptions.CLOUDSTACK_TEMPLATE_ID_OPTION, templateId)
            .option(ProviderOptions.CLOUDSTACK_SERVICE_OFFERING_OPTION, serviceOffering)
            .createProvider());
    }
}
private ProviderOptions() {
        throw new RuntimeException(ProviderOptions.class.getName() + " should not be instantiated");
    }

    public static final String CLOUDSTACK_ZONE_ID_OPTION = "zoneId";
    public static final String CLOUDSTACK_TEMPLATE_ID_OPTION = "templateId";
    public static final String CLOUDSTACK_SERVICE_OFFERING_OPTION = "serviceOffering";
}
    public void execute(CloudStackClient cloudStackClient, Pool pool, DelegateExecution execution) {
        Network network = checkNotNull(pool.getNetwork(), "Please configure a network for the pool");
        String securityGroupName = SecurityGroups.formatNameFromBusinessKey(execution.getProcessBusinessKey());
        SecurityGroup securityGroup = null;
        try {
            LOG.info("Creating SecurityGroup {}", securityGroupName);
            securityGroup = SecurityGroups.createSecurityGroup(cloudStackClient, securityGroupName);

    <logger name="jclouds.headers">
        <level value="DEBUG" />
        <appender-ref ref="STDOUT" />
    </logger>

    <logger name="jclouds.compute">
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void testShellStage() throws Exception {
		DataInputStream in = new DataInputStream(new ByteArrayInputStream(commands.getBytes("ISO-8859-1")));
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		shell.start(in, out, new String[] {"Payload", "--", "Shell"});
		String shellOutput = new String(out.toByteArray(), "ISO-8859-1");
		Assert.assertTrue("MagicToken missing in shell output: "+shellOutput, shellOutput.contains("MagicToken"));
		Assert.assertEquals(-1, in.read());
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import rx.Observable.Operator;
import rx.Producer;
import rx.Subscriber;
import rx.observers.SerializedSubscriber;
import rx.subscriptions.SerialSubscription;

    public static <T> OperatorSwitch<T> instance() {
        return (OperatorSwitch<T>)Holder.INSTANCE;
    }
    private OperatorSwitch() { }
    @Override
    public Subscriber<? super Observable<? extends T>> call(final Subscriber<? super T> child) {
        SwitchSubscriber<T> sws = new SwitchSubscriber<T>(child);
private OperatorSwitch() { }
    }

    private static final class SwitchSubscriber<T> extends Subscriber<Observable<? extends T>> {
        final SerializedSubscriber<T> s;
        final SerialSubscription ssub;
        final Object guard = new Object();
        final NotificationLite<?> nl = NotificationLite.instance();
        /** Guarded by guard. */
        int index;
        /** Guarded by guard. */
private OperatorSwitch() { }
        /** Guarded by guard. */
        boolean emitting;
        /** Guarded by guard. */
        InnerSubscriber currentSubscriber;
        /** Guarded by guard. */
        long initialRequested;

        volatile boolean infinite = false;

        public SwitchSubscriber(Subscriber<? super T> child) {
            s = new SerializedSubscriber<T>(child);
            ssub = new SerialSubscription();
            child.add(ssub);
            child.setProducer(new Producer(){

                @Override
                public void request(long n) {
                    if (infinite) {
                        return;
                    }
                    if(n == Long.MAX_VALUE) {
                        infinite = true;
                    }
                    InnerSubscriber localSubscriber;
                    synchronized (guard) {
                        localSubscriber = currentSubscriber;
                        if (currentSubscriber == null) {
                            long r = initialRequested + n;
                            if (r < 0) {
                                infinite = true;
                            } else {
                                initialRequested = r;
                            }
                        } else {
                            long r = currentSubscriber.requested + n;
                            if (r < 0) {
                                infinite = true;
                            } else {
                                currentSubscriber.requested = r;
                            }
                        }
                    }
                    if (localSubscriber != null) {
                        if (infinite)
                            localSubscriber.requestMore(Long.MAX_VALUE);
                        else 
                            localSubscriber.requestMore(n);
                    }
                }
            });
public void request(long n) {
        @Override
        public void onNext(Observable<? extends T> t) {
            final int id;
            long remainingRequest;
            synchronized (guard) {
                id = ++index;
                active = true;
                if (infinite) {
                    remainingRequest = Long.MAX_VALUE;
                } else {
                    remainingRequest = currentSubscriber == null ? initialRequested : currentSubscriber.requested;
                }
                currentSubscriber = new InnerSubscriber(id, remainingRequest);
                currentSubscriber.requested = remainingRequest;
            }
            ssub.set(currentSubscriber);

            t.unsafeSubscribe(currentSubscriber);
        }

        @Override
        public void onError(Throwable e) {
            s.onError(e);
            unsubscribe();
        }

public void onCompleted() {
                emitting = true;
            }
            drain(localQueue);
            s.onCompleted();
            unsubscribe();
        }
        void emit(T value, int id, InnerSubscriber innerSubscriber) {
            List<Object> localQueue;
            synchronized (guard) {
                if (id != index) {
void emit(T value, int id, InnerSubscriber innerSubscriber) {
                    if (queue == null) {
                        queue = new ArrayList<Object>();
                    }
                    if (innerSubscriber.requested != Long.MAX_VALUE)
                        innerSubscriber.requested--;
                    queue.add(value);
                    return;
                }
void emit(T value, int id, InnerSubscriber innerSubscriber) {
                    drain(localQueue);
                    if (once) {
                        once = false;
                        synchronized (guard) {
                            if (innerSubscriber.requested != Long.MAX_VALUE)
                                innerSubscriber.requested--;
                        }
                        s.onNext(value);
                    }
                    synchronized (guard) {
                        localQueue = queue;
void emit(T value, int id, InnerSubscriber innerSubscriber) {
                            break;
                        }
                    }
                } while (!s.isUnsubscribed());
            } finally {
                if (!skipFinal) {
                    synchronized (guard) {
void drain(List<Object> localQueue) {
            }
            for (Object o : localQueue) {
                if (nl.isCompleted(o)) {
                    s.onCompleted();
                    break;
                } else
                if (nl.isError(o)) {
                    s.onError(nl.getError(o));
                    break;
                } else {
                    @SuppressWarnings("unchecked")
                    T t = (T)o;
                    s.onNext(t);
                }
            }
        }
void error(Throwable e, int id) {
            }

            drain(localQueue);
            s.onError(e);
            unsubscribe();
        }
        void complete(int id) {
void complete(int id) {
            }

            drain(localQueue);
            s.onCompleted();
            unsubscribe();
        }

        final class InnerSubscriber extends Subscriber<T> {

            /**
             * The number of request that is not acknowledged.
             *
             * Guarded by guard.
             */
            private long requested = 0;

            private final int id;

            private final long initialRequested;

            public InnerSubscriber(int id, long initialRequested) {
                this.id = id;
                this.initialRequested = initialRequested;
            }

            @Override
            public void onStart() {
                requestMore(initialRequested);
            }

            public void requestMore(long n) {
                request(n);
            }

            @Override
            public void onNext(T t) {
                emit(t, id, this);
            }

            @Override
            public void onError(Throwable e) {
                error(e, id);
            }

            @Override
            public void onCompleted() {
                complete(id);
            }
        }
    }
}
import rx.Observable;
import rx.Observable.OnSubscribe;
import rx.functions.Action0;
import rx.functions.Action1;
import rx.observers.TestSubscriber;
import rx.schedulers.Schedulers;
import rx.subscriptions.Subscriptions;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
public void testSecondaryRequestsDontOverflow() throws InterruptedException {
    }
    
    @Test(timeout = 10000)
    public void testSecondaryRequestsAdditivelyAreMoreThanLongMaxValueInducesMaxValueRequestFromUpstream() throws InterruptedException {
        final List<Long> requests = new CopyOnWriteArrayList<Long>();
        final Action1<Long> addRequest = new Action1<Long>() {

            @Override
            public void call(Long n) {
                requests.add(n);
            }};
        TestSubscriber<Long> ts = new TestSubscriber<Long>(0);
        Observable.switchOnNext(
                Observable.interval(100, TimeUnit.MILLISECONDS)
                        .map(new Func1<Long, Observable<Long>>() {
                            @Override
                            public Observable<Long> call(Long t) {
                                return Observable.from(Arrays.asList(1L, 2L, 3L)).doOnRequest(addRequest);
                            }
                        }).take(3)).subscribe(ts);
        ts.requestMore(1);
        //we will miss two of the first observable
        Thread.sleep(250);
        ts.requestMore(Long.MAX_VALUE - 1);
        ts.requestMore(Long.MAX_VALUE - 1);
        ts.awaitTerminalEvent();
        assertTrue(ts.getOnNextEvents().size() > 0);
        assertEquals(5, (int) requests.size());
        assertEquals(Long.MAX_VALUE, (long) requests.get(3));
        assertEquals(Long.MAX_VALUE, (long) requests.get(4));
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
group = org.threadly
version = 4.6.1
org.gradle.daemon = false
  <modelVersion>4.0.0</modelVersion>
  <groupId>org.threadly</groupId>
  <artifactId>threadly</artifactId>
  <version>4.6.0</version>
  <packaging>jar</packaging>

  <name>Threadly</name>
public boolean isShutdownFinished() {
    public void finishShutdown() {
      shutdownFinishing = true;

      /* we only need to wake up the head worker, it will shut itself down.  As the worker 
       * finishes it will wake up additional idle workers until all idle workers are dead.
       */
      Worker w = idleWorker.get();
      if (w != null) {
        LockSupport.unpark(w.thread);
      }
    }

    /**
public void setPoolSize(int newPoolSize) {
          // now that pool size increased, start a worker so workers we can for the waiting tasks
          handleQueueUpdate();
        } else {
          /* we only need to wake up the head worker, it will shut itself down.  As the worker 
           * finishes it will wake up additional idle workers, and shut down as needed until 
           * the desired pool size is reached, or until all idle workers are gone.
           */
          Worker w = idleWorker.get();
          if (w != null) {
            LockSupport.unpark(w.thread);
          }
        }
      }
    }
protected void removeWorkerFromIdleChain(Worker worker) {
     * @return Task that is ready for immediate execution
     */
    public TaskWrapper workerIdle(Worker worker) {
      boolean interruptedChecked = false;
      boolean queued = false;
      try {
        idle: while (true) {
          int casPoolSize;
          if (shutdownFinishing) {
            currentPoolSize.decrementAndGet();
            worker.stopIfRunning();
            return null;
          } else if ((casPoolSize = currentPoolSize.get()) > maxPoolSize) {
            if (currentPoolSize.compareAndSet(casPoolSize, casPoolSize - 1)) {
              worker.stopIfRunning();
              return null;
            }
          } else {
            // ready to poll task, we loop here to avoid pool state recheck logic unless we have to block
            while (true) {
              TaskWrapper nextTask = queueManager.getNextTask();
              if (nextTask == null) {
                if (queued) {
                  // we can only park after we have queued, then checked again for a result
                  LockSupport.park();
                  continue idle;
                } else {
                  addWorkerToIdleChain(worker);
                  queued = true;
                }
              } else {
                /* TODO - right now this has a a deficiency where a recurring period task can cut in 
                 * the queue line.  The condition would be as follows:
                 * 
                 * * Thread 1 gets task to run...task is behind execution schedule, likely due to large queue
                 * * Thread 2 gets same task
                 * * Thread 1 gets reference, executes, task execution completes
                 * * Thread 2 now gets the reference, and execution check and time check pass fine
                 * * End result is that task has executed twice (on expected schedule), the second 
                 *     execution was unfair since it was done without respects to queue order and 
                 *     other tasks which are also likely behind execution schedule in this example
                 *     
                 * This should be very rare, but is possible.  The only way I see to solve this right 
                 * now is to introduce locking.
                 */
                // must get executeReference before time is checked
                short executeReference = nextTask.getExecuteReference();
                long taskDelay = nextTask.getScheduleDelay();
                if (taskDelay > 0) {
                  if (taskDelay == Long.MAX_VALUE) {
                    // the hack at construction/start is to avoid this from causing us to spin here 
                    // if only one recurring task is scheduled (otherwise we would keep pulling 
                    // that task while it's running)
                    continue;
                  }
                  if (queued) {
                    if (nextTask.getPureRunTime() < workerTimedParkRunTime) {
                      // we can only park after we have queued, then checked again for a result
                      workerTimedParkRunTime = nextTask.getPureRunTime();
                      LockSupport.parkNanos(Clock.NANOS_IN_MILLISECOND * taskDelay);
                      workerTimedParkRunTime = Long.MAX_VALUE;
                      continue idle;
                    } else {
                      // there is another worker already doing a timed park, so we can wait till woken up
                      LockSupport.park();
                      continue idle;
                    }
                  } else {
                    addWorkerToIdleChain(worker);
                    queued = true;
                  }
                } else if (nextTask.canExecute(executeReference)) {
                  return nextTask;
                }
              }
              // reset interrupted status if we may block and have not checked
              if (queued && ! interruptedChecked) {
                interruptedChecked = true;
                if (Thread.interrupted()) {
                  // verify we were not interrupted due to pool shutdown
                  continue idle;
                }
              }
            } // end pollTask loop
          }
        } // end idle loop
      } finally {
        // if queued, we must now remove ourselves, since worker is about to either shutdown or become active
        if (queued) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import net.dv8tion.jda.core.entities.User;
import net.dv8tion.jda.core.entities.VoiceChannel;
import net.dv8tion.jda.core.entities.impl.JDAImpl;
import net.dv8tion.jda.core.utils.SimpleLog;
import org.apache.commons.lang3.tuple.Pair;
import org.json.JSONObject;
private synchronized void setupReceiveThread()
    {
        if (receiveThread == null)
        {
            receiveThread = new Thread(threadIdentifier + " Receiving Thread")
            {
                @Override
                public void run()
private synchronized void setupCombinedExecutor()
    {
        if (combinedAudioExecutor == null)
        {
            combinedAudioExecutor = Executors.newSingleThreadScheduledExecutor( r -> new Thread(r, threadIdentifier + " Combined Thread"));
            combinedAudioExecutor.scheduleAtFixedRate(() ->
            {
                try
public void send(String message)
    @Override
    public void onConnected(WebSocket websocket, Map<String, List<String>> headers)
    {
        JSONObject connectObj = new JSONObject()
                .put("op", 0)
                .put("d", new JSONObject()
public void onTextMessage(WebSocket websocket, String message)
                int heartbeatInterval = content.getInt("heartbeat_interval");

                //Find our external IP and Port using Discord
                InetSocketAddress externalIpAndPort = null;

                changeStatus(ConnectionStatus.CONNECTING_ATTEMPTING_UDP_DISCOVERY);
                int tries = 0;
public void onDisconnected(WebSocket websocket, WebSocketFrame serverCloseFrame,
            LOG.debug("ClientReason: " + clientCloseFrame.getCloseReason());
            LOG.debug("ClientCode: " + clientCloseFrame.getCloseCode());
            if (clientCloseFrame.getCloseCode() != 1000)
                this.close(ConnectionStatus.ERROR_LOST_CONNECTION);
        }
        else
            this.close(ConnectionStatus.NOT_CONNECTED);
    }

    @Override
public void setAutoReconnect(boolean shouldReconnect)
        this.shouldReconnect = shouldReconnect;
    }

    public static class KeepAliveThreadFactory implements ThreadFactory
    {
        final String identifier;
public KeepAliveThreadFactory(JDAImpl api)
        @Override
        public Thread newThread(Runnable r)
        {
            Thread t = new Thread(r, identifier + " - Thread " + threadCount.getAndIncrement());
            t.setDaemon(true);

            return t;

import net.dv8tion.jda.core.audio.AudioConnection;
import net.dv8tion.jda.core.entities.Guild;

import java.net.DatagramPacket;
import java.net.DatagramSocket;
public void start()
        final Guild guild = packetProvider.getConnectedChannel().getGuild();
        final DatagramSocket udpSocket = packetProvider.getUdpSocket();


        sendThread = new Thread(packetProvider.getIdentifier() + " Sending Thread")
        {
            @Override
            public void run()

public class AudioManagerImpl implements AudioManager
{
    //These values are set at the bottom of this file.
    public static boolean AUDIO_SUPPORTED;
    public static String OPUS_LIB_NAME;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public class ThreadDumpFactory implements CliRuntimeFactory {

    private static final StackTraceElement WAIT_TRACE_ELEMENT = StackTrace.nativeElement("java.lang.Object", "wait");

    private static final String NL = "(?:\\r\\n|\\n)";
    private static final String LOCK_SUBPATTERN = "<0x(\\w+)> \\(a ([^\\)]+)\\)";

    private static final Pattern THREAD_DELIMITER = Pattern.compile(NL + NL + "(?!\\s)");
    private static final Pattern STACK_TRACE_ELEMENT_LINE = Pattern.compile(" *at (\\S+)\\.(\\S+)\\(([^:]+?)(\\:\\d+)?\\)");
    private static final Pattern ACQUIRED_LINE = Pattern.compile("- locked " + LOCK_SUBPATTERN);
    private static final Pattern WAITING_ON_LINE = Pattern.compile("- waiting on " + LOCK_SUBPATTERN); // In Object.wait()
    // Oracle/OpenJdk puts unnecessary space after 'parking to wait for'
    // Omit 'waiting on' as it is not a monitor that blocks the thread
    private static final Pattern WAITING_TO_LOCK_LINE = Pattern.compile("- (?:waiting to lock|parking to wait for ?) " + LOCK_SUBPATTERN);
    private static final Pattern OWNABLE_SYNCHRONIZER_LINE = Pattern.compile("- " + LOCK_SUBPATTERN);
    private static final Pattern THREAD_HEADER = Pattern.compile(
            "^\"(.*)\" ([^\\n\\r]+)(?:" + NL + "\\s+java.lang.Thread.State: ([^\\n\\r]+)(?:" + NL + "(.+))?)?",
private Builder initLocks(Builder builder, String string) {
        }

        ThreadStatus status = builder.getThreadStatus();

        // Probably a bug in JVM/jstack but let's see what we can do
        if (waitingOnLock == null && !status.isRunnable() && WAIT_TRACE_ELEMENT.equals(builder.getStacktrace().getElement(0))) {
            HashSet<ThreadLock> acquiredLocks = new HashSet<ThreadLock>(monitors.size());
            for (Monitor m: monitors) {
                acquiredLocks.add(m.getLock());
private Builder initLocks(Builder builder, String string) {
            }
        }

        if (waitingToLock != null && !status.isBlocked() && !status.isParked()) throw new AssertionError(
                status + " thread declares waitingTo lock:\n" + string
        );
import static com.github.olivergondza.dumpling.model.ProcessThread.nameIs;
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.Assert.assertEquals;

import java.io.ByteArrayInputStream;
public void parseThreadInObjectWaitThatDoesNotDeclareDesiredMonitor() throws Exc
        assertThat(timedWaiting.getAcquiredLocks(), Matchers.<ThreadLock>empty());
    }

    private ProcessRuntime runtimeFrom(String resource) throws IOException, URISyntaxException {
        return new ThreadDumpFactory().fromFile(Util.resourceFile(getClass(), resource));
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void doAppendMessage(final Request<RpcWireRequest, RpcReply> request) {

    // 6. if existing entries conflict with new entries, delete all
    // existing entries starting with first conflicting entry (sec 5.3)
    // nb: The process in which we fix the local log may involve a async log operation, so that is entirely
    // hidden up in this future.  Note that the process can fail, so we handle that as well.
    ListenableFuture<ArrayList<LogEntry>> entriesToCommitFuture = validateAndFixLocalLog(appendMessage);
    // TODO this method of placing callbacks on the replicator's fiber can cause race conditions
    // TODO since later-received messages can be handled prior to the callback on earlier-received messages
    C5Futures.addCallback(entriesToCommitFuture,
        (entriesToCommit) -> {
          // 7. Append any new entries not already in the log.
          ListenableFuture<Boolean> logCommitNotification = log.logEntries(entriesToCommit);
          refreshQuorumConfigurationFromLog();

          // 8. apply newly committed entries to state machine

          // wait for the log to commit before returning message.  But do so async.
          C5Futures.addCallback(logCommitNotification,
              (result) -> {
                appendReply(request, true);

                // Notify and mark the last committed index.
                long newCommitIndex = Math.min(appendMessage.getCommitIndex(), log.getLastIndex());
                setLastCommittedIndex(newCommitIndex);
              },
              (Throwable t) -> {
                // TODO A log commit failure is probably a fatal error. Quit the instance?
                // TODO better error reporting. A log commit failure will be a serious issue.
                logger.error("failure appending new entries to log", t);
                appendReply(request, false);
              }, fiber);

        },
        (Throwable t) -> {
          logger.error("failure validating and fixing local log", t);
          appendReply(request, false);
        }, fiber);
  }
private void acknowledgeNewLeader(long theLeader) {
    );
  }

  private ListenableFuture<ArrayList<LogEntry>> validateAndFixLocalLog(AppendEntries appendMessage) {
    final SettableFuture<ArrayList<LogEntry>> future = SettableFuture.create();

    validateAndFixLocalLog0(appendMessage, future);
    return future;
  }

  private void validateAndFixLocalLog0(final AppendEntries appendMessage,
                                       final SettableFuture<ArrayList<LogEntry>> future) {

    // 6. if existing entries conflict with new entries, delete all
    // existing entries starting with first conflicting entry (sec 5.3)

    long nextIndex = log.getLastIndex() + 1;

    List<LogEntry> entries = appendMessage.getEntriesList();
    ArrayList<LogEntry> entriesToCommit = new ArrayList<>(entries.size());
    for (LogEntry entry : entries) {
      long entryIndex = entry.getIndex();

      if (entryIndex == nextIndex) {
        logger.debug("new log entry for idx {} term {}", entryIndex, entry.getTerm());

        entriesToCommit.add(entry);

        nextIndex++;
        continue;
      }

      if (entryIndex > nextIndex) {
        // ok this entry is still beyond the LAST entry, so we have a problem:
        logger.error("log entry missing, I expected {} and the next in the message is {}",
            nextIndex, entryIndex);

        future.setException(new Exception("Log entry missing"));
        return;
      }

      // at this point entryIndex should be <= log.getLastIndex
      assert entryIndex < nextIndex;

      if (log.getLogTerm(entryIndex) != entry.getTerm()) {
        // This is generally expected to be fairly uncommon.  To prevent busywaiting on the truncate,
        // we basically just redo some work (that ideally shouldn't be too expensive).

        // So after this point, we basically return immediately, with a callback schedule.

        // conflict:
        logger.debug("log conflict at idx {} my term: {} term from leader: {}, truncating log after this point",
            entryIndex, log.getLogTerm(entryIndex), entry.getTerm());

        // delete this and all subsequent entries:
        ListenableFuture<Boolean> truncateResult = log.truncateLog(entryIndex);
        C5Futures.addCallback(truncateResult,
            (result) ->
                // Recurse, which involved a little redo work, but at makes this code easier to reason about.
                validateAndFixLocalLog0(appendMessage, future),

            (Throwable t) -> {
              failReplicatorInstance(t);
              future.setException(t); // TODO determine if this is the proper thing to do here?
            }, fiber);

        return;
      }
    }
    future.set(entriesToCommit);
  }

  @FiberOnly
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public int deliverMessageToSubscriptions(String destination, Set<AndesMessageMet
                            message.setDestination(localSubscription.getSubscribedDestination());
                        }

                        MessageFlusher.getInstance().deliverMessageAsynchronously(localSubscription, message);
                        numOfCurrentMsgDeliverySchedules++;

public int sendMessagesToSubscriptions(String destination, Set<AndesMessageMetad
     */
    public void scheduleMessageForSubscription(LocalSubscription subscription,
                                               final AndesMessageMetadata message) {
        deliverMessageAsynchronously(subscription, message);
    }

public void deliverMessageAsynchronously(LocalSubscription subscription, AndesMe
        if(log.isDebugEnabled()) {
            log.debug("Scheduled message id= " + message.getMessageID() + " to be sent to subscription= " + subscription);
        }
        OnflightMessageTracker.getInstance().incrementNumberOfScheduledDeliveries(message.getMessageID());
        flusherExecutor.submit(subscription, message);
    }

public int deliverMessageToSubscriptions(String destination, Set<AndesMessageMet
                    break;
                }

                for (int j = 0; j < subscriptions4Queue.size(); j++) {
                    LocalSubscription localSubscription = MessageFlusher.getInstance()
                            .findNextSubscriptionToSent(destination, subscriptions4Queue);
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * This class will track message delivery by broker
public int incrementNumberOfScheduledDeliveries(long messageID) {
    }

    /**
     * Decrement number of times this message is scheduled to be delivered.
     * If message is actually sent to the subscriber this is decreased.
     *
public int deliverMessageToSubscriptions(String destination, Set<AndesMessageMet
                    }
                }
                if (allTopicSubscriptionsHasRoom) {
                    //schedule message to all subscribers
                    for (int j = 0; j < subscriptions4Queue.size(); j++) {
                        LocalSubscription localSubscription = MessageFlusher.getInstance().
public void onEvent(DeliveryEventData deliveryEventData, long sequence, boolean
            AndesMessageMetadata message = deliveryEventData.getMetadata();

            try {
                //decrement number of schedule deliveries before send to subscriber to avoid parallel status update issues
                OnflightMessageTracker.getInstance().decrementNumberOfScheduledDeliveries(message.getMessageID());
                if (deliveryEventData.isErrorOccurred()) {
                    handleSendError(message);
                    return;
public void onEvent(DeliveryEventData deliveryEventData, long sequence, boolean
                }
            } catch (Throwable e) {
                log.error("Error while delivering message. Message id " + message.getMessageID(), e);
                //increment above schedule count because exception occurred while send message to subscriber
                OnflightMessageTracker.getInstance().incrementNumberOfScheduledDeliveries(message.getMessageID());
                handleSendError(message);
            } finally {
                deliveryEventData.clearData();
            }
        }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                <artifactId>license-maven-plugin</artifactId>
            </plugin>
            <plugin>
                <groupId>org.jacoco</groupId>
                <artifactId>jacoco-maven-plugin</artifactId>
            </plugin>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.util.stream.StreamSupport;

import javax.ws.rs.ClientErrorException;
import javax.ws.rs.core.Response;

import com.bouncestorage.bounce.BlobStoreTarget;
import com.bouncestorage.bounce.Utils;
import com.bouncestorage.bounce.admin.BounceApplication;
import com.bouncestorage.bounce.admin.BouncePolicy;
import com.google.auto.service.AutoService;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableSet;
    private static final ListContainerOptions LIST_CONTAINER_RECURSIVE = new ListContainerOptions().recursive();
    protected Duration copyDelay;
    protected Duration evictDelay;

    public static boolean isMarkerBlob(String name) {
        return name.endsWith(LOG_MARKER_SUFFIX);
public boolean deleteContainerIfEmpty(String container) {

    @Override
    public String putBlob(String containerName, Blob blob, PutOptions options) {
        if (blob.getMetadata().getName().startsWith(INTERNAL_PREFIX)) {
            throw new UnsupportedOperationException("illegal prefix");
        }
        putMarkerBlob(containerName, blob.getMetadata().getName());
        String etag = getSource().putBlob(containerName, blob, options);
        String blobName = blob.getMetadata().getName();
        enqueueReconcile(containerName, blobName);
        return etag;
    }

    @Override
private BounceResult reconcileObject(String container, String blob)
    @Override
    public BounceResult reconcileObject(String container, BounceStorageMetadata sourceObject, StorageMetadata
            destinationObject) {
        logger.debug("reconciling {}", sourceObject == null ? destinationObject.getName() : sourceObject.getName());
        if (sourceObject != null) {
            logger.debug("reconciling {} {} {}", sourceObject.getName(),
                    destinationObject == null ? "null" : destinationObject.getName(), sourceObject.getRegions());
            try {
                if (isEvict() && isObjectExpired(sourceObject, evictDelay)) {
                    return maybeMoveObject(container, sourceObject, destinationObject);
                } else if (isCopy() && (isImmediateCopy() || isObjectExpired(sourceObject, copyDelay))) {
                    return maybeCopyObject(container, sourceObject, destinationObject);
                }
            } catch (IOException e) {
                throw propagate(e);
            }

            return BounceResult.NO_OP;
        } else {
            logger.debug("reconciling null {}", destinationObject.getName());
            getDestination().removeBlob(container, destinationObject.getName());
            return BounceResult.REMOVE;
        }
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public A _1() {
            A a = v != null ? v.get() : null;
            if (a == null)
              synchronized (latch) {
                if (v == null || v.get() == null)
                  a = self._1();
                v = new SoftReference<A>(a);
              }
            return a;
          }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public IScope resolveScope(IScope root, String path) {
					// skip empty path elements
					continue;
				}
				if (scope.hasChildScope(child)) {
					scope = scope.getScope(child);
				} else if (!scope.equals(root)) {
					// no need for sync here, scope.children is concurrent
					if (scope.createChildScope(child)) {
						scope = scope.getScope(child);
					}
				}
				// if the scope is still equal to root then the room was not found
				if (scope == root) {
					throw new ScopeNotFoundException(scope, child);
				}
				// some scopes don't implement IScope, such as SharedObjectScope
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import io.scif.FormatException;
import io.scif.MetadataService;
import io.scif.SCIFIO;

import org.junit.Test;

 */
public class OMEROFormatTest {

	/** Tests {@link OMEROFormat#getFormatName()}. */
	@Test
	public void testGetFormatName() {
public void testParseArguments() throws FormatException {
	// -- Helper methods --

	private OMEROFormat getFormat() {
		return new SCIFIO().format().getFormatFromClass(OMEROFormat.class);
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

package org.opencb.opencga.catalog.db.mongodb;

import com.mongodb.DuplicateKeyException;
import com.mongodb.MongoClient;
import com.mongodb.client.MongoCursor;
import com.mongodb.client.model.Aggregates;
import com.mongodb.client.model.Filters;
public MongoDBCollection getFileCollection() {

        try {
            fileCollection.insert(fileDocument, null);
        } catch (DuplicateKeyException e) {
            throw CatalogDBException.alreadyExists("File", studyId, "path", file.getPath(), e);
        }

private void createParents(long studyId, String userId, URI studyURI, Path path,

    public QueryResult<File> link(URI uriOrigin, String pathDestiny, long studyId, ObjectMap params, String sessionId)
            throws CatalogException, IOException {

        CatalogIOManager ioManager = catalogIOManagerFactory.get(uriOrigin);
        if (!ioManager.exists(uriOrigin)) {
            throw new CatalogIOException("File " + uriOrigin + " does not exist");
public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOEx

            return fileDBAdaptor.get(query, queryOptions);
        }

    }

    public QueryResult<File> unlink(String fileIdStr, @Nullable String studyStr, String sessionId) throws CatalogException, IOException {
import org.opencb.commons.utils.StringUtils;
import org.opencb.opencga.catalog.CatalogManagerExternalResource;
import org.opencb.opencga.catalog.db.api.FileDBAdaptor;
import org.opencb.opencga.catalog.exceptions.*;
import org.opencb.opencga.catalog.io.CatalogIOManager;
import org.opencb.opencga.catalog.managers.api.IFileManager;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;

import static org.hamcrest.CoreMatchers.containsString;
public void testLinkNonExistentFile() throws CatalogException, IOException {
        catalogManager.link(uri, "test/myLinkedFolder/", Long.toString(studyId), params, sessionIdUser);
    }

    @Test
    public void testUnlinkFolder() throws CatalogException, IOException {
        URI uri = Paths.get(catalogManager.getStudyUri(studyId)).resolve("data").toUri();

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void updateItemsForEvent() {
        for (String item : bindingProvider.getItemNames()) {
            CalDavConfig config = bindingProvider.getConfig(item);
            List<CalDavEvent> events = eventCache.get(config.getUniqueEventListKey());
            if (events == null) {
                CalDavQuery query = getQueryForConfig(config);
                events = this.calDavLoader.getEvents(query);
                eventCache.put(config.getUniqueEventListKey(), events);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public class AsyncLoggingEventAppenderFactory implements AsyncAppenderFactory<ILoggingEvent> {

    /**
     * Creates an {@link AsyncAppenderFactory} of type {@link ILoggingEvent}
     * @return the {@link AsyncAppenderFactory}
     */
    @Override
    public AsyncAppenderBase<ILoggingEvent> build() {
public class AsyncAccessEventAppenderFactory implements AsyncAppenderFactory<IAccessEvent> {

    /**
     * Creates an {@link AsyncAppenderFactory} of type {@link IAccessEvent} that prepares events
     * for deferred processing
     * @return the {@link AsyncAppenderFactory}
     */
    @Override
    public AsyncAppenderBase<IAccessEvent> build() {
        return new AsyncAppenderBase<IAccessEvent>() {
            @Override
            protected void preprocess(IAccessEvent event) {
                event.prepareForDeferredProcessing();
            }
        };
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import com.google.common.collect.UnmodifiableIterator;
import org.apache.lucene.util.IOUtils;
import org.elasticsearch.ElasticsearchException;
import org.elasticsearch.common.Nullable;
import org.elasticsearch.common.inject.*;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.common.util.concurrent.AbstractRunnable;
import org.elasticsearch.common.util.concurrent.CountDown;
import org.elasticsearch.env.NodeEnvironment;
import org.elasticsearch.env.ShardLock;
import org.elasticsearch.indices.InternalIndicesLifecycle;
import org.elasticsearch.plugins.PluginsService;
import org.elasticsearch.plugins.ShardsPluginsModule;
import org.elasticsearch.threadpool.ThreadPool;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;


    private final Settings indexSettings;

    private final ThreadPool threadPool;

    private final PluginsService pluginsService;

    private final InternalIndicesLifecycle indicesLifecycle;
    private final AtomicBoolean closed = new AtomicBoolean(false);

    @Inject
    public InternalIndexService(Injector injector, Index index, @IndexSettings Settings indexSettings, NodeEnvironment nodeEnv, ThreadPool threadPool,
                                AnalysisService analysisService, MapperService mapperService, IndexQueryParserService queryParserService,
                                SimilarityService similarityService, IndexAliasesService aliasesService, IndexCache indexCache, IndexEngine indexEngine,
                                IndexGateway indexGateway, IndexStore indexStore, IndexSettingsService settingsService, IndexFieldDataService indexFieldData,
                                BitsetFilterCache bitSetFilterCache ) {
        super(index, indexSettings);
        this.injector = injector;
        this.threadPool = threadPool;
        this.indexSettings = indexSettings;
        this.analysisService = analysisService;
        this.mapperService = mapperService;
public IndexEngine engine() {
        return indexEngine;
    }

    public void close(final String reason, @Nullable Executor executor, final IndicesService.IndexCloseListener listener) {
       if (closed.compareAndSet(false, true)) {
           final Set<Integer> shardIds = shardIds();
           final CountDownLatch latch = new CountDownLatch(shardIds.size());
           final IndicesService.IndexCloseListener innerListener = listener == null ? null :
                   new PerShardIndexCloseListener(shardIds, listener);
           for (final int shardId : shardIds) {
               executor = executor == null ? threadPool.generic() : executor;
               executor.execute(new AbstractRunnable() {
                   @Override
                   public void onFailure(Throwable t) {
                       logger.warn("failed to close shard", t);
                   }

                   @Override
                   public void doRun() {
                       try {
                           removeShard(shardId, reason, innerListener);
                       } finally {
                           latch.countDown();
                       }
                   }
               });
           }
           try {
               latch.await();
           } catch (InterruptedException e) {
               logger.debug("Interrupted closing index [{}]", e, index().name());
               Thread.currentThread().interrupt();
           }
       }
    }

    @Override
import org.elasticsearch.index.similarity.SimilarityModule;
import org.elasticsearch.index.store.IndexStore;
import org.elasticsearch.index.store.IndexStoreModule;
import org.elasticsearch.index.store.Store;
import org.elasticsearch.indices.analysis.IndicesAnalysisService;
import org.elasticsearch.indices.recovery.RecoverySettings;
import org.elasticsearch.indices.store.IndicesStore;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;

import static com.google.common.collect.Maps.newHashMap;
import static org.elasticsearch.cluster.metadata.IndexMetaData.SETTING_NUMBER_OF_REPLICAS;
protected void doStop() throws ElasticsearchException {
        final CountDownLatch latch = new CountDownLatch(indices.size());

        final ExecutorService indicesStopExecutor = Executors.newFixedThreadPool(5, EsExecutors.daemonThreadFactory("indices_shutdown"));
        final ExecutorService shardsStopExecutor = Executors.newFixedThreadPool(5, EsExecutors.daemonThreadFactory("shards_shutdown"));

        for (final String index : indices) {
            indicesStopExecutor.execute(new Runnable() {
                @Override
                public void run() {
                    try {
                        removeIndex(index, "shutdown", shardsStopExecutor, new IndexCloseListener() {
                            @Override
                            public void onAllShardsClosed(Index index, List<Throwable> failures) {
                                latch.countDown();
                            }
                            @Override
                            public void onShardClosed(ShardId shardId) {}
                            @Override
                            public void onShardCloseFailed(ShardId shardId, Throwable t) {}
                        });
                    } catch (Throwable e) {
                        latch.countDown();
public void onShardCloseFailed(ShardId shardId, Throwable t) {}
        } catch (InterruptedException e) {
            // ignore
        } finally {
            shardsStopExecutor.shutdown();
            indicesStopExecutor.shutdown();
        }
    }
public synchronized IndexService createIndex(String sIndexName, Settings setting

    @Override
    public void removeIndex(String index, String reason) throws ElasticsearchException {
        removeIndex(index, reason, null, null);
    }

    @Override
    public void removeIndex(String index, String reason, @Nullable  IndexCloseListener listener) throws ElasticsearchException {
        removeIndex(index, reason, null, listener);
    }

    private synchronized void removeIndex(String index, String reason, @Nullable Executor executor,  @Nullable IndexCloseListener listener) throws ElasticsearchException {
        IndexService indexService;
        Injector indexInjector = indicesInjectors.remove(index);
        if (indexInjector == null) {
            return;
        }

        logger.debug("[{}] closing ... (reason [{}])", index, reason);
        Map<String, IndexService> tmpMap = newHashMap(indices);
        indexService = tmpMap.remove(index);
        indices = ImmutableMap.copyOf(tmpMap);

        indicesLifecycle.beforeIndexClosed(indexService);

        for (Class<? extends CloseableIndexComponent> closeable : pluginsService.indexServices()) {
            indexInjector.getInstance(closeable).close();
        }

        logger.debug("[{}] closing index service", index, reason);
        ((InternalIndexService) indexService).close(reason, executor, listener);

        logger.debug("[{}] closing index cache", index, reason);
        indexInjector.getInstance(IndexCache.class).close();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.io.FileOutputStream;
import java.io.IOException;

import nl.esciencecenter.octopus.engine.jobs.JobImplementation;
import nl.esciencecenter.octopus.engine.util.MergingOutputStream;
import nl.esciencecenter.octopus.engine.util.ProcessWrapper;
import nl.esciencecenter.octopus.engine.util.StreamForwarder;
import nl.esciencecenter.octopus.jobs.JobDescription;
import nl.esciencecenter.octopus.jobs.Streams;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * LocalBatchProcess implements a {@link ProcessWrapper} for local batch processes. 
 * 
 */
class LocalBatchProcess implements ProcessWrapper {

    private static final Logger logger = LoggerFactory.getLogger(LocalBatchProcess.class);

    private final java.lang.Process[] processes;

    private final StreamForwarder[] stdinForwarders;
    private final StreamForwarder[] stdoutForwarders;
    private final StreamForwarder[] stderrForwarders;

    private final MergingOutputStream stdoutStream;
    private final MergingOutputStream stderrStream;

    private final int [] exitCodes;
    private final boolean [] done;
    
    LocalBatchProcess(JobImplementation job) throws IOException { 

        JobDescription description = job.getJobDescription();
        
        int count = description.getProcessesPerNode();

        exitCodes = new int[count];
        done = new boolean[count];

        ProcessBuilder builder = new ProcessBuilder();
            
        String workingDirectory = description.getWorkingDirectory();
        
        String stdout = description.getStdout();
            stdin = workingDirectory + File.separator + stdin;
        }
        
        builder.command().add(description.getExecutable());
        builder.command().addAll(description.getArguments());
        builder.environment().putAll(description.getEnvironment());
        builder.directory(new java.io.File(workingDirectory));

        // Merge stdout and stderr into a single stream
        if (description.getMergeOutputStreams()) {             
            stdoutStream = new MergingOutputStream(new FileOutputStream(stdout));
            stderrStream = new MergingOutputStream(new FileOutputStream(stderr));
        } else { 
            stdoutStream = null;
            stderrStream = null;
        }

        processes = new java.lang.Process[count];
        stdinForwarders = new StreamForwarder[count];
        stdoutForwarders = new StreamForwarder[count];
        stderrForwarders = new StreamForwarder[count];

        for (int i = 0; i < count; i++) {
            processes[i] = builder.start();

            if (stdin == null) {
                stdinForwarders[i] = null;
                processes[i].getOutputStream().close();
            } else {
                stdinForwarders[i] = new StreamForwarder(new FileInputStream(stdin),
                                processes[i].getOutputStream());
            }

            if (description.getMergeOutputStreams()) { 
                stdoutForwarders[i] = new StreamForwarder(processes[i].getInputStream(), stdoutStream);
                stderrForwarders[i] = new StreamForwarder(processes[i].getErrorStream(), stderrStream);
            } else { 
                stdoutForwarders[i] = new StreamForwarder(processes[i].getInputStream(), 
                        new FileOutputStream(stdout + "." + i));
                 
                stderrForwarders[i] = new StreamForwarder(processes[i].getErrorStream(),
                        new FileOutputStream(stderr  + "." + i));
            }
        }
    }

//    private void kill() {
//        for (int i = 0; i < processes.length; i++) {
//            processes[i].destroy();
//
//            if (stdinForwarders[i] != null) {
//                stdinForwarders[i].close();
//            }
//
//            stdoutForwarders[i].close();
//            stderrForwarders[i].close();
//        }
//        
//        try {
//            if (stdoutStream != null) { 
//                stdoutStream.close();
//            }
//        } catch (IOException e) {
//            // IGNORE
//        }
//        
//        try {
//            if (stderrStream != null) { 
//                stderrStream.close();
//            }
//        } catch (IOException e) {
//            // IGNORE
//        }
//    }

//    public int waitFor() throws InterruptedException {
//        
//        int[] results = new int[processes.length];
//
//        for (int i = 0; i < processes.length; i++) {
//            results[i] = processes[i].waitFor();
//        }
//
//        return results[0];
//    }

    public boolean isDone() {
        
        for (int i=0;i<processes.length;i++) {
            
            if (!done[i]) {
                try { 
                    exitCodes[i] = processes[i].exitValue();
                    done[i] = true;
                } catch (IllegalThreadStateException e) { 
                    // ignored
                    return false;
                }
            }
        } 
        
        return true;
    }
  
    public int getExitStatus() {
        
        for (int i=0;i<exitCodes.length;i++) { 
            if (exitCodes[i] != 0) { 
                return exitCodes[i];
            }
        }
        
        return 0;
    }
    
    public void destroy() {
        for (int i = 0; i < processes.length; i++) {
            LocalUtils.unixDestroy(processes[i]);
        }
    }

    @Override
public String toString() {
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((attributes == null) ? 0 : attributes.hashCode());
        result = prime * result + (executable ? 1231 : 1237);
        result = prime * result + (hidden ? 1231 : 1237);
        result = prime * result + (readable ? 1231 : 1237);
public boolean equals(Object obj) {
            return false;
        }
        
        if (hidden != other.hidden) { 
            return false;
        }
        
        if (readable != other.readable) { 
            return false;
        }
        
        if (writable != other.writable) { 
            return false;
        }
        
// FIXME: Always fails ?         
//        if (attributes == null) { 
    public Streams getStreams() { 
        return streams;
    }
    
//    public int waitFor() throws InterruptedException {
//        exitCode = process.waitFor();
//        done = true;
//        return exitCode;
//    }

    public boolean isDone() {
        

    @Override
    public ProcessWrapper createProcessWrapper(Adaptor adaptor, JobImplementation job) throws IOException {
        if (job.getJobDescription().isInteractive()) {
            return new LocalInteractiveProcess(job);
        } else { 
            return new LocalBatchProcess(job);
        }
    }
}
private void streamCopy(InputStream in, OutputStream out, CopyInfo ac) throws IO
    private void append(AbsolutePath source, long fromOffset, AbsolutePath target, CopyInfo ac) throws OctopusIOException { 

        // We need to append some bytes from source to target. 
        try (InputStream in = owner.newInputStream(source); 
             OutputStream out = owner.newOutputStream(target, OpenOption.OPEN, OpenOption.APPEND)) {

            in.skip(fromOffset);
            
            streamCopy(in, out, ac);
        } catch (IOException e) { 
            throw new OctopusIOException("CopyEngine", "Failed to copy " + source.getPath() + ":" + fromOffset + 
                    " to target " + target.getPath(), e);
        }          
    }
    
    private boolean compareHead(CopyInfo ac, AbsolutePath target, AbsolutePath source) throws OctopusIOException, IOException { 
        
        byte [] buf1 = new byte[4*1024];
        byte [] buf2 = new byte[4*1024];
        
        try (InputStream in1 = owner.newInputStream(target);
             InputStream in2 = owner.newInputStream(source)) { 
            
            while (true) { 

                if (ac.isCancelled()) {
private boolean compareHead(CopyInfo ac, AbsolutePath target, AbsolutePath sourc
                        return false;
                    }
                }
            }           
        }        
    }
    
    private void doResume(CopyInfo ac) throws OctopusIOException {
private void doCopy(CopyInfo ac) throws OctopusIOException {
    
    private void copy(CopyInfo info) {
        
        if (logger.isDebugEnabled()) { 
            logger.debug("Start copy: " + info);
        }
        
        try { 
            switch (info.mode) { 
private void copy(CopyInfo info) {
            info.setException(e);
        }
        
        if (logger.isDebugEnabled()) { 
            logger.debug("Finished copy: " + info);
        }        
    }
    
    public void copy(CopyInfo info, boolean asynchronous) {
    
    private static final Logger logger = LoggerFactory.getLogger(JobQueues.class);
    
    private final Scheduler myScheduler;
    
    private final LinkedList<JobExecutor> singleQ;
    
    public JobQueues(Adaptor adaptor, Scheduler myScheduler, ProcessWrapperFactory factory, int multiQThreads, int maxQSize, 
            int pollingDelay) throws BadParameterException { 
    
        this.adaptor = adaptor;
        this.myScheduler = myScheduler;
        this.factory = factory;
        this.maxQSize = maxQSize;
public JobQueues(Adaptor adaptor, Scheduler myScheduler, ProcessWrapperFactory f
        unlimitedQ = new LinkedList<JobExecutor>();

        if (maxQSize < 0 && maxQSize != -1) {
            throw new BadParameterException(adaptor.getName(), "Maximum queue size cannot be negative (excluding -1 for unlimited)");
        }

        if (multiQThreads < 1) {
            throw new BadParameterException(adaptor.getName(), "Number of slots for the multi queue cannot be smaller than one!");
        }
        
        if (pollingDelay < 100 ||  pollingDelay > 60000) {
            throw new BadParameterException(adaptor.getName(), "Polling delay must be between 100 and 60000!");
        }

        unlimitedExecutor = Executors.newCachedThreadPool();
private synchronized int getNextJobID() {
    
    private void checkScheduler(Scheduler scheduler) throws OctopusException { 
        if (scheduler != myScheduler) {
            throw new OctopusException(adaptor.getName(), "Scheduler mismatch! " + scheduler + " != " + myScheduler) ;
        }
    }
    
    private void getJobs(LinkedList<JobExecutor> list, LinkedList<Job> out) {
        
        if (list == null) { 
            return;
        }
        
        for (JobExecutor e : list) {
            out.add(e.getJob());
        }
    }
    
    public Job[] getJobs(String... queueNames) throws NoSuchQueueException {
        
        LinkedList<Job> out = new LinkedList<Job>();
        
        if (queueNames == null) {
            getJobs(singleQ, out);
            getJobs(multiQ, out);
            getJobs(unlimitedQ, out);
private void getJobs(LinkedList<JobExecutor> list, LinkedList<Job> out) {
                } else if (name.equals("unlimited")) {
                    getJobs(unlimitedQ, out);
                } else { 
                    throw new NoSuchQueueException(adaptor.getName(), "Queue \"" + name + "\" does not exist");                    
                }
            }
        }
        
        return out.toArray(new Job[out.size()]);
    }
/*
    private synchronized void purgeQ(LinkedList<JobExecutor> q) {
        
        if (maxQSize == -1) {
            return;
        }

        //how many jobs do we need to remove
        int purgeCount = q.size() - maxQSize;

        if (purgeCount <= 0) {
            return;
        }

        Iterator<JobExecutor> iterator = q.iterator();

        while (iterator.hasNext() && purgeCount > 0) {
            if (iterator.next().isDone()) {
                iterator.remove();
                purgeCount--;
            }
        }
    }
*/
    private LinkedList<JobExecutor> findQueue(String queueName) throws OctopusException {

        if (queueName == null || queueName.equals("single")) {
private synchronized void purgeQ(LinkedList<JobExecutor> q) {
        } else if (queueName.equals("unlimited")) {
            return unlimitedQ;
        } else {
            throw new OctopusException(adaptor.getName(), "Queue \"" + queueName + "\" does not exist!");
        }
    }

private JobExecutor findJob(LinkedList<JobExecutor> queue, Job job) throws Octop
            }
        }

        throw new OctopusException(adaptor.getName(), "Job not found: " + job.getIdentifier());
    }

    private JobExecutor findJob(Job job) throws OctopusException {
private void cleanupJob(LinkedList<JobExecutor> queue, Job job) {
    }
    
    public JobStatus getJobStatus(Job job) throws OctopusException {
        checkScheduler(job.getScheduler());
        
        LinkedList<JobExecutor> queue = findQueue(job.getJobDescription().getQueueName());
public JobStatus getJobStatus(Job job) throws OctopusException {
    
    public JobStatus[] getJobStatuses(Job... jobs) {

        JobStatus[] result = new JobStatus[jobs.length];

        for (int i = 0; i < jobs.length; i++) {
public JobStatus getJobStatus(Job job) throws OctopusException {
    
    public JobStatus waitUntilDone(Job job, long timeout) throws OctopusException, OctopusIOException {
        
        if (logger.isDebugEnabled()) { 
            logger.debug("Waiting for " + job.getIdentifier() + " for " + timeout + " ms.");
        }
        
        if (timeout < 0) { 
            throw new OctopusException(adaptor.getName(), "Illegal timeout " + timeout);
        }
        
        checkScheduler(job.getScheduler());
        
        LinkedList<JobExecutor> queue = findQueue(job.getJobDescription().getQueueName());
        JobStatus status = findJob(queue, job).waitUntilDone(timeout);
        
        if (status.isDone()) { 
            if (logger.isDebugEnabled()) { 
                logger.debug("Job " + job.getIdentifier() + " is done after " + timeout + " ms.");
            }
            
            cleanupJob(queue, job);
        } else { 
            if (logger.isDebugEnabled()) { 
                logger.debug("Job " + job.getIdentifier() + " is NOT done after " + timeout + " ms.");
            }
        }
        
        return status;    
private void verifyJobDescription(JobDescription description) throws OctopusExce
        }
        
        if (!(queue.equals("single") || queue.equals("multi") || queue.equals("unlimited"))) {
            throw new InvalidJobDescriptionException(adaptor.getName(), "Queue " + queue + " not available locally!");
        }

        String executable = description.getExecutable(); 
        
        if (executable == null) { 
            throw new IncompleteJobDescriptionException(adaptor.getName(), "Executable missing in JobDescription!");
        }
        
        int nodeCount = description.getNodeCount();
        
        if (nodeCount != 1) { 
            throw new InvalidJobDescriptionException(adaptor.getName(), "Illegal node count: " + nodeCount);
        }
        
        int processesPerNode = description.getProcessesPerNode();
        
        if (processesPerNode <= 0) { 
            throw new InvalidJobDescriptionException(adaptor.getName(), "Illegal processes per node count: " + 
                    processesPerNode);
        }

        int maxTime = description.getMaxTime();
        
        if (maxTime <= 0) { 
            throw new InvalidJobDescriptionException(adaptor.getName(), "Illegal maximum runtime: " + maxTime);
        }

        if (description.isInteractive()) { 

            if (description.getStdin() != null) { 
                throw new InvalidJobDescriptionException(adaptor.getName(), 
                        "Illegal stdin redirect for interactive job!");            
            }
            
            if (description.getStdout() != null && !description.getStdout().equals("stdout.txt")) { 
                throw new InvalidJobDescriptionException(adaptor.getName(), 
                        "Illegal stdout redirect for interactive job!");            
            }
            
            if (description.getStderr() != null && !description.getStderr().equals("stderr.txt")) { 
                throw new InvalidJobDescriptionException(adaptor.getName(), 
                        "Illegal stderr redirect for interactive job!");            
            }
        } else {             
            
            if (description.getStdout() == null) { 
                throw new InvalidJobDescriptionException(adaptor.getName(), 
                        "Missing stdout redirect for interactive job!");            
            }
            
            if (description.getStderr() == null) { 
                throw new InvalidJobDescriptionException(adaptor.getName(), 
                        "Missing stderr redirect for interactive job!");            
            }            
        }
    }
    
    public Job submitJob(Scheduler scheduler, JobDescription description) throws OctopusException {
        
        if (logger.isDebugEnabled()) { 
            logger.debug(adaptor.getName() + ": Submitting job");
        }
        
        checkScheduler(scheduler);
        
        verifyJobDescription(description);

        if (logger.isDebugEnabled()) { 
            logger.debug(adaptor.getName() + ": JobDescription verified OK");
        }

        JobImplementation result = new JobImplementation(description, scheduler, OctopusEngine.getNextUUID(), 
                adaptor.getName() + "-" + getNextJobID(), description.isInteractive(), true);

        if (logger.isDebugEnabled()) { 
            logger.debug(adaptor.getName() + ": Created Job " + result.getIdentifier());
        }
        
        JobExecutor executor = new JobExecutor(adaptor, result, factory, pollingDelay);
        
        String queueName = description.getQueueName();
       
        if (logger.isDebugEnabled()) { 
            logger.debug(adaptor.getName() + ": Submitting job to queue " + queueName);
        }
       
        if (queueName == null || queueName.equals("single")) {
            singleQ.add(executor);
            singleExecutor.execute(executor);
        } else if (queueName.equals("multi")) {
            multiQ.add(executor);
            multiExecutor.execute(executor);
        } else if (queueName.equals("unlimited")) {
            unlimitedQ.add(executor);
            unlimitedExecutor.execute(executor);
        } else {
            throw new OctopusException(adaptor.getName(), "INTERNAL ERROR: failed to submit job!");
        }
        
        // Purge jobs from the queue if needed (will not actually cancel execution of jobs)
//        purgeQ(singleQ);
//        purgeQ(multiQ);
//        purgeQ(unlimitedQ);

        if (description.isInteractive()) {
            executor.waitUntilRunning();
            
            if (executor.isDone() && !executor.hasRun()) { 
                Exception e = executor.getError();
                throw new OctopusException(adaptor.getName(), "Job failed to start!", e);
            } 
        }
        
        return result;
    }
    
    public JobStatus cancelJob(Job job) throws OctopusException {
        checkScheduler(job.getScheduler());
        
        LinkedList<JobExecutor> queue = findQueue(job.getJobDescription().getQueueName());
public JobStatus cancelJob(Job job) throws OctopusException {
    }

    public QueueStatus getQueueStatus(Scheduler scheduler, String queueName) throws OctopusException {
     
        checkScheduler(scheduler);
        
        if (queueName == null || queueName.equals("single")) {
            return new QueueStatusImplementation(scheduler, "single", null, null);
        } else if (queueName.equals("multi")) {
            return new QueueStatusImplementation(scheduler, "multi", null, null);
        } else if (queueName.equals("unlimited")) {
            return new QueueStatusImplementation(scheduler, "unlimited", null, null);
        } else {
            throw new NoSuchQueueException(adaptor.getName(), "No such queue: " + queueName);
        }
    }
    
 */
package nl.esciencecenter.octopus.engine.util;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
public StreamForwarder(InputStream in, OutputStream out) {
    /**
     * Closes the input stream, thereby stopping the stream forwarder, and closing the output stream.
     */
    public void close() {
        try {
            in.close();
        } catch (IOException e) {
            logger.error("Cannot close input stream", e);
        }
    }

    public void run() {
        try {
public void run() {
        } catch (IOException e) {
            logger.error("Cannot forward stream", e);
        } finally {
            try {
                in.close();
            } catch (IOException e) {
                logger.error("Cannot close input stream", e);
            }
            try {
                out.close();
            } catch (IOException e) {
                logger.error("Cannot close output stream", e);
            }
        }
    }
}
public static void recursiveDelete(Octopus octopus, AbsolutePath path) throws Oc
        octopus.files().delete(path);
    }

    public static void recursiveWipe(Octopus octopus, AbsolutePath path) {
        // TODO Auto-generated method stub
    }
}

    private List<Pair> downloadFiles = new LinkedList<Pair>();

    public class Pair {

        final AbsolutePath source;
        final AbsolutePath destination;
public String toString() {
     * @throws OctopusIOException
     */
    public Sandbox(Octopus octopus, AbsolutePath root, String sandboxName) throws OctopusException, OctopusIOException {
        this.octopus = octopus;

        if (sandboxName == null) {
            path = root.resolve(new RelativePath("octopus_sandbox_" + UUID.randomUUID()));
        } else {
            path = root.resolve(new RelativePath(sandboxName));
        }
    }

    /**
public void download(CopyOption... options) throws OctopusIOException, Unsupport
        copy(downloadFiles, options);
    }

    public void wipe() throws OctopusIOException {
        FileUtils.recursiveWipe(octopus, path);
    }

    /**
     * Deletes all files in sandbox.
     *
public void delete() throws OctopusIOException {
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((octopus == null) ? 0 : octopus.hashCode());
        result = prime * result + ((path == null) ? 0 : path.hashCode());
        result = prime * result + uploadFiles.hashCode();
        result = prime * result + downloadFiles.hashCode();
        return result;
public boolean equals(Object obj) {
        if (getClass() != obj.getClass()) {
            return false;
        }
        Sandbox other = (Sandbox) obj;
        if (octopus == null) {
            if (other.octopus != null) {
                return false;
            }
        } else if (!octopus.equals(other.octopus)) {
            return false;
        }
        if (path == null) {
            if (other.path != null) {
                return false;
            }
        } else if (!path.equals(other.path)) {
            return false;
        }
        if (!downloadFiles.equals(other.downloadFiles)) {
            return false;
        }
        if (!uploadFiles.equals(other.uploadFiles)) {
            return false;
        }
        return true;
    }

 */
package nl.esciencecenter.octopus.engine.jobs;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;
import static org.hamcrest.CoreMatchers.*;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.Properties;
import java.util.UUID;

import nl.esciencecenter.octopus.engine.Adaptor;
import nl.esciencecenter.octopus.engine.OctopusEngine;
import nl.esciencecenter.octopus.exceptions.OctopusException;
import nl.esciencecenter.octopus.exceptions.OctopusIOException;
import nl.esciencecenter.octopus.jobs.Job;
import nl.esciencecenter.octopus.jobs.JobDescription;
import nl.esciencecenter.octopus.jobs.Jobs;

import org.junit.Test;

public void testToString() throws OctopusException {
        assertTrue(je.toString().equals("JobsEngine [octopusEngine=" + oe + "]"));
    }
    
//    
//    
//    

public class SandboxTest {

    @Test
    public void testSandbox_WithName() throws URISyntaxException, OctopusIOException, OctopusException {
        Octopus octopus = mock(Octopus.class);
public void testAddUploadFile_SrcAndDst() throws URISyntaxException, OctopusIOEx
    }

    @Test
    public void testAddUploadFile_DstNull_DstSameFileName() throws URISyntaxException, OctopusIOException, OctopusException {
        Octopus octopus = mock(Octopus.class);
        FileSystem fs = new FileSystemImplementation("local", "local-0", new URI("file:///"), new RelativePath(), null, null);
public void testDownload() throws OctopusIOException, URISyntaxException, Octopu
        verify(files).copy(src, dst);
    }

    private Sandbox sampleSandbox() throws URISyntaxException, OctopusException, OctopusIOException {
        FileSystem fs = new FileSystemImplementation("local", "local-0", new URI("file:///"), new RelativePath(), null, null);
        AbsolutePath path = new AbsolutePathImplementation(fs, new RelativePath("/tmp"));
        // Use null for octopus so hashcode is the same every time
        Sandbox sandbox = new Sandbox(null, path, "sandbox-1");
        sandbox.addUploadFile(new AbsolutePathImplementation(fs, new RelativePath("/tmp/inputfile")));
        sandbox.addDownloadFile("outputfile", new AbsolutePathImplementation(fs, new RelativePath("/tmp/outputfile")));
        return sandbox;
    }

    @Test
    public void testHashCode() throws URISyntaxException, OctopusIOException, OctopusException {
        Sandbox sandbox = sampleSandbox();

        assertEquals(47434737, sandbox.hashCode());
    }

    @Test
    public void testToString() throws URISyntaxException, OctopusIOException, OctopusException {
        Sandbox sandbox = sampleSandbox();

        String expected =
                "Sandbox [octopus=null, path=FileSystemImplementation [adaptorName=local, uri=file:///, entryPath=RelativePath [element=[], seperator=/], properties=null]RelativePath [element=[tmp, sandbox-1], seperator=/], uploadFiles=[Pair [source=FileSystemImplementation [adaptorName=local, uri=file:///, entryPath=RelativePath [element=[], seperator=/], properties=null]RelativePath [element=[tmp, inputfile], seperator=/], destination=FileSystemImplementation [adaptorName=local, uri=file:///, entryPath=RelativePath [element=[], seperator=/], properties=null]RelativePath [element=[tmp, sandbox-1, inputfile], seperator=/]]], downloadFiles=[Pair [source=FileSystemImplementation [adaptorName=local, uri=file:///, entryPath=RelativePath [element=[], seperator=/], properties=null]RelativePath [element=[tmp, sandbox-1, outputfile], seperator=/], destination=FileSystemImplementation [adaptorName=local, uri=file:///, entryPath=RelativePath [element=[], seperator=/], properties=null]RelativePath [element=[tmp, outputfile], seperator=/]]]]";
        assertEquals(expected, sandbox.toString());
    }

    @Test
    public void testEquals_sameObject_equal() throws URISyntaxException, OctopusIOException, OctopusException {
        Sandbox sandbox = sampleSandbox();
public void testEquals_otherOctopus_notEqual() throws URISyntaxException, Octopu
    }

    @Test
    public void testEquals_thisOctopusIsNull_notEqual() throws URISyntaxException, OctopusIOException, OctopusException {
        Octopus octopus = mock(Octopus.class);
        FileSystem fs = new FileSystemImplementation("local", "local-0", new URI("file:///"), new RelativePath(), null, null);
        AbsolutePath path = new AbsolutePathImplementation(fs, new RelativePath("/tmp"));

        Sandbox sandbox1 = new Sandbox(null, path, "sandbox-1");
        Sandbox sandbox2 = new Sandbox(octopus, path, "sandbox-1");
        
        assertNotEquals(sandbox1,sandbox2);
    }

    @Test
    public void testEquals_otherOctopusIsNull_notEqual() throws URISyntaxException, OctopusIOException, OctopusException {
        Octopus octopus = mock(Octopus.class);
        FileSystem fs = new FileSystemImplementation("local", "local-0", new URI("file:///"), new RelativePath(), null, null);
        AbsolutePath path = new AbsolutePathImplementation(fs, new RelativePath("/tmp"));

        Sandbox sandbox1 = new Sandbox(octopus, path, "sandbox-1");
        Sandbox sandbox2 = new Sandbox(null, path, "sandbox-1");

        assertNotEquals(sandbox1,sandbox2);
    }

    @Test
    public void testEquals_bothOctopusNull_Equal() throws URISyntaxException, OctopusIOException, OctopusException {
        FileSystem fs = new FileSystemImplementation("local", "local-0", new URI("file:///"), new RelativePath(), null, null);
        AbsolutePath path = new AbsolutePathImplementation(fs, new RelativePath("/tmp"));

        Sandbox sandbox1 = new Sandbox(null, path, "sandbox-1");
        Sandbox sandbox2 = new Sandbox(null, path, "sandbox-1");

        assertNotEquals(sandbox1,sandbox2);
    }

    @Test
    public void testEquals_otherPath_notEqual() throws URISyntaxException, OctopusIOException, OctopusException {
        Octopus octopus = mock(Octopus.class);
        FileSystem fs = new FileSystemImplementation("local", "local-0", new URI("file:///"), new RelativePath(), null, null);
        AbsolutePath path = new AbsolutePathImplementation(fs, new RelativePath("/tmp"));

        Sandbox sandbox1 = new Sandbox(octopus, path, "sandbox-1");
        Sandbox sandbox2 = new Sandbox(octopus, path, "sandbox-2");

        assertNotEquals(sandbox1,sandbox2);
    }

    @Test
    public void testEquals_otherUpload_notEqual() throws URISyntaxException, OctopusIOException, OctopusException {
        Octopus octopus = mock(Octopus.class);
public void testEquals_sameUpload_Equal() throws URISyntaxException, OctopusIOEx

        assertEquals(sandbox1,sandbox2);
    }

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  </prerequisites>

  <artifactId>microbean-cdi</artifactId>
  <version>0.1.3-SNAPSHOT</version>

  <parent>
    <groupId>org.microbean</groupId>
    <dependencies>

      <dependency>
        <groupId>javax.enterprise</groupId>
        <artifactId>cdi-api</artifactId>
        <version>2.0-PFD2</version>
        <type>jar</type>
      </dependency>

    <!-- Provided-scoped dependencies. -->

    <dependency>
      <groupId>javax.enterprise</groupId>
      <artifactId>cdi-api</artifactId>
      <type>jar</type>
    <findbugs.threshold>Medium</findbugs.threshold>

    <!-- maven-javadoc-plugin properties; see https://maven.apache.org/plugins/maven-javadoc-plugin/javadoc-mojo.html -->
    <links>https://www.slf4j.org/api/,http://docs.jboss.org/cdi/api/2.0-PFD2/,http://docs.oracle.com/javaee/7/api/</links>

    <!-- maven-release-plugin properties -->
    <goals>deploy,site-deploy</goals>
 */
package org.microbean.cdi;

import java.util.Objects;

import java.util.concurrent.CountDownLatch;

import javax.enterprise.event.Event; // for javadoc only
import javax.enterprise.event.NotificationOptions;
import javax.enterprise.event.ObservesAsync;

import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.inject.spi.Extension;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;



  /*
   * Instance fields.
   */

protected AbstractBlockingExtension() {
   * Creates a new {@link AbstractBlockingExtension} that uses the
   * supplied {@link CountDownLatch} for governing blocking behavior,
   * and installs a {@linkplain Runtime#addShutdownHook(Thread)
   * shutdown hook} that calls {@link CountDownLatch#countDown()
   * countDown()} on the supplied {@code latch}.
   *
   * @param latch a {@link CountDownLatch} whose {@link
   * CountDownLatch#countDown()} and {@link CountDownLatch#await()}
protected AbstractBlockingExtension(final CountDownLatch latch) {
    this.latch = latch;
    this.logger = LoggerFactory.getLogger(this.getClass());
    Runtime.getRuntime().addShutdownHook(new ShutdownHook());
  }


protected AbstractBlockingExtension(final CountDownLatch latch) {
   * cause {@link CountDownLatch#await()} to be called in a separate
   * thread.
   *
   * @param beanManager the {@link BeanManager} to use to fire the
   * event; must not be {@code null}
   *
   * @exception NullPointerException if {@code beanManager} is {@code
   * null}
   *
   * @see #unblock()
   */
  protected void fireBlockingEvent(final BeanManager beanManager) {
    if (this.logger.isTraceEnabled()) {
      this.logger.trace("ENTRY {} {} {}", this.getClass().getName(), "fireBlockingEvent", beanManager);
    }
    Objects.requireNonNull(beanManager);
    beanManager.getEvent().select(BlockingEvent.class).fireAsync(new BlockingEvent());
    if (this.logger.isTraceEnabled()) {
      this.logger.trace("EXIT {} {}", this.getClass().getName(), "fireBlockingEvent");
    }
  }

  /**
protected void fireBlockingEvent(final BeanManager beanManager) {
   * AbstractBlockingExtension} that will cause {@link
   * CountDownLatch#await()} to be called in a separate thread.
   *
   * @param beanManager the {@link BeanManager} to use to fire the
   * event; must not be {@code null}
   *
protected void fireBlockingEvent(final BeanManager beanManager) {
   * @exception NullPointerException if {@code beanManager} is {@code 
   * null}
   *
   * @see #unblock()
   */
  protected void fireBlockingEvent(final BeanManager beanManager, final NotificationOptions options) {
    if (this.logger.isTraceEnabled()) {
      this.logger.trace("ENTRY {} {} {}, {}", this.getClass().getName(), "fireBlockingEvent", beanManager, options);
    }
    Objects.requireNonNull(beanManager);
    beanManager.getEvent().select(BlockingEvent.class).fireAsync(new BlockingEvent(), options);
    if (this.logger.isTraceEnabled()) {
      this.logger.trace("EXIT {} {}", this.getClass().getName(), "fireBlockingEvent");
    }
  }

  /**
   * {@linkplain ObservesAsync Observes the asynchronous firing} of a
   * {@link BlockingEvent}, such as fired by the {@link
   * #fireBlockingEvent(BeanManager)} method, by calling {@link
   * CountDownLatch#await()} on the {@link CountDownLatch} {@linkplain
   * #AbstractBlockingExtension(CountDownLatch) supplied at
   * construction time}.
   *
   * @param event the event in question; may be {@code null}; ignored
   *
   * @exception InterruptedException if the current {@link Thread} is
   * {@linkplain Thread#interrupt() interrupted}
   *
   * @see #fireBlockingEvent(BeanManager)
   *
   * @see #unblock()
   */
  private final void block(@ObservesAsync final BlockingEvent event) throws InterruptedException {
    if (this.logger.isTraceEnabled()) {
      this.logger.trace("ENTRY {} {} {}", this.getClass().getName(), "block", event);
    }
private final void block(@ObservesAsync final BlockingEvent event) throws Interr
   * #AbstractBlockingExtension(CountDownLatch) supplied at
   * construction time}.
   *
   * @see #fireBlockingEvent(BeanManager)
   */
  public void unblock() {
    if (this.logger.isTraceEnabled()) {
      this.logger.trace("ENTRY {} {}", this.getClass().getName(), "unblock");
    }
    this.latch.countDown();
    if (this.logger.isTraceEnabled()) {
      this.logger.trace("EXIT {} {}", this.getClass().getName(), "unblock");
    }
  }


  /*
   * Inner and nested classes.
public final void run() {


  /**
   * A CDI event indicating that, when {@linkplain
   * Event#fireAsync(Object) fired asynchronously}, indicates that the
   * receiver should wait for its current {@link Thread} to die.
   *
   * @author <a href="https://about.me/lairdnelson"
   * target="_parent">Laird Nelson</a>
   *
   * @see #fireBlockingEvent(BeanManager)
   *
   * @see CountDownLatch#await()
   */
  protected static final class BlockingEvent {


    /*
     * Constructors.
     */


    /**
     * Creates a new {@link BlockingEvent}.
     */
    private BlockingEvent() {
      super();
    }
    
  }
  
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import org.elasticsearch.action.admin.cluster.state.ClusterStateAction;
import org.elasticsearch.action.admin.cluster.state.ClusterStateRequest;
import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;
import org.elasticsearch.action.search.SearchRequest;
import org.elasticsearch.cluster.node.DiscoveryNode;
import org.elasticsearch.cluster.node.DiscoveryNodes;
import org.elasticsearch.common.component.AbstractComponent;
import java.util.Set;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.Semaphore;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Represents a connection to a single remote cluster. In contrast to a local cluster a remote cluster is not joined such that the

    private final TransportService transportService;
    private final ConnectionProfile remoteProfile;
    private final Set<DiscoveryNode> connectedNodes = Collections.newSetFromMap(new ConcurrentHashMap<>());
    private final Supplier<DiscoveryNode> nodeSupplier;
    private final String clusterAlias;
    private final int maxNumRemoteConnections;
    private final Predicate<DiscoveryNode> nodePredicate;
            TransportRequestOptions.Type.STATE,
            TransportRequestOptions.Type.RECOVERY);
        remoteProfile = builder.build();
        nodeSupplier = new Supplier<DiscoveryNode>() {
            private volatile Iterator<DiscoveryNode> current;
            @Override
            public DiscoveryNode get() {
                if (current == null || current.hasNext() == false) {
                    current = connectedNodes.iterator();
                    if (current.hasNext() == false) {
                        throw new IllegalStateException("No node available for cluster: " + clusterAlias + " nodes: " + connectedNodes);
                    }
                }
                return current.next();
            }
        };
        this.seedNodes = Collections.unmodifiableList(seedNodes);
        this.connectHandler = new ConnectHandler();
        transportService.addConnectionListener(this);
public void onNodeDisconnected(DiscoveryNode node) {
     */
    public void fetchSearchShards(ClusterSearchShardsRequest searchRequest,
                                  ActionListener<ClusterSearchShardsResponse> listener) {
        if (connectedNodes.isEmpty()) {
            // just in case if we are not connected for some reason we try to connect and if we fail we have to notify the listener
            // this will cause some back pressure on the search end and eventually will cause rejections but that's fine
            // we can't proceed with a search on a cluster level.
public void fetchSearchShards(ClusterSearchShardsRequest searchRequest,
     * will invoke the listener immediately.
     */
    public void ensureConnected(ActionListener<Void> voidActionListener) {
        if (connectedNodes.isEmpty()) {
            connectHandler.connect(voidActionListener);
        } else {
            voidActionListener.onResponse(null);
public void ensureConnected(ActionListener<Void> voidActionListener) {

    private void fetchShardsInternal(ClusterSearchShardsRequest searchShardsRequest,
                                     final ActionListener<ClusterSearchShardsResponse> listener) {
        final DiscoveryNode node = nodeSupplier.get();
        transportService.sendRequest(node, ClusterSearchShardsAction.NAME, searchShardsRequest,
            new TransportResponseHandler<ClusterSearchShardsResponse>() {

void collectNodes(ActionListener<Function<String, DiscoveryNode>> listener) {
            request.clear();
            request.nodes(true);
            request.local(true); // run this on the node that gets the request it's as good as any other
            final DiscoveryNode node = nodeSupplier.get();
            transportService.sendRequest(node, ClusterStateAction.NAME, request, TransportRequestOptions.EMPTY,
                new TransportResponseHandler<ClusterStateResponse>() {
                    @Override
public String executor() {
                    }
                });
        };
        if (connectedNodes.isEmpty()) {
            // just in case if we are not connected for some reason we try to connect and if we fail we have to notify the listener
            // this will cause some back pressure on the search end and eventually will cause rejections but that's fine
            // we can't proceed with a search on a cluster level.
public String executor() {
     * given node.
     */
    Transport.Connection getConnection(DiscoveryNode remoteClusterNode) {
        DiscoveryNode discoveryNode = nodeSupplier.get();
        Transport.Connection connection = transportService.getConnection(discoveryNode);
        return new Transport.Connection() {
            @Override
public void close() throws IOException {
    }

    Transport.Connection getConnection() {
        DiscoveryNode discoveryNode = nodeSupplier.get();
        return transportService.getConnection(discoveryNode);
    }


        @Override
    public void close() throws IOException {
        connectHandler.close();
    }
boolean isNodeConnected(final DiscoveryNode node) {
        return connectedNodes.contains(node);
    }


    /**
     * Fetches connection info for this connection
     */
    public void getConnectionInfo(ActionListener<RemoteConnectionInfo> listener) {
        final Optional<DiscoveryNode> anyNode = connectedNodes.stream().findAny();
        if (anyNode.isPresent() == false) {
            // not connected we return immediately
            RemoteConnectionInfo remoteConnectionStats = new RemoteConnectionInfo(clusterAlias,
public String executor() {
    int getNumNodesConnected() {
        return connectedNodes.size();
    }
}
package org.elasticsearch.transport;

import org.apache.lucene.store.AlreadyClosedException;
import org.elasticsearch.Build;
import org.elasticsearch.Version;
import org.elasticsearch.action.ActionListener;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Function;

public void testCollectNodes() throws Exception {
            }
        }
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import com.google.common.reflect.TypeToken;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.io.IOException;
import java.lang.reflect.Type;
 */
@Beta
public class ProgramClient {

  private static final Gson GSON = new GsonBuilder()
    .registerTypeAdapter(WorkflowActionSpecification.class, new WorkflowActionSpecificationCodec())
    .registerTypeAdapter(CustomActionSpecification.class, new CustomActionSpecificationCodec())
public void stopAll(NamespaceId namespace)
          ProgramId program = appId.program(programRecord.getType(), programRecord.getName());
          String status = this.getStatus(program);
          if (!status.equals("STOPPED")) {
            this.stop(program);
            this.waitForStatus(program, ProgramStatus.STOPPED, 60, TimeUnit.SECONDS);
          }
        } catch (ProgramNotFoundException e) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
package com.thinkaurelius.titan.graphdb.types.system;

import com.google.common.collect.ImmutableSet;
import com.thinkaurelius.titan.core.TypeGroup;
import com.thinkaurelius.titan.graphdb.types.group.StandardTypeGroup;
	public static SystemType getSystemEdgeType(long id) {
		if (systemEdgeTypes==null) {
			//Initialize
			systemEdgeTypes=new HashMap<Long,SystemType>();
			for (SystemType et : SystemKey.values()) {
				assert !systemEdgeTypes.containsKey(et.getID());
				systemEdgeTypes.put(Long.valueOf(et.getID()), et);
			}
			for (SystemType et : SystemLabel.values()) {
				assert !systemEdgeTypes.containsKey(et.getID());
				systemEdgeTypes.put(Long.valueOf(et.getID()), et);
			}
		}
		SystemType et = systemEdgeTypes.get(Long.valueOf(id));
		if (et==null) throw new IllegalArgumentException("System edge type is unknown with ID:" + id);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import java.util.AbstractSet;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
public synchronized boolean remove(Object o) {
    }

    /**
     * Synchronized clearing of the set
     * Copy of the HashSet code if clear()
     * 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
<?xml version="1.0" encoding="UTF-8"?>
<classpath>
	<classpathentry kind="src" path="src"/>
	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
	<classpathentry kind="lib" path="lib/commons-codec-1.9.jar"/>
	<classpathentry kind="lib" path="/home/kevin/University Twente/softwaresystemen/Rolit/lib/forms-1.3.0.jar" sourcepath="forms-1.3.0-src.zip"/>
	<classpathentry kind="output" path="bin"/>
</classpath>
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;

/**.
 * Game board for Rolit
 *
 * @author Sophie Lathouwers & Kevin Alberts
 * @version $Revision: 1.0 $
 */
public class Board {

	/*		CONSTANTS		*/
	/**.
public boolean canHitDiagonalRightLeft(int index, Mark m) {
	public int getPlayerCount() {
		return this.amountPlayers;
	}
}
 * @author Sophie Lathouwers & Kevin Alberts
 * @version $Revision: 1.0 $
 */
public class Game extends Observable {

    // -- Instance variables -----------------------------------------
	/**.
public Game(ArrayList<Player> players) {

    /**
     * Starts the Rolit game. <br>
     * Asks after each ended game if the user want to continue. Continues until
     * the user does not want to play anymore.
     */
    public void start() {
        boolean oneMoreTime = true;
        while (oneMoreTime) {
            reset();
            play();
            oneMoreTime = readBoolean("\n> Play another time? (y/n)?", "y", "n");
        }
    }

    /**
     * Prints a question which can be answered by yes (true) or no (false).
     * After prompting the question on standard out, this method reads a String
     * from standard in and compares it to the parameters for yes and no. If the
     * user inputs a different value, the prompt is repeated and te method reads
     * input again.
     *
     * @param prompt the question to print
     * @param yes
     *            the String corresponding to a yes answer
     * @param no
     *            the String corresponding to a no answer
     * @return true is the yes answer is typed, false if the no answer is typed
     */
    private boolean readBoolean(String prompt, String yes, String no) {
        String answer;
        do {
            System.out.print(prompt);
            Scanner in = new Scanner(System.in);
            answer = in.hasNextLine() ? in.nextLine() : null;
        } while (answer == null || (!answer.equals(yes) && !answer.equals(no)));
        return answer.equals(yes);
    }

    /**
     * Resets the game. <br>
     * The board is emptied and player[0] becomes the current player.
     */
    private void reset() {
        current = 0;
        board.reset();
    }
private void play() {
     * Performs one move and notifies the observers
     */
    public void playOneMove() {
    	int keuze = playersArray[current].makeMove(board);
    	this.lastMoveMade = keuze;
    	current = (current + 1) %!n(MISSING)umPlayers;
    	update();
        setChanged();
public int getPlayerCount() {
	public void resetGame() {
		this.reset();
	}
}
	 * higher means less verbose
	 */
	private static final int LOGLEVEL = 0;
	/**
	 * log method to print errors, debugs, incoming messages, etc.
	 * @param level - level of the log,
	public static void log(int level, String string) {
		String levelString;
		switch(level) {
			case 0:
				levelString = "DEBUG";
				break;
			case 1:
				levelString = "INFO";
				break;
			case 2:
				levelString = "WARNING";
				break;
			case 3:
				levelString = "ERROR";
				break;
			case 4:
				levelString = "MSG";
				break;
			case 5:
				levelString = "COMMAND";
				break;
			case 6:
				levelString = "CUSTOMCMD";
				break;
			default:
				levelString = "INFO";
				break;
public Mark next(int numPlayers) {
		}
		return next;
	}
}
public Mark getMark() {
    public int makeMove(Board board) {
    	int keuze = determineMove(board);
    	board.setField(keuze, getMark());
    	setChanged();
    	notifyObservers();
    	return keuze;
public Client(String serverName, int serverPort, String nickName){
	
	private void connectServer(){
		
		Logger.log(1, "Establishing connection with server...");
		try{
			socket = new Socket(this.serverIP, this.serverPort);
			Logger.log(1, "Connected to server "+socket.getInetAddress()+":"+socket.getPort());
			start();
		}catch(UnknownHostException e){
			Logger.log(3, "Unknown host: "+e.getMessage());
		}catch(IOException e){
			Logger.log(3, "Unexpected error: "+e.getMessage());
		}
	}
	
public void run() {
				streamOut.flush();
				handle(message);
			}catch(IOException e){
				Logger.log(3, "Cannot send string: "+e.getMessage());
				stop();
			}
		}
public void start() throws IOException{
	public void stop(){
		try{
			if(streamIn != null){
				Logger.log(1, "Stopping client! [Closing InputStream]");
				streamIn.close();
				streamIn = null;
			}
			if(streamOut != null){
				Logger.log(1, "Stopping client! [Closing OutputStream]");
				streamOut.close();
				streamOut = null;
			}
			if(server != null){
				Logger.log(1, "Stopping client! [Closing ServerHandler]");
				server.close();
				server = null;
			}
			if(socket != null){
				Logger.log(1, "Stopping client! [Closing Socket]");
				socket.close();
				socket = null;
			}
		}catch(IOException e){
			Logger.log(3, "Failed closing the connection.");
		}
		if(thread != null){
			try {
				thread.join();
				Logger.log(1, "Stopping client! [Thread joined main program]");
			} catch (InterruptedException e) {
				Logger.log(3, "Could not stop client! [Thread failed to join]");
			}
			thread = null;
		}
	public InputHandler(Client client) {
		this.parentClient = client;
		
		Logger.log(0, "InputHandler breaking off into own thread");
		this.thread = new Thread(this);
		this.thread.start();
	}
	
	public void listen(){
		Logger.log(0, "Started listening to console input");
		while(!finished){
			try {
				this.lastMessage = this.consoleInReader.readLine();
				this.consoleOutWriter.write(this.lastMessage);
				this.parentClient.handleInput(this.lastMessage);
			} catch (IOException e) {
				Logger.log(3, "Could not send messages to client ["+e.getMessage()+"]");
			}
		}
	}
public void open(){
		try{
			streamIn = new DataInputStream(socket.getInputStream());
		}catch(IOException e){
			Logger.log(3, "Could not get input stream: "+e.getMessage());
			client.stop();
		}
	}
public void close(){
				streamIn.close();
			}
		}catch(IOException e){
			Logger.log(3, "Could not close input stream: "+e.getMessage());
		}
	}
	
public void run(){
			try{
				client.handle(streamIn.readUTF());
			}catch(IOException e){
				Logger.log(3, "Listening error: "+e.getMessage());
				client.stop();
			}
		}
private void startGame() {
	public static void main(String[] args){
		if (args.length > 1 && args.length < 5) {
			ArrayList<Player> players = new ArrayList<Player>();
	        Mark[] marks = {Mark.RED, Mark.YEL, Mark.BLU, Mark.GRN}; 
	        for(int i=0; i<args.length; i++){
	        	players.add(Rolit.createPlayer(args[i], marks[i]));
	        }
public void executeCommand(String msg) throws IllegalArgumentException, IOExcept
	* @param version Een beschrijving van wat de server kan
	*/
	public void handshake(int supports, String version) throws IOException {
		Logger.log(5, "hello "+supports+" "+version);
	}

	/**
public void handshake(int supports, String version) throws IOException {
	* @throws IOException
	*/
	public void handshake(int supports, String version, String nonce) throws IOException {
		Logger.log(5, "hello "+supports+" "+version+" "+nonce);
	}

	/**
public void handshake(int supports, String version, String nonce) throws IOExcep
	* @throws IOException
	*/
	public void authOk() throws IOException {
		Logger.log(5, "authok");
	}

	/**
public void authOk() throws IOException {
	* @param errorCode De error-code, op te zoeken in de errorCode-tabel.
	*/
	public void error(int errorCode) throws IOException {
		Logger.log(5, "error "+errorCode);
	}

	/**
public void error(int errorCode) throws IOException {
	* @param noPlayers Het aantal spelers in het spel.
	*/
	public void game(String creator, int status, int noPlayers) throws IOException {
		Logger.log(5, "game "+creator+" "+status+" "+noPlayers);
	}

	/**
public void game(String creator, int status, int noPlayers) throws IOException {
	* @param playerTwo De tweede speler
	*/
	public void start(String playerOne, String playerTwo) throws IOException {
		Logger.log(5, "start "+playerOne+" "+playerTwo);
	}

	/**
public void start(String playerOne, String playerTwo) throws IOException {
	* @param playerThree De derde speler
	*/
	public void start(String playerOne, String playerTwo, String playerThree) throws IOException {
		Logger.log(5, "start "+playerOne+" "+playerTwo+" "+playerThree);
	}

	/**
public void start(String playerOne, String playerTwo, String playerThree) throws
	* @param playerFour De vierde speler
	*/
	public void start(String playerOne, String playerTwo, String playerThree, String playerFour) throws IOException {
		Logger.log(5, "start "+playerOne+" "+playerTwo+" "+playerThree+" "+playerFour);
	}

	/**
public void start(String playerOne, String playerTwo, String playerThree, String
	* @requires Dat de speler ook echt aan de beurt is.
	*/
	public void move() throws IOException {
		Logger.log(5, "move");
	}

	/**
public void move() throws IOException {
	* @param y Y-coördinaat, waarbij de bovenkant 0 is en de onderkant 7.
	*/
	public void moveDone(String name, int x, int y) throws IOException {
		Logger.log(5, "movedone "+name+" "+x+" "+y);
	}
	
	/**
public void moveDone(String name, int x, int y) throws IOException {
	* @requires Dat één van de mensen is weggegaan
	*/
	public void gameOver() throws IOException {
		Logger.log(5, "gameover");
	}

	/**
public void gameOver(int score, String[] winners) throws IOException {
		for(String winner : winners){
			winnerString = winnerString+winner;
		}
		Logger.log(5, "gameover "+score+" "+winnerString);
	}

	/**
public void gameOver(int score, String[] winners) throws IOException {
	* @param body Tekst van het chatbericht
	*/
	public void message(String name, String body) throws IOException {
		Logger.log(5, "message "+name+" "+body);
	}

	/**
public void message(String name, String body) throws IOException {
	* @param challenger De uitdager
	*/
	public void challenge(String challenger, String other1) throws IOException {
		Logger.log(5, "challenge "+challenger+" "+other1);
	}

	/**
public void challenge(String challenger, String other1) throws IOException {
	* @param other1 Andere gebruiker
	*/
	public void challenge(String challenger, String other1, String other2) throws IOException {
		Logger.log(5, "challenge "+challenger+" "+other1+" "+other2);
	}

	/**
public void challenge(String challenger, String other1, String other2) throws IO
	* @param other2 Andere gebruiker 2
	*/
	public void challenge(String challenger, String other1, String other2, String other3) throws IOException {
		Logger.log(5, "challenge "+challenger+" "+other1+" "+other2+" "+other3);
	}

	/**
public void challenge(String challenger, String other1, String other2, String ot
	* @param accept Of deze persoon accepteert.
	*/
	public void challengeResponse(String name, boolean accept) throws IOException {
		Logger.log(5, "challengeresponse "+name+" "+String.valueOf(accept));
	}

	/**
public void challengeResponse(String name, boolean accept) throws IOException {
	* @param flag Of hij kan worden uitgedaagd.
	*/
	public void canBeChallenged(String name, boolean flag) throws IOException {
		Logger.log(5, "canbechallenged "+name+" "+String.valueOf(flag));
	}

	/**
public void highscore(String[] args) throws IOException {
		for(String arg : args){
			argString = argString + arg;
		}
		Logger.log(5, "highscore "+argString);
	}

	/**
public void highscore(String[] args) throws IOException {
	* zonder chat.
	*/
	public void online(String name, boolean isOnline) throws IOException {
		Logger.log(5, "online "+name+" "+String.valueOf(isOnline));
	}
	
	public ClientProtocol(){
package rolit.network;

import java.util.ArrayList;

import rolit.Game;
import rolit.server.ClientHandler;

public class NetworkGame {
	public ClientHandler ownerClient = null;
	public ArrayList<ClientHandler> participants = new ArrayList<ClientHandler>();
	public Game game = null;
	public boolean hasStarted = false;
	
	public boolean isFull() {
		return (participants.size() == Game.MAX_PLAYERS && participants.size() <= Game.MAX_PLAYERS);
	}
	
	public void addPlayer(String name){
		participants.add(this.ownerClient.parentServer.getClient(name));
	}

	public void removePlayer(ClientHandler clientHandler) {
		participants.remove(clientHandler);
	}
}
public static PublicKey getPublicKey(String user) {
			KeyFactory keyFactory = KeyFactory.getInstance("RSA");
			return keyFactory.generatePublic(keySpec);
		} catch (InvalidKeySpecException e) {
			Logger.log(3, "Could not convert received data into key specification ["+e.getMessage()+"]");
		} catch (NoSuchAlgorithmException e) {
			Logger.log(3, "Could not convert received data into Public Key ["+e.getMessage()+"]");
		} catch (IOException e) {
			Logger.log(3, "Error communicating with Security Server ["+e.getMessage()+"]");
		}
		return null;
	}
public static PrivateKey getPrivateKey(String user, String pass){
			keyFactory = KeyFactory.getInstance("RSA");
			return keyFactory.generatePrivate(keySpec);
		} catch (NoSuchAlgorithmException e) {
			Logger.log(3, "Could not convert data into Private Key ["+e.getMessage()+"]");
		} catch (InvalidKeySpecException e) {
			Logger.log(3, "Could not convert data into key specification ["+e.getMessage()+"]");
		} catch (IOException e) {
			Logger.log(3, "Error communicating with Security Server ["+e.getMessage()+"]");
		}
		return null;
		
public static boolean verify(byte[] cypherText, byte[] original, PublicKey publi
			signature.update(original);
			return signature.verify(cypherText);
		} catch (NoSuchAlgorithmException e) {
			Logger.log(3, "Could not verify key ["+e.getMessage()+"]");
		} catch (InvalidKeyException e) {
			Logger.log(3, "Invalid key ["+e.getMessage()+"]");
		} catch (SignatureException e) {
			Logger.log(3, "Signature exception ["+e.getMessage()+"]");
		}
		return false;
	}
public static boolean verify(byte[] cypherText, byte[] original, PublicKey publi
			sign.update(original);
			return sign.sign();
		} catch (NoSuchAlgorithmException e) {
			Logger.log(3, "Could not verify key ["+e.getMessage()+"]");
		} catch (InvalidKeyException e) {
			Logger.log(3, "Invalid key ["+e.getMessage()+"]");
		} catch (SignatureException e) {
			Logger.log(3, "Signature exception ["+e.getMessage()+"]");
		}
		return null;
		
	* @param version Een beschrijving van wat de client kan.
	*/
	public void hello(String clientName, int supports, String version) {
		Logger.log(5, ServerProtocol.HANDSHAKE+" "+clientName+" "+supports+" "+version);
		Logger.log(0, "Client exists? "+this.parentHandler.parentServer.hasClient(clientName));
		if(!this.parentHandler.clientInfo.hasAuthed && !this.parentHandler.clientInfo.hasHandshaked && !this.parentHandler.parentServer.hasClient(clientName)){
			this.setNickname(clientName);
			this.setSupports(supports);
public void hello(String clientName, int supports, String version) {
				this.setNeedsAuth(true);
				this.parentHandler.sendCommand(ClientProtocol.HANDSHAKE, new String[]{String.valueOf(this.getServerSupports()), this.getServerVersion(), this.getNonce()});
				this.setSentNonce(true);
				Logger.log(0, "The nonce signed with your private key, converted to base64 is:");
				Logger.log(0, Security.base64Encode(Security.sign(this.getNonce().getBytes(), this.parentHandler.clientInfo.privateKey)));
			}else{
				// Needs no authing
				this.setNeedsAuth(false);
				this.setAuthDone(true);
				this.parentHandler.sendCommand(ClientProtocol.HANDSHAKE, new String[]{String.valueOf(this.getServerSupports()), this.getServerVersion()});
			}
			this.setHandshakeDone(true);
		}else if(this.isAuthDone()){
public void hello(String clientName, int supports, String version) {
	 * @param errorcode Errorcode (-1 voor generic error)
	 */
	public void error(int errorCode){
		Logger.log(5, ServerProtocol.ERROR+" "+errorCode);
		Logger.log(3, Errors.getError(1, errorCode));
		this.parentHandler.parentServer.handleError(1, errorCode);
	}

public void error(int errorCode){
	* @param signature De gesignde nonce
	*/
	public void auth(String signature) {
		Logger.log(5, ServerProtocol.AUTH+" "+signature);
		if(this.isHandshakeDone() && this.hasSentNonce() && this.needsAuth() && !this.isAuthDone()){
			Logger.log(0, "Validating signature");
			if(this.checkAuth(signature)){
				this.setAuthDone(true);
				this.parentHandler.sendCommand(ClientProtocol.AUTH_OK, new String[0]);
			}else{
				this.sendError(Errors.ERROR_INVALID_LOGIN);
				try {
					Logger.log(2, "Invalid signed nonce. Closing connection.");
					this.parentHandler.close();
				} catch (IOException e) {
					Logger.log(3, "Could not close connection. ["+e.getMessage()+"]");
				}
			}
		}else if(!this.parentHandler.clientInfo.hasHandshaked){
public void auth(String signature) {
	* @requires Dat de client nog geen spel is begonnen
	*/
	public void createGame() {
		Logger.log(5, ServerProtocol.CREATE_GAME);
		if(this.isHandshakeDone() && !this.hasGame()){
			this.setNetworkGame(new NetworkGame(), true);
			this.setOwnsGame(true);
public void createGame() {
	* @param creator De maker van het spel
	*/
	public void joinGame(String creator) {
		Logger.log(5, ServerProtocol.JOIN_GAME+" "+creator);
		try{
			if(this.isHandshakeDone() && !this.hasGame() && this.parentHandler.parentServer.getClient(creator).clientInfo.hasGame && !this.getGameForClient(creator).isFull()){
				this.getGameForClient(creator).addPlayer(this.getNick());
public void joinGame(String creator) {
	* Start het spel waarvan de gebruiker de creator is.
	*/
	public void startGame() {
		Logger.log(5, ServerProtocol.START_GAME);
		if(this.isHandshakeDone() && this.hasGame() && this.getNetworkGame().ownerClient.getNick().toLowerCase().equals(this.getNick().toLowerCase()) && this.getNetworkGame().hasStarted == false){
			
		}else if(!this.isHandshakeDone()){
			this.sendError(ClientProtocol.ERROR_HANDSHAKE_MISSING);
		}else if(!this.hasGame()){
public void startGame() {
			this.sendGenericError();
		}else if(this.getNetworkGame().hasStarted == true){
			this.sendError(ClientProtocol.ERROR_GAME_FULL);
		}else{
			this.sendGenericError();
		}
public void startGame() {
	* @param y Y-coördinaat
	*/
	public void move(int x, int y) {
		Logger.log(5, ServerProtocol.MOVE+" "+x+" "+y);
		if(this.isHandshakeDone() && this.hasGame() && this.getNetworkGame().game.getCurrentPlayer() == this.parentHandler.clientInfo.mark){
			GUIPlayer p = (GUIPlayer) this.getNetworkGame().game.getPlayer();
			Board b = this.getNetworkGame().game.getBoard();
			int index = b.index(x, y);
			if(p.isMoveValid(index, b)){
				p.chooseMove(index);
				this.parentHandler.sendCommand(ClientProtocol.MOVE_DONE, new String[]{String.valueOf(x), String.valueOf(y)});
			}else{
				this.sendError(ClientProtocol.ERROR_INVALID_MOVE);
			}
		}else if(!this.isHandshakeDone()){
			this.sendError(ClientProtocol.ERROR_HANDSHAKE_MISSING);
		}else if(!this.hasGame()){
			this.sendError(ClientProtocol.ERROR_NO_SUCH_GAME);
		}else if(this.getNetworkGame().game.getCurrentPlayer() != this.parentHandler.clientInfo.mark){
			this.sendError(ClientProtocol.ERROR_INVALID_MOVE);
		}else{
			this.sendGenericError();
		}
	}

public void move(int x, int y) {
	* @param body Het bericht
	*/
	public void message(String body) {
		Logger.log(5, ServerProtocol.MESSAGE+" "+body);
		int s = this.parentHandler.parentServer.serverInfo.supports;
		if(this.isHandshakeDone() && (s == ServerProtocol.SERVER_SUPPORTS_CHAT || s == ServerProtocol.SERVER_SUPPORTS_CHATCHALLENGE)){
			// Prepend nickname to message as our protocol
public void challenge(String[] others){
			log = log+" "+others[i];
		}
		
		Logger.log(5, log);
		int s = this.parentHandler.parentServer.serverInfo.supports;
		if(this.isHandshakeDone() && !this.hasGame() && this.isChallenger() && this.isChallenged() && this.canBeChallenged(os) && (s == ServerProtocol.SERVER_SUPPORTS_CHALLENGE || s == ServerProtocol.SERVER_SUPPORTS_CHATCHALLENGE)){
			for(ClientHandler client : os){
public void challenge(String[] others){
	* @param accept Of de client accepteert
	*/
	public void challengeResponse(boolean accept) {
		Logger.log(5, ServerProtocol.CHALLENGE_RESPONSE+" "+String.valueOf(accept));
		if(this.isHandshakeDone() && this.isChallenged()){
			String challenger = this.getChallenger();
			String[] args = new String[]{challenger, String.valueOf(accept)};
public void challengeResponse(boolean accept) {
	* @param arg Een argument (bijv. 2014-01-01)
	*/
	public void highscore(String type, String arg) {
		Logger.log(5, ServerProtocol.HIGHSCORE+" "+type+" "+arg);
		if(this.isHandshakeDone()){
			// TODO: Implement leaderboard.
			//this.parentHandler.parentServer.getLeaderboard().getScore(type, arg);	
public void highscore(String type, String arg) {
	* @requires Dat de handshake is gedaan
	*/
	public void customListGames(){
		Logger.log(6, ServerProtocol.CUSTOM_LIST_GAMES);
		if(this.isHandshakeDone()){
			ArrayList<NetworkGame> games = this.parentHandler.parentServer.getGames();
			
public void customListGames(){

	public boolean isValidCommand(String msg) {
		
		Logger.log(0, "Checking command "+msg+" for validity");
		
		String[] splitCommand = msg.split(" ");
		String command = splitCommand[0].toLowerCase();
		int numArgs = splitCommand.length-1;
		
		if(serverCommands.containsKey(command)){
			for(int possibleArgs : serverCommands.get(command)){
				Logger.log(0, "Command has "+numArgs+" arguments and can have "+possibleArgs);
				if(numArgs == possibleArgs){
					return true;
				}
public boolean isValidCommand(String msg) {
				}
			}
		}
		Logger.log(0, "Invalid command.");
		return false;
	}
	
private String generateNonce() {
	
	// Command helper functions
	public void sendGenericError(){
		Logger.log(3, "Sending generic error to client.");
		this.parentHandler.sendCommand(ClientProtocol.ERROR, new String[]{String.valueOf(ClientProtocol.ERROR_GENERIC)});
	}
	
	public void sendError(int errorcode){
		Logger.log(3, "Sending error to client. ["+Errors.getError(1, errorcode)+"]");
		this.parentHandler.sendCommand(ClientProtocol.ERROR, new String[]{String.valueOf(errorcode)});
	}
	
public void broadcastGame(NetworkGame game){
		this.parentHandler.sendCommand(ClientProtocol.GAME, new String[]{creator, status, numPlayers});
	}
	
	public ServerProtocol(ClientHandler handler){
		// Add commands to serverCommands Map
		// to help with command detection and
public ClientHandler(Server server, Socket client){
		this.parentServer = server;
		this.socket = client;
		
		Logger.log(0, "ClientHandler breaking off into own thread");
		this.thread = new Thread(this);
		this.thread.start();
	}
public String getNick(){
	}
	
	public void listen(){
		Logger.log(0, "Started listening to client "+this.clientInfo.nickName);
		while(!finished){
			try {
                this.lastMessage = this.inReader.readLine();
public void listen(){
                
	        } catch (IOException e) {
	        	if(!this.finished){
	                Logger.log(3, "Could not receive messages from client ["+e.getMessage()+"]");
	                try {
	                		this.close();
					} catch (IOException e1) {
						Logger.log(3, "Could not close ClientHandler ["+e.getMessage()+"]");
					}
	        	}
	        } catch (NullPointerException npe){
	        	for(StackTraceElement e : npe.getStackTrace()){
	        		Logger.log(0, e.toString());
	        	}
	        	Logger.log(3, "Unexpected client disconnect! ["+npe.getMessage()+"]");
	        	try {
	        		if(!this.finished){
	        			this.close();
	        		}
	        	} catch (IOException e) {
	        		Logger.log(3, "Could not close ClientHandler ["+e.getMessage()+"]");
	        	}
	        }
		}
	}
	
	public void run(){
		Logger.log(0, "Trying to open channel to client");
        Logger.log(1, "Client has been assigned the name "+this.clientInfo.nickName);
        try {
                this.inStream = this.socket.getInputStream();
                this.inReader = new BufferedReader(new InputStreamReader(this.inStream));
                this.outStream = this.socket.getOutputStream();
                this.outWriter = new BufferedWriter(new OutputStreamWriter(this.outStream));
                Logger.log(1, "Opened channel");
        } catch (IOException e) {
                Logger.log(3, "Unable to open channel ["+e.getMessage()+"]");
        }
        this.listen();
	}
public void send(String msg) {
                this.outWriter.write(msg+"\n");
                this.outWriter.flush();
        } catch (IOException e) {
                Logger.log(3, "Could not send message "+msg+" ["+e.getMessage()+"]");
                try {
                	if(!this.finished){
                		this.close();
                	}
				} catch (IOException e1) {
					Logger.log(3, "Could not close connection with client "+this.getNick()+" ["+e1.getMessage()+"]");
				}
        }
	}
public void sendCommand(String string, String[] args){
			case ClientProtocol.GAME:
			case ClientProtocol.MESSAGE:
			case ClientProtocol.ONLINE:
				Logger.log(1, "Server Broadcasted: "+string+body);
				broadcast(string+body);
				break;
			default:
				Logger.log(1, "Server sent to "+this.getNick()+": "+string+body);
				send(string+body);
		}
	}
	public boolean hasGame = false;
	public boolean ownsGame = false;
	public NetworkGame networkGame = null;
	public Mark mark = null;
	
	// Challenge
	public boolean isChallenged = false;
	public InputHandler(Server server) {
		this.parentServer = server;
		
		Logger.log(0, "InputHandler breaking off into own thread");
		this.thread = new Thread(this);
		this.thread.start();
	}
	
	public void listen(){
		Logger.log(0, "Started listening to console input");
		while(!finished){
			try {
				this.lastMessage = this.consoleInReader.readLine();
				Logger.log(0, "Received console input: "+this.lastMessage);
				this.parentServer.handleInput(this.lastMessage);
			} catch (IOException e) {
				Logger.log(3, "Could not read from console. ["+e.getMessage()+"]");
			}
		}
	}
public InetAddress getLocalIp(){
        	try{
        		addr = InetAddress.getLocalHost();
        	}catch(Exception e){
        		Logger.log(3, e.getMessage());
        	}
        	return addr;        
        }
public int getPort(){
	}
	
	public void run() {
		Logger.log(1, "Starting server on port "+this.serverInfo.port);
		Logger.log(0, "Local IP: "+this.serverInfo.localIp.getHostAddress()+" - Port: "+String.valueOf(this.serverInfo.port));
		
		try {
			this.server = new ServerSocket(this.serverInfo.port);
			Logger.log(0, "ServerSocket created on port "+this.serverInfo.port);
			
			inputHandler = new InputHandler(this);
			
			while(!finished){
				Socket client = this.server.accept();
				Logger.log(1, "New client connected from "+client.getInetAddress().getHostAddress()+":"+String.valueOf(client.getPort()));
				ClientHandler clientHandler = new ClientHandler(this, client);
				connectedClients.add(clientHandler);
			}
			System.exit(0);
		} catch (IOException e) {
			Logger.log(3, "Failed to start server ["+e.getMessage()+"]");
		}
	}
	
public Server(int port){
		this.serverInfo.port = port;
		this.serverInfo.localIp = getLocalIp();

		Logger.log(0, "Server breaking off into own thread");
		this.thread = new Thread(this);
		this.thread.start();
	}
public static void main(String[] args){
	}
	
	public void messageReceived(ClientHandler clientHandler, String msg){
		Logger.log(4, msg);
		if(clientHandler.protocol.isValidCommand(msg)){
			try {
				clientHandler.protocol.executeCommand(msg);
			} catch (IllegalArgumentException e) {
				Logger.log(3, "Illegal arguments in command "+msg+" ["+e.getMessage()+"]");
			} catch (IOException e) {
				Logger.log(3, "Error while processing command "+msg+" ["+e.getMessage()+"]");
			}
		}
	}
	
	public void broadcast(String msg){
		for(ClientHandler client : this.connectedClients){
			if(client.protocol.isHandshakeDone() && client.protocol.isAuthDone()){
				Logger.log(0, "Sending msg to client "+client.getNick());
				client.send(msg);	
			}
		}
public void setupConsoleCommands(){
	}
	
	public void executeConsoleCommand(String cmd){
		Logger.log(0, "Executing console command "+cmd);
		switch(cmd.split(" ")[0]){
			case "exit":
			case "quit":
			case "stop":
				Logger.log(2, "Stopping server!");
				this.close();
				break;
			case "kick":
				this.kick(cmd.split(" ")[1]);
				break;
			default:
				Logger.log(3, "Command not implemented: "+cmd);
				break;
				
		}
public ClientHandler getClient(String name) {
	}
	
	public void kick(String clientName){
		Logger.log(1, "Kicking client "+clientName);
		try {
			this.getClient(clientName).close();
		} catch (IOException e) {
			Logger.log(3, "Couldn't kick client. ["+e.getMessage()+"]");
		} catch (NullPointerException e){
			Logger.log(3, "Couldn't kick client. [No such client]");
		}
	}
	
	public void close(){
		this.finished = true;
		Logger.log(1, "Stopped listening for clients.");
		ArrayList<ClientHandler> tempList = new ArrayList<ClientHandler>();
		for(ClientHandler c : this.connectedClients){
			tempList.add(c);
		}
		Logger.log(1, "Disconnecting connected clients");
		for(ClientHandler c : tempList){
			try {
				c.close();
			} catch (IOException e) {
				Logger.log(3, "Error closing client."+e.getMessage());
			}
		}
		Logger.log(1, "Stopping process.");
		System.exit(0);
	}
}
	
	// Server info
	public int supports = 1;
	public String version = "KSS_v0.1";
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import org.jtrfp.trcl.Submitter;
import org.jtrfp.trcl.gpu.GLProgram;
import org.jtrfp.trcl.gpu.GLUniform;
import org.jtrfp.trcl.gpu.GlobalDynamicTextureBuffer;
import org.jtrfp.trcl.mem.PagedByteBuffer;
import org.jtrfp.trcl.obj.PositionedRenderable;
import org.jtrfp.trcl.obj.WorldObject;
public RenderList(GL3 gl, GLProgram prg, TR tr){
		renderModeUniform=prg.getUniform("renderFlags");
		renderListPageTable=prg.getUniform("renderListPageTable");
		hostRenderListPageTable=new int[ObjectListWindow.OBJECT_LIST_SIZE_BYTES_PER_PASS*RenderList.NUM_RENDER_PASSES/PagedByteBuffer.PAGE_SIZE_BYTES];
		
		tr.getGPU().addGLEventListener(new GLEventListener(){
		    @Override
		    public void init(GLAutoDrawable drawable) {
			System.out.println("hostRenderListPageTable length="+hostRenderListPageTable.length);
			for(int i=0; i<hostRenderListPageTable.length;i++){
			    hostRenderListPageTable[i]=RenderList.this.tr.getObjectListWindow().logicalPage2PhysicalPage(i);
			}//end for(hostRenderListPageTable.length)
			renderListPageTable.setArrayui(hostRenderListPageTable);
			modulusUintOffset = (RenderList.this.tr.getObjectListWindow().getPhysicalAddressInBytes(0)%!P(MISSING)agedByteBuffer.PAGE_SIZE_BYTES)/4;
		    }
		    @Override
		    public void dispose(GLAutoDrawable drawable) {}
		    @Override
		    public void display(GLAutoDrawable drawable) {}
		    @Override
		    public void reshape(GLAutoDrawable drawable, int x, int y,
			    int width, int height) {}});
	    }
	private static int frameCounter=0;
	
public void run(){
			//frame.pack();
			}});
		}catch(Exception e){e.printStackTrace();}
		gpu.takeGL();
		renderer=new Renderer(gpu);
		gpu.releaseGL();
public void run(){
				256*mapSquareSize,
				mapSquareSize*visibilityDiameterInMapSquares/2., this);
		getRenderer().setRootGrid(world);
		threadManager = new ThreadManager(this);
		}//end constructor
	
	public void showStopper(final Exception e)
package org.jtrfp.trcl.core;

import java.util.List;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.ScheduledThreadPoolExecutor;

import javax.media.opengl.GLAutoDrawable;
import javax.media.opengl.GLEventListener;

import com.jogamp.opengl.util.FPSAnimator;


public class ThreadManager
	{
	public static final int RENDER_FPS=60;
	public static final int GAMEPLAY_FPS=RENDER_FPS;
	public static final int RENDERLIST_REFRESH_FPS=5;
	public static final int RENDERING_PRIORITY=6;
	public static final int SOUND_PRIORITY=8;
	private final TR tr;
	private final FPSAnimator renderingAnimator;
	private final Timer gameplayTimer = new Timer("GameplayTimer");
	private long lastGameplayTickTime=0;
	private long timeInMillisSinceLastGameTick=0L;
	
	private int counter=0;
	
	ThreadManager(TR tr)
		{this.tr=tr;
		renderingAnimator = new FPSAnimator((GLCanvas)tr.getGPU().getComponent(),RENDER_FPS);
		tr.getGPU().addGLEventListener(new GLEventListener()
			{
			@Override
			public void init(GLAutoDrawable drawable)
				{}

			@Override
			public void dispose(GLAutoDrawable drawable)
				{}

			@Override
			public void display(GLAutoDrawable drawable)
				{
				Thread.currentThread().setPriority(RENDERING_PRIORITY);
				ThreadManager.this.tr.getGPU().getMemoryManager().map();
				if(counter++%!((MISSING)RENDER_FPS/RENDERLIST_REFRESH_FPS)==0)visibilityCalc();
				gameplay();
				ThreadManager.this.tr.getRenderer().render();
				}

			@Override
			public void reshape(GLAutoDrawable drawable, int x, int y,
					int width, int height)
				{display(drawable);}
			});
		
		}//end constructor
	
	private void gameplay(){
	 // Ticks
		final long tickTimeInMillis = System.currentTimeMillis();
		timeInMillisSinceLastGameTick=tickTimeInMillis-lastGameplayTickTime;
			List<WorldObject> vl = tr.getCollisionManager().getVisibilityList();
		    	for(WorldObject wo:vl){
		    	    if(wo.isActive()&&
				    (TR.twosComplimentDistance(wo.getPosition(), tr.getPlayer().getPosition())
				    <CollisionManager.MAX_CONSIDERATION_DISTANCE)||wo instanceof VisibleEverywhere)
				       wo.tick(tickTimeInMillis);
		    	    }//end for(worldObjects)
		    	  tr.getCollisionManager().performCollisionTests();
		lastGameplayTickTime=tickTimeInMillis;
	}//end gameplay()
	
	private void visibilityCalc(){
		tr.getRenderer().updateVisibilityList();
		tr.getCollisionManager().updateVisibilityList();
	}
	
	public void start(){
		renderingAnimator.start();
		lastGameplayTickTime=System.currentTimeMillis();
		}//end constructor
	
	public long getElapsedTimeInMillisSinceLastGameTick(){return timeInMillisSinceLastGameTick;}

	public Timer getGameplayTimer() {
	    return gameplayTimer;
	}
	}//end ThreadManager
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import org.junit.Test;
import org.junit.rules.ExpectedException;

/** Tests transactor class
 */
public class TransactorIT extends Base {
  
  public static Long id1 = new Long(1);
  public static Long id2 = new Long(2);
  
  @Rule
  public ExpectedException exception = ExpectedException.none();
public void testTransactorAndCache() throws Exception {
    TransactorID t2 = new TransactorID(config);

    // verify that they were created correctly
    Assert.assertEquals(2, getNumOpen());
    Assert.assertEquals(id1, t1.getLongID());
    Assert.assertEquals(id2, t2.getLongID());
    Assert.assertTrue(checkExists(t1));
public void testTransactorAndCache() throws Exception {
    t1.close();
    
    // verify that t1 was closed
    Assert.assertEquals(1, getNumOpen());
    Assert.assertFalse(checkExists(t1));
    Assert.assertTrue(checkExists(t2));
    Assert.assertFalse(cache.checkExists(id1));
public void testTransactorAndCache() throws Exception {
    t2.close();
    
    // verify that t2 closed
    Assert.assertEquals(0, getNumOpen());
    Assert.assertFalse(checkExists(t2));
    
    // verify the cache
public void testFailures() throws Exception {
    
    TransactorID t1 = new TransactorID(config);  
    
    Assert.assertEquals(1, getNumOpen());
    Assert.assertEquals(id1, t1.getLongID());
    Assert.assertTrue(checkExists(t1));
   
    // Test that node will be recreated if removed
    curator.delete().forPath(t1.getNodePath());
    
    Assert.assertEquals(id1, t1.getLongID());
    Assert.assertEquals(1, getNumOpen());
    Assert.assertTrue(checkExists(t1));
    
    t1.close();
    
    Assert.assertEquals(0, getNumOpen());
    Assert.assertFalse(checkExists(t1));
    
    // Test for exception to be called
private boolean checkExists(TransactorID t) throws Exception {
  private int getNumOpen() throws Exception {
    return curator.getChildren().forPath(config.getZookeeperRoot()+Constants.Zookeeper.TRANSACTOR_NODES).size();
  }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void run()
                {
                    try
                    {
                        attemptedToSend = false;
                        needRatelimit = false;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public ValueFactory getValueFactory() {
	@Override
	public void notifySailChanged(SailChangedEvent event) {
		super.notifySailChanged(event);
		contentsChanged = true;
	}

	protected void scheduleSyncTask()
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	private final ApiClient apiClient = new ApiClient();
	
	private ChooseStreamActivity chooseStreamActivity;
	
	public String getApiKey() {
		return getApiPreferences().getString(PROPERTY_API_KEY, null);
private void storeApiKey(String apiKey) {
	}
	
	private SharedPreferences getApiPreferences() {
	    return this.chooseStreamActivity.getSharedPreferences(ApiRegistration.class.getSimpleName(), Context.MODE_PRIVATE);
	}


	
}

public class ChooseStreamActivity extends Activity {
	
	private final GcmRegistration gcmRegistration = new GcmRegistration();
	private final ApiRegistration apiRegistration = new ApiRegistration();
	
	public final static String EXTRA_URL = extra("URL");
	
protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_choose_stream);
		
		apiRegistration.ensureRegistered(this, GcmRegistration.getRegistrationId(this));
		gcmRegistration.ensureRegistered(this);
		
		urlEditText = (EditText) findViewById(R.id.url);
import java.io.IOException;
import java.sql.Timestamp;

import uk.me.tom_fitzhenry.motionremote.ChooseStreamActivity;

import com.google.android.gms.gcm.GoogleCloudMessaging;
    private static final String PROPERTY_ON_SERVER_EXPIRATION_TIME = "onServerExpirationTimeMs";
    private static final long REGISTRATION_EXPIRY_TIME_MS = 1000 * 3600 * 24 * 7;
    
    private final String SENDER_ID = "416185604969";
    private GoogleCloudMessaging gcm;
    private Context context;
    private String regid;
    
	public void ensureRegistered(Context context) {
		this.context = context;
		if (!registered(context)) {
			gcm = GoogleCloudMessaging.getInstance(context);
private void registerBackground() {
	    new AsyncTask<Void, Void, String>() {
	        @Override
	        protected String doInBackground(Void... params) {
	            String msg = "";
	            try {
	                regid = gcm.register(SENDER_ID);
	                msg = "Device registered, registration id=" + regid;

	                // You should send the registration ID to your server over HTTP,
	                // so it can use GCM/HTTP or CCS to send messages to your app.

	                // For this demo: we don't need to send it because the device
	                // will send upstream messages to a server that echo back the message
	                // using the 'from' address in the message.

	                // Save the regid - no need to register again.
	                setRegistrationId(context, regid);
	            } catch (IOException ex) {
	                msg = "Error :" + ex.getMessage();
	            }
	            return msg;
	        }

	        @Override
	        protected void onPostExecute(String msg) {
	            //mDisplay.append(msg + "\n");
	        }
	    }.execute(null, null, null);
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public static void showExceptionDialog(final Download download) {
     * Closes the DownloadManagerDialog.
     */
    public static void close() {
        if (SwingUtilities.isEventDispatchThread()) {
            SwingUtilities.invokeLater(new Runnable() {

                    @Override
                    public void run() {
                        instance.dispatchEvent(new WindowEvent(instance, WindowEvent.WINDOW_CLOSING));
                    }
                });
        }
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public static void deleteOnExitRecursivelyAndEmptyParentsUpTo(File directoryToCl

    /** as {@link File#mkdirs()} but throwing on failure and returning the directory made for fluent convenience */
    public static File mkdirs(File dir) {
        if (dir.isDirectory()) return dir;
        boolean success = dir.mkdirs();
        if (!success) throw Exceptions.propagate(new IOException("Failed to create directory " + dir + 
                (dir.isFile() ? "(is file)" : "")));
        return dir;
    }

    /** writes given contents to a temporary file which will be deleted on exit */
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void abortActiveConnections() throws InterruptedException
      for (IHikariConnectionProxy connectionProxy : connectionBag.values(STATE_IN_USE)) {
         try {
            connectionProxy.abort(assassinExecutor);
         }
         catch (AbstractMethodError e) {
            quietlyCloseConnection(connectionProxy);
private void abortActiveConnections() throws InterruptedException
            quietlyCloseConnection(connectionProxy);
         }
         finally {
            totalConnections.decrementAndGet();
            try {
               connectionBag.remove(connectionProxy);
            }

package com.zaxxer.hikari;

import java.sql.SQLException;
import java.util.concurrent.TimeUnit;

 */
public class ShutdownTest
{
    @Before
    public void beforeTest()
    {
        StubConnection.count.set(0);
    }

    @After
    public void afterTest()
    {
        StubConnection.slowCreate = false;
    }

    @Test
    public void testShutdown1() throws SQLException
    {
        Assert.assertSame("StubConnection count not as expected", 0, StubConnection.count.get());

        StubConnection.slowCreate = true;

        HikariConfig config = new HikariConfig();
        config.setMinimumIdle(0);
        config.setMaximumPoolSize(10);
        config.setInitializationFailFast(true);
        config.setConnectionTestQuery("VALUES 1");
        config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

        final HikariDataSource ds = new HikariDataSource(config);
        HikariPool pool = TestElf.getPool(ds);

        Thread[] threads = new Thread[10];
        for (int i = 0; i < 10; i++)
        {
            threads[i] = new Thread() {
                public void run() {
                    try
                    {
                        if (ds.getConnection() != null)
                        {
                            PoolUtilities.quietlySleep(TimeUnit.SECONDS.toMillis(1));
                        }
                    }
                    catch (SQLException e)
                    {
                    }
                }
            };
            threads[i].setDaemon(true);
            threads[i].start();
        }

        PoolUtilities.quietlySleep(300);

        Assert.assertTrue("Totals connection count not as expected, ", pool.getTotalConnections() > 0);
        
        ds.close();

        Assert.assertSame("Active connection count not as expected, ", 0, pool.getActiveConnections());
        Assert.assertSame("Idle connection count not as expected, ", 0, pool.getIdleConnections());
        Assert.assertSame("Total connection count not as expected", 0, pool.getTotalConnections());
    }

    @Test
    public void testShutdown2() throws SQLException
    {
        Assert.assertSame("StubConnection count not as expected", 0, StubConnection.count.get());

        StubConnection.slowCreate = true;

        HikariConfig config = new HikariConfig();
        config.setMinimumIdle(10);
        config.setMaximumPoolSize(10);
        config.setInitializationFailFast(false);
        config.setConnectionTestQuery("VALUES 1");
        config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

        HikariDataSource ds = new HikariDataSource(config);
        HikariPool pool = TestElf.getPool(ds);

        PoolUtilities.quietlySleep(300);

        Assert.assertTrue("Totals connection count not as expected, ", pool.getTotalConnections() > 0);
        
        ds.close();

        Assert.assertSame("Active connection count not as expected, ", 0, pool.getActiveConnections());
        Assert.assertSame("Idle connection count not as expected, ", 0, pool.getIdleConnections());
        Assert.assertSame("Total connection count not as expected", 0, pool.getTotalConnections());
    }

    @Test
    public void testShutdown3() throws SQLException
    {
        Assert.assertSame("StubConnection count not as expected", 0, StubConnection.count.get());

        StubConnection.slowCreate = true;

        HikariConfig config = new HikariConfig();
        config.setMinimumIdle(5);
        config.setMaximumPoolSize(5);
        config.setInitializationFailFast(true);
        config.setConnectionTestQuery("VALUES 1");
        config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

        HikariDataSource ds = new HikariDataSource(config);
        HikariPool pool = TestElf.getPool(ds);

        PoolUtilities.quietlySleep(300);

        Assert.assertTrue("Totals connection count not as expected, ", pool.getTotalConnections() == 5);
        
        ds.close();

        Assert.assertSame("Active connection count not as expected, ", 0, pool.getActiveConnections());
        Assert.assertSame("Idle connection count not as expected, ", 0, pool.getIdleConnections());
        Assert.assertSame("Total connection count not as expected", 0, pool.getTotalConnections());
    }
    
    @Test
    public void testShutdown4() throws SQLException
    {
        StubConnection.slowCreate = true;
        
        HikariConfig config = new HikariConfig();
        config.setMinimumIdle(10);
        config.setMaximumPoolSize(10);
        config.setInitializationFailFast(false);
        config.setConnectionTestQuery("VALUES 1");
        config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

        HikariDataSource ds = new HikariDataSource(config);

        PoolUtilities.quietlySleep(300);

        ds.close();

        long start = System.currentTimeMillis();
        while (PoolUtilities.elapsedTimeMs(start) < TimeUnit.SECONDS.toMillis(5) && threadCount() > 0)
        {
            PoolUtilities.quietlySleep(250);
        }

        Assert.assertSame("Thread was leaked", 0, threadCount());
    }

	private int threadCount()
	{
	    Thread[] threads = new Thread[Thread.activeCount() * 2];
	    Thread.enumerate(threads);

	    int count = 0;
	    for (Thread thread : threads)
	    {
	        count += (thread != null && thread.getName().startsWith("Hikari")) ? 1 : 0;
	    }

	    return count;
	}
}
public String getSchema() throws SQLException
    /** {@inheritDoc} */
    public void abort(Executor executor) throws SQLException
    {
    }

    /** {@inheritDoc} */
private void abortActiveConnections() throws InterruptedException
      connectionBag.values(STATE_IN_USE).parallelStream().forEach(connectionProxy -> {
         try {
            connectionProxy.abort(assassinExecutor);
         }
         catch (SQLException | AbstractMethodError e) {
            quietlyCloseConnection(connectionProxy);
         }
         finally {
            totalConnections.decrementAndGet();
            try {
               connectionBag.remove(connectionProxy);
            }

package com.zaxxer.hikari;

import java.sql.SQLException;
import java.util.concurrent.TimeUnit;

 */
public class ShutdownTest
{
    @Before
    public void beforeTest()
    {
        StubConnection.count.set(0);
    }

    @After
    public void afterTest()
    {
        StubConnection.slowCreate = false;
    }

    @Test
    public void testShutdown1() throws SQLException
    {
        Assert.assertSame("StubConnection count not as expected", 0, StubConnection.count.get());

        StubConnection.slowCreate = true;

        HikariConfig config = new HikariConfig();
        config.setMinimumIdle(0);
        config.setMaximumPoolSize(10);
        config.setInitializationFailFast(true);
        config.setConnectionTestQuery("VALUES 1");
        config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

        final HikariDataSource ds = new HikariDataSource(config);
        HikariPool pool = TestElf.getPool(ds);

        Thread[] threads = new Thread[10];
        for (int i = 0; i < 10; i++)
        {
            threads[i] = new Thread() {
                public void run() {
                    try
                    {
                        if (ds.getConnection() != null)
                        {
                            PoolUtilities.quietlySleep(TimeUnit.SECONDS.toMillis(1));
                        }
                    }
                    catch (SQLException e)
                    {
                    }
                }
            };
            threads[i].setDaemon(true);
            threads[i].start();
        }

        PoolUtilities.quietlySleep(300);

        Assert.assertTrue("Totals connection count not as expected, ", pool.getTotalConnections() > 0);
        
        ds.close();

        Assert.assertSame("Active connection count not as expected, ", 0, pool.getActiveConnections());
        Assert.assertSame("Idle connection count not as expected, ", 0, pool.getIdleConnections());
        Assert.assertSame("Total connection count not as expected", 0, pool.getTotalConnections());
    }

    @Test
    public void testShutdown2() throws SQLException
    {
        Assert.assertSame("StubConnection count not as expected", 0, StubConnection.count.get());

        StubConnection.slowCreate = true;

        HikariConfig config = new HikariConfig();
        config.setMinimumIdle(10);
        config.setMaximumPoolSize(10);
        config.setInitializationFailFast(false);
        config.setConnectionTestQuery("VALUES 1");
        config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

        HikariDataSource ds = new HikariDataSource(config);
        HikariPool pool = TestElf.getPool(ds);

        PoolUtilities.quietlySleep(300);

        Assert.assertTrue("Totals connection count not as expected, ", pool.getTotalConnections() > 0);
        
        ds.close();

        Assert.assertSame("Active connection count not as expected, ", 0, pool.getActiveConnections());
        Assert.assertSame("Idle connection count not as expected, ", 0, pool.getIdleConnections());
        Assert.assertSame("Total connection count not as expected", 0, pool.getTotalConnections());
    }

    @Test
    public void testShutdown3() throws SQLException
    {
        Assert.assertSame("StubConnection count not as expected", 0, StubConnection.count.get());

        StubConnection.slowCreate = true;

        HikariConfig config = new HikariConfig();
        config.setMinimumIdle(5);
        config.setMaximumPoolSize(5);
        config.setInitializationFailFast(true);
        config.setConnectionTestQuery("VALUES 1");
        config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

        HikariDataSource ds = new HikariDataSource(config);
        HikariPool pool = TestElf.getPool(ds);

        PoolUtilities.quietlySleep(300);

        Assert.assertTrue("Totals connection count not as expected, ", pool.getTotalConnections() == 5);
        
        ds.close();

        Assert.assertSame("Active connection count not as expected, ", 0, pool.getActiveConnections());
        Assert.assertSame("Idle connection count not as expected, ", 0, pool.getIdleConnections());
        Assert.assertSame("Total connection count not as expected", 0, pool.getTotalConnections());
    }
    
    @Test
    public void testShutdown4() throws SQLException
    {
        StubConnection.slowCreate = true;
        
        HikariConfig config = new HikariConfig();
        config.setMinimumIdle(10);
        config.setMaximumPoolSize(10);
        config.setInitializationFailFast(false);
        config.setConnectionTestQuery("VALUES 1");
        config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

        HikariDataSource ds = new HikariDataSource(config);

        PoolUtilities.quietlySleep(300);

        ds.close();

        long start = System.currentTimeMillis();
        while (PoolUtilities.elapsedTimeMs(start) < TimeUnit.SECONDS.toMillis(5) && threadCount() > 0)
        {
            PoolUtilities.quietlySleep(250);
        }

        Assert.assertSame("Thread was leaked", 0, threadCount());
    }

	private int threadCount()
	{
	    Thread[] threads = new Thread[Thread.activeCount() * 2];
	    Thread.enumerate(threads);

	    int count = 0;
	    for (Thread thread : threads)
	    {
	        count += (thread != null && thread.getName().startsWith("Hikari")) ? 1 : 0;
	    }

	    return count;
	}
}
public String getSchema() throws SQLException
    /** {@inheritDoc} */
    public void abort(Executor executor) throws SQLException
    {
    }

    /** {@inheritDoc} */
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	private DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();

    private ClosestTrackingCaptureFilterGroup closestGroup;

	private static final String WB_XML_REQUEST_TAGNAME = "request";


public SearchResults query(WaybackRequest wbRequest)
		ResourceNotInArchiveException, BadQueryException,
		AccessControlException {
//		throw new ResourceIndexNotAvailableException("oops");
        closestGroup = new ClosestTrackingCaptureFilterGroup(wbRequest, canonicalizer);
		SearchResults results = urlToSearchResults(getRequestUrl(wbRequest),
				getSearchResultFilters(wbRequest));
        closestGroup.annotateResults(results);
        return results;
	}
private String getNodeTextValue(Node n) {
	}
	
	protected ObjectFilter<CaptureSearchResult> getSearchResultFilters(
			WaybackRequest wbRequest) {
		ObjectFilterChain<CaptureSearchResult> filters = null;
		if (wbRequest.isReplayRequest()) {
			filters = new ObjectFilterChain<CaptureSearchResult>();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /** Server push sender id. This is static so the {@link IPushListener} can see it. */
    static String sPushSenderId;
    /** Push registration id. */
    private String mPushRegistrationId;
    /** Flag marking a currently ongoing push registration cycle (unregister/register) */
    boolean mPushRegistrationCycle;

    /** Cached last used server. */
    EndpointServer mServer;
    /** The connection helper instance. */
    private XMPPConnectionHelper mHelper;
    /** The connection instance. */
    KontalkConnection mConnection;
    /** My username (account name). */
        private final static int INACTIVE_TIME = 30000;

        /** A reference to the message center. */
        private WeakReference<MessageCenterService> s;
        /** Reference counter. */
        private int mRefCount;

        public IdleConnectionHandler(MessageCenterService service, int refCount, Looper looper) {
            super(looper);
public void quit() {
        }

        /** Aborts any idle message because we are using the service or quitting. */
        private void abortIdle() {
            Looper.myQueue().removeIdleHandler(IdleConnectionHandler.this);
            removeMessages(MSG_IDLE);
            removeMessages(MSG_INACTIVE);
private void abortIdle() {
                service.cancelIdleAlarm();
        }

        public void queueInactiveIfNeeded() {
            post(new Runnable() {
                public void run() {
                    if (mRefCount <= 0 && !hasMessages(MSG_INACTIVE)) {
                        queueInactive();
                    }
                }
            });
public void forceInactive() {
            }
        }

        private void queueInactive() {
            // send inactive state message only if connected
            MessageCenterService service = s.get();
            if (service != null && service.isConnected()) {
public void authenticated(XMPPConnection connection, boolean resumed) {
        // we can now release any pending push notification
        Preferences.setLastPushNotification(this, -1);

        // queue inactive message if needed
        mIdleHandler.queueInactiveIfNeeded();

        // update alarm manager
        AndroidAdaptiveServerPingManager
private void discovery() {
        sendPacket(items);
    }

    private synchronized void active(boolean available) {
        final XMPPConnection connection = mConnection;
        if (connection != null) {
            cancelIdleAlarm();
private synchronized void active(boolean available) {
        }
    }

    private synchronized void inactive() {
        final XMPPConnection connection = mConnection;
        if (connection != null) {
            if (!mInactive) {
private synchronized void inactive() {
        }
    }

    private boolean isInactive() {
        return mInactive;
    }

    private boolean fastReply() {
        if (!isConnected()) return false;

        try {
private boolean fastReply() {
        }
    }

    private long getLastReceivedStanza() {
        return mConnection != null ? mConnection.getLastStanzaReceived() : 0;
    }

public static String getPushSenderId() {
        return sPushSenderId;
    }

    private void setWakeupAlarm() {
        long delay = Preferences.getWakeupTimeMillis(this,
            MIN_WAKEUP_TIME);

private void ensureIdleAlarm() {
        }
    }

    private void cancelIdleAlarm() {
        ensureIdleAlarm();
        mAlarmManager.cancel(mIdleIntent);
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }

    public void broadcast(Object event) {
        requireNotNull(event);
        LOG.trace("{}: Supervisor {} about to inspect", this, supervisor);
        supervisor.inspect(event);
        LOG.trace("{}: Listeners about to listen", this);
        doBroadcast(event);
    }

    private void doBroadcast(Object event) {
        List<ListenerReferenceHolder> eventListeners = listeners.nullSafeGetListeners(event.getClass());
        Envelope enveloped = new Envelope(event);
        for (ListenerReferenceHolder holder : eventListeners) {
private void doBroadcast(Object event) {
                LOG.trace("{}: Notifing event {} to {}", this, event, listener);
                listener.onEvent(enveloped);
            } else {
                LOG.trace("{}: Removing garbage collected listener from the station", this);
                listeners.remove(event.getClass(), holder);
            }
        }
private void doBroadcast(Object event) {
                LOG.warn("{}: Unable to store unlistened event, it's going to be lost {}", this, event);
            }
        }
    }

    <T> void add(Listener<T> listener, int priority, ReferenceStrength strength) {
private void doBroadcast(Object event) {
    <T> void add(Class<T> eventClass, Listener<T> listener, int priority, ReferenceStrength strength) {
        requireNotNull(eventClass);
        requireNotNull(listener);
        LOG.trace("{}: Adding listener {} [priority={} strength={}]", this, listener, priority, strength);
        listeners.add(eventClass, listener, priority, strength);
        broadcastEnqueuedEventsFor(eventClass);
    }

    void addAll(Object bean, List<ReflectiveListenerDescriptor> descriptors) {
        requireNotNull(descriptors);
        LOG.trace("{}: Adding {} reflective listeners for {}", this, descriptors.size(), bean);
        Set<Class<?>> updatedEventClasses = listeners.addAll(bean, descriptors);
        for (Class<?> updatedClass : updatedEventClasses) {
            broadcastEnqueuedEventsFor(updatedClass);
void addAll(Object bean, List<ReflectiveListenerDescriptor> descriptors) {
    private void broadcastEnqueuedEventsFor(Class<?> updatedClass) {
        BlockingQueue<Object> queue = getQueue(updatedClass);
        Object event = null;
        while ((event = queue.poll()) != null) {
            LOG.debug("{}: Found enqueued event {}, now broadcasting it.", this, event);
            doBroadcast(event);
        }
    }

private void broadcastEnqueuedEventsFor(Class<?> updatedClass) {
    <T> boolean remove(Class<T> eventClass, Listener<T> listener) {
        requireNotNull(eventClass);
        requireNotNull(listener);
        return listeners.remove(eventClass, listener);
    }

		</encoder>
	</appender>

	<logger name="org.eventstudio" level="TRACE" />

	<root level="WARN">
		<appender-ref ref="STDOUT" />
	</root>
</configuration>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import org.springframework.security.oauth2.provider.endpoint.WhitelabelErrorEndpoint;
import org.springframework.security.oauth2.provider.token.AuthorizationServerTokenServices;
import org.springframework.security.oauth2.provider.token.ConsumerTokenServices;
import org.springframework.security.oauth2.provider.token.TokenStore;
import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;

/**
public void init() {
	@Bean
	public AuthorizationEndpoint authorizationEndpoint() throws Exception {
		AuthorizationEndpoint authorizationEndpoint = new AuthorizationEndpoint();
		FrameworkEndpointHandlerMapping mapping = getEndpoints().getFrameworkEndpointHandlerMapping();
		authorizationEndpoint.setUserApprovalPage(extractPath(mapping, "/oauth/confirm_access"));
		authorizationEndpoint.setErrorPage(extractPath(mapping, "/oauth/error"));
		authorizationEndpoint.setTokenGranter(tokenGranter());
public TokenEndpoint tokenEndpoint() throws Exception {

	@Bean
	public CheckTokenEndpoint checkTokenEndpoint() {
		CheckTokenEndpoint endpoint = new CheckTokenEndpoint(getEndpoints().getResourceServerTokenServices());
		endpoint.setAccessTokenConverter(getEndpoints().getAccessTokenConverter());
		return endpoint;
	}

public WhitelabelErrorEndpoint whitelabelErrorEndpoint() {

	@Bean
	public FrameworkEndpointHandlerMapping oauth2EndpointHandlerMapping() throws Exception {
		return getEndpoints().getFrameworkEndpointHandlerMapping();
	}

	@Bean
	public ConsumerTokenServices consumerTokenServices() throws Exception {
		return getEndpoints().getConsumerTokenServices();
	}

	/**
public AuthorizationServerTokenServices defaultAuthorizationServerTokenServices(
		return endpoints.getDefaultAuthorizationServerTokenServices();
	}

	@Bean
	public TokenStore tokenStore() throws Exception {
		return getEndpoints().getTokenStore();
	}

	private AuthorizationServerEndpointsConfigurer getEndpoints() {
		if (!endpoints.isTokenServicesOverride()) {
			endpoints.tokenServices(defaultAuthorizationServerTokenServices());
		}
		return endpoints;
	}

	private OAuth2RequestFactory oauth2RequestFactory() throws Exception {
		return getEndpoints().getOAuth2RequestFactory();
	}

	private UserApprovalHandler userApprovalHandler() throws Exception {
		return getEndpoints().getUserApprovalHandler();
	}

	private OAuth2RequestValidator oauth2RequestValidator() throws Exception {
		return getEndpoints().getOAuth2RequestValidator();
	}

	private AuthorizationCodeServices authorizationCodeServices() throws Exception {
		return getEndpoints().getAuthorizationCodeServices();
	}

	private TokenGranter tokenGranter() throws Exception {
		return getEndpoints().getTokenGranter();
	}

	private String extractPath(FrameworkEndpointHandlerMapping mapping, String page) {
protected void configure(HttpSecurity http) throws Exception {
		ResourceServerTokenServices services = resolveTokenServices();
		if (services != null) {
			resources.tokenServices(services);
		}
		else {
			if (tokenStore != null) {
				resources.tokenStore(tokenStore);
			}
		}
		for (ResourceServerConfigurer configurer : configurers) {
 */
package org.springframework.security.oauth2.config.annotation;

import javax.servlet.Filter;
import javax.servlet.http.HttpServletRequest;

public void testDefaults() throws Exception {
				.addFilters(new DelegatingFilterProxy(context.getBean("springSecurityFilterChain", Filter.class)))
				.build();
		mvc.perform(MockMvcRequestBuilders.get("/")).andExpect(MockMvcResultMatchers.status().isUnauthorized());
		context.close();
	}

public void testCustomTokenServices() throws Exception {
				.addFilters(new DelegatingFilterProxy(context.getBean("springSecurityFilterChain", Filter.class)))
				.build();
		mvc.perform(MockMvcRequestBuilders.get("/")).andExpect(MockMvcResultMatchers.status().isUnauthorized());
		context.close();
	}

public TokenStore tokenStore() {
		public void configure(HttpSecurity http) throws Exception {
			http.authorizeRequests().anyRequest().authenticated();
		}
		
		@Override
		public void configure(ResourceServerSecurityConfigurer resources) throws Exception {
			resources.authenticationEntryPoint(authenticationEntryPoint());
public void configure(ResourceServerSecurityConfigurer resources) throws Excepti
				public Authentication extract(HttpServletRequest request) {
					return new PreAuthenticatedAuthenticationToken("FOO", "N/A");
				}
			});
		}

		@Override
public TokenStore tokenStore() {

		@Bean
		protected ClientDetailsService clientDetailsService() {
			return new InMemoryClientDetailsService();
		}

		@Bean
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.IntegrationTest;
import org.springframework.boot.test.SpringApplicationConfiguration;
import org.springframework.security.oauth2.provider.token.TokenStore;
import org.springframework.security.oauth2.provider.token.store.JwtTokenStore;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = Application.class)
public class ApplicationTests {

	@Autowired
	private TokenStore tokenStore;

	@Test
	public void contextLoads() {
		assertTrue("Wrong token store type: " + tokenStore, tokenStore instanceof JwtTokenStore);
	}

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void setTheme(MessageListItemTheme theme) {

    @Override
    public void onClick(View v) {
        mAudioPlayerControl.buttonClick(new File(mComponent.getLocalUri().getPath()), this, mMessageId);
    }

    @Override
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void exec(String line, Conn conn) {
		}

		d.reset();
		while(nclients --> 0) {
			String s;
			String fields[];
public Controller(String addr, int port, String mode, String color, String name)
		Frame frame = new Frame(m);
		Conn conn = new Conn(new Socket(addr, port));

		Player.init();

		((ChatUpdate) Cmd.ChatUpdate.getFn()).addDisplayer(frame.chatDisp);
		((ClientlistUpdate) Cmd.ClientlistUpdate.getFn()).addDisplayer(frame.playerDisp);
public Client(Socket sock) throws IOException {
	 * @return false on failure (name already used or nil), true otherwise
	 */
	public boolean subscribe(String color, Mode mode, String name) {
		if(name == null)
			return false;

public boolean subscribe(String color, Mode mode, String name) {
				return false;


		this.player = new Player(Player.parseColor(color), mode, name);
		return true;
	}

public boolean isSubscribed() {
	 */
	public void remove() {
		clients.remove(this);
		listClients();
	}

public static void broadcast(String s) {
	}

	/**
	 * Initialise the client table.
	 */
	public static void init() {
		clients = new HashSet<>();
	}
	
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package main;

import java.io.IOException;
import model.Player;

/**
 *
 * @author leander.dreier
 */
public class SrvMain {
	public static void srvmain(String[] args) {
		ServerSocket listener;
		Client.init();
		Player.init();

		try {
			listener = new ServerSocket(1918);
	private String name;
	private Color color;
	private Mode mode;

	/* only active players */
	private static HashSet<Player> players;

	private HashSet<Plot> plots;
	private HashSet<Plot> hypothecs;
	private int cash;                         /* actual liquid money */
public Player(Color color, Mode mode, String name) {
		this.name = name;
		this.color = color;
		this.mode = mode;
		
		players.add(this);
		
		if(mode == Mode.Player) {
			plots = new HashSet<>();
public String toString() {
		return col + ": " + mode + ": " + name;
	}

	/* GAME LOGIC */

	/**
public void hypothec(Plot p, boolean addhyp) {
	}

	/**
	 * Give up and auction everything of value.
	 */
	public void ragequit() {
		// XXX auction all the plots and houses the player had 
	}

	
public void prison(boolean enter) {
	/* STATIC */

	/**
	 * Initialise the player table.
	 */
	public static void init() {
		players = new HashSet<>();
	}

public static Color parseColor(String s) {
			return Color.BLACK;  // XXX default color - randomise
		}
	}
	
	public static int numPlayers() {
		return players.size();
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void registerAggregates(final Class<T> aggregateClass, final T aggregate)
    }

    @Override
    public long append(final Stream<JsonEnvelope> events) throws EventStreamException {
        final long currentVersion = super.append(events);
        createAggregateSnapshotsFor(currentVersion);
        return currentVersion;
    }

    @Override
    public long append(final Stream<JsonEnvelope> events, final Tolerance tolerance) throws EventStreamException {
        final long currentVersion = super.append(events, tolerance);
        if (tolerance == CONSECUTIVE) {
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.Matchers.nullValue;
import static uk.gov.justice.services.messaging.DefaultJsonEnvelope.envelope;
import static uk.gov.justice.services.messaging.JsonObjectMetadata.metadataWithRandomUUID;

import uk.gov.justice.domain.aggregate.Aggregate;
import uk.gov.justice.domain.aggregate.TestAggregate;
import uk.gov.justice.services.eventsourcing.source.core.EventStreamManager;
import uk.gov.justice.services.eventsourcing.source.core.SnapshotAwareEnvelopeEventStream;
import uk.gov.justice.services.eventsourcing.source.core.SnapshotAwareEventSource;
import uk.gov.justice.services.eventsourcing.source.core.snapshot.DefaultSnapshotService;
import uk.gov.justice.services.eventsourcing.source.core.snapshot.DefaultSnapshotStrategy;
import uk.gov.justice.services.messaging.JsonEnvelope;
public void shouldStoreABrandNewSnapshotWhenEventCountInTheStreamReachesThreshol

        final EventStream stream = eventSource.getStreamById(STREAM_ID);

        rebuildAggregateAndApplyEvents(stream, SNAPSHOT_THRESHOLD);

        final Optional<AggregateSnapshot<TestAggregate>> snapshot = snapshotRepository.getLatestSnapshot(STREAM_ID, TestAggregate.class);

public void shouldNotStoreABrandNewSnapshotWhenEventCountInTheStreamReachesThres

        final EventStream stream = eventSource.getStreamById(STREAM_ID);

        rebuildAggregateAndApplyEvents(stream, SNAPSHOT_THRESHOLD - 2);

        final Optional<AggregateSnapshot<TestAggregate>> snapshot = snapshotRepository.getLatestSnapshot(STREAM_ID, TestAggregate.class);

public void shouldNotCreateNewSnapshotOnAggregateChangeWhenWeJustOneExistingSnap
        final EventStream stream = eventSource.getStreamById(STREAM_ID);
        final Class aggregateClass = TestAggregate.class;

        rebuildAggregateAndApplyEvents(stream, SNAPSHOT_THRESHOLD);

        final Optional<AggregateSnapshot> snapshot = snapshotRepository.getLatestSnapshot(STREAM_ID, aggregateClass);

        assertThat(snapshot, IsNot.not(nullValue()));
        assertThat(snapshot.isPresent(), equalTo(true));
        assertThat(snapshotRepository.snapshotCount(STREAM_ID), is(1L));

        rebuildAggregateAndApplyEvents(stream, SNAPSHOT_THRESHOLD - 2);

        final Optional<AggregateSnapshot<TestAggregate>> snapshotChanged = snapshotRepository.getLatestSnapshot(STREAM_ID, aggregateClass);
        assertThat(snapshotChanged, IsNot.not(nullValue()));
public void shouldCreateNewSnapshotOnAggregateChangeWhenWeHaveMultipleExistingSn

        final long initialNumberOfSnapshots = 4;
        for (int i = 0; i < initialNumberOfSnapshots; i++) {
            rebuildAggregateAndApplyEvents(stream, SNAPSHOT_THRESHOLD);
        }

        final Optional<AggregateSnapshot> snapshot = snapshotRepository.getLatestSnapshot(STREAM_ID, aggregateClass);
public void shouldCreateNewSnapshotOnAggregateChangeWhenWeHaveMultipleExistingSn

        assertThat(snapshotRepository.snapshotCount(STREAM_ID), is(initialNumberOfSnapshots));

        rebuildAggregateAndApplyEvents(stream, SNAPSHOT_THRESHOLD - 2);


        final Optional<AggregateSnapshot> newSnapshot = snapshotRepository.getLatestSnapshot(STREAM_ID, aggregateClass);
public void shouldNotStoreABrandNewSnapshotWhenStrategyDoesNotMandateSavingSnaps
        final EventStream stream = eventSource.getStreamById(STREAM_ID);

        TestAggregate aggregate = aggregateService.get(stream, TestAggregate.class);
        stream.append(createEventAndApply(24, "context.eventA", aggregate));


        final Optional<AggregateSnapshot<TestAggregate>> snapshot = snapshotRepository.getLatestSnapshot(STREAM_ID, TestAggregate.class);
public void shouldNotStoreABrandNewSnapshotWhenStrategyDoesNotMandateSavingSnaps
    public void shouldNotStoreANewSnapshotOnTopOfExistingSnapshotsWhenThresholdNotMet() throws Exception {
        assertThat(snapshotRepository.snapshotCount(STREAM_ID), is(0L));

        final EventStream stream = eventSource.getStreamById(STREAM_ID);

        rebuildAggregateAndApplyEvents(stream, SNAPSHOT_THRESHOLD);

        TestAggregate aggregate = aggregateService.get(stream, TestAggregate.class);

        stream.append(createEventAndApply(SNAPSHOT_THRESHOLD - 2, "context.eventA", aggregate));

        final Optional<AggregateSnapshot<TestAggregate>> snapshot = snapshotRepository.getLatestSnapshot(STREAM_ID, TestAggregate.class);
        assertThat(snapshot, IsNot.not(Matchers.nullValue()));
        assertThat(snapshot.isPresent(), equalTo(true));
        assertThat(snapshot.get().getType(), equalTo(TYPE));
        assertThat(snapshot.get().getStreamId(), equalTo(STREAM_ID));
public void shouldStoreANewSnapshotOnTopOfExistingSnapshot() throws Exception {

        final EventStream eventStream = eventSource.getStreamById(STREAM_ID);

        rebuildAggregateAndApplyEvents(eventStream, SNAPSHOT_THRESHOLD);

        rebuildAggregateAndApplyEvents(eventStream, SNAPSHOT_THRESHOLD);

        final Optional<AggregateSnapshot<TestAggregate>> snapshot = snapshotRepository.getLatestSnapshot(STREAM_ID, TestAggregate.class);
        assertThat(snapshot, IsNot.not(Matchers.nullValue()));
public void shouldStoreANewSnapshotOnTopOfExistingSnapshot() throws Exception {
    @Test
    public void shouldRebuildSnapshotOnAggregateModelChange() throws Exception {

        final EventStream eventStream = eventSource.getStreamById(STREAM_ID);

        DynamicAggregateTestClassGenerator classGenerator = new DynamicAggregateTestClassGenerator();

        final Class oldAggregateClass = classGenerator.generatedTestAggregateClassOf(1L, TEST_AGGREGATE_PACKAGE, TEST_AGGREGATE_CLASS_NAME);

        final long initialNumberOfSnapshots = 4;

        for (int i = 1; i <= initialNumberOfSnapshots; i++) {
            eventStream.append(createEventStreamAndApply(SNAPSHOT_THRESHOLD, "context.eventA", aggregateService.get(eventStream, oldAggregateClass)));
        }


        final Optional<AggregateSnapshot> snapshot = snapshotRepository.getLatestSnapshot(STREAM_ID, oldAggregateClass);

        assertThat(snapshot, IsNot.not(Matchers.nullValue()));
public void shouldRebuildSnapshotOnAggregateModelChange() throws Exception {
        snapshotService.setStreamStrategy(
                new CustomClassLoaderObjectInputStreamStrategy(classLoaderWithGeneratedAggregateLoaded()));

        eventStream.append(createEventStreamAndApply(SNAPSHOT_THRESHOLD - 2, "context.eventA", aggregateService.get(eventStream, newAggregateClass)));

        final Optional<AggregateSnapshot> newSnapshot = snapshotRepository.getLatestSnapshot(STREAM_ID, newAggregateClass);
        assertThat(newSnapshot, IsNot.not(Matchers.nullValue()));
private DynamicallyLoadingClassLoader classLoaderWithGeneratedAggregateLoaded()
        return classLoader;
    }

    private <T extends Aggregate> void rebuildAggregateAndApplyEvents(final EventStream eventStream, long eventCount) throws Exception {

        TestAggregate aggregateRebuilt = aggregateService.get(eventStream, TestAggregate.class);

        eventStream.append(createEventAndApply(eventCount, "context.eventA", aggregateRebuilt));
    }

    private Stream<JsonEnvelope> createEventAndApply(long count, String eventName, TestAggregate aggregate) {
        List<Object> envelopes = new LinkedList<>();
        for (int i = 1; i <= count; i++) {
            JsonEnvelope envelope =
                    envelope()
                    .with(metadataWithRandomUUID(eventName)
                            .createdAt(clock.now())
                            .withStreamId(STREAM_ID))
                    .withPayloadOf("value", "name")
                    .build();
            aggregate.addEvent(envelope);
            envelopes.add(envelope);
        }
        return envelopes.stream().map(x -> (JsonEnvelope) x);
    }

    private <T extends Aggregate> Stream<JsonEnvelope> createEventStreamAndApply(long count, String eventName, T aggregate) {
        List<Object> envelopes = new LinkedList<>();

        for (int i = 1; i <= count; i++) {

            JsonEnvelope envelope =
                    envelope()
                    .with(metadataWithRandomUUID(eventName)
                            .createdAt(clock.now())
                            .withStreamId(STREAM_ID))
private DynamicallyLoadingClassLoader classLoaderWithGeneratedAggregateLoaded()
            aggregate.apply(new EventA(String.valueOf(i)));
            envelopes.add(envelope);
        }
        return envelopes.stream().map(x -> (JsonEnvelope) x);
    }

    @ApplicationScoped
public EventLogInsertionStrategy eventLogInsertionStrategy() {
            return new AnsiSQLEventLogInsertionStrategy();
        }
    }
}
package uk.gov.justice.services.eventsourcing.source.core;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.core.Is.is;
import static org.junit.Assert.assertThat;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import static uk.gov.justice.services.test.utils.core.messaging.JsonEnvelopeBuilder.envelope;

import uk.gov.justice.domain.aggregate.TestAggregate;
import uk.gov.justice.services.eventsourcing.source.core.snapshot.SnapshotService;
import uk.gov.justice.services.messaging.JsonEnvelope;

import java.util.UUID;
import java.util.stream.Stream;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
public void setup() {

    @Test
    public void shouldReturnStreamOfEnvelopes() throws Exception {
        final Stream<JsonEnvelope> stream = Stream.of(envelope().build());
        when(eventStreamManager.read(STREAM_ID)).thenReturn(stream);

        assertThat(eventStream.read(), is(stream));
    }

    @Test
    public void shouldReturnStreamFromVersion() throws Exception {
        final Stream<JsonEnvelope> stream = Stream.of(envelope().build());
        final long version = 10L;
        when(eventStreamManager.readFrom(STREAM_ID, version)).thenReturn(stream);

        assertThat(eventStream.readFrom(version), is(stream));
    }

    @Test
public void shouldAttemptSnapshotCreationOnAppendingEventsFrom() throws Exceptio

    }

}
import uk.gov.justice.services.messaging.jms.JmsEnvelopeSender;
import uk.gov.justice.services.repository.EventLogOpenEjbAwareJdbcRepository;

import java.util.LinkedList;
import java.util.List;
import java.util.UUID;
import java.util.stream.Stream;


    private static final String TEST_AGGREGATE_PACKAGE = "uk.gov.justice.services.core.aggregate";

    private static final String TYPE = TEST_AGGREGATE_PACKAGE + ".DefaultAggregateServiceIT$TestAggregate";

    @Resource(name = "openejb/Resource/eventStore")
    private DataSource dataSource;

public void shouldCreateAggregateFromSingletonStream() throws EventStreamExcepti

        aggregateService.get(eventStream, TestAggregate.class);

        eventStream.append(envelopes(1, "context.eventA"));

        final TestAggregate aggregate = aggregateService.get(eventStream, TestAggregate.class);

        assertThat(aggregate, notNullValue());
        assertThat(aggregate.recordedEvents(), hasSize(1));
public void shouldCreateAggregateFromStreamOfTwo() throws EventStreamException {

        aggregateService.get(eventStream, TestAggregate.class);

        eventStream.append(envelopes(1, "context.eventA"));
        eventStream.append(envelopes(1, "context.eventB"));

        final TestAggregate aggregate = aggregateService.get(eventStream, TestAggregate.class);

        assertThat(aggregate, notNullValue());
        assertThat(aggregate.recordedEvents(), hasSize(2));
public void shouldThrowExceptionForUnregisteredEvent() throws EventStreamExcepti

        final EventStream eventStream = eventSource.getStreamById(STREAM_ID);

        eventStream.append(envelopes(1, "context.eventA"));

        aggregateService.get(eventStream, TestAggregate.class);

private void initDatabase() throws Exception {

    }

    private Stream<JsonEnvelope> envelopes(final int numberOfEnvelopes, String eventName) {
        List<JsonEnvelope> envelopes = new LinkedList<>();
        for (int i = 1; i <= numberOfEnvelopes; i++) {
            envelopes.add(envelope()
                    .with(metadataWithRandomUUID(eventName)
                            .createdAt(clock.now())
                            .withStreamId(STREAM_ID))
                    .withPayloadOf("value", "name").build());
        }
        return envelopes.stream();
    }

    public static class DummyJmsEventPublisher implements EventPublisher {
public EventLogInsertionStrategy eventLogInsertionStrategy() {
            return new AnsiSQLEventLogInsertionStrategy();
        }
    }
}
package uk.gov.justice.services.eventsourcing.source.core;

import uk.gov.justice.services.eventsourcing.source.core.exception.EventStreamException;
import uk.gov.justice.services.messaging.JsonEnvelope;

import java.util.UUID;
import java.util.stream.Stream;

public class EnvelopeEventStream implements EventStream {

    private final EventStreamManager eventStreamManager;
    private final UUID id;


    EnvelopeEventStream(final UUID id, final EventStreamManager eventStreamManager) {
        this.id = id;

    @Override
    public Stream<JsonEnvelope> read() {
        return eventStreamManager.read(id);
    }

    @Override
    public Stream<JsonEnvelope> readFrom(final long version) {
        return eventStreamManager.readFrom(id, version);
    }

    @Override
    public long append(final Stream<JsonEnvelope> events) throws EventStreamException {
        return eventStreamManager.append(id, events);
    }

    @Override
    public long append(final Stream<JsonEnvelope> stream, final Tolerance tolerance) throws EventStreamException {
        switch (tolerance) {
            case NON_CONSECUTIVE:
                return eventStreamManager.appendNonConsecutively(id, stream);
            default:
                return eventStreamManager.append(id, stream);
        }
    }

public long appendAfter(final Stream<JsonEnvelope> events, final long version) t

    @Override
    public long getCurrentVersion() {
        return eventStreamManager.getCurrentVersion(id);
    }

    @Override
    public UUID getId() {
        return id;
    }
}
package uk.gov.justice.services.eventsourcing.source.core;


import static java.util.stream.Collectors.toList;

import uk.gov.justice.services.common.configuration.GlobalValue;
private long append(final UUID id, final Stream<JsonEnvelope> events, final Opti
        final List<JsonEnvelope> envelopeList = events.collect(toList());

        long currentVersion = eventRepository.getCurrentSequenceIdForStream(id);
        validateVersion(id, versionFrom, currentVersion);
        validateEvents(id, envelopeList);

        for (final JsonEnvelope event : envelopeList) {
private void validateEvents(final UUID id, final List<JsonEnvelope> envelopeList
        }
    }

    private void validateVersion(final UUID id, final Optional<Long> versionFrom, final Long currentVersion) throws VersionMismatchException {
        if (versionFrom.isPresent() && !versionFrom.get().equals(currentVersion)) {
            throw new VersionMismatchException(String.format("Failed to append to stream %!s(MISSING). Version mismatch. Expected %!d(MISSING), Found %!d(MISSING)",
                    id, versionFrom.get(), currentVersion));
        }
    }
}
package uk.gov.justice.services.eventsourcing.source.core;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.junit.Assert.assertThat;
import static org.mockito.Mockito.verify;

import uk.gov.justice.services.eventsourcing.source.core.exception.EventStreamException;
import uk.gov.justice.services.messaging.JsonEnvelope;

import java.util.UUID;
import java.util.stream.Stream;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class EnvelopeEventStreamTest {

    public static final Long VERSION = 5L;
    private static final UUID STREAM_ID = UUID.randomUUID();
    @Mock
    EventStreamManager eventStreamManager;

    @Mock
    Stream<JsonEnvelope> stream;

    private EventStream eventStream;

    @Before
    public void setup() {
        eventStream = new EnvelopeEventStream(STREAM_ID, eventStreamManager);
    }

    @Test
public void shouldReturnCurrentVersion() throws Exception {
    }

    @Test
    public void testGetId() throws Exception {
        final UUID actualId = eventStream.getId();

        assertThat(actualId, equalTo(STREAM_ID));
    }

}
public void shouldThrowExceptionOnNullFromVersion() throws Exception {
    }

    @Test(expected = VersionMismatchException.class)
    public void shouldThrowExceptionWhenFromVersionNotCorrect() throws Exception {
        when(eventRepository.getCurrentSequenceIdForStream(STREAM_ID)).thenReturn(CURRENT_VERSION);

        eventStreamManager.appendAfter(STREAM_ID, Stream.of(envelope().with(metadataWithDefaults()).build()), INVALID_VERSION);
    }

    @Test
    public void shouldReadStream() {
        when(eventRepository.getByStreamId(STREAM_ID)).thenReturn(eventStream);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void delayPrepareBulkRequest(ThreadPool threadPool, TimeValue lastBatchStartTime
        // Synchronize so we are less likely to schedule the same request twice.
        synchronized (delayedPrepareBulkRequestReference) {
            TimeValue delay = throttleWaitTime(lastBatchStartTime, lastBatchSize);
            AbstractRunnable oneTime = new AbstractRunnable() {
                private final AtomicBoolean hasRun = new AtomicBoolean(false);

                @Override
                protected void doRun() throws Exception {
                    // Paranoia to prevent furiously rethrottling from running the command multiple times. Without this we totally can.
                    if (hasRun.compareAndSet(false, true)) {
                        prepareBulkRequestRunnable.run();
                    }
                }

                @Override
                public void onFailure(Throwable t) {
                    prepareBulkRequestRunnable.onFailure(t);
                }
            };
            delayedPrepareBulkRequestReference.set(new DelayedPrepareBulkRequest(threadPool, getRequestsPerSecond(), delay, oneTime));
        }
    }

TimeValue newDelay(long remainingDelay, float newRequestsPerSecond) {
            return timeValueNanos(round(remainingDelay * requestsPerSecond / newRequestsPerSecond));
        }
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void afterRefresh(boolean didRefresh) throws IOException {
             */
            return;
        }
        // First check if we've actually moved forward. If not then just bail immediately.
        assert lastRefreshedLocation == null || currentRefreshLocation.compareTo(lastRefreshedLocation) >= 0;
        if (lastRefreshedLocation != null && currentRefreshLocation.compareTo(lastRefreshedLocation) == 0) {
            return;
        }
        /*
         * Set the lastRefreshedLocation so listeners that come in for locations before that will just execute inline without messing
         * around with refreshListeners or synchronizing at all.
         */
        lastRefreshedLocation = currentRefreshLocation;
        /*
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import rx.Producer;
import rx.Subscriber;
import rx.functions.Action0;
import rx.observers.SerializedSubscriber;
import rx.subscriptions.SerialSubscription;
import rx.subscriptions.Subscriptions;
public void request(long n) {

        volatile int wip;
        @SuppressWarnings("rawtypes")
        static final AtomicIntegerFieldUpdater<ConcatSubscriber> WIP_UPDATER = AtomicIntegerFieldUpdater.newUpdater(ConcatSubscriber.class, "wip");

        // accessed by REQUESTED_UPDATER
        private volatile long requested;
        @SuppressWarnings("rawtypes")
        private static final AtomicLongFieldUpdater<ConcatSubscriber> REQUESTED_UPDATER = AtomicLongFieldUpdater.newUpdater(ConcatSubscriber.class, "requested");

        public ConcatSubscriber(Subscriber<T> s, SerialSubscription current) {
            super(s);
            this.child = s;
            this.current = current;
            this.queue = new ConcurrentLinkedQueue<Object>();
            add(Subscriptions.create(new Action0() {
                @Override
public void onStart() {
        }

        private void requestFromChild(long n) {
            // we track 'requested' so we know whether we should subscribe the next or not
            ConcatInnerSubscriber<T> actualSubscriber = currentSubscriber;
            if (n > 0 && BackpressureUtils.getAndAddRequest(REQUESTED_UPDATER, this, n) == 0) {
                if (actualSubscriber == null && wip > 0) {
                    // this means we may be moving from one subscriber to another after having stopped processing
                    // so need to kick off the subscribe via this request notification
                    subscribeNext();
                    // return here as we don't want to do the requestMore logic below (which would double request)
                    return;
                }
            } 
                
            if (actualSubscriber != null) {
                // otherwise we are just passing it through to the currentSubscriber
                actualSubscriber.requestMore(n);
            }
        }

        private void decrementRequested() {
            REQUESTED_UPDATER.decrementAndGet(this);
        }

        @Override
        public void onNext(Observable<? extends T> t) {
            queue.add(nl.next(t));
            if (WIP_UPDATER.getAndIncrement(this) == 0) {
                subscribeNext();
            }
        }
public void onError(Throwable e) {
        @Override
        public void onCompleted() {
            queue.add(nl.completed());
            if (WIP_UPDATER.getAndIncrement(this) == 0) {
                subscribeNext();
            }
        }

        void completeInner() {
            currentSubscriber = null;
            if (WIP_UPDATER.decrementAndGet(this) > 0) {
                subscribeNext();
            }
            request(1);
void subscribeNext() {
                    child.onCompleted();
                } else if (o != null) {
                    Observable<? extends T> obs = nl.getValue(o);
                    currentSubscriber = new ConcatInnerSubscriber<T>(this, child, requested);
                    current.set(currentSubscriber);
                    obs.unsafeSubscribe(currentSubscriber);
                }
void subscribeNext() {
        @SuppressWarnings("unused")
        private volatile int once = 0;
        @SuppressWarnings("rawtypes")
        private final static AtomicIntegerFieldUpdater<ConcatInnerSubscriber> ONCE_UPDATER = AtomicIntegerFieldUpdater.newUpdater(ConcatInnerSubscriber.class, "once");

        public ConcatInnerSubscriber(ConcatSubscriber<T> parent, Subscriber<T> child, long initialRequest) {
            this.parent = parent;
            this.child = child;
            request(initialRequest);
        }

        void requestMore(long n) {
            request(n);
        }

        @Override
        public void onNext(T t) {
            parent.decrementRequested();
            child.onNext(t);
        }

        @Override
        public void onError(Throwable e) {
            if (ONCE_UPDATER.compareAndSet(this, 0, 1)) {
                // terminal error through parent so everything gets cleaned up, including this inner
                parent.onError(e);
            }
        }

        @Override
        public void onCompleted() {
            if (ONCE_UPDATER.compareAndSet(this, 0, 1)) {
                // terminal completion to parent so it continues to the next
                parent.completeInner();
            }
        }

    };
}
public void produced(long n) {
            if (r != Long.MAX_VALUE) {
                long u = r - n;
                if (u < 0) {
                    throw new IllegalStateException();
                }
                requested = u;
            }
import org.mockito.InOrder;

import rx.Observable.OnSubscribe;
import rx.Scheduler.Worker;
import rx.*;
import rx.functions.Action0;
import rx.functions.Func1;
import rx.internal.util.RxRingBuffer;
import rx.observers.TestSubscriber;
public void onNext(Integer t) {
        assertTrue(completed.get());
    }
    
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void dispatch() {
            try {
                for (;;) {
                    /*
                     * See if the queue is empty; since we need this information multiple
                     * times later on, we read it one.
                     * Although the queue can become non-empty in the mean time, we will
void dispatch() {
                    // if the queue is empty and the terminal event was received, quit
                    // and don't bother restoring emitting to false: no further activity is
                    // possible at this point
                    if (checkTerminated(terminalEvent, empty)) {
                        skipFinal = true;
                        return;
                    }
void dispatch() {
                        // it may happen everyone has unsubscribed between here and producers.get()
                        // or we have no subscribers at all to begin with
                        if (len == unsubscribed) {
                            // so let's consume a value from the queue
                            Object v = queue.poll();
                            // or terminate if there was a terminal event and the queue is empty
                            if (checkTerminated(terminalEvent, v == null)) {
                                skipFinal = true;
                                return;
                            }
public void unsubscribe() {
            }
        }
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
package com.ning.billing.overdue.applicator;

import java.io.IOException;
import java.util.LinkedList;
import java.util.List;
import java.util.UUID;
import com.ning.billing.callcontext.InternalCallContext;
import com.ning.billing.callcontext.InternalTenantContext;
import com.ning.billing.catalog.api.BillingActionPolicy;
import com.ning.billing.clock.Clock;
import com.ning.billing.entitlement.api.BlockingApiException;
import com.ning.billing.entitlement.api.BlockingStateType;
import com.ning.billing.entitlement.api.Entitlement;
import com.ning.billing.entitlement.api.EntitlementApi;
import com.ning.billing.entitlement.api.EntitlementApiException;
import com.ning.billing.events.OverdueChangeInternalEvent;
import com.ning.billing.invoice.api.InvoiceApiException;
import com.ning.billing.invoice.api.InvoiceInternalApi;
import com.ning.billing.junction.BlockingInternalApi;
import com.ning.billing.junction.DefaultBlockingState;
import com.ning.billing.overdue.OverdueApiException;
import com.ning.billing.util.tag.ControlTagType;
import com.ning.billing.util.tag.Tag;

import com.google.common.collect.ImmutableList;
import com.google.inject.Inject;
import com.samskivert.mustache.MustacheException;
private void cancelSubscriptionsIfRequired(final Account account, final OverdueS
        }
    }

    @SuppressWarnings("unchecked")
    private void computeEntitlementsToCancel(final Account account, final List<Entitlement> result, final InternalTenantContext context) throws EntitlementApiException {
        final UUID tenantId = nonEntityDao.retrieveIdFromObject(context.getTenantRecordId(), ObjectType.TENANT);
        result.addAll(entitlementApi.getAllEntitlementsForAccountId(account.getId(), context.toTenantContext(tenantId)));
    }

    private void sendEmailIfRequired(final BillingState billingState, final Account account,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void discovery() {
        sendPacket(items);
    }

    private void active(boolean available) {
        if (mConnection != null) {
            cancelIdleAlarm();

            if (available) {
                if (ClientStateIndicationManager.isSupported(mConnection)) {
                    Log.d(TAG, "entering active state");
                    try {
                        ClientStateIndicationManager.active(mConnection);
                    }
                    catch (NotConnectedException e) {
                        return;
private void active(boolean available) {
        }
    }

    private void inactive() {
        if (mConnection != null) {
            if (!mInactive) {
                if (ClientStateIndicationManager.isSupported(mConnection)) {
                    Log.d(TAG, "entering inactive state");
                    try {
                        ClientStateIndicationManager.inactive(mConnection);
                    }
                    catch (NotConnectedException e) {
                        cancelIdleAlarm();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void redrawLayers() {

    @Override
    protected void afterRun() {
        for (Layer layer : this.layers) {
            layer.onDestroy();
        }
        this.drawingCanvas.destroy();
    }
protected void doWork() throws InterruptedException {
            BoundingBox boundingBox = MapPositionUtil.getBoundingBox(mapPosition, canvasDimension, tileSize);
            Point topLeftPoint = MapPositionUtil.getTopLeftPoint(mapPosition, canvasDimension, tileSize);

            for (Layer layer : this.layers) {
                if (layer.isVisible()) {
                    layer.draw(boundingBox, mapPosition.zoomLevel, this.drawingCanvas, topLeftPoint);
                }
            }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.math.MathContext;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
 * @author Chris Jackson
 */
public abstract class ZWaveCommandClassConverter {
    private static Map<CommandClass, Class<? extends ZWaveCommandClassConverter>> converterMap = null;

    private static Logger logger = LoggerFactory.getLogger(ZWaveCommandClassConverter.class);

public int getRefreshInterval() {
    }

    public static ZWaveCommandClassConverter getConverter(CommandClass commandClass) {
        if (converterMap == null) {
            converterMap = new HashMap<CommandClass, Class<? extends ZWaveCommandClassConverter>>();

            converterMap.put(CommandClass.ALARM, ZWaveAlarmConverter.class);
            converterMap.put(CommandClass.BASIC, ZWaveBasicConverter.class);
            converterMap.put(CommandClass.BATTERY, ZWaveBatteryConverter.class);
            converterMap.put(CommandClass.COLOR, ZWaveColorConverter.class);
            converterMap.put(CommandClass.CONFIGURATION, ZWaveConfigurationConverter.class);
            converterMap.put(CommandClass.METER, ZWaveMeterConverter.class);
            converterMap.put(CommandClass.SENSOR_ALARM, ZWaveAlarmSensorConverter.class);
            converterMap.put(CommandClass.SENSOR_BINARY, ZWaveBinarySensorConverter.class);
            converterMap.put(CommandClass.SENSOR_MULTILEVEL, ZWaveMultiLevelSensorConverter.class);
            converterMap.put(CommandClass.SWITCH_BINARY, ZWaveBinarySwitchConverter.class);
            converterMap.put(CommandClass.SWITCH_MULTILEVEL, ZWaveMultiLevelSwitchConverter.class);
            converterMap.put(CommandClass.THERMOSTAT_FAN_MODE, ZWaveThermostatFanModeConverter.class);
            converterMap.put(CommandClass.THERMOSTAT_FAN_STATE, ZWaveThermostatFanStateConverter.class);
            converterMap.put(CommandClass.THERMOSTAT_MODE, ZWaveThermostatModeConverter.class);
            converterMap.put(CommandClass.THERMOSTAT_OPERATING_STATE, ZWaveThermostatOperatingStateConverter.class);
            converterMap.put(CommandClass.THERMOSTAT_SETPOINT, ZWaveThermostatSetpointConverter.class);
        }

        Constructor<? extends ZWaveCommandClassConverter> constructor;
        try {
            if (converterMap.get(commandClass) == null) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import org.kontalk.provider.MyMessages.Threads;
import org.kontalk.util.Preferences;

import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
public static void updateMessagesNotification(Context context, boolean isNew) {
        // notifications are disabled
        if (!Preferences.getNotificationsEnabled(context))
            return;

        // if notifying new messages, wait a little bit
        // to let all incoming messages come through
else if (content == null && attMime != null) {
                    // TODO i18n
                    summary = "+" + (convs.size() - count) + " more";
                else
                    summary = Authenticator.getDefaultAccount(context).name;

                ((InboxStyle) style).setSummaryText(summary);
            }
else if (content == null && attMime != null) {
                // big text content
                style = new BigTextStyle();
                ((BigTextStyle) style).bigText(content);
                ((BigTextStyle) style).setSummaryText(Authenticator.getDefaultAccount(context).name);

                // ticker
                Contact contact = Contact.findByUserId(context, peer);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
protected void updateUI() {

        if (mToggleEncryptionMenu != null) {
            Context context = getActivity();
            if (mConversation != null && Preferences.getEncryptionEnabled(context)) {
                boolean encryption = mConversation.isEncryptionEnabled();
                mToggleEncryptionMenu
                    .setVisible(true)
                    .setEnabled(true)
                    .setChecked(encryption);
            }
            else {
                mToggleEncryptionMenu
                    .setVisible(false)
                    .setEnabled(false)
                    .setChecked(false);
            }
        }
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
protected Integer addToFacts(

    if (null != priorIndex) {
      aggs = concurrentGet(priorIndex);
    } else {
      aggs = new Aggregator[metrics.length];

      rowContainer.set(row);
      for (int i = 0; i < metrics.length; i++) {
        final AggregatorFactory agg = metrics[i];
        aggs[i] = agg.factorize(
            selectors.get(agg.getName())
        );
      }
      rowContainer.set(null);

      final Integer rowIndex = indexIncrement.getAndIncrement();

      concurrentSet(rowIndex, aggs);

      // Last ditch sanity checks
protected Integer addToFacts(
      } else {
        // We lost a race
        aggs = concurrentGet(prev);
        // Free up the misfire
        concurrentRemove(rowIndex);
        // This is expected to occur ~80%!o(MISSING)f the time in the worst scenarios
      }
    }

    rowContainer.set(row);

    for (Aggregator agg : aggs) {
protected Integer addToFacts(
    }

    rowContainer.set(null);


    return numEntries.get();
  }

  protected Aggregator[] concurrentGet(int offset)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public final void shutdown() throws InterruptedException
         connectionBag.close();
         softEvictConnections();
         houseKeepingExecutorService.shutdown();
         addConnectionExecutor.shutdown();
         houseKeepingExecutorService.awaitTermination(5L, TimeUnit.SECONDS);
         addConnectionExecutor.awaitTermination(5L, TimeUnit.SECONDS);

protected final boolean addConnection()
         }
         catch (Exception e) {
            lastConnectionFailure.set(e);
            poolUtils.quietlyCloseConnection(connection);
            LOGGER.debug("Connection attempt to database {} failed: {}", configuration.getPoolName(), e.getMessage(), e);
         }
      }
   
      totalConnections.decrementAndGet(); // We failed or pool is max, so undo speculative increment of totalConnections
      return false;
   }
public void testAfterShutdown() throws Exception
   }

   @Test
   public void testThreadedShutdown() throws Exception
   {
      final HikariConfig config = new HikariConfig();
      config.setMinimumIdle(5);
      config.setMaximumPoolSize(5);
      config.setConnectionTimeout(1000);
      config.setInitializationFailFast(true);
      config.setConnectionTestQuery("VALUES 1");
      config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

package com.navercorp.pinpoint.profiler.context;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;

import com.navercorp.pinpoint.bootstrap.context.ServerMetaData;
import com.navercorp.pinpoint.bootstrap.context.ServerMetaDataHolder;
import com.navercorp.pinpoint.bootstrap.context.ServiceInfo;

/**
 * @author hyungil.jeong
 */
public void removeListener(ServerMetaDataListener listener) {
    }

    @Override
    public void notifyListeners() {
        final ServerMetaData serverMetaData = createServerMetaData();
        for (ServerMetaDataListener listener : this.listeners) {
            listener.publishServerMetaData(serverMetaData);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void run() {
				} catch (InterruptedException exc) {
					// ignore
				}
				if (!process.isAlive()) {
					synchronized (Fork.this) {
						if (!forkDeathConfirmed) {
							forkDeathConfirmed = true;
public void run() {
							process = null;
							forkCallback.onForkExit(Fork.this);
							Fork.this.notifyAll();
							return;
						}
					}
				}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void record(T item) {
            }
        }

        if (shouldLaunchNewWorker)
            asyncWorkerCreator.submit(new Runnable() {
                public void run() {
                    try {
                        launchNewWorker(queue, startTime);
                    } catch (Exception e) {
                        LOG.error("Could not launch WritingWorker", e);
                    }
                }
            });

        return queue;
    }
protected void prune() {
                List<Thread> workersForQueue = getWorkersForStartTime(startTime);
                boolean needAnotherWorker = workersForQueue.isEmpty() || (queue.size() >= spawnNewWorkerAtQueueDepth && workersForQueue.size() < NUM_PROCESSORS);
                if (needAnotherWorker)
                    launchNewWorker(queue, startTime);
            }
        }
    }
protected void prune() {
        return result;
    }

    protected void launchNewWorker(BlockingQueue<T> queue, DateTime startTime) {
        LOG.debug("Launching new worker for {}", rollingScheme.getRepresentation(startTime));
        String logFilePathPattern = rollingScheme.makeOutputPathPattern(startTime);
        LogFile logFileRecord = tracker.open(rollingScheme.getRepresentation(startTime), logFilePathPattern, startTime);
        Thread worker = factory.buildWorker(queue, logFileRecord, tracker);
        synchronized (workers) {
            List<Thread> workersForQueue = workers.get(startTime);
            if (workersForQueue == null) {
                workersForQueue = new LinkedList<>();
                workers.put(startTime,workersForQueue);
            }
            workersForQueue.add(worker);
        }
        worker.start();
    }

    public void start() throws Exception {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import com.carrotsearch.hppc.cursors.ObjectObjectCursor;
import org.apache.lucene.util.CollectionUtil;
import org.elasticsearch.ExceptionsHelper;
import org.elasticsearch.action.search.ShardSearchFailure;
import org.elasticsearch.action.support.IndicesOptions;
import org.elasticsearch.cluster.ClusterChangedEvent;
import org.elasticsearch.cluster.routing.RoutingTable;
import org.elasticsearch.cluster.routing.ShardRouting;
import org.elasticsearch.cluster.service.ClusterService;
import org.elasticsearch.common.Strings;
import org.elasticsearch.common.collect.ImmutableOpenMap;
import org.elasticsearch.common.collect.Tuple;
public ClusterState execute(ClusterState currentState) {
                @Override
                public void onFailure(String source, Throwable t) {
                    logger.warn("[{}] failed to create snapshot", t, snapshot.snapshotId());
                    removeSnapshotFromClusterState(snapshot.snapshotId(), null, t);
                    try {
                        repositoriesService.repository(snapshot.snapshotId().getRepository()).finalizeSnapshot(
                                snapshot.snapshotId(), snapshot.indices(), snapshot.startTime(), ExceptionsHelper.detailedMessage(t), 0, Collections.<SnapshotShardFailure>emptyList());
                    } catch (Throwable t2) {
                        logger.warn("[{}] failed to close snapshot in repository", snapshot.snapshotId());
                    }
                    userCreateSnapshotListener.onFailure(t);
                }

                @Override
public void clusterStateProcessed(String source, ClusterState oldState, ClusterS
            });
        } catch (Throwable t) {
            logger.warn("failed to create snapshot [{}]", t, snapshot.snapshotId());
            removeSnapshotFromClusterState(snapshot.snapshotId(), null, t);
            if (snapshotCreated) {
                try {
                    repositoriesService.repository(snapshot.snapshotId().getRepository()).finalizeSnapshot(snapshot.snapshotId(), snapshot.indices(), snapshot.startTime(),
                            ExceptionsHelper.detailedMessage(t), 0, Collections.<SnapshotShardFailure>emptyList());
                } catch (Throwable t2) {
                    logger.warn("[{}] failed to close snapshot in repository", snapshot.snapshotId());
                }
            }
            userCreateSnapshotListener.onFailure(t);
        }
    }

    private SnapshotInfo inProgressSnapshot(SnapshotsInProgress.Entry entry) {
public void run() {
     * @param t          exception if snapshot failed
     */
    private void removeSnapshotFromClusterState(final SnapshotId snapshotId, final SnapshotInfo snapshot, final Throwable t) {
        clusterService.submitStateUpdateTask("remove snapshot metadata", new ClusterStateUpdateTask() {
            @Override
            public ClusterState execute(ClusterState currentState) {
public ClusterState execute(ClusterState currentState) {
            @Override
            public void onFailure(String source, Throwable t) {
                logger.warn("[{}] failed to remove snapshot metadata", t, snapshotId);
            }

            @Override
public void clusterStateProcessed(String source, ClusterState oldState, ClusterS
                        logger.warn("failed to notify listener [{}]", t, listener);
                    }
                }

            }
        });
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	String ACTION_KEY = "_action";
	String CONTENTS_KEY = "contents";
	String METADATA_KEY = "metadata";
	String PENDING_METADATA_FLAG = "pending";
	String PROCESSED_METADATA_FLAG = "processed";
	String DISCARDED_METADATA_FLAG = "discarded";
			<type>jar</type>
			<scope>compile</scope>
		</dependency>
	</dependencies>

	<build>
public boolean insert(DatabaseDocument<MemoryType> d) {
		return true;
	}

	private void removeNullFields(MemoryDocument md) {
		HashSet<String> fields = new HashSet<String>();
		for (String entry : md.getTouchedContent()) {
package com.findwise.hydra.memorydb;

import static org.junit.Assert.fail;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import com.findwise.hydra.DocumentFile;
import com.findwise.hydra.SerializationUtils;

@RunWith(RepeatRunner.class)
public class MemoryDocumentIOTest {
	private MemoryDocumentIO io;
public void testInsertDocument() {
	}

	@Test
	public void testUpdateDocument() {
		String field = "xyz";
		String content = "zyx";
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>slf4j-api</artifactId>
			<version>1.6.4</version>
public boolean insert(DatabaseDocument<MongoType> d) {
		}
		return false;
	}
	
	private Set<String> getNullFields(MongoDocument d) {
		Set<String> set = new HashSet<String>();
		for(Map.Entry<String, Object> e : d.getContentMap().entrySet()) {
public MongoDocument getAndTag(DatabaseQuery<MongoType> query, String ... tag) {
		MongoQuery mq = (MongoQuery)query;
		mq.requireMetadataFieldNotExists(Document.PENDING_METADATA_FLAG);

		for(String t : tag) {
			mq.requireMetadataFieldNotExists(DatabaseDocument.FETCHED_METADATA_TAG+"."+t);
		}

import static org.junit.Assert.fail;

import java.util.Random;

import junit.framework.Assert;

import org.bson.types.ObjectId;
import org.junit.AfterClass;
import org.junit.Before;
import com.mongodb.Mongo;
import com.mongodb.WriteConcern;

public class MongoDocumentIOTest {
	private MongoConnector mdc;
	
public void testDoneContentTransfer() throws Exception {
	}

	@Test
	public void testFetchRemoval() throws Exception {
		MongoDocumentIO dw = (MongoDocumentIO) mdc.getDocumentWriter();
		MongoDocument md = new MongoDocument();

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.ConcurrentModificationException;
import java.util.Date;
import java.util.List;
public boolean insert(DatabaseDocument<T> d) {
	}

	@Override
	public boolean update(DatabaseDocument<T> d) {
		if (!cache.update(d)) {
			DatabaseDocument<T> doc = reader.getDocumentById(d.getID());

import java.io.IOException;
import java.util.Collection;

import com.findwise.hydra.DocumentFile;

	 * Inserts a new document into the database. Will fail if the document
	 * already has a non-null ID. The document's new ID will be applied to the
	 * document.
	 * 
	 * A field that is <pre>null</pre> is ignored.
	 * 
	 * @param d
	 *            the document to insert
	 * @return false if the document already has an id, true otherwise.
	 */
	boolean insert(DatabaseDocument<T> d);
	
	/**
	 * Updates the document in the database. If any field in document is 
	 * <pre>null</pre>, this field will be ignored and removed. 
public void testMarkPending() {
	}

	@Test
	public void testInsert() {
		io.insert(doc1);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public LeaderState(ServerState context) {
    // Append initial entries to the log, including an initial no-op entry and the server's configuration.
    appendInitialEntries();

    // Schedule the initial entries commit to occur after the state is opened. Attempting any communication
    // within the open() method will result in a deadlock since RaftProtocol calls this method synchronously.
    // What is critical about this logic is that the heartbeat timer not be started until a no-op entry has been committed.
    context.getThreadContext().execute(this::commitInitialEntries).whenComplete((result, error) -> {
      if (isOpen() && error == null) {
        startAppendTimer();
      }
private void appendInitialEntries() {
    final long term = context.getTerm();

    // Append a no-op entry to reset session timeouts and commit entries from prior terms.
    try (NoOpEntry entry = context.getLog().create(NoOpEntry.class)) {
      entry.setTerm(term)
        .setTimestamp(appender.time());
      assert context.getLog().append(entry) == appender.index();
    }

    // Append a configuration entry to propagate the leader's cluster configuration.
private void setLastCompleted(long lastCompleted) {
      return apply((KeepAliveEntry) entry);
    } else if (entry instanceof UnregisterEntry) {
      return apply((UnregisterEntry) entry, expectResult);
    } else if (entry instanceof NoOpEntry) {
      return apply((NoOpEntry) entry);
    } else if (entry instanceof ConnectEntry) {
      return apply((ConnectEntry) entry);
    } else if (entry instanceof ConfigurationEntry) {
else if (entry.getIndex() > session.getLastApplied()) {
  }

  /**
   * Applies a no-op entry to the state machine.
   * <p>
   * No-op entries are committed by leaders at the start of their term. Typically, no-op entries
   * serve as a mechanism to allow leaders to commit entries from prior terms. However, we extend
   * the functionality of the no-op entry to use it as an indicator that a leadership change occurred.
   * In order to ensure timeouts do not expire during lengthy leadership changes, we use no-op entries
   * to reset timeouts for client sessions and server heartbeats.
   */
  private CompletableFuture<Long> apply(NoOpEntry entry) {
    // Iterate through all the server sessions and reset timestamps. This ensures that sessions do not
    // timeout during leadership changes or shortly thereafter.
    long timestamp = executor.tick(entry.getTimestamp());
import io.atomix.copycat.server.storage.compaction.Compaction;

/**
 * No-op entry.
 *
 * @author <a href="http://github.com/kuujo">Jordan Halterman</a>
 */
@SerializeWith(id=224)
public class NoOpEntry extends TimestampedEntry<NoOpEntry> {

  public NoOpEntry() {
  }

  public NoOpEntry(ReferenceManager<Entry<?>> referenceManager) {
    super(referenceManager);
  }

io.atomix.copycat.server.response.VoteResponse
io.atomix.copycat.server.storage.entry.CommandEntry
io.atomix.copycat.server.storage.entry.ConfigurationEntry
io.atomix.copycat.server.storage.entry.KeepAliveEntry
io.atomix.copycat.server.storage.entry.NoOpEntry
io.atomix.copycat.server.storage.entry.QueryEntry
io.atomix.copycat.server.storage.entry.RegisterEntry
io.atomix.copycat.server.storage.entry.ConnectEntry
public void testSessionLeaderReset() throws Throwable {
    callerContext.execute(() -> {

      long index;
      try (NoOpEntry entry = log.create(NoOpEntry.class)) {
        entry.setTerm(1)
          .setTimestamp(timestamp + 100);
        index = log.append(entry);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
dependencies {
    compile 'com.netflix.archaius:archaius-core:0.4.1'
    compile 'io.reactivex:rxjava:1.1.5'
    compile 'org.slf4j:slf4j-api:1.7.0'
	compile 'org.hdrhistogram:HdrHistogram:2.1.7'
    testCompile 'junit:junit-dep:4.10'
    testCompile project(':hystrix-junit')
}
javadoc {
    // we do not want the com.netflix.hystrix.util package include
    exclude '**/util/**'

        options {
	doclet = "org.benjchristensen.doclet.DocletExclude"
        docletpath = [rootProject.file('./gradle/doclet-exclude.jar')]
        stylesheetFile = rootProject.file('./gradle/javadocStyleSheet.css')
        windowTitle = "Hystrix Javadoc ${project.version}"
jar {
}

jmh {
	fork = 10
	iterations = 3
	jmhVersion = '1.11.2'
	profilers = ['gc']
	threads = 8
	warmup = '1s'
	warmupBatchSize = 1
	warmupIterations = 5
}
 */
package com.netflix.hystrix;

import java.util.concurrent.ConcurrentHashMap;

/**
 * A group name for a {@link HystrixCommand}. This is used for grouping together commands such as for reporting, alerting, dashboards or team/library ownership.
 * <p>
 * This interface is intended to work natively with Enums so that implementing code can have an enum with the owners that implements this interface.
 */
public interface HystrixCommandGroupKey {

    /**
     * The word 'name' is used instead of 'key' so that Enums can implement this interface and it work natively.
     * 
     * @return String
     */
    public String name();

    public static class Factory {

        private Factory() {
        }

        // used to intern instances so we don't keep re-creating them millions of times for the same key
        private static ConcurrentHashMap<String, HystrixCommandGroupKey> intern = new ConcurrentHashMap<String, HystrixCommandGroupKey>();

        /**
         * Retrieve (or create) an interned HystrixCommandGroup instance for a given name.
         * 
         * @param name command group name
         * @return HystrixCommandGroup instance that is interned (cached) so a given name will always retrieve the same instance.
         */
        public static HystrixCommandGroupKey asKey(String name) {
            HystrixCommandGroupKey k = intern.get(name);
            if (k == null) {
                k = new HystrixCommandGroupDefault(name);
                intern.putIfAbsent(name, k);
            }
            return k;
        }

        private static class HystrixCommandGroupDefault implements HystrixCommandGroupKey {

            private String name;

            private HystrixCommandGroupDefault(String name) {
                this.name = name;
            }

            @Override
            public String name() {
                return name;
            }

        }

        /* package-private */ static int getGroupCount() {
 */
package com.netflix.hystrix;

import java.util.concurrent.ConcurrentHashMap;

/**
 * A key to represent a {@link HystrixCommand} for monitoring, circuit-breakers, metrics publishing, caching and other such uses.
 * <p>
 * This interface is intended to work natively with Enums so that implementing code can be an enum that implements this interface.
 */
public interface HystrixCommandKey {

    /**
     * The word 'name' is used instead of 'key' so that Enums can implement this interface and it work natively.
     * 
     * @return String
     */
    public String name();

    public static class Factory {

        private Factory() {
        }

        // used to intern instances so we don't keep re-creating them millions of times for the same key
        private static ConcurrentHashMap<String, HystrixCommandKey> intern = new ConcurrentHashMap<String, HystrixCommandKey>();

        /**
         * Retrieve (or create) an interned HystrixCommandKey instance for a given name.
private Factory() {
         * @return HystrixCommandKey instance that is interned (cached) so a given name will always retrieve the same instance.
         */
        public static HystrixCommandKey asKey(String name) {
            HystrixCommandKey k = intern.get(name);
            if (k == null) {
                k = new HystrixCommandKeyDefault(name);
                intern.putIfAbsent(name, k);
            }
            return k;
        }

        private static class HystrixCommandKeyDefault implements HystrixCommandKey {

            private String name;

            private HystrixCommandKeyDefault(String name) {
                this.name = name;
            }

            @Override
            public String name() {
                return name;
            }
            
            @Override
            public String toString() {
            	return name;
            }
        }

 */
package com.netflix.hystrix;

import java.util.concurrent.ConcurrentHashMap;

/**
 * A key to represent a {@link HystrixThreadPool} for monitoring, metrics publishing, caching and other such uses.
 * <p>
 * This interface is intended to work natively with Enums so that implementing code can be an enum that implements this interface.
 */
public interface HystrixThreadPoolKey {

    /**
     * The 'key' used as the name for a thread-pool.
     * <p>
     * The word 'name' is used instead of 'key' so that Enums can implement this interface and it work natively.
     * 
     * @return String
     */
    public String name();

    public static class Factory {

        private Factory() {
        }

        // used to intern instances so we don't keep re-creating them millions of times for the same key
        private static ConcurrentHashMap<String, HystrixThreadPoolKey> intern = new ConcurrentHashMap<String, HystrixThreadPoolKey>();

        /**
         * Retrieve (or create) an interned HystrixThreadPoolKey instance for a given name.
private Factory() {
         * @return HystrixThreadPoolKey instance that is interned (cached) so a given name will always retrieve the same instance.
         */
        public static HystrixThreadPoolKey asKey(String name) {
            HystrixThreadPoolKey k = intern.get(name);
            if (k == null) {
                k = new HystrixThreadPoolKeyDefault(name);
                intern.putIfAbsent(name, k);
            }
            return k;
        }

        private static class HystrixThreadPoolKeyDefault implements HystrixThreadPoolKey {

            private String name;

            private HystrixThreadPoolKeyDefault(String name) {
                this.name = name;
            }

            @Override
            public String name() {
                return name;
            }
            
            @Override
            public String toString() {
            	return name;
            }
        }

        /* package-private */ static int getThreadPoolCount() {
            return intern.size();
        }
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#!/bin/sh

CDPATH=""
SCRIPT="$0"

# SCRIPT may be an arbitrarily deep series of symlinks. Loop until we have the concrete path.
while [ -h "$SCRIPT" ] ; do
  ls=`ls -ld "$SCRIPT"`
  # Drop everything prior to ->
  link=`expr "$ls" : '.*-> \(.*\)$'`
  if expr "$link" : '/.*' > /dev/null; then
    SCRIPT="$link"
  else
    SCRIPT=`dirname "$SCRIPT"`/"$link"
  fi
done

# determine elasticsearch home
ES_HOME=`dirname "$SCRIPT"`/..

# make ELASTICSEARCH_HOME absolute
ES_HOME=`cd "$ES_HOME"; pwd`


if [ -x "$JAVA_HOME/bin/java" ]; then
    JAVA=$JAVA_HOME/bin/java
else
    JAVA=`which java`
fi

# this is a poor mans getopt replacement
# real getopt cannot be used because we need to hand options over to the PluginManager
while [ $# -gt 0 ]; do
  case $1 in
    -D*=*)
      properties="$properties $1"
      ;;
    -D*)
      var=$1
      shift
      properties="$properties $var=$1"
      ;;
    *)
      args="$args $1"
  esac
  shift
done

exec $JAVA $JAVA_OPTS -Xmx64m -Xms16m -Delasticsearch -Des.path.home="$ES_HOME" $properties -cp "$ES_HOME/lib/*" org.elasticsearch.plugins.PluginManager $args

protected ParseContext initialValue() {

    private final Filter typeFilter;

    private final Object mutex = new Object();

    private boolean initMappersAdded = true;

public ParsedDocument parse(SourceToParse source, @Nullable ParseListener listen
                parser.nextToken();
            }

            // fire up any new mappers if exists
            if (!context.newFieldMappers().mappers.isEmpty()) {
                addFieldMappers(context.newFieldMappers().mappers);
                context.newFieldMappers().mappers.clear();
            }
            if (!context.newObjectMappers().mappers.isEmpty()) {
                addObjectMappers(context.newObjectMappers().mappers);
                context.newObjectMappers().mappers.clear();
            }

            for (RootMapper rootMapper : rootMappersOrdered) {
                rootMapper.postParse(context);
            }
public ParsedDocument parse(SourceToParse source, @Nullable ParseListener listen
                rootMapper.validate(context);
            }
        } catch (Throwable e) {
            // we have to fire up any new mappers even on a failure, because they
            // have been added internally to each compound mapper...
            // ... we have no option to "rollback" a change, which is very tricky in our copy on change system...
            if (!context.newFieldMappers().mappers.isEmpty()) {
                addFieldMappers(context.newFieldMappers().mappers);
                context.newFieldMappers().mappers.clear();
            }
            if (!context.newObjectMappers().mappers.isEmpty()) {
                addObjectMappers(context.newObjectMappers().mappers);
                context.newObjectMappers().mappers.clear();
            }

            // if its already a mapper parsing exception, no need to wrap it...
            if (e instanceof MapperParsingException) {
                throw (MapperParsingException) e;
public ParsedDocument parse(SourceToParse source, @Nullable ParseListener listen
        return doc;
    }

    private void addFieldMappers(Collection<FieldMapper> fieldMappers) {
        addFieldMappers(fieldMappers.toArray(new FieldMapper[fieldMappers.size()]));
    }

    private void addFieldMappers(FieldMapper... fieldMappers) {
        synchronized (mutex) {
            this.fieldMappers = this.fieldMappers.concat(this, fieldMappers);
        }
        for (FieldMapperListener listener : fieldMapperListeners) {
public void traverse(FieldMapperListener listener) {
        rootObjectMapper.traverse(listener);
    }

    private void addObjectMappers(Collection<ObjectMapper> objectMappers) {
        addObjectMappers(objectMappers.toArray(new ObjectMapper[objectMappers.size()]));
    }

    private void addObjectMappers(ObjectMapper... objectMappers) {
        synchronized (mutex) {
            MapBuilder<String, ObjectMapper> builder = MapBuilder.newMapBuilder(this.objectMappers);
            for (ObjectMapper objectMapper : objectMappers) {
                builder.put(objectMapper.fullPath(), objectMapper);

    private volatile Map<String, DocumentMapper> mappers = ImmutableMap.of();

    private final Object mutex = new Object();

    private volatile Map<String, FieldMappers> nameFieldMappers = ImmutableMap.of();
    private volatile Map<String, FieldMappers> indexNameFieldMappers = ImmutableMap.of();
public DocumentMapper merge(String type, String mappingSource, boolean applyDefa
            DocumentMapper mapper = documentParser.parse(type, mappingSource);
            // still add it as a document mapper so we have it registered and, for example, persisted back into
            // the cluster meta data if needed, or checked for existence
            synchronized (mutex) {
                mappers = newMapBuilder(mappers).put(type, mapper).map();
            }
            defaultMappingSource = mappingSource;
public DocumentMapper merge(String type, String mappingSource, boolean applyDefa
    // never expose this to the outside world, we need to reparse the doc mapper so we get fresh
    // instances of field mappers to properly remove existing doc mapper
    private DocumentMapper merge(DocumentMapper mapper) {
        synchronized (mutex) {
            if (mapper.type().length() == 0) {
                throw new InvalidTypeNameException("mapping type name is empty");
            }
private DocumentMapper merge(DocumentMapper mapper) {
    }

    private void addObjectMappers(ObjectMapper[] objectMappers) {
        synchronized (mutex) {
            MapBuilder<String, ObjectMappers> fullPathObjectMappers = newMapBuilder(this.fullPathObjectMappers);
            for (ObjectMapper objectMapper : objectMappers) {
                ObjectMappers mappers = fullPathObjectMappers.get(objectMapper.fullPath());
private void addObjectMappers(ObjectMapper[] objectMappers) {
    }

    private void addFieldMappers(FieldMapper[] fieldMappers) {
        synchronized (mutex) {
            MapBuilder<String, FieldMappers> nameFieldMappers = newMapBuilder(this.nameFieldMappers);
            MapBuilder<String, FieldMappers> indexNameFieldMappers = newMapBuilder(this.indexNameFieldMappers);
            MapBuilder<String, FieldMappers> fullNameFieldMappers = newMapBuilder(this.fullNameFieldMappers);
private void addFieldMappers(FieldMapper[] fieldMappers) {
    }

    public void remove(String type) {
        synchronized (mutex) {
            DocumentMapper docMapper = mappers.get(type);
            if (docMapper == null) {
                return;
public void remove(String type) {
    }

    private void removeObjectAndFieldMappers(DocumentMapper docMapper) {
        // we need to remove those mappers
        MapBuilder<String, FieldMappers> nameFieldMappers = newMapBuilder(this.nameFieldMappers);
        MapBuilder<String, FieldMappers> indexNameFieldMappers = newMapBuilder(this.indexNameFieldMappers);
        MapBuilder<String, FieldMappers> fullNameFieldMappers = newMapBuilder(this.fullNameFieldMappers);

        for (FieldMapper mapper : docMapper.mappers()) {
            FieldMappers mappers = nameFieldMappers.get(mapper.names().name());
            if (mappers != null) {
                mappers = mappers.remove(mapper);
                if (mappers.isEmpty()) {
                    nameFieldMappers.remove(mapper.names().name());
                } else {
                    nameFieldMappers.put(mapper.names().name(), mappers);
                }
            }

            mappers = indexNameFieldMappers.get(mapper.names().indexName());
            if (mappers != null) {
                mappers = mappers.remove(mapper);
                if (mappers.isEmpty()) {
                    indexNameFieldMappers.remove(mapper.names().indexName());
                } else {
                    indexNameFieldMappers.put(mapper.names().indexName(), mappers);
                }
            }

            mappers = fullNameFieldMappers.get(mapper.names().fullName());
            if (mappers != null) {
                mappers = mappers.remove(mapper);
                if (mappers.isEmpty()) {
                    fullNameFieldMappers.remove(mapper.names().fullName());
                } else {
                    fullNameFieldMappers.put(mapper.names().fullName(), mappers);
                }
            }
        }
        this.nameFieldMappers = nameFieldMappers.map();
        this.indexNameFieldMappers = indexNameFieldMappers.map();
        this.fullNameFieldMappers = fullNameFieldMappers.map();

        MapBuilder<String, ObjectMappers> fullPathObjectMappers = newMapBuilder(this.fullPathObjectMappers);
        for (ObjectMapper mapper : docMapper.objectMappers().values()) {
            ObjectMappers mappers = fullPathObjectMappers.get(mapper.fullPath());
            if (mappers != null) {
                mappers = mappers.remove(mapper);
                if (mappers.isEmpty()) {
                    fullPathObjectMappers.remove(mapper.fullPath());
                } else {
                    fullPathObjectMappers.put(mapper.fullPath(), mappers);
                }
            }
        }

        this.fullPathObjectMappers = fullPathObjectMappers.map();
    }

    /**
public DocumentMapper documentMapperWithAutoCreate(String type) {
            throw new TypeMissingException(index, type, "trying to auto create mapping, but dynamic mapping is disabled");
        }
        // go ahead and dynamically create it
        synchronized (mutex) {
            mapper = mappers.get(type);
            if (mapper != null) {
                return mapper;
    private Map<String, String> ignoredValues = new HashMap<String, String>();

    private boolean mappingsModified = false;

    private boolean externalValueSet;


    private float docBoost = 1.0f;

    private FieldMapperListener.Aggregator newFieldMappers = new FieldMapperListener.Aggregator();
    private ObjectMapperListener.Aggregator newObjectMappers = new ObjectMapperListener.Aggregator();

    public ParseContext(String index, @Nullable Settings indexSettings, DocumentMapperParser docMapperParser, DocumentMapper docMapper, ContentPath path) {
        this.index = index;
        this.indexSettings = indexSettings;
public void reset(XContentParser parser, Document document, SourceToParse source
        this.source = source == null ? null : sourceToParse.source();
        this.path.reset();
        this.mappingsModified = false;
        this.listener = listener == null ? DocumentMapper.ParseListener.EMPTY : listener;
        this.allEntries = new AllEntries();
        this.ignoredValues.clear();
        this.docBoost = 1.0f;
        this.newFieldMappers.mappers.clear();
        this.newObjectMappers.mappers.clear();
    }

    public boolean flyweight() {
        return sourceToParse.flyweight();
    }

    public FieldMapperListener.Aggregator newFieldMappers() {
        return newFieldMappers;
    }

    public ObjectMapperListener.Aggregator newObjectMappers() {
        return newObjectMappers;
    }

    public DocumentMapperParser docMapperParser() {
        return this.docMapperParser;
    }
public void setMappingsModified() {
        this.mappingsModified = true;
    }

    public String index() {
        return this.index;
    }
private void serializeObject(final ParseContext context, String currentFieldName
            } else if (dynamic == Dynamic.TRUE) {
                // we sync here just so we won't add it twice. Its not the end of the world
                // to sync here since next operations will get it before
                boolean newMapper = false;
                synchronized (mutex) {
                    objectMapper = mappers.get(currentFieldName);
                    if (objectMapper == null) {
                        newMapper = true;
                        // remove the current field name from path, since template search and the object builder add it as well...
                        context.path().remove();
                        Mapper.Builder builder = context.root().findTemplateBuilder(context, currentFieldName, "object");
private void serializeObject(final ParseContext context, String currentFieldName
                        }
                        BuilderContext builderContext = new BuilderContext(context.indexSettings(), context.path());
                        objectMapper = builder.build(builderContext);
                        putMapper(objectMapper);
                        // ...now re add it
                        context.path().add(currentFieldName);
                        context.setMappingsModified();
                    }
                }
                // traverse and parse outside of the mutex
                if (newMapper) {
                    // we need to traverse in case we have a dynamic template and need to add field mappers
                    // introduced by it
                    objectMapper.traverse(context.newFieldMappers());
                    objectMapper.traverse(context.newObjectMappers());
                }
                // now, parse it
                objectMapper.parse(context);
            } else {
                // not dynamic, read everything up to end object
                context.parser().skipChildren();
private void serializeValue(final ParseContext context, String currentFieldName,
        // we sync here since we don't want to add this field twice to the document mapper
        // its not the end of the world, since we add it to the mappers once we create it
        // so next time we won't even get here for this field
        boolean newMapper = false;
        synchronized (mutex) {
            mapper = mappers.get(currentFieldName);
            if (mapper == null) {
                newMapper = true;
                BuilderContext builderContext = new BuilderContext(context.indexSettings(), context.path());
                if (token == XContentParser.Token.VALUE_STRING) {
                    boolean resolved = false;
private void serializeValue(final ParseContext context, String currentFieldName,
                        throw new ElasticSearchIllegalStateException("Can't handle serializing a dynamic type with content token [" + token + "] and field name [" + currentFieldName + "]");
                    }
                }
                putMapper(mapper);
                context.setMappingsModified();
            }
        }
        if (newMapper) {
            mapper.traverse(context.newFieldMappers());
        }
        mapper.parse(context);
    }

    @Override
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
 * Copyright © 2014 Cask Data, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
import co.cask.cdap.common.async.AsyncFunctions;
import co.cask.cdap.common.io.Codec;
import com.google.common.base.Function;
import com.google.common.util.concurrent.AsyncFunction;
import com.google.common.util.concurrent.FutureCallback;
import com.google.common.util.concurrent.Futures;
   *
   * @param zkClient The ZKClient to perform the operations.
   * @param path The path in ZK.
   * @param data The content of the ZK node.
   * @param result The result that will be set into the result future when completed successfully.
   * @param maxFailure Maximum number of times to try to create/set the content.
   * @param <V> Type of the result.
   * @return A {@link ListenableFuture} that will be completed when node is created or data is set. The future will
   *         fail if failed to create and to set the data. Calling {@link ListenableFuture#cancel(boolean)} has
   *         no effect.
   */
  public static <V> ListenableFuture<V> createOrSet(ZKClient zkClient, String path,
                                                    byte[] data, V result, int maxFailure) {
    return setContent(zkClient, path, data, result, maxFailure, true, null);
  }

  /**
   *
   * @param zkClient The ZKClient to perform the operations.
   * @param path The path in ZK.
   * @param data The content of the ZK node.
   * @param result The result that will be set into the result future when completed successfully.
   * @param maxFailure Maximum number of times to try to create/set the content.
   * @param createAcl The access control list to set on the node, if it is created.
   * @param <V> Type of the result.
   * @return A {@link ListenableFuture} that will be completed when node is created or data is set. The future will
   *         fail if failed to create and to set the data. Calling {@link ListenableFuture#cancel(boolean)} has
   *         no effect.
   */
  public static <V> ListenableFuture<V> createOrSet(ZKClient zkClient, String path,
                                                    byte[] data, V result, int maxFailure, List<ACL> createAcl) {
    return setContent(zkClient, path, data, result, maxFailure, true, createAcl);
  }

  /**
   * Attempts to set the content of the given node. If it failed due to node not exists
   * ({@link KeeperException.NoNodeException}), a persistent node will be created with the given content.
   * This method is suitable for cases where the node is expected to be existed.
   *
   * @param zkClient The ZKClient to perform the operations.
   * @param path The path in ZK.
   * @param data The content of the ZK node.
   * @param result The result that will be set into the result future when completed successfully.
   * @param maxFailure Maximum number of times to try to create/set the content.
   * @param <V> Type of the result.
   * @return A {@link ListenableFuture} that will be completed when node is created or data is set. The future will
   *         fail if failed to create and to set the data. Calling {@link ListenableFuture#cancel(boolean)} has
   *         no effect.
   */
  public static <V> ListenableFuture<V> setOrCreate(ZKClient zkClient, String path,
                                                    byte[] data, V result, int maxFailure) {
    return setContent(zkClient, path, data, result, maxFailure, false, null);
  }

  /**
   * Update the content of the given node. If the node doesn't exists, it will try to create the node. Same as calling
   *
   * {@link #updateOrCreate(ZKClient, String, Function, Codec, List)
   * updateOrCreate(zkClient, path, modifier, codec, null)}
  }

  /**
   * Update the content of the given node. If the node doesn't exists, it will try to create the node.
   * The modifier will be executed in the ZooKeeper callback thread, hence no blocking operation should be performed
   * in it. If blocking operation is needed, use the async version of this method.
   *
  }

  /**
   * Update the content of the given node. If the node doesn't exists, it will try to create the node. Same as calling
   *
   * {@link #updateOrCreate(ZKClient, String, AsyncFunction, Codec, List)
   * updateOrCreate(zkClient, path, modifier, codec, null)}
  }

  /**
   * Update the content of the given node. If the node doesn't exists, it will try to create the node. If the node
   * exists, the existing content of the data will be provided to the modifier function to generate new content. A
   * conditional set will be performed which requires existing content the same as the one provided to the modifier
   * function. If the conditional set failed, the latest content will be fetched and fed to the modifier function
  }

  /**
   * Attempts to set the content of the given node. If it failed due to node not exists
   * ({@link KeeperException.NoNodeException}), a persistent node will be created with the given content.
   * This method is suitable for cases where the node is expected to be existed.
   *
   * @param zkClient The ZKClient to perform the operations.
   * @param path The path in ZK.
   * @param data The content of the ZK node.
   * @param result The result that will be set into the result future when completed successfully.
   * @param maxFailure Maximum number of times to try to create/set the content.
   * @param createAcl The access control list to set on the node, if it is created.
   * @param <V> Type of the result.
   * @return A {@link ListenableFuture} that will be completed when node is created or data is set. The future will
   *         fail if failed to create and to set the data. Calling {@link ListenableFuture#cancel(boolean)} has
   *         no effect.
   */
  public static <V> ListenableFuture<V> setOrCreate(ZKClient zkClient, String path,
                                                    byte[] data, V result, int maxFailure, List<ACL> createAcl) {
    return setContent(zkClient, path, data, result, maxFailure, false, createAcl);
  }

  /**
   * Sets the content of a ZK node. Depends on the {@code createFirst} value,
   * either {@link ZKClient#create(String, byte[], org.apache.zookeeper.CreateMode)} or
   * {@link ZKClient#setData(String, byte[])} wil be called first.
   *
   * @param zkClient The ZKClient to perform the operations.
   * @param path The path in ZK.
   * @param data The content of the ZK node.
   * @param result The result that will be set into the result future when completed successfully.
   * @param maxFailure Maximum number of times to try to create/set the content.
   * @param createFirst If true, create is called first, otherwise setData is called first.
   * @param <V> Type of the result.
   * @return A {@link ListenableFuture} that will be completed when node is created or data is set. The future will
   *         fail if failed to create and to set the data. Calling {@link ListenableFuture#cancel(boolean)} has
   *         no effect.
   */
  private static <V> ListenableFuture<V> setContent(final ZKClient zkClient, final String path,
                                                    final byte[] data, final V result,
                                                    final int maxFailure, boolean createFirst,
                                                    final List<ACL> createAcls) {

    final SettableFuture<V> resultFuture = SettableFuture.create();
    final AtomicInteger failureCount = new AtomicInteger(0);

    OperationFuture<?> operationFuture;

    if (createFirst) {
      if (createAcls != null) {
        operationFuture = zkClient.create(path, data, CreateMode.PERSISTENT, createAcls);
      } else {
        operationFuture = zkClient.create(path, data, CreateMode.PERSISTENT);
      }
    } else {
      operationFuture = zkClient.setData(path, data);
    }

    Futures.addCallback(operationFuture, new FutureCallback<Object>() {
      @Override
      public void onSuccess(Object zkResult) {
        resultFuture.set(result);
      }

      @Override
      public void onFailure(Throwable t) {
        if (failureCount.getAndIncrement() > maxFailure) {
          resultFuture.setException(new Exception("Failed more than " + maxFailure + "times", t));
        } else if (t instanceof KeeperException.NoNodeException) {
          // If node not exists, create it with the data
          OperationFuture<?> createFuture;
          if (createAcls != null) {
            createFuture = zkClient.create(path, data, CreateMode.PERSISTENT, createAcls);
          } else {
            createFuture = zkClient.create(path, data, CreateMode.PERSISTENT);
          }
          Futures.addCallback(createFuture, this, Threads.SAME_THREAD_EXECUTOR);
        } else if (t instanceof KeeperException.NodeExistsException) {
          // If the node exists when trying to create, set data.
          Futures.addCallback(zkClient.setData(path, data), this, Threads.SAME_THREAD_EXECUTOR);
        } else {
          resultFuture.setException(t);
        }
      }
    }, Threads.SAME_THREAD_EXECUTOR);

    return resultFuture;
  }

  /**
   * Performs the get and condition set part as described in
   * {@link #updateOrCreate(ZKClient, String, Function, Codec, List)}.
   */
public void onFailure(Throwable t) {
                      // If the version is not good, get and set again
                      getAndSet(zkClient, path, modifier, codec, resultFuture, createAcl);
                    } else if (t instanceof KeeperException.NoNodeException) {
                      // If the node not exists, try to do create
                      createOrGetAndSet(zkClient, path, modifier, codec, resultFuture, createAcl);
                    } else {
                      resultFuture.setException(t);
public void onFailure(Throwable t) {

      @Override
      public void onFailure(Throwable t) {
        // If failed to get data because node not exists, try the create.
        if (t instanceof KeeperException.NoNodeException) {
          createOrGetAndSet(zkClient, path, modifier, codec, resultFuture, createAcl);
        } else {
public void onFailure(Throwable t) {
    }, Threads.SAME_THREAD_EXECUTOR);
  }


  /**
   * Performs the create part as described in
   * {@link #updateOrCreate(ZKClient, String, Function, Codec, List)}. If the creation failed with
public void onFailure(Throwable t) {
   */
  private static <V> void createOrGetAndSet(final ZKClient zkClient, final String path,
                                            final AsyncFunction<V, V> modifier, final Codec<V> codec,
                                            final SettableFuture<V> resultFuture, final List<ACL> createAcl) {
    try {
      Futures.addCallback(modifier.apply(null), new FutureCallback<V>() {
        @Override
        public void onSuccess(final V content) {
          if (content == null) {
            resultFuture.set(null);
            return;
          }

          try {
            byte[] data = codec.encode(content);

            OperationFuture<String> future;
            if (createAcl == null) {
              future = zkClient.create(path, data, CreateMode.PERSISTENT);
            } else {
              future = zkClient.create(path, data, CreateMode.PERSISTENT, createAcl);
            }

            Futures.addCallback(future, new FutureCallback<String>() {
              @Override
              public void onSuccess(String result) {
                resultFuture.set(content);
              }

              @Override
              public void onFailure(Throwable t) {
                if (t instanceof KeeperException.NodeExistsException) {
                  // If failed to create due to node exists, try to do getAndSet.
                  getAndSet(zkClient, path, modifier, codec, resultFuture, createAcl);
                } else {
                  resultFuture.setException(t);
                }
              }
            }, Threads.SAME_THREAD_EXECUTOR);
          } catch (Throwable t) {
            resultFuture.setException(t);
          }

        }

        @Override
        public void onFailure(Throwable t) {
          resultFuture.setException(t);
        }
      }, Threads.SAME_THREAD_EXECUTOR);
    } catch (Throwable e) {
      resultFuture.setException(e);
    }
  }

  private ZKExtOperations() {
  }
}

import co.cask.cdap.api.common.Bytes;
import co.cask.cdap.common.zookeeper.ZKExtOperations;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Maps;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Map;
import java.util.Set;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
public ResourceCoordinator(ZKClient zkClient,
    this.zkClient = zkClient;
    this.discoveryService = discoveryService;
    this.assignmentStrategy = assignmentStrategy;
    this.requirements = Maps.newHashMap();
    this.assignments = Maps.newHashMap();
    this.serviceDiscovered = Maps.newHashMap();
    this.discoverableListener = new DiscoverableChangeListener();
  }

public void onFailure(Throwable t) {
   * @param assignment The assignment to be persisted.
   */
  private void saveAssignment(ResourceAssignment assignment) {
    assignments.put(assignment.getName(), assignment);

    try {
      final byte[] data = CoordinationConstants.RESOURCE_ASSIGNMENT_CODEC.encode(assignment);
      String zkPath = CoordinationConstants.ASSIGNMENTS_PATH + "/" + assignment.getName();

      Futures.addCallback(
        ZKExtOperations.setOrCreate(zkClient, zkPath, data, assignment, CoordinationConstants.MAX_ZK_FAILURE_RETRY),
        new FutureCallback<ResourceAssignment>() {

          @Override
public void onFailure(Throwable t) {
      );
    } catch (Exception e) {
      // Something very wrong
      LOG.error("Failed to save assignment: {}", assignment.getName(), e);
    }
  }

import com.google.common.base.Function;
import com.google.common.base.Functions;
import com.google.common.base.Objects;
import com.google.common.base.Throwables;
import com.google.common.collect.LinkedHashMultimap;
import com.google.common.collect.Maps;
public ResourceCoordinatorClient(ZKClient zkClient) {
   *         {@link ListenableFuture#cancel(boolean)} has no effect.
   */
  public ListenableFuture<ResourceRequirement> submitRequirement(ResourceRequirement requirement) {
    try {
      String zkPath = CoordinationConstants.REQUIREMENTS_PATH + "/" + requirement.getName();
      byte[] data = CoordinationConstants.RESOURCE_REQUIREMENT_CODEC.encode(requirement);

      return ZKExtOperations.createOrSet(zkClient, zkPath, data,
                                         requirement, CoordinationConstants.MAX_ZK_FAILURE_RETRY);
    } catch (Exception e) {
      return Futures.immediateFailedFuture(e);
    }
  }

  /**
import co.cask.cdap.common.conf.PropertyUpdater;
import co.cask.cdap.common.io.Codec;
import co.cask.cdap.common.zookeeper.ZKExtOperations;
import com.google.common.collect.Sets;
import com.google.common.util.concurrent.FutureCallback;
import com.google.common.util.concurrent.Futures;
private ZKPropertyStore(ZKClient zkClient, Codec<T> codec) {

  @Override
  public ListenableFuture<T> set(String name, T property) {
    try {
      return ZKExtOperations.setOrCreate(zkClient, getPath(name),
                                         codec.encode(property), property, MAX_ZK_FAILURE_RETRIES);
    } catch (IOException e) {
      return Futures.immediateFailedFuture(e);
    }
  }

  @Override
/*
 * Copyright © 2014 Cask Data, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
import co.cask.cdap.api.common.Bytes;
import co.cask.cdap.common.io.Codec;
import com.google.common.base.Function;
import com.google.common.base.Throwables;
import org.apache.twill.internal.zookeeper.InMemoryZKServer;
import org.apache.twill.zookeeper.ZKClientService;
public Integer apply(@Nullable Integer input) {
    zkClient2.stopAndWait();
  }


  @AfterClass
  public static void finish() {
import co.cask.cdap.common.io.Codec;
import co.cask.cdap.common.zookeeper.ZKExtOperations;
import com.google.common.base.Preconditions;
import com.google.common.base.Throwables;
import com.google.common.cache.AbstractLoadingCache;
import com.google.common.collect.Maps;
public T getIfPresent(Object key) {
  public void put(final String name, final T instance) {
    final String znode = joinZNode(parentZnode, name);
    try {
      final byte[] encoded = codec.encode(instance);
      LOG.debug("Setting value for node {}", znode);
      ListenableFuture<String> future = ZKExtOperations.createOrSet(zookeeper, znode, encoded, znode,
                                                                    MAX_RETRIES, znodeACL);

      Futures.addCallback(future, new FutureCallback<String>() {
        @Override
        public void onSuccess(String result) {
          LOG.debug("Created or set node {}", znode);
          resources.put(name, instance);
        }

        @Override
public void onFailure(Throwable t) {
        }
      });

    } catch (IOException ioe) {
      throw Throwables.propagate(ioe);
    }
  }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public Controller() {
        // XXX When we move the SdnController stuff to a different bundle, this code should be
        // a part of the activator of that bundle.
        //
        // XXX When we start up a Karaf container that has netshell-controller already loaded,
        // there appears to be a (not yet well understood) race condition with the startup of the ODL
        // MD-SAL and ODL Corsa bundles.  The symptom is that SdnController doesn't get
        // PacketReceived notifications.  If we delay the instantiation of the SdnController object
        // by 20 seconds, this appears to let things settle down so that notifications work.
        try {
            Thread.sleep(20000);
        }
        catch (InterruptedException e) {
        }
        try {
            SdnController sdncont = new SdnController();
            sdncont.setCallback();
            Thread sdnthr = new Thread(sdncont);
            sdnthr.start();
        }
        catch (Exception e) {
            e.printStackTrace();
            logger.error("Unable to start SDNController instance");
        }
    }
    public static Controller getInstance() { return instance; }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.ThreadContext;
	 * Contains all client channels with an established connection.
	 */
	private final Map<UUID, Channel> clientChannels = new HashMap<UUID, Channel>();

	/**
	 * Set to true if the TCPConnectionManager is shutting down.
	 */
	private boolean shutdown = false;

	/**
	 * Lock used for synchronizing access to {@link #serverChannels}, {@link #clientChannels},
	 * {@link #unconnectedChannels} and {@link #shutdown}.
	 */
	private final ReadWriteLock channelsLock = new ReentrantReadWriteLock();
public void handleMessage(ChannelHandlerContext ctx,
			if (localUUID.compareTo(remoteUUID) < 0) {
				boolean establish = false;
				channelsLock.readLock().lock();
				if (!clientChannels.containsKey(remoteUUID)) {
					channelsLock.readLock().unlock();
					channelsLock.writeLock().lock();
					if (!clientChannels.containsKey(remoteUUID)) {
						clientChannels.put(remoteUUID, ctx.channel());
						establish = true;
					}
					channelsLock.readLock().lock();
public void handleMessage(ChannelHandlerContext ctx,
				channelsLock.readLock().unlock();
				if (establish) {
					ctx.write(new ConnectionEstablishedMessage());
					notifyEstablished(remoteUUID);
				} else {
					LOGGER.debug("we already have a connection, closing");
					ctx.write(new ConnectionClosedMessage());
public void handleMessage(ChannelHandlerContext ctx, ConnectionEstablishedMessag
				return;
			}
			if (localUUID.compareTo(remoteUUID) < 0) {
				LOGGER.warn("got {} but the other module has a higher UUID", msg);
				LOGGER.exit();
				return;
			}
			channelsLock.writeLock().lock();
			final Channel channel = clientChannels.get(remoteUUID);
			if (channel != null && !channel.equals(ctx.channel())) {
				LOGGER.info("got {} but there is already another connection ({}), closing that");
				unconnectedChannels.remove(channel);
				channel.close();
			}
			clientChannels.put(remoteUUID, ctx.channel());
			channelsLock.writeLock().unlock();
			notifyEstablished(remoteUUID);
			LOGGER.exit();
		}
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public String toString() {
     */
    private static final class Loader<SVC> implements Iterable<SVC> {
        private final Class<SVC> serviceType;
        private final Iterable<SVC> delegate;

        @SuppressWarnings("unchecked") // Type is actually safe, although we use reflection.
        private Loader(Class<SVC> serviceType) {
            this.serviceType = serviceType;
            Iterable<SVC> serviceLoader = null;
            try { // Attempt to use Java 1.6 ServiceLoader:
                // ServiceLoader.load(ContextManager.class, ContextManagers.class.getClassLoader());
                serviceLoader = (Iterable<SVC>) Class.forName("java.util.ServiceLoader")
                        .getDeclaredMethod("load", Class.class, ClassLoader.class)
                        .invoke(null, serviceType, serviceType.getClassLoader());
            } catch (ClassNotFoundException cnfe) {
                LOGGER.log(Level.FINEST, "Java 6 ServiceLoader not found, falling back to the imageio ServiceRegistry.");
            } catch (NoSuchMethodException nsme) {
                LOGGER.log(Level.SEVERE, "Could not find the 'load' method in the JDK's ServiceLoader.", nsme);
            } catch (IllegalAccessException iae) {
                LOGGER.log(Level.SEVERE, "Not allowed to call the 'load' method in the JDK's ServiceLoader.", iae);
            } catch (InvocationTargetException ite) {
                throw new IllegalStateException(String.format(
                        "Exception calling the 'load' method in the JDK's ServiceLoader for the %!s(MISSING) service.",
                        serviceType.getSimpleName()), ite.getCause());
            }
            this.delegate = serviceLoader;
        }

        public Iterator<SVC> iterator() {
            return delegate != null ? delegate.iterator()
                    : ServiceRegistry.lookupProviders(serviceType, serviceType.getClassLoader());
        }
    }
}
import nl.talsmasoftware.context.executors.ContextAwareExecutorService;
import org.junit.Test;

import java.util.concurrent.*;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.Matchers.nullValue;

/**
public String call() throws Exception {
        ctx1.close();
    }

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public Population(final List<T> population) {
        return subpopulations[i];
    }
    
    public void setSubpopulation(final int i, final List<T> population) {
        assert(i >= 0);
        assert(i < subpopulations.length);
        assert(population != null);
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.logging.Level;
import java.util.logging.Logger;

public EvolutionResult evolve(final int run) {
                // Execute each island in parallel
                // FIXME This is causing race conditions.
                final Collection<Callable<Void>> tasks = new ArrayList<>(topology.numIslands());
                for (int i = 0; i < topology.numIslands(); i++)
                    tasks.add(new HeterogeneousIslandModelCircleOfLife.IslandStepper(run, step, islands.get(i), population));
                try {
                    executor.invokeAll(tasks);
                } catch (final InterruptedException ex) {
                    Logger.getLogger(HeterogeneousIslandModelCircleOfLife.class.getName()).log(Level.SEVERE, null, ex);
                }

public EvolutionResult evolve(final int run) {
            return new EvolutionResult<>(population, bestSoFarInds, getFitnesses(bestSoFarInds));
    }
    
    private List<T> getBestsOfStep(final Population<T> population) {
        return new ArrayList<T>() {{
           for (int i = 0; i < population.numSuppopulations(); i++)
public EvolutionResult evolve(final int run) {
                add(ind.getFitness());
        }};
    }

    /** Flush I/O buffers. */
    private void flushMetrics() {
        if (metrics.isDefined())
public void step(final int run, final int step, final Population<T> population)
            // Apply operators
            for (final Operator<T> gen : operators) {
                final List<T> newSubpop = gen.operate(run, step, population.getSubpopulation(islandID));
                synchronized (population) {
                    population.setSubpopulation(islandID, newSubpop);
                }
            }
            
            if (isDynamic)
public final boolean repOK() {
                && !islands.isEmpty()
                && !Misc.containsNulls(islands);
    }

    @Override
    public boolean equals(final Object o) {
        if (this == o)
private void migrate(final int sourcePopIndex, final int targetPopIndex, final P
        final int targetIndex = replacementSelector.selectIndividualIndex(targetPop);
        final T targetInd = targetPop.get(targetIndex);
        if (alwaysReplace || fitnessComparator.get().betterThan(sourceInd, targetInd))
            targetPop.set(targetIndex, sourceInd);
    }

    // <editor-fold defaultstate="collapsed" desc="Standard Methods">
import SigmaEC.util.Parameters;
import java.util.ArrayList;
import java.util.List;

/**
 * Takes a population of LinearGenomeIndividuals and mutates individual genes
public class PerGeneMutatingOperator<T extends LinearGenomeIndividual<G>, G extends Gene> extends MutatingOperator<T> {
    public final static String P_MUTATOR = "mutator";
    public final static String P_OVERLAP_STYLE = "overlapStyle";
    
    public static enum OverlapStyle { COMMA, PLUS };
    private final OverlapStyle overlapStyle;
    
    private final Mutator<T, G> mutator;
    private final Selector<T> parentSelector = new IterativeSelector<T>();
    
    public PerGeneMutatingOperator(final Parameters parameters, final String base) {
        assert(parameters != null);
        assert(base != null);
        this.mutator = parameters.getInstanceFromParameter(Parameters.push(base, P_MUTATOR), Mutator.class);
        overlapStyle = OverlapStyle.valueOf(parameters.getOptionalStringParameter(Parameters.push(base, P_OVERLAP_STYLE), OverlapStyle.COMMA.toString()));
        assert(repOK());
    }

    @Override
    public List<T> operate(final int run, final int generation, final List<T> parentPopulation) {
        final List<T> newPopulation = new ArrayList<T>(parentPopulation.size());
        for(int i = 0; i < parentPopulation.size(); i++) {
            final T individual = parentSelector.selectIndividual(parentPopulation);
            newPopulation.add(operateInd(individual));
        }
        switch (overlapStyle) {
            case COMMA:
                return newPopulation;
            case PLUS:
                parentPopulation.addAll(newPopulation);
                return parentPopulation;
            default:
                throw new IllegalStateException("Unrecognized overlap style encountered.");
        }
public T operateInd(final T ind) {
    // <editor-fold defaultstate="collapsed" desc="Standard Methods">
    @Override
    final public boolean repOK() {
        return mutator != null
                && parentSelector != null;
    }
    
    @Override
    public String toString() {
        return String.format("[%!s(MISSING): parentSelector=%!s(MISSING), mutator=%!s(MISSING)", this.getClass().getSimpleName(), parentSelector, mutator);
    }
    
    @Override
public boolean equals(final Object o) {
        if (!(o instanceof PerGeneMutatingOperator))
            return false;
        
        final PerGeneMutatingOperator cRef = (PerGeneMutatingOperator) o;
        return mutator.equals(cRef.mutator)
                && parentSelector.equals(cRef.parentSelector);
    }

    @Override
    public int hashCode() {
        int hash = 5;
        hash = 59 * hash + (this.mutator != null ? this.mutator.hashCode() : 0);
        hash = 59 * hash + (this.parentSelector != null ? this.parentSelector.hashCode() : 0);
        return hash;
    }
    //</editor-fold>
 */
public class SelectionOperator<T extends Individual> extends Operator<T> {
    public final static String P_SELECTOR = "selector";
    public final static String P_CHILD_POP_SIZE = "childPopSize";
    
    private final Selector<T> selector;
    private final Option<Integer> childPopSize;
    
    public SelectionOperator(final Parameters parameters, final String base) {
        assert(parameters != null);
        assert(base != null);
        selector = parameters.getInstanceFromParameter(Parameters.push(base, P_SELECTOR), Selector.class);
        childPopSize = parameters.getOptionalIntParameter(Parameters.push(base, P_CHILD_POP_SIZE));
        assert(repOK());
    }
    
    @Override
    public List<T> operate(final int run, final int generation, final List<T> population) {
        assert(population != null);
        assert(repOK());
        return selector.selectMultipleIndividuals(population, childPopSize.isDefined() ? childPopSize.get() : population.size());
    }

    // <editor-fold defaultstate="collapsed" desc="Standard Methods">
public static double mean(double[] values) {
    public static double std(double[] values, double mean) {
        assert(Misc.doubleEquals(mean, mean(values)));
        assert(values != null);
        double sum = 0;
        for (int i = 0; i < values.length; i++)
            sum += Math.pow(values[i] - mean, 2);
public static double std(double[] values, double mean) {

    /** Sample standard deviation (with Bessel's correction). */
    public static double std(double[] values) {
        return std(values, mean(values));
    }
    
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            <action issue="53" dev="dadoonet" type="update">
                Update to Elasticsearch 1.4.0.
            </action>
        </release>

        <release date="2014-02-14" description="August 2014 Release" version="1.3.0">
public Client call() throws Exception {

	private Client initialize() throws Exception {
		client = buildClient();
		if (autoscan) {
			computeMappings();
		}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  private final UUID client;
  private final LogCleaner cleaner;
  private final ServerStateMachineContext context;
  private volatile State state = State.CLOSED;
  private final long timeout;
  private Connection connection;
  private Address address;
public UUID client() {
   * Opens the session.
   */
  void open() {
    setState(State.OPEN);
  }

  @Override
public Session publish(String event) {

  @Override
  public Session publish(String event, Object message) {
    Assert.stateNot(state == State.CLOSED, "session is closed");
    Assert.stateNot(state == State.EXPIRED, "session is expired");
    Assert.state(context.consistency() != null, "session events can only be published during command execution");
else if (!session.state().active()) {
      executor.executor().execute(() -> keepAliveSession(index, timestamp, commandSequence, eventIndex, session, future, context));

      // Update the session keep alive index for log cleaning.
      session.setKeepAliveIndex(entry.getIndex());
    }

    return future;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void propertyChange(PropertyChangeEvent evt) {
    private SwingWorker<IContextMapping<INode>, IMappingElement<INode>> createMatchTask() {
        final SwingWorker<Void, Void> sourcePreprocess;
        final SwingWorker<Void, Void> targetPreprocess;
        if (!source.getRoot().nodeData().isSubtreePreprocessed()) {
            sourcePreprocess = createContextOfflineTask(source, semSource, pbSourceProgress, true);
        } else {
            sourcePreprocess = null;
        }
        if (!target.getRoot().nodeData().isSubtreePreprocessed()) {
            targetPreprocess = createContextOfflineTask(target, semTarget, pbTargetProgress, false);
        } else {
            targetPreprocess = null;
        }

        // prepare the match task
        pbProgress.setIndeterminate(true);
public void propertyChange(PropertyChangeEvent evt) {
        } else {
            matchTask = null;
        }
        SwingWorker<IContextMapping<INode>, IMappingElement<INode>> task =
                new SwingWorker<IContextMapping<INode>, IMappingElement<INode>>() {
                    @Override
                    public IContextMapping<INode> doInBackground() throws Exception {
                        if (null != sourcePreprocess) {
                            sourcePreprocess.execute();
                        }
                        if (null != targetPreprocess) {
                            targetPreprocess.execute();
                        }
                        if (null != sourcePreprocess) {
                            sourcePreprocess.get();
                        }
                        if (null != targetPreprocess) {
                            targetPreprocess.get();
                        }

                        semManager.acquire();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void run() {
            }
            log.info(id + ": Crawling " + this.name);
            Elements anchors = doc.select("a");
            ArrayList<URL> unseenLinks = filterUnseen(anchors);
            log.info(id + ": Found " + unseenLinks.size() + " new links on page");
            for (URL u : unseenLinks) {
                if (u != null && !this.pages.containsKey(u)) {
                    if (this.depth_limit > this.webpage.getDepth()) {
                        WebPage w = new WebPage(this.webpage, u);
                        w.setDepth(this.webpage.getDepth() + 1);
                        this.pages.put(u, w);
                    }
                }
            }
            this.webpage.setStatus(200);
private boolean shouldCrawlPage() {
        return this.webpage.getUrl().getHost().equals(base.getHost());
    }

    private ArrayList<URL> filterUnseen(Elements anchors) {
        ArrayList<URL> res = new ArrayList<>();
        for (Element a : anchors) {
            URL u = parseUrl(a.attr("abs:href"));
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
angular.module(PKG.name + '.services')
              }, 2000)();

    }
    function success() {
      EventPipe.emit('backendUp');
      startPolling();
function makeApp (authAddress, cdapConfig) {
          rejectUnauthorized: false,
          requestCert: true,
          agent: false
        }, function(err) {
          if (!err) {
            res.status(200).send();
          } else {
            res.status(404).send();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
protected void configure() {
        serviceBinder.addBinding().to(MetricsReporterService.class);
        serviceBinder.addBinding().to(DashboardRegistryService.class);
        serviceBinder.addBinding().to(ProcessBufferService.class);
        serviceBinder.addBinding().to(DeflectorSetupService.class);
        serviceBinder.addBinding().to(IndexerSetupService.class);
        serviceBinder.addBinding().to(BufferSynchronizerService.class);
        serviceBinder.addBinding().to(OutputSetupService.class);
/*
 * Copyright 2012-2014 TORCH GmbH
 *
 * This file is part of Graylog2.
 *
 * Graylog2 is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Graylog2 is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Graylog2.  If not, see <http://www.gnu.org/licenses/>.
 */

package org.graylog2.initializers;

import com.google.common.util.concurrent.AbstractIdleService;
import org.graylog2.indexer.Deflector;
import org.graylog2.indexer.Indexer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;
import javax.inject.Singleton;

/**
 * @author Dennis Oelkers <dennis@torch.sh>
 */
@Singleton
public class DeflectorSetupService extends AbstractIdleService {
    private static final Logger LOG = LoggerFactory.getLogger(DeflectorSetupService.class);
    private final Deflector deflector;
    private final Indexer indexer;
    private final IndexerSetupService indexerSetupService;

    @Inject
    public DeflectorSetupService(Deflector deflector,
                                 Indexer indexer,
                                 IndexerSetupService indexerSetupService) {
        this.deflector = deflector;
        this.indexer = indexer;
        this.indexerSetupService = indexerSetupService;
    }

    @Override
    protected void startUp() throws Exception {
        if (indexerSetupService.isRunning()) {
            // Set up deflector.
            LOG.info("Setting up deflector.");
            deflector.setUp(indexer);
        }
    }

    @Override
    protected void shutDown() throws Exception {
    }
}

import com.google.common.util.concurrent.AbstractIdleService;
import com.google.inject.Singleton;
import org.graylog2.indexer.Indexer;
import org.graylog2.plugin.Tools;
import org.slf4j.Logger;
    private static final Logger LOG = LoggerFactory.getLogger(IndexerSetupService.class);

    private final Indexer indexer;
    private final BufferSynchronizerService bufferSynchronizerService;

    @Inject
    public IndexerSetupService(Indexer indexer, BufferSynchronizerService bufferSynchronizerService) {
        this.indexer = indexer;
        this.bufferSynchronizerService = bufferSynchronizerService;

        // Shutdown after the BufferSynchronizerServer has stopped to avoid shutting down ES too early.
public void terminated(State from) {
    @Override
    protected void startUp() throws Exception {
        Tools.silenceUncaughtExceptionsInThisThread();
        try {
            indexer.start();
        } catch (Exception e) {
            bufferSynchronizerService.setIndexerUnavailable();
            throw e;
        }
    }

    @Override
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private RangeProducer(Subscriber<? super Integer> o, int start, int end) {

        @Override
        public void request(long n) {
            if (REQUESTED_UPDATER.get(this) == Long.MAX_VALUE) {
                // already started with fast-path
                return;
            }
            if (n == Long.MAX_VALUE) {
                REQUESTED_UPDATER.set(this, n);
                // fast-path without backpressure
                for (long i = index; i <= end; i++) {
                    if (o.isUnsubscribed()) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public class QuestionsActivity extends ActivityWithDrawer implements QuestionFragment.OnFragmentActivityChatter, LoaderManager.LoaderCallbacks<Cursor> {
    private static final boolean DEBUG = true;
    private ViewPager mPager;
    private final int QUIZ_SIZE = 280;
    private int mRightAnswered = 0;
    private static final int QUESTION_LOADER = 0;
    private QuestionsPagerAdapter mPagerAdapter;
package doit.study.droid;

import android.content.ContentProviderOperation;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.graphics.Canvas;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;
import android.os.RemoteException;
import android.support.v4.app.LoaderManager;
private void setSelectionToAllTags(boolean checked){
        mTopicAdapter.notifyDataSetChanged();
    }

//    @Override
//    protected void onPause() {
//        new Thread(){
//            @Override
//            public void run() {
//                Uri uri = QuizProvider.TAG_URI;
//                StringBuilder selected = new StringBuilder();
//                StringBuilder unselected = new StringBuilder();
//                ContentValues contentValuesSelected = new ContentValues();
//                contentValuesSelected.put(Tag.Table.SELECTED, 1);
//                ContentValues contentValuesUnselected = new ContentValues();
//                contentValuesUnselected.put(Tag.Table.SELECTED, 0);
//                for (Tag tag: mTopicAdapter.getTags()) {
//                    if (tag.getSelectionStatus()) {
//                        if (selected.length() != 0)
//                            selected.append(" OR ");
//                        selected.append(Tag.Table._ID).append(" = ").append(tag.getId());
//                    }
//                    else {
//                        if (unselected.length() != 0)
//                            unselected.append(" OR ");
//                        unselected.append(Tag.Table._ID).append(" = ").append(tag.getId());
//                    }
//                }
//                getContentResolver().update(uri, contentValuesSelected, selected.toString(), null);
//                getContentResolver().update(uri, contentValuesUnselected, unselected.toString(), null);
//            }
//        }.start();
//        super.onPause();
//    }


    @Override
    protected void onPause() {
        new Thread(){
            @Override
            public void run() {
                ArrayList<ContentProviderOperation> ops = new ArrayList<>();
                ContentProviderOperation.Builder builder;
                for (Tag tag: mTopicAdapter.getTags()) {
                    builder = ContentProviderOperation.newUpdate(QuizProvider.TAG_URI);
                    builder.withValue(Tag.Table.SELECTED, tag.getSelectionStatus());
                    builder.withSelection(Tag.Table._ID + " = " + tag.getId(), null);
                    ops.add(builder.build());
                }
                try {
                    getContentResolver().applyBatch(QuizProvider.AUTHORITY, ops);
                    getContentResolver().notifyChange(QuizProvider.TAG_URI, null);
                    getContentResolver().notifyChange(QuizProvider.QUESTION_URI, null);
                } catch (RemoteException e) {
                    e.printStackTrace();
                } catch (OperationApplicationException e) {
                    e.printStackTrace();
                }
            }
        }.start();
        super.onPause();
    }

    @Override
    public Loader<Cursor> onCreateLoader(int id, Bundle args) {
        switch(id){
public void swapCursor(Cursor newCursor) {
            mCursor = newCursor;
            notifyDataSetChanged();
        }

        public Cursor getCursor() {
            return mCursor;
        }
    }

    private static class DividerItemDecoration extends RecyclerView.ItemDecoration {

        private final int[] ATTRS = new int[]{android.R.attr.listDivider};
package doit.study.droid.data;

import android.content.ContentProvider;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.UriMatcher;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteQueryBuilder;
import android.net.Uri;
import android.support.annotation.Nullable;

import timber.log.Timber;

public class QuizProvider extends ContentProvider {
    private static final boolean DEBUG = true;

    public static final String AUTHORITY = "doit.study.droid";
    public static final Uri BASE_URI = Uri.parse("content://" + AUTHORITY);
    static {
        sQuizQueryBuilder = new SQLiteQueryBuilder();

        //This is an inner join which looks like
        //weather INNER JOIN location ON weather.location_id = location._id
        sQuizQueryBuilder.setTables(
                Question.Table.NAME +
                        " INNER JOIN " + RelationTables.QuestionTag.NAME +
        );
    }

    @Override
    public boolean onCreate() {
        mQuizDBHelper = new QuizDBHelper(getContext());
public int update(Uri uri, ContentValues values, String selection, String[] sele
            case (TAG_DIR):{
                int mod = db.update(Tag.Table.NAME, values, selection, selectionArgs);
                if (DEBUG) Timber.d("update db: %!s(MISSING) %!s(MISSING)", values, selection);
                getContext().getContentResolver().notifyChange(uri, null);
                return mod;
            }
        }
public int delete(Uri uri, String selection, String[] selectionArgs) {

    private Cursor getRandSelectedQuestions(Uri uri, String[] projection) {
        String limit = uri.getPathSegments().get(2);
        SQLiteDatabase db = mQuizDBHelper.getReadableDatabase();
        String selection = Tag.Table.NAME + "." + Tag.Table.SELECTED + " = 1";
        String sortOrder = "RANDOM()";
        return sQuizQueryBuilder.query(db, projection, selection, null, null, null, sortOrder, limit);
private Cursor getRandSelectedQuestions(Uri uri, String[] projection) {

    private Cursor getTags() {
        // authority/tag/
        SQLiteDatabase db = mQuizDBHelper.getReadableDatabase();
        String tagTotalCounter = "COUNT(" + Tag.Table.FQ_TEXT + ") as " + Tag.Table.TOTAL_COUNTER;
        String tagStudiedCounter = "SUM(" + Question.Table.FQ_STATUS + "=" + Tag.Table.QTY_WHEN_STUDIED + ") as " +
                Tag.Table.STUDIED_COUNTER;
private Cursor getTags() {
    }

    private Cursor getQuestions(Uri uri, String [] projection){
        SQLiteDatabase db = mQuizDBHelper.getReadableDatabase();
        return db.query(Question.Table.NAME, projection, null, null, null, null, null);
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import com.google.common.util.concurrent.FutureCallback;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import org.apache.twill.common.Threads;
import org.apache.twill.zookeeper.NodeChildren;
import org.apache.twill.zookeeper.NodeData;
public void put(final String name, final T instance) {
    final String znode = joinZNode(parentZnode, name);
    try {
      LOG.debug("Setting value for node {}", znode);
      ListenableFuture<T> future = ZKExtOperations.createOrSet(zookeeper, znode, Suppliers.ofInstance(instance),
                                                               codec, MAX_RETRIES, znodeACL);

      Futures.addCallback(future, new FutureCallback<T>() {
        @Override
        public void onSuccess(T result) {
          LOG.debug("Created or set node {}", znode);
          resources.put(name, result);
        }

        @Override
        public void onFailure(Throwable t) {
          LOG.error("Failed to set value for node {}", znode, t);
          listeners.notifyError(name, t);
        }
      });

      // Block until it is done
      future.get();

    } catch (Exception ioe) {
      throw Throwables.propagate(ioe);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
protected void init() {
            if (configuration.getEmbeddingClass() == null) {
                configuration.setEmbeddingClass(computation.getEmbeddingClass());
            }
            computation.initAggregations();
        }

        computation.init();
public static void set(Configuration configuration) {
    public Configuration(ImmutableClassesGiraphConfiguration giraphConfiguration) {
        this.giraphConfiguration = giraphConfiguration;

        useCompressedCaches = getBoolean(CONF_COMPRESSED_CACHES, CONF_COMPRESSED_CACHES_DEFAULT);
        cacheThresholdSize = getInteger(CONF_CACHE_THRESHOLD_SIZE, CONF_CACHE_THRESHOLD_SIZE_DEFAULT);
        infoPeriod = getLong(INFO_PERIOD, INFO_PERIOD_DEFAULT);
public void initialize() {
            return;
        }

        initialized = true;
        OptimizationSetDescriptor optimizationSetDescriptor = ReflectionUtils.newInstance(optimizationSetDescriptorClass);
        LOG.info("Initializing configuration");
        OptimizationSet optimizationSet = optimizationSetDescriptor.describe();

        LOG.info("Active optimizations: " + optimizationSet);
public void initialize() {
        mainGraph = createGraph();

        optimizationSet.applyAfterGraphLoad();
    }

    public ImmutableClassesGiraphConfiguration getUnderlyingConfiguration() {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

package org.wildfly.extension.camel.undertow;

import java.net.InetAddress;
import java.net.MalformedURLException;
import java.net.URI;
import org.jboss.gravia.runtime.ModuleContext;
import org.jboss.gravia.runtime.Runtime;
import org.jboss.gravia.runtime.ServiceRegistration;
import org.jboss.gravia.utils.IllegalStateAssertion;
import org.jboss.msc.service.AbstractService;
import org.jboss.msc.service.ServiceBuilder;
import org.jboss.msc.service.ServiceController;
    private UndertowEventListener eventListener;
    private UndertowHost undertowHost;

    public static ServiceController<UndertowHost> addService(ServiceTarget serviceTarget, SubsystemRuntimeState runtimeState) {
        CamelUndertowHostService service = new CamelUndertowHostService(runtimeState);
        ServiceBuilder<UndertowHost> builder = serviceTarget.addService(SERVICE_NAME, service);
public void start(StartContext startContext) throws StartException {
    }

    private URL getConnectionURL() throws StartException {
        SocketBinding socketBinding = injectedHttpSocketBinding.getValue();
        InetAddress address = socketBinding.getNetworkInterfaceBinding().getAddress();

        /* Derive the address from network interfaces
        if (address.getHostAddress().equals("127.0.0.1")) {
            InetAddress derived = null;
            try {
                List<NetworkInterface> nets = Collections.list(NetworkInterface.getNetworkInterfaces());
                for (int i = 0; derived == null && i < nets.size(); i++) {
                    for (InetAddress aux : Collections.list(nets.get(i).getInetAddresses())) {
                        if (!aux.getHostAddress().equals("127.0.0.1")) {
                            derived = aux;
                            break;
                        }
                    }
                }
            } catch (SocketException ex) {
                throw new StartException(ex);
            }
            IllegalStateAssertion.assertNotNull(derived, "Cannot derive internet address from interfaces");
            address = derived;
        }
        */

        URL result;
        try {
            String hostAddress = NetworkUtils.formatPossibleIpv6Address(address.getHostAddress());
public void validateEndpointURI(URI httpURI) {
                    }
                }
            }

            IllegalStateAssertion.assertEquals("localhost", httpURI.getHost(), "Cannot bind to host other than 'localhost': " + httpURI);
            IllegalStateAssertion.assertTrue(portMatched, "Cannot bind to specific port: " + httpURI);
        }

        @Override
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
final boolean tryMatchData() {
        }

        boolean lease() {
            if (sa == null)
                return true;
            return sa.lease();
        }

        void returnLease() {
            if (sa != null)
                sa.returnLease();
        }

        void won() {
            if (sa != null) {
                Object x = item;
                sa.setItem(x == CHANNEL_CLOSED ? null : x);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import com.nordnetab.chcp.main.utils.Paths;
import com.nordnetab.chcp.main.utils.VersionHelper;

import org.apache.cordova.CallbackContext;
import org.apache.cordova.ConfigXmlParser;
import org.apache.cordova.CordovaArgs;
private void installUpdate(CallbackContext jsCallback) {
            installJsCallback = jsCallback;
        }

        UpdatesInstaller.install(fileStructure);
    }

    // endregion
private void redirectToLocalStorage() {
        currentUrl = currentUrl.replace(LOCAL_ASSETS_FOLDER, "");
        String external = Paths.get(fileStructure.wwwFolder(), currentUrl);
        if (!new File(external).exists()) {
            return;
        }

public void onEvent(NothingToUpdateEvent event) {
    @SuppressWarnings("unused")
    public void onEvent(UpdateDownloadErrorEvent event) {
        Log.d("CHCP", "Failed to update");

        PluginResult jsResult = PluginResultHelper.pluginResultFromEvent(event);

public void onEvent(UpdateDownloadErrorEvent event) {
    public void onEvent(UpdateInstalledEvent event) {
        Log.d("CHCP", "Update is installed");

        final PluginResult jsResult = PluginResultHelper.pluginResultFromEvent(event);

        if (installJsCallback != null) {
private void resetApplicationToStartingPage() {
            public void run() {
                webView.clearHistory();
                webView.clearCache();
                final String startingPage = getStartingPage() + "?" + System.currentTimeMillis();
                final String externalStartingPage = FILE_PREFIX + Paths.get(fileStructure.wwwFolder(), startingPage);
                webView.loadUrlIntoView(externalStartingPage, false);
            }
        });
public static boolean isInstalling() {
    }

    private static void execute(final InstallationWorker task) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                isInstalling = true;
                task.run();
                isInstalling = false;
            }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileFilter;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
private String getSDName(String config){
      return SERVICE_DISCOVERY_PREFIX + splitted[0].substring(2, splitted[0].length());
    }

    public boolean processServiceDiscovery(byte[] buffer) {
      boolean reinit = false;
      String[] discovered;
void start() {
        long delta_s = 0;
        FileInputStream sdPipe = null;

        try {
          sdPipe = new FileInputStream(appConfig.getServiceDiscoveryPipe()); //Should we use RandomAccessFile?
        } catch (FileNotFoundException e) {
          LOGGER.warn("Unable to open named pipe - Service Discovery disabled.");
          sdPipe = null;
        }

        while (true) {
void start() {
            }

            // any SD configs waiting in pipe?
            try {
              if(sdPipe != null && sdPipe.available() > 0) {
                int len = sdPipe.available();
                byte[] buffer = new byte[len];
                sdPipe.read(buffer);
                setReinit(processServiceDiscovery(buffer));
              }
            } catch(IOException e) {
              LOGGER.warn("Unable to read from pipe - Service Discovery configuration may have been skipped.");
            }
            required = false)
    private int checkPeriod = 15000;

    @Parameter(names = {"--sd_standby", "-w"},
            description = "Service Discovery standby.",
            required = false)
    private boolean sdStandby = false;

    @Parameter(names = {"--sd_pipe", "-S"},
            description = "Service Discovery pipe name.",
public int getCheckPeriod() {
        return checkPeriod;
    }

    public boolean getSDStandby() {
        return sdStandby;
    }

    public Reporter getReporter() {
protected void initApplication(String yamlFileName, String serviceDiscoveryPipeF
        if (sdEnabled) {
            params.add(4, "--tmp_directory");
            params.add(5, "/foo"); //could be anything we're stubbing it out
        }
        new JCommander(appConfig, params.toArray(new String[params.size()]));

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
     */
    public void removeEventListener(EventListener listener, String uei);


}
public void setHandlerQueueLength(int size) {
        Assert.state(m_eventHandlerPool == null, "handlerQueueLength property cannot be set after afterPropertiesSet() is called");
        m_handlerQueueLength = size;
    }
}
package org.opennms.minion.heartbeat.consumer;

import com.google.common.collect.Sets;
import org.opennms.core.ipc.sink.api.MessageConsumer;
import org.opennms.core.ipc.sink.api.MessageConsumerManager;
import org.opennms.core.ipc.sink.api.SinkModule;
import org.opennms.netmgt.events.api.EventConstants;
import org.opennms.netmgt.events.api.EventProxy;
import org.opennms.netmgt.events.api.EventProxyException;
import org.opennms.netmgt.model.events.EventBuilder;
import org.opennms.netmgt.model.minion.OnmsMinion;
import org.opennms.netmgt.provision.persist.ForeignSourceRepository;

    @Autowired
    @Qualifier("eventProxy")
    private EventProxy m_eventProxy;

    @Override
    @Transactional
public void handleMessage(MinionIdentityDTO minionHandle) {
        if (minion == null) {
            minion = new OnmsMinion();
            minion.setId(minionHandle.getId());
        }

        String prevLocation = minion.getLocation();
        String nextLocation = minionHandle.getLocation();

        minion.setLocation(minionHandle.getLocation());

public void handleMessage(MinionIdentityDTO minionHandle) {
    private void provision(final OnmsMinion minion,
                           final String prevLocation,
                           final String nextLocation) {
        if (!PROVISIONING) {
            return;
        }

        final String prevForeignSource = String.format(PROVISIONING_FOREIGN_SOURCE_PATTERN, prevLocation);
        final String nextForeignSource = String.format(PROVISIONING_FOREIGN_SOURCE_PATTERN, nextLocation);

private void provision(final OnmsMinion minion,
            final Requisition prevRequisition = this.deployedForeignSourceRepository.getRequisition(prevForeignSource);
            if (prevRequisition != null && prevRequisition.getNode(minion.getId()) != null) {
                prevRequisition.deleteNode(minion.getId());
                prevRequisition.setDate(new Date());

                deployedForeignSourceRepository.save(prevRequisition);
                deployedForeignSourceRepository.flush();
private void provision(final OnmsMinion minion,
        Requisition nextRequisition = deployedForeignSourceRepository.getRequisition(nextForeignSource);
        if (nextRequisition == null) {
            nextRequisition = new Requisition(nextForeignSource);
            nextRequisition.setDate(new Date());

            // We have to save the requisition before we can alter the according foreign source definition
            deployedForeignSourceRepository.save(nextRequisition);
private void provision(final OnmsMinion minion,
            eventBuilder.addParam(EventConstants.PARM_URL, String.valueOf(deployedForeignSourceRepository.getRequisitionURL(alteredForeignSource)));

            try {
                m_eventProxy.send(eventBuilder.getEvent());
            } catch (final EventProxyException e) {
                throw new DataAccessResourceFailureException("Unable to send event to import group " + alteredForeignSource, e);
            }
public void send(final Log eventLog) throws EventProxyException {
        sendNow(eventLog);
    }

}
public void minionHeartBeatTestForLastUpdated() {

		// The heartbeat runs every minute so if we miss the first one, poll long enough
		// to catch the next one
		await().atMost(900, SECONDS)
			   .pollInterval(5, SECONDS)
			   .until(DaoUtils.countMatchingCallable(minionDao,
													 new CriteriaBuilder(OnmsMinion.class).ge("lastUpdated", startOfTest).toCriteria()),
					  greaterThan(0));

		/* Ignoring due to NMS-8735
		await().atMost(90, SECONDS)
			   .pollInterval(5, SECONDS)
			   .until(DaoUtils.countMatchingCallable(nodeDao,
													 new CriteriaBuilder(OnmsNode.class).eq("foreignSource", "Minions")
public void minionHeartBeatTestForLastUpdated() {
					  equalTo(1));

		Assert.assertEquals("MINION", nodeDao.get("Minions:00000000-0000-0000-0000-000000ddba11").getLocation().getLocationName());
	    */
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public boolean exists(Serializable id, Class<?> type) {
			AerospikePersistentEntity<?> entity = mappingContext.getPersistentEntity(type);
			Key key = getKey(id, entity);

			Record record = this.client.get(null, key);
			if (record != null && entity.isTouchOnRead()) {
				Assert.state(!entity.hasExpirationProperty(), "Touch on read is not supported for expiration property");
				record = getAndTouch(key, record, entity.getExpiration());
			}
			return mapToEntity(key, type, record);
		}
		catch (AerospikeException e) {
			DataAccessException translatedException = exceptionTranslator.translateExceptionIfPossible(e);
			throw translatedException == null ? e : translatedException;
		}
	}

	private Record getAndTouch(Key key, Record record, int expiration) {
		WritePolicy writePolicy = new WritePolicy(client.writePolicyDefault);
		writePolicy.expiration = expiration;

		Record touched = this.client.operate(writePolicy, key, Operation.touch(), Operation.getHeader());
		return new Record(record.bins, touched.generation, touched.expiration);
	}

	@Override
package org.springframework.data.aerospike;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.*;

public class AsyncUtils {

	public static void executeConcurrently(int numThreads, Callable<Void> task) throws Exception {
		ExecutorService pool = Executors.newFixedThreadPool(numThreads);

		try {
			Collection<Callable<Void>> tasks = Collections.nCopies(numThreads, task);

			List<Future<Void>> futures = pool.invokeAll(tasks);
			for (Future future : futures) {
				future.get(5, TimeUnit.SECONDS);
			}
		} finally {
			pool.shutdownNow();
		}

	}
}
public User convert(AerospikeReadData source) {

		@Id
		private String id;
		@Version
		private long version;

		@PersistenceConstructor
		public DocumentWithTouchOnRead(String id) {
			this.id = id;
		}
	}

import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataRetrievalFailureException;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.dao.OptimisticLockingFailureException;
public void shouldUpdateAlreadyExistingDocument() throws Exception {
                } catch (OptimisticLockingFailureException e) {
                }
            }
            return null;
        });

		VersionedClass actual = template.findById(id, VersionedClass.class);
public void shouldSaveOnlyFirstDocumentAndNextAttemptsShouldFailWithOptimisticLo
            } catch (OptimisticLockingFailureException e) {
                optimisticLockCounter.incrementAndGet();
            }
            return null;
        });

		assertThat(optimisticLockCounter.intValue()).isEqualTo(numberOfConcurrentSaves - 1);
public void findById_shouldFailOnTouchOnReadWithExpirationProperty() {
		template.insert(new DocumentWithTouchOnReadAndExpirationProperty(id, EXPIRATION_ONE_MINUTE));
		template.findById(id, DocumentWithTouchOnReadAndExpirationProperty.class);
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
kws : compiler_lib.kws_repl_tmpl {
				indent : indent,
				code :
					"\(sum_indent)\(output_callback.storage_name).Load(\(generator));" &
					"\(sum_indent)\(generator).LoadReboxed(\(item.storage_name), typeof(object));" &
					"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Callvirt, typeof(ConsumeResult).GetMethod(\"Invoke\", new [] { typeof(object) }));" &
					code
internal abstract class Generator {
	 * Generate a successful return.
	 */
	public void Return(LoadableValue result) {
		if (result.BackingType == typeof(Frame) || result.BackingType == typeof(object)) {
			var end = Builder.DefineLabel();
			if (result.BackingType == typeof(object)) {
internal abstract class Generator {
			Builder.Emit(OpCodes.Call, typeof(Frame).GetMethod("Slot"));
			Builder.MarkLabel(end);
		}
		CopyField(result, typeof(Computation).GetField("result", BindingFlags.NonPublic | BindingFlags.Instance));
		Builder.Emit(OpCodes.Ldc_I4_1);
		Builder.Emit(OpCodes.Ret);
	}
	private LoadableValue ToStringishHelper(LoadableValue source) {
		if (source.BackingType == typeof(bool)) {
public class REPL {

			if (files.Count == 1) {
				var parser = Parser.Open(files[0]);
				var root_type = parser.ParseFile(collector, unit, "TestRoot");
				if (root_type != null) {
					var computation = (Computation) Activator.CreateInstance(root_type, task_master);
					computation.Notify(r => original = r as Frame);
public class REPL {

			while (run && (s = line_editor.Edit(id + "‽ ", "")) != null) {
				var parser = new Parser("line" + id, s);
				var run_type = parser.ParseRepl(collector, unit, "Test" + id++);
				if (run_type != null) {
					var computation = (Computation) Activator.CreateInstance(run_type, new object[] { task_master, original, current, update_current, (ConsumeResult) HandleResult, (ConsumeResult) Console.WriteLine });
					computation.Notify(r => run = (r as bool?) ?? true);
					task_master.Slot(computation);
					task_master.Run();
					task_master.ReportCircularEvaluation();
				}
			}
kws : compiler_lib.kws_repl_tmpl {
				indent : indent,
				code :
					"\(sum_indent)\(output_callback.storage_name).load(\(generator));" &
					"\(sum_indent)\(generator).loadReboxed(\(item.storage_name), Object.class);" &
					"\(sum_indent)\(generator).visitMethod(ConsumeResult.class.getMethod(\"consume\", Object.class));" &
					code
public int defineState() {
	 * @throws NoSuchMethodException
	 */
	public void doReturn(LoadableValue result) throws Exception {
		if (result.getBackingType() == Frame.class
				|| result.getBackingType() == Object.class) {
			Label end = new Label();
			if (result.getBackingType() == Object.class) {
				result.load(builder);
				builder.visitTypeInsn(Opcodes.INSTANCEOF,
						getInternalName(Frame.class));
				builder.visitJumpInsn(Opcodes.IFEQ, end);
				result.load(builder);
				builder.visitTypeInsn(Opcodes.CHECKCAST,
						getInternalName(Frame.class));
			} else {
				result.load(builder);
			}
			visitMethod(Frame.class.getMethod("slot"));
			builder.visitLabel(end);
		}
		copyField(result, "result", Object.class);
		builder.visitInsn(Opcodes.ICONST_0);
		builder.visitInsn(Opcodes.IRETURN);
public void slot(LoadableValue target) throws Exception {
		visitMethod(TaskMaster.class.getMethod("slot", Computation.class));
	}

	/**
	 * Slot a computation for execution and stop execution.
	 * 

	public static class PrintToConsole extends ElaboratePrinter {
		private ConsoleReader reader;

		public PrintToConsole(ConsoleReader reader) {
			this.reader = reader;
		}

		@Override
		protected void write(String string) throws IOException {
			reader.printString(string);
		}
public static void main(String[] args) {

		ErrorCollector collector = new ConsoleCollector();
		DynamicCompiler compiler = new DynamicCompiler(collector);
		TaskMaster task_master = new ConsoleTaskMaster();
		task_master.addUriHandler(BuiltInLibraries.INSTANCE);
		task_master.addUriHandler(new LoadPrecompiledLibraries());
		task_master.addUriHandler(compiler);
public void consume(Object result) {
			reader.setUsePagination(true);
			String line;
			int id = 0;
			ElaboratePrinter printer = new PrintToConsole(reader);
			RawPrint raw_printer = new RawPrint(reader);
			KeepRunning keep_running = new KeepRunning();
			while (keep_running.allowed() && (line = reader.readLine()) != null) {
				Parser parser = new Parser("<console>", line);
				Class<? extends Computation> run_type = parser.parseRepl(
						collector, compiler.getCompilationUnit(),
						"flabbergast/interactive/Line" + (id++));
public void consume(Object result) {
					computation.listen(keep_running);
					task_master.slot(computation);
					task_master.run();
				}
			}
		} catch (Exception e) {

	@Override
	public void consume(Object result) {
		Map<Frame, String> seen = new HashMap<Frame, String>();
		try {
			print(result, "", seen);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 * Custom preference type for selecting a camera
 *
 * Since the number and type of hardware cameras can differ from one model to
 * the next, the user needs to be able to select which one to use.
 */
public class CameraPreference extends ListPreference {


/**
 * Configurable settings for the application
 */
public class SettingsActivity extends PreferenceActivity {

public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            addPreferencesFromResource(R.xml.preferences);

            bindPreferenceSummaryToValue(findPreference("interval"));
            bindPreferenceSummaryToValue(findPreference("limit"));
            bindPreferenceSummaryToValue(findPreference("camera"));
            bindPreferenceSummaryToValue(findPreference("focus"));
        }

        private static Preference.OnPreferenceChangeListener sListener = new Preference.OnPreferenceChangeListener() {
            @Override
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                String stringValue = newValue.toString();

                if (preference instanceof ListPreference) {
                    ListPreference listPreference = (ListPreference) preference;
                    int index = listPreference.findIndexOfValue(stringValue);
public boolean onPreferenceChange(Preference preference, Object newValue) {
            }
        };

        private static void bindPreferenceSummaryToValue(Preference preference) {
            preference.setOnPreferenceChangeListener(sListener);

            sListener.onPreferenceChange(preference, PreferenceManager
                    .getDefaultSharedPreferences(preference.getContext())
                    .getString(preference.getKey(), ""));
import android.os.Build;
import android.os.IBinder;
import android.preference.PreferenceManager;
import android.support.v4.content.LocalBroadcastManager;
import android.util.Log;
import android.widget.Toast;
    // Used for capturing the images
    private ImageCapturer mImageCapturer;

    /**
     * Reimplementation of Service.onCreate()
     */
public void onCreate() {
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {

        // TODO: figure out why the intent is sometimes NULL

        if (intent != null) {

            // Dispatch the command to the appropriate method
public IBinder onBind(Intent intent) {
    }

    /**
     * Send a broadcast with current status
     */
    private void broadcastStatus() {

        Intent intent = new Intent(BROADCAST_STATUS);
        intent.putExtra(EXTRA_START_TIME, mStartTime);
        intent.putExtra(EXTRA_IMAGES_CAPTURED, mIndex);
        intent.putExtra(EXTRA_IMAGES_REMAINING, mLimit == 0 ? 0 : mLimit - mIndex);
        LocalBroadcastManager.getInstance(this).sendBroadcast(intent);
    }

    /**
     * Start capturing a sequence of images
     */
    @SuppressWarnings("deprecation")
    private void startCapture() {

        log("Starting image capture.");

        // Indicate that this is a foreground service by creating a persistent
        // notification displayed while the capture is in progress
        Intent intent = new Intent(this, MainActivity.class);
        Notification notification = new Notification.Builder(this)
                .setContentTitle(getText(R.string.notification_title))
                .setContentText(getText(R.string.notification_text))
                .setSmallIcon(R.drawable.ic_stat_notify)
                .setContentIntent(PendingIntent.getActivity(this, 0, intent, 0))
                .getNotification();
        startForeground(1, notification);

        // Set the start time and reset the index
        mStartTime = System.currentTimeMillis();
private void startCapture() {

        // Broadcast the new status (that the capture has started) and set an alarm
        broadcastStatus();
        setAlarm();
    }

    /**
     * Stop capturing a sequence of images
     */
    private void stopCapture() {

        log("Stopping image capture.");

        // TODO: this currently cannot cancel an image capture in progress

        // Cancel any pending capture intents and leave the foreground
        mAlarmManager.cancel(mCaptureIntent);
        stopForeground(true);

        // Reset the start time (to indicate no transfer) and broadcast this status
        mStartTime = 0;
        broadcastStatus();

        // Stop the service
        stopSelf();
    }

    /**
     * Capture a single image
     */
    private void capture() {

        log("Capturing image #" + String.valueOf(mIndex) + ".");

        mImageCapturer.startCapture(mIndex, new ImageCapturer.CaptureCallback() {

            @Override
            public void onSuccess() {

                log("Image #" + String.valueOf(mIndex) + " captured.");

                // Increment the counter and broadcast the status
                mIndex++;
                broadcastStatus();

                // Check to see if more images should be captured (and set the alarm)
                // or if the limit was reached (and the capture may be stopped
                if (mLimit == 0 || mIndex < mLimit) {

                    // TODO: this should be a configurable setting
                    mImageCapturer.close();

                    setAlarm();

                } else {
                    stopCapture();
                }
            }

            @Override
            public void onError(String description) {

                log("Error: " + description);

                // Inform the user that an error has occurred during capture
                Toast.makeText(CaptureService.this, R.string.toast_error_storage_img,
                        Toast.LENGTH_LONG).show();

                // Stop the capture
                stopCapture();
            }
        });
    }

    /**
     * Set the alarm for the next capture
     */
    private void setAlarm() {

        long triggerAtMillis = System.currentTimeMillis() + mInterval;

        // For KitKat and newer devices, we need to use setExact or we don't
        // end up with the same level of precision as earlier versions
private void setAlarm() {
    }

    /**
     * Log the specified message
     */
    private void log(String message) {
        Log.d(CaptureService.class.getSimpleName(), message);
    }
}
    /**
     * Callback interface used to provide notification of capture state
     *
     * Both of the callbacks may leave the camera open (to save time when
     * starting the next capture), so it needs to be explicitly closed when
     * capturing is finished.
     */
    public interface CaptureCallback {

        /**
         * Called when a capture completes successfully
         */
        void onSuccess();

        /**
         * Called when an error condition occurs
         * @param description human-readable description of the error condition
         */
        void onError(String description);
    }

    // Data initialized in the constructor
    private int mIndex;
    private CaptureCallback mCaptureCallback;

    // (Potentially) persistent connection to the camera
    @SuppressWarnings("deprecation")
    private Camera mCamera;

protected String doInBackground(Void... params) {
                @Override
                protected void onPostExecute(String message) {

                    // If message is non-null, then call CaptureCallback.onError(),
                    // otherwise start the camera preview and begin autofocus
                    if (message != null) {
                        mCaptureCallback.onError(message);
                        return;
                    }

                    // Move to the setup step
                    setup();
                }
            }.execute();
        }
public void close() {

    /**
     * Setup the camera in preparation for image capture
     */
    @SuppressWarnings("deprecation")
    private void setup() {
private void setup() {
                @Override
                public void onAutoFocus(boolean success, Camera camera) {

                    // TODO: if unable to focus, try again a couple of times
                    // TODO: error message needs to be localized

                    // If setup was not successful, we need to report an error
                    if (!success) {
                        mCaptureCallback.onError("Unable to focus.");
                        return;
                    }

                    // Move to the capture step
                    capture();
                }
            });

public void onPictureTaken(byte[] data, Camera camera) {

                    // Report an error if the directory could not be created
                    if (!mSequencePath.mkdirs()) {
                        mCaptureCallback.onError("Unable to create storage directory.");
                        return;
                    }
                }
public void onPictureTaken(byte[] data, Camera camera) {

                } catch (IOException e) {

                    mCaptureCallback.onError(e.getMessage());
                    return;
                }

                // Indicate that the capture was successful
                mCaptureCallback.onSuccess();
            }
        });
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void showBrightnessWarning(Camera webcam) {
	@Override
	public void setExercise(TrainingExercise exercise) {
		try {
			if (exercise == null)
			{
				config.setExercise(null);
				return;
			}
			
			Constructor<?> ctor = exercise.getClass().getConstructor(List.class);

			List<Target> knownTargets = new ArrayList<Target>();
			knownTargets.addAll(getTargets());

			if (projectorSlide.getArenaPane() != null) {
				knownTargets.addAll(projectorSlide.getArenaPane().getCanvasManager().getTargets());
			}

			TrainingExercise newExercise = (TrainingExercise) ctor.newInstance(knownTargets);

			Optional<Plugin> plugin = pluginEngine.getPlugin(newExercise);
			if (plugin.isPresent()) {
				config.setPlugin(plugin.get());
			} else {
public void setExercise(TrainingExercise exercise) {
	@Override
	public void setProjectorExercise(TrainingExercise exercise) {
		try {
			Constructor<?> ctor = exercise.getClass().getConstructor(List.class);
			TrainingExercise newExercise = (TrainingExercise) ctor
					.newInstance(projectorSlide.getArenaPane().getCanvasManager().getTargets());

			Optional<Plugin> plugin = pluginEngine.getPlugin(newExercise);
			if (plugin.isPresent()) {
				config.setPlugin(plugin.get());
			} else {
import com.shootoff.courses.io.CourseIO;
import com.shootoff.gui.LocatedImage;
import com.shootoff.gui.ShotEntry;
import com.shootoff.gui.TargetView;
import com.shootoff.gui.controller.ShootOFFController;
import com.shootoff.gui.pane.ProjectorArenaPane;
import com.shootoff.targets.Target;
public boolean setTargetDistance(Target target, int currentRealWidth, int curren
				.calculateObjectSize(currentRealWidth, currentRealHeight, desiredDistance);

		if (targetDimensions.isPresent()) {
			Dimension2D d = targetDimensions.get();
			target.setDimensions(d.getWidth(), d.getHeight());

			return true;
public boolean setTargetDistance(Target target, int currentRealWidth, int curren
	@Override
	public void destroy() {
		for (Target target : targets)
			arenaPane.getCanvasManager().removeTarget((TargetView) target);

		Platform.runLater(() -> {
			if (arenaPane != null)
				arenaPane.getCanvasManager().getCanvasGroup().getChildren().remove(exerciseLabel);
		});

		targets.clear();

		super.destroy();
	}
}
public void run() {

			thisSuper.showTextOnFeed(String.format("missed targets: %!d(MISSING)%!n(MISSING)bad hits: %!d(MISSING)", missedTargets, badHits));

			if (!testRun) {
				for (Target target : shootTargets)
					thisSuper.removeTarget(target);
				shootTargets.clear();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.nio.BufferUnderflowException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.TreeSet;
import java.util.concurrent.Callable;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.ReentrantLock;

import javax.media.opengl.GL2ES2;
import javax.sound.sampled.AudioFormat;
import org.jtrfp.trcl.conf.TRConfigurationFactory.TRConfiguration;
import org.jtrfp.trcl.core.Features;
import org.jtrfp.trcl.core.TRFactory.TR;
import org.jtrfp.trcl.gpu.GLFrameBuffer;
import org.jtrfp.trcl.gpu.GLTexture;
import org.jtrfp.trcl.gpu.GLTexture.PixelReadDataType;
import org.jtrfp.trcl.gpu.GLTexture.PixelReadOrder;
import org.jtrfp.trcl.gpu.GPU;
import org.jtrfp.trcl.obj.RelevantEverywhere;
import org.jtrfp.trcl.snd.SoundEvent.Factory;
import org.jtrfp.trcl.tools.Util;

public class SoundSystem {
           BUFFER_SIZE_FRAMES_STRING = "bufferSizeFramesString";
    
    private TR tr;
    private GLFrameBuffer playbackFrameBuffer;
    private GLTexture playbackTexture;
    protected final PropertyChangeSupport pcs = new PropertyChangeSupport(this);
    private final HashMap<SoundEvent.Factory,ArrayList<SoundEvent>> eventMap 
     = new HashMap<SoundEvent.Factory,ArrayList<SoundEvent>>();
    private SamplePlaybackEvent.Factory playbackFactory, musicPlaybackFactory;
    private MusicPlaybackEvent.Factory musicFactory;
    private LoopingSoundEvent.Factory loopFactory;
    private long soundRenderingFinishedSync;
    private AtomicBoolean paused = new AtomicBoolean(false);
    private int bufferSizeFrames = 4096;
    private ByteBuffer gpuFloatBytes;
    private static final AudioProcessor SILENCE = new Silence();
    private TRConfiguration trConfiguration;
    private boolean         initialized = false;
    private GPU             gpu;
    private boolean         bufferLag=true, linearFiltering=false;
    private double          modStereoWidth = .3;
    private final CollectionActionDispatcher<String> audioDriverNames = new CollectionActionDispatcher<String>(new HashSet<String>());
    private final ReentrantLock lock = new ReentrantLock();
    
   ////VARS
   private AudioDriver          activeDriver;
                                outputByName,
                                formatByName;
    
    private boolean firstRun=true;
    private final TreeSet<SoundEvent> pendingEvents = new TreeSet<SoundEvent>(new Comparator<SoundEvent>(){
	@Override
	public int compare(SoundEvent first, SoundEvent second) {
	    final double result = 88200. * (first.getStartRealtimeSeconds()-second.getStartRealtimeSeconds());
	    if(result==0)return first.hashCode()-second.hashCode();
	    else if(result>0)return 1;
	    else return -1;
	}//end compare()
    });
    private final ArrayList<SoundEvent> activeEvents = new ArrayList<SoundEvent>();
    private double bufferTimeCounter;
    

    public static final double DEFAULT_SFX_VOLUME = .3;
    private static final int NUM_BUFFER_ROWS=1;
    
    public SoundSystem() {
	audioDriverNames.add("org.jtrfp.trcl.snd.JavaSoundSystemAudioOutput");//TODO: Implement a registry.
    }// end constructor
    
    public void initialize(){
public void initialize(){
	System.out.println("Setting up sound system...");
	loadConfigAndAttachListeners();
	final GPU gpu = getGpu();
	tr.getThreadManager().submitToGL(new Callable<Void>() {
	    @Override
	    public Void call() throws Exception {
public Void call() throws Exception {
	loopFactory    = new LoopingSoundEvent.Factory(tr);
	
	new Thread() {//TODO: This is not thread-safe with sound config changes!
	    private final DynamicCompressor compressor = new DynamicCompressor();
	    @Override
	    public void run() {
		try {
public void run() {
			while(getActiveFormat() == null || getActiveOutput() == null || getActiveDevice() == null)
			    Thread.sleep(100);//Rolling loop waiting for valid state.
			
			    renderPrep();
			    tr.getThreadManager().submitToGL(new Callable<Void>() {
				@Override
				public Void call() throws Exception {
				    final ByteBuffer floatBytes = getGPUFloatBytes();
				    floatBytes.clear();
				    render(getGpu().getGl(), floatBytes);
				    return null;
				}
			    }).get();
			    //sBuf.clear();
			    final FloatBuffer fBuf = getGPUFloatBytes().asFloatBuffer();
			    fBuf.clear();
			    compressor.setSource(fBuf);
			    final AudioDriver driver = getActiveDriver();
			    if(driver!=null){
				driver.setSource(compressor);
				driver.flush();
			    }//end driver!=null
		    }// end while(true)
		} catch (Exception e) {
		    tr.showStopper(e);
private int getFilteringParm(){
    }
    
    public void enqueuePlaybackEvent(SoundEvent evt){
	lock.lock();try{
	    if(evt instanceof RelevantEverywhere)
		activeEvents.add(evt);
	    else pendingEvents.add(evt);
	}finally{lock.unlock();}
    }
    
    private void firstRun(){
	firstRun=false;
    }

    private void renderPrep(){
	lock.lock();
	try{
	    cleanActiveEvents();
	    pickupActiveEvents(getBufferSizeFrames()/getActiveFormat().getFrameRate());
	}finally{lock.unlock();}
    }
    
    private void render(GL2ES2 gl, ByteBuffer audioByteBuffer) {
	if( lock.tryLock() )try{
	    if (firstRun)
		firstRun();
	    final GPU gpu = getGpu();

	    if(isBufferLag())
		readGLAudioBuffer(gpu,audioByteBuffer);

	    // Render
	    getPlaybackFrameBuffer().bindToDraw();
	    gl.glViewport(0, 0, getBufferSizeFrames(), 1);
	    gl.glClear(GL2ES2.GL_COLOR_BUFFER_BIT);
	    for (SoundEvent ev : activeEvents) {// TODO: Replace with Factory calls
		if (ev.isActive()) {
		    final SoundEvent.Factory factory = ev.getOrigin();
		    if (!eventMap.containsKey(factory))
			eventMap.put(factory, new ArrayList<SoundEvent>());
		    eventMap.get(factory).add(ev);
		}// end if(active)
	    }// end for(events)
	    for(Factory factory:eventMap.keySet()){
		final ArrayList<SoundEvent> events = eventMap.get(factory);
		factory.apply(gl, events, bufferTimeCounter);
		events.clear();
	    }//end for(keySet)

	    if(!isBufferLag())
		readGLAudioBuffer(gpu,audioByteBuffer);

	    bufferTimeCounter += getBufferSizeSeconds();
	    // Cleanup
	    gpu.defaultFrameBuffers();
	    gpu.defaultProgram();
	    gpu.defaultTIU();
	    gpu.defaultTexture();
	    gpu.defaultViewport();
	}finally{lock.unlock();}
    }// end render()
    
    public double getBufferSizeSeconds() {
	final AudioFormat activeFormat = getActiveFormat();
	if( activeFormat != null )
	    return (double)getBufferSizeFrames() / (double)getActiveFormat().getFrameRate();
	return 0;
    }

    private void readGLAudioBuffer(GPU gpu, ByteBuffer audioByteBuffer){
	// Read and export previous results to sound card.
	final GL2ES2 gl = gpu.getGl();
	gpu.defaultFrameBuffers();
	getPlaybackTexture().bind().readPixels(PixelReadOrder.RG, PixelReadDataType.FLOAT,
		audioByteBuffer).unbind();// RG_INTEGER throws INVALID_OPERATION!?
    }//end readGLAudioBuffer(...)
    
    private void pickupActiveEvents(double windowSizeInSeconds){
	final double playbackTimeSeconds = bufferTimeCounter;
	final Iterator<SoundEvent> eI = pendingEvents.iterator();
	while(eI.hasNext()){
	    final SoundEvent event = eI.next();
	    if(event.isDestroyed())
		eI.remove();
	    else if(event.getStartRealtimeSeconds()<playbackTimeSeconds+windowSizeInSeconds && event.getEndRealtimeSeconds()>playbackTimeSeconds){
		activeEvents.add(event);
		eI.remove();
	    }//end if(in range)
	    if(event.getStartRealtimeSeconds()>playbackTimeSeconds+windowSizeInSeconds)
		return;//Everything after this point is out of range.
	}//end hashNext(...)
    }//end pickupActiveEvents()
    
    private void cleanActiveEvents(){
	final double currentTimeSeconds = bufferTimeCounter;
	final Iterator<SoundEvent> eI = activeEvents.iterator();
	while(eI.hasNext()){
	    final SoundEvent event = eI.next();
	    if(event.isDestroyed())
		eI.remove();
	    else if(event.getEndRealtimeSeconds()<currentTimeSeconds && 
		    !(event instanceof RelevantEverywhere))
		eI.remove();
	}//end while(hasNext)
    }//end cleanActiveEvents()

    /**
     * @return the playbackFactory
     */
public double getCurrentFrameBufferTimeCounter() {
    }

    public void dequeueSoundEvent(SoundEvent event) {
	lock.lock();try{
	    pendingEvents.remove(event);
	    activeEvents.remove(event);
	}finally{lock.unlock();}
    }//end dequeneSoundEvent(...)

    public GLFrameBuffer getSoundOutputFrameBuffer() {
	return playbackFrameBuffer;
    }

    public double getSamplesPerMilli() {
	return ((double)getActiveFormat().getFrameRate())/1000.;
public double getSamplesPerMilli() {
    /**
     * @return the activeDriver
     */
    private AudioDriver getActiveDriver() {
	if(activeDriver==null){
            System.out.println("Overriding null driver to default...");
            setActiveDriver(new JavaSoundSystemAudioOutput());
private AudioDriver getActiveDriver() {
     * @param activeDriver the activeDriver to set
     */
    private void setActiveDriver(AudioDriver activeDriver) {
	if(this.activeDriver!=null)
	    activeDriver.release();
	final AudioDriver oldActiveDriver = this.activeDriver;
        this.activeDriver = activeDriver;
        activeDriver.setBufferSizeFrames(getBufferSizeFrames());
        setActiveDevice(activeDriver.getDefaultDevice());
        System.out.println("SoundSystem: Active Driver Set To "+activeDriver);
        pcs.firePropertyChange(ACTIVE_DRIVER, oldActiveDriver, activeDriver);
    }

    /**
     * @return the activeDevice
private AudioDevice getActiveDevice() {
    private void setActiveDevice(AudioDevice activeDevice) {
	final AudioDevice oldDevice = this.activeDevice;
        this.activeDevice = activeDevice;
        pcs.firePropertyChange(ACTIVE_DEVICE, oldDevice, activeDevice);
        setActiveOutput(activeDevice.getDefaultOutput());
        System.out.println("SoundSystem: Active Device Set To "+activeDevice);
    }

    /**
private AudioOutput getActiveOutput() {
    private void setActiveOutput(AudioOutput newActiveOutput) {
	final AudioOutput oldOutput = this.activeOutput;
        this.activeOutput = newActiveOutput;
        System.out.println("SoundSystem: Active Output Set To "+newActiveOutput);
	getActiveDriver().setOutput(newActiveOutput);
	if( newActiveOutput != null )
	    setActiveFormat(newActiveOutput.getDefaultFormat());
	else
	    setActiveFormat(null);
	pcs.firePropertyChange(ACTIVE_OUTPUT, oldOutput, newActiveOutput);
    }

private void setActiveFormat(AudioFormat newFormat) {
		    newFormat.isBigEndian());
	
        this.activeFormat = newFormat;
        System.out.println("SoundSystem: Active Format Set To "+newFormat+" for driver "+activeDriver);
        if(activeDriver!=null)
	    activeDriver.setFormat(newFormat);
        pcs.firePropertyChange(ACTIVE_FORMAT, oldFormat, newFormat);
    }

int getBufferSizeFrames() {
     * @param bufferSizeFrames the bufferSizeFrames to set
     */
    public void setBufferSizeFrames(int bufferSizeFrames) {
	lock.lock();try{
	    System.out.println("setBufferSizeFrames "+bufferSizeFrames);
	    if(bufferSizeFrames<=0)
		throw new RuntimeException("Invalid buffer size: "+bufferSizeFrames+". Must be greater than zero.");
	    this.bufferSizeFrames = bufferSizeFrames;
	    getActiveDriver().setBufferSizeFrames(bufferSizeFrames);
	    stalePlaybackTexture();
	    staleFloatBytes();
	}finally{lock.unlock();}
    }
    
    public void setBufferSizeFramesString(String newValue){
public String getBufferSizeFramesString(){
	return ""+getBufferSizeFrames();
    }
    
    private GLFrameBuffer getPlaybackFrameBuffer(){
	lock.lock(); try{
	    if(playbackFrameBuffer==null){
		playbackFrameBuffer = tr.getThreadManager().submitToGL(new Callable<GLFrameBuffer>(){
		    @Override
		    public GLFrameBuffer call() throws Exception {
			final GPU gpu = getGpu();
			gpu.defaultTexture();
			gpu.defaultTIU();
			final GLTexture texture = getPlaybackTexture();
			return getGpu()
				.newFrameBuffer()
				.bindToDraw()
				.attachDrawTexture(texture,
					GL2ES2.GL_COLOR_ATTACHMENT0);
		    }}).get();
	    }//end if(playbackFrameBuffer==null)
	    return playbackFrameBuffer;
	}finally{lock.unlock();}
    }//end getPlaybackFrameBuffer()

    private void stalePlaybackFrameBuffer(){
	lock.lock();try{
	    if(playbackFrameBuffer!=null){
		final GLFrameBuffer toDelete = playbackFrameBuffer;
		tr.getThreadManager().submitToGL(new Callable<Void>(){
		    @Override
		    public Void call() throws Exception {
			toDelete.destroy();
			return null;
		    }});
	    }//end playbackFrameBuffer!=null
	    playbackFrameBuffer=null;
	}finally{lock.unlock();}
    }//end stalePlaybackFrameBuffer()
    
    private GLTexture getPlaybackTexture(){
	lock.lock();try{
	    if(playbackTexture==null){
		tr.getThreadManager().submitToGL(new Callable<Void>(){
		    @Override
		    public Void call() throws Exception {
			final GPU gpu = getGpu();
			gpu.defaultProgram();
			gpu.defaultTIU();
			gpu.defaultTexture();
			gpu.defaultFrameBuffers();
			playbackTexture = gpu
				.newTexture()
				.bind()
				.setMagFilter(GL2ES2.GL_NEAREST)
				.setMinFilter(GL2ES2.GL_NEAREST)
				.setWrapS(GL2ES2.GL_CLAMP_TO_EDGE)
				.setWrapT(GL2ES2.GL_CLAMP_TO_EDGE)
				.setDebugName("playbackTexture")
				.setExpectedMinValue(-1, -1, -1, -1)
				.setExpectedMaxValue(1, 1, 1, 1)
				.setPreferredUpdateIntervalMillis(100)
				.setImage(GL2ES2.GL_RG32F, getBufferSizeFrames(),
					NUM_BUFFER_ROWS, GL2ES2.GL_RGBA, GL2ES2.GL_FLOAT,
					null);
			return null;
		    }}).get();
	    }
	    return playbackTexture;
	}finally{lock.unlock();}
    }//end getPlaybackTexture()
    
    private void stalePlaybackTexture(){
	lock.lock();try{
	if(playbackTexture!=null){
	    final GLTexture toDelete = playbackTexture;
	    tr.getThreadManager().submitToGL(new Callable<Void>(){
		@Override
		public Void call() throws Exception {
		    toDelete.delete();//This fails with no-GL exception?!
		    return null;
		}});
	}//end playbackTexture!=null
        stalePlaybackFrameBuffer();
	playbackTexture=null;
	}finally{lock.unlock();}
    }//end stalePlaybackTexture()

    private ByteBuffer getGPUFloatBytes() {
	if(gpuFloatBytes==null)
	    setGPUFloatBytes(ByteBuffer.allocateDirect(
		     getBufferSizeFrames()*4
		     *getActiveFormat().getChannels())
		    .order(ByteOrder.nativeOrder()));
	return gpuFloatBytes;
    }

    private void setGPUFloatBytes(ByteBuffer gpuFloatBytes) {
	this.gpuFloatBytes = gpuFloatBytes;
    }
    
    private void staleFloatBytes(){
	gpuFloatBytes=null;
    }

    public LoopingSoundEvent.Factory getLoopFactory() {
        return loopFactory;
    }
public void setBufferLag(Boolean bufferLag) {
	System.out.println("setBufferLag "+bufferLag);
	final Boolean oldValue = this.bufferLag;
        this.bufferLag = bufferLag;
        pcs.firePropertyChange(BUFFER_LAG, oldValue, bufferLag);
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public DiscoveryNode localNode() {
        return discovery.localNode();
    }

    /**
     * Returns <tt>true</tt> if the initial state was received within the timeout waiting for it
     * on {@link #doStart()}.
     */
    public boolean initialStateReceived() {
        return initialStateListener.initialStateReceived;
    }

    public String nodeDescription() {
        return discovery.nodeDescription();
    }
import org.elasticsearch.rest.RestStatus;
import org.elasticsearch.threadpool.ThreadPool;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicBoolean;

/**
public GatewayService(Settings settings, Gateway gateway, AllocationService allo
    @Override
    protected void doStart() {
        clusterService.addLast(this);
        // if we received initial state, see if we can recover within the start phase, so we hold the
        // node from starting until we recovered properly
        if (discoveryService.initialStateReceived()) {
            ClusterState clusterState = clusterService.state();
            if (clusterState.nodes().localNodeMaster() && clusterState.blocks().hasGlobalBlock(STATE_NOT_RECOVERED_BLOCK)) {
                checkStateMeetsSettingsAndMaybeRecover(clusterState, false);
            }
        } else {
            logger.debug("can't wait on start for (possibly) reading state from gateway, will do it asynchronously");
        }
    }

    @Override
public void clusterChanged(final ClusterChangedEvent event) {
        if (lifecycle.stoppedOrClosed()) {
            return;
        }
        if (event.localNodeMaster() && event.state().blocks().hasGlobalBlock(STATE_NOT_RECOVERED_BLOCK)) {
            checkStateMeetsSettingsAndMaybeRecover(event.state(), true);
        }
    }

    protected void checkStateMeetsSettingsAndMaybeRecover(ClusterState state, boolean asyncRecovery) {
        DiscoveryNodes nodes = state.nodes();
        if (state.blocks().hasGlobalBlock(discoveryService.getNoMasterBlock())) {
            logger.debug("not recovering from gateway, no master elected yet");
protected void checkStateMeetsSettingsAndMaybeRecover(ClusterState state, boolea
                    reason = "expecting [" + expectedMasterNodes + "] master nodes, but only have [" + nodes.masterNodes().size() + "]";
                }
            }
            performStateRecovery(asyncRecovery, enforceRecoverAfterTime, reason);
        }
    }

    private void performStateRecovery(boolean asyncRecovery, boolean enforceRecoverAfterTime, String reason) {
        final Gateway.GatewayStateRecoveredListener recoveryListener = new GatewayRecoveryListener(new CountDownLatch(1));

        if (enforceRecoverAfterTime && recoverAfterTime != null) {
            if (scheduledRecovery.compareAndSet(false, true)) {
                logger.info("delaying initial state recovery for [{}]. {}", recoverAfterTime, reason);
                threadPool.schedule(recoverAfterTime, ThreadPool.Names.GENERIC, new Runnable() {
                    @Override
                    public void run() {
                        if (recovered.compareAndSet(false, true)) {
                            logger.info("recover_after_time [{}] elapsed. performing state recovery...", recoverAfterTime);
                            gateway.performStateRecovery(recoveryListener);
                        }
                    }
                });
            }
        } else {
            if (recovered.compareAndSet(false, true)) {
                if (asyncRecovery) {
                    threadPool.generic().execute(new Runnable() {
                        @Override
                        public void run() {
                            gateway.performStateRecovery(recoveryListener);
                        }
                    });
                } else {
                    logger.trace("performing state recovery...");
                    gateway.performStateRecovery(recoveryListener);
                }
            }
        }
    }

    class GatewayRecoveryListener implements Gateway.GatewayStateRecoveredListener {

        private final CountDownLatch latch;

        GatewayRecoveryListener(CountDownLatch latch) {
            this.latch = latch;
        }

        @Override
        public void onSuccess(final ClusterState recoveredState) {
            logger.trace("successful state recovery, importing cluster state...");
public void onFailure(String source, Throwable t) {
                @Override
                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {
                    logger.info("recovered [{}] indices into cluster_state", newState.metaData().indices().size());
                    latch.countDown();
                }
            });
        }
public void onFailure(String message) {
            // don't remove the block here, we don't want to allow anything in such a case
            logger.info("metadata state not restored, reason: {}", message);
        }
    }

    // used for testing
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void renameFile(String from, String to) throws IOException {
    public void writeChecksums() throws IOException {
        ensureOpen();
        ImmutableMap<String, StoreFileMetaData> files = list();
        String checksumName = CHECKSUMS_PREFIX + System.currentTimeMillis();
        synchronized (mutex) {
            Map<String, String> checksums = new HashMap<>();
            for (StoreFileMetaData metaData : files.values()) {
                if (metaData.checksum() != null) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
