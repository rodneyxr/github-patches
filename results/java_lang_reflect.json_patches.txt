private void onLoadingMessageUpdated(String message) {
            return;
        }
        currentLoadingMessage = message;
        loadingMessage.setText(message);
    }

    public void onProgressUpdate(LoadTBAData.LoadProgressInfo info) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    <ConfirmationsSetting value="0" id="Add" />
    <ConfirmationsSetting value="0" id="Remove" />
  </component>
  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_8" default="true" assert-keyword="true" jdk-15="true" project-jdk-name="1.8" project-jdk-type="JavaSDK">
    <output url="file://$PROJECT_DIR$/build/classes" />
  </component>
  <component name="ProjectType">
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
                updateCurrentProject();
            }
        } else if (requestCode == 1011) {
            String user = data.getStringExtra("user");
            UsuarioController.UpdateUserProjects(user, currentProjectId);
            projeto.getMembrosProjeto().add(user);
            updateCurrentProject();
        }

    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private String getExceptionName(com.sun.javadoc.ThrowsTag throwsTag, ExecutableM
    if (exceptionType != null) {
      return exceptionType.qualifiedTypeName();
    }
    // Try to collect the exception's name from the import declarations
    String exceptionName = throwsTag.exceptionName();
    for (ClassDoc importedClass : member.containingClass().importedClasses()) {
      if (importedClass.name().equals(exceptionName)) {
        return importedClass.qualifiedName();
      }
public void freeColTest() {
        };
    Toradocu.main(toradocuArgs);
  }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	<groupId>de.codecentric</groupId>
	<artifactId>jbehave-junit-runner</artifactId>
	<version>1.0.0-SNAPSHOT</version>
	<packaging>jar</packaging>

	<name>JBehave JUnit Runner</name>
public JUnitReportingRunner(Class<? extends ConfigurableEmbedder> testClass)
		candidateSteps = embedder.stepsFactory().createCandidateSteps();

		storyDescriptions = buildDescriptionFromStories();
	}

	@Override
	public Description getDescription() {
		rootDescription = Description.createSuiteDescription(embedder
				.getClass());
		rootDescription.getChildren().addAll(storyDescriptions);
		return rootDescription;
	}

	@Before
	public void setUp() throws Throwable {
		MockitoAnnotations.initMocks(this);
		description = runner.getDescription();
	}

	@Parameters
public JUnitReportingRunnerTest(Class<? extends ConfigurableEmbedder> cls,
	@Test
	public void runUpExampleScenarioAndCheckNotifications() {
		runner.run(notifier);
		verifyAllChildDescriptionsFired(description, true);
	}

	private void verifyAllChildDescriptionsFired(Description description,
private boolean considerStepForVerification(Description d) {

	@Test
	public void topLevelDescriptionForExample() {
		assertThat(description.getDisplayName(), equalTo(expectedDisplayName));
	}

	@Test
public void stepDescriptionsForExample() {
	}

	private Description getFirstStory() {
		return description.getChildren().get(1);
	}

	private Description getFirstScenario() {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void run() {
	}

	private void setSelectedProject(final IModelProject project) {
		projectSelectionViewer.setSelection(new StructuredSelection(project), true);
	}

	public void populate(IModelProject modelProject) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public Map toMap() {
        HashMap<String, Object> map = new HashMap<>();
        map.put("itemId", itemId);
        map.put("tracked", tracked);
        map.put("job", job.toMap());
        return map;
    }
}
package org.rundeck.client.tool.commands.projects

import com.simplifyops.toolbelt.CommandOutput
import org.rundeck.client.api.RundeckApi
import org.rundeck.client.api.model.ScmProjectStatusResult
import org.rundeck.client.api.model.ScmSynchState
import org.rundeck.client.tool.AppConfig
import org.rundeck.client.tool.RdApp
import org.rundeck.client.util.Client
import retrofit2.Retrofit
import retrofit2.mock.Calls
import spock.lang.Specification

import spock.lang.Specification
 * @since 1/11/17
 */
class SCMSpec extends Specification {
    def "scm status use project from env var"() {
        given:
        def api = Mock(RundeckApi)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
android {
        applicationId "com.ae.apps.tripmeter"
        minSdkVersion 16
        targetSdkVersion 25
        versionCode 11
        versionName "2.0.18"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
        vectorDrawables.useSupportLibrary = true
    }
    /**
     * Return a reference to the ExpenseContactManager implementation
     *
     * @param contentResolver
     * @return
     */
    public static ExpenseContactManager newInstance(ContentResolver contentResolver){
        if(null == instance){
            instance = new ExpenseContactManager(contentResolver);
        }
        return instance;
    }

    public ExpenseContactManager(ContentResolver contentResolver) {
        super(contentResolver);
    }

    @Override
public ExpenseContactManager(ContentResolver contentResolver) {

    /**
     * Returns a list of ContactVos from contactIds
     * @param memberIds comma separated member ids
     * @return
     */
    public List<ContactVo> getContactsFromIds(String memberIds) {
        List<ContactVo> contacts = new ArrayList<>();
        if(null != memberIds && !TextUtils.isEmpty(memberIds)){
            ContactVo contactVo;
            String [] contactIds = memberIds.split(",");
            for(String contactId : contactIds){
                contactVo = getContactInfo(contactId);
                contacts.add(contactVo);
            }
public ExpenseContactManager(ContentResolver contentResolver) {

    /**
     * Finds and returns the default Profile (current user)
     *
     * Owner details are stored in ContactsContract.Profile for ICS and up
     *
     * @return
     */
    public ContactVo getDefaultContact(){
        ContactVo contactVo = new ContactVo();

        boolean userFound = false;
        Cursor cursor = contentResolver.query( ContactsContract.Profile.CONTENT_URI, null, null, null, null);
        if(cursor.moveToFirst()){
            contactVo.setName(cursor.getString(cursor.getColumnIndex( ContactsContract.Profile.DISPLAY_NAME)));
            contactVo.setId(cursor.getString(cursor.getColumnIndex( ContactsContract.Profile._ID)));
            userFound = true;
        }
        cursor.close();

        if(!userFound){
            contactVo.setName("You");
            contactVo.setId("0");
        }
public static ExpenseManager newInstance(final Context context) {
    private ExpenseManager(final Context context) {
        mContext = context;
        mExpensesDatabase = new TripExpensesDatabase(mContext);
        mContactManager = new ExpenseContactManager(mContext.getContentResolver());

        mDefaultProfilePic = BitmapFactory.decodeResource(mContext.getResources(), R.drawable.default_profile_image);
    }
<resources>
    <string name="app_name">Trip O Meter</string>
    <string name="app_version_name">2.0.18 (Balanjar)</string>
    <string name="app_version_code">Balanjar was a medieval city located in the North Caucasus region, between the cities of Derbent and Samandar, which flourished from the seventh to the tenth centuries CE.</string>
    <string name="app_release_date">Mar 2017</string>
    <string name="app_disclaim">The data shown in this app is approximate and should be used for a rough estimate only and may vary with actually observed values.</string>
    <string name="app_desc">This app calculates an estimate of fuel and cost needed for a trip</string>
    <string name="app_developer_info">Designed &amp; Developed at ae labs</string>
buildscript {
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:2.3.0'

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private String getTempDirectoryPath(Context ctx) {

		return cache.getAbsolutePath();
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
dependencies {

    // map and location
    compile 'com.mapzen.tangram:tangram:0.6.3'
    compile 'com.mapzen.android:lost:2.1.2'

    // config files
    compile 'com.esotericsoftware.yamlbeans:yamlbeans:1.09'
public void startPositionTracking()

	public void stopPositionTracking()
	{
		try // TODO remove when https://github.com/mapzen/lost/issues/178 is solved
		{
			if(lostApiClient.isConnected())
			{
				LocationServices.FusedLocationApi.removeLocationUpdates(lostApiClient, this);
				lostApiClient.disconnect();
			}
		} catch(Exception e) {
			e.printStackTrace();
		}
	}

public void onConnectionSuspended() {}

	@Override public void onLocationChanged(Location location)
	{
		LatLon pos = new OsmLatLon(location.getLatitude(), location.getLongitude());
		// TODO remove when https://github.com/mapzen/lost/issues/142 is fixed
		if(this.pos != null)
		{
			if(SphericalEarthMath.distance(pos, this.pos) < 400) return;
		}
		this.pos = pos;
		triggerAutoDownload();
	}

	@Override public void onProviderEnabled(String provider) {}
	@Override public void onProviderDisabled(String provider) {}

	public void triggerAutoDownload()
	{
		if(!isAllowedByPreference()) return;
public void startRequest(int priority, Callback listener)

	public void stopRequest()
	{
		try // TODO remove when https://github.com/mapzen/lost/issues/178 is solved
		{
			Handler h = new Handler(Looper.getMainLooper());
			h.post(new Runnable()
			{
				@Override public void run()
				{
					if(lostApiClient.isConnected())
					{
						LocationServices.FusedLocationApi.removeLocationUpdates(lostApiClient, SingleLocationRequest.this);
						lostApiClient.disconnect();
					}
				}
			});

		} catch(Exception e) {
			e.printStackTrace();
		}
	}

	@Override public void onConnected() throws SecurityException
public void stopRequest()
		stopRequest();
	}

	@Override public void onProviderDisabled(String provider) {}
	@Override public void onProviderEnabled(String provider) {}
	@Override public void onConnectionSuspended() {}
}
public void stopPositionTracking()
		}
		zoomedYet = false;

		try // TODO remove when https://github.com/mapzen/lost/issues/178 is solved
		{
			if(lostApiClient.isConnected())
			{
				LocationServices.FusedLocationApi.removeLocationUpdates(lostApiClient, this);
				lostApiClient.disconnect();
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

private float meters2Pixels(LngLat at, float meters) {
		return Math.abs(screenPos1.y - screenPos0.y);
	}

	@Override public void onProviderEnabled(String provider)
	{

	}

	@Override public void onProviderDisabled(String provider)
	{

	}

	private static final String PREF_ROTATION = "map_rotation";
	private static final String PREF_TILT = "map_tilt";
	private static final String PREF_ZOOM = "map_zoom";
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void startPlaying(Uri uri) {
			mPlayer.start();
			mPlayer.setOnCompletionListener(mp -> {
				mPlayer = null;
				((ImageView) isPlayingView.findViewById(R.id.gridview_item_picture)).setImageBitmap
						(recordingBitmap);
				recordingBitmap = null;
				isPlayingView = null;
			});
		} catch (IOException e) {
			Log.e(Constants.TAG, "prepare() failed", e);
private void startPlaying(Uri uri) {

	private void stopPlaying() {
		if (mPlayer != null) {
			((ImageView) isPlayingView.findViewById(R.id.gridview_item_picture)).setImageBitmap(recordingBitmap);
			isPlayingView = null;
			recordingBitmap = null;
			mPlayer.release();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void visitClassDef(JCClassDecl classdecl) {
				}
			}

			if (classdecl.implementing != null && !classdecl.implementing.isEmpty()) {
				List<JCExpression> implementing = new ArrayList<>(classdecl.implementing);

				if (context.hasAnnotationType(classdecl.sym, JSweetConfig.ANNOTATION_SYNTACTIC_ITERABLE)) {
import org.junit.Test;

import source.enums.ComplexEnumWithAbstractMethods;
import source.enums.ComplexEnums;
import source.enums.EnumInSamePackage;
import source.enums.Enums;

public class EnumTests extends AbstractTest {

	class AddRootFactory extends JSweetFactory {
		@Override
		public Java2TypeScriptAdapter createAdapter(JSweetContext context) {
			return new Java2TypeScriptAdapter(super.createAdapter(context)) {
				{
					context.addAnnotation("@Root", "source.enums");
				}
			};
		}
	}

	class EraseEnumFactory extends JSweetFactory {
		@Override
		public Java2TypeScriptAdapter createAdapter(JSweetContext context) {
			return new Java2TypeScriptAdapter(super.createAdapter(context)) {
				{
					context.addAnnotation("@Erased", "source.enums.ErasedEnum");
				}
			};
		}
	}

	@Test
	public void testEnums() {
		eval((logHandler, r) -> {
			assertEquals("There should be no errors", 0, logHandler.reportedProblems.size());
			Assert.assertEquals(0, ((Number) r.get("value")).intValue());
			Assert.assertEquals("A", r.get("nameOfA"));
			Assert.assertEquals(0, ((Number) r.get("ordinalOfA")).intValue());
			Assert.assertEquals("A", r.get("valueOfA"));
			Assert.assertEquals(2, ((Number) r.get("valueOfC")).intValue());
			Assert.assertEquals("B", r.get("ref"));
			Assert.assertEquals("A", r.get("switch"));
		}, getSourceFile(EnumInSamePackage.class), getSourceFile(EnumInOtherPackage.class), getSourceFile(Enums.class));
	}

	@Test
	public void testComplexEnums() {
		eval((logHandler, r) -> {
			assertEquals("There should be no errors", 0, logHandler.reportedProblems.size());
			Assert.assertEquals(">static,2,--2--,ratio_2_1_5,true,true,true,true", r.get("trace"));
		}, getSourceFile(ComplexEnums.class));
	}

	@Test
	public void testComplexEnumWithAbstractMethods() {
		eval((logHandler, r) -> {
			assertEquals("There should be no errors", 0, logHandler.reportedProblems.size());
			Assert.assertEquals(">ok1,ok2", r.get("trace"));
		}, getSourceFile(ComplexEnumWithAbstractMethods.class));
		transpiler.setBundle(true);
		eval(ModuleKind.none, (logHandler, r) -> {
			assertEquals("There should be no errors", 0, logHandler.reportedProblems.size());
			Assert.assertEquals(">ok1,ok2", r.get("trace"));
		}, getSourceFile(ComplexEnumWithAbstractMethods.class));
		transpiler.setBundle(false);
		createTranspiler(new AddRootFactory());
		eval((logHandler, r) -> {
			assertEquals("There should be no errors", 0, logHandler.reportedProblems.size());
			Assert.assertEquals(">ok1,ok2", r.get("trace"));
		}, getSourceFile(ComplexEnumWithAbstractMethods.class));
		transpiler.setBundle(true);
		eval(ModuleKind.none, (logHandler, r) -> {
			assertEquals("There should be no errors", 0, logHandler.reportedProblems.size());
			Assert.assertEquals(">ok1,ok2", r.get("trace"));
		}, getSourceFile(ComplexEnumWithAbstractMethods.class));
		transpiler.setBundle(false);
		createTranspiler(new JSweetFactory());
	}

	@Test
	public void testErasedEnum() {
		createTranspiler(new EraseEnumFactory());
		transpile(logHandler -> {
			assertEquals("There should be no errors", 0, logHandler.reportedProblems.size());
		}, getSourceFile(ErasedEnum.class));
		createTranspiler(new JSweetFactory());
	}

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void onNothingSelected(AdapterView<?> parent) {
        }
        else {
            final TelephonyManager tm = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
            final String regionCode = tm.getSimCountryIso().toUpperCase(Locale.US);
            CountryCode cc = new CountryCode();
            cc.regionCode = regionCode;
            cc.countryCode = util.getCountryCodeForRegion(regionCode);
            mCountryCode.setSelection(ccList.getPositionForId(cc));
        }

        // listener for autoselecting country code from typed phone number
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void onLoadFinished(Loader<Cursor> loader, Cursor data) {
            // Two cases:

            boolean grouped = masterKeyId == lastMasterKeyId;
            boolean subGrouped = data.isFirst() || grouped && lastName.equals(name);
            // Remember for next loop
            lastName = name;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
apply plugin: 'net.minecraftforge.gradle.forge'
//    id "net.minecraftforge.gradle.forge" version "2.0.2"
//}

version = "2.4.0"
def silentlib_version = "2.2.5"
def buildNum = 0
group = "net.silentchaos512.gems"
archivesBaseName = "SilentsGems-1.12"
package net.silentchaos512.gems.client.render.models;

import java.util.List;

import org.lwjgl.opengl.GL11;

import com.google.common.collect.ImmutableMap;

import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.block.model.BakedQuad;
import net.minecraft.client.renderer.block.model.IBakedModel;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.crash.CrashReport;
import net.minecraft.util.ReportedException;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.client.model.Attributes;
import net.minecraftforge.client.model.IModel;
import net.minecraftforge.client.model.ModelLoader;
import net.minecraftforge.client.model.obj.OBJLoader;
import net.minecraftforge.client.model.obj.OBJModel;
import net.minecraftforge.client.model.pipeline.LightUtil;
import net.minecraftforge.common.model.TRSRTransformation;

public class ModelHelper {

  public static OBJModel loadModel(String suffix) {

    OBJModel model;
    try {
      model = ((OBJModel) OBJLoader.INSTANCE
          .loadModel(new ResourceLocation("silentgems:models/block/" + suffix + ".obj")));
      return model;
    } catch (Exception e) {
      throw new ReportedException(new CrashReport("Error making the mode for " + suffix + "!", e));
    }
  }

  public static IModel retexture(OBJModel model, String toReplace, String suffix) {

    return (((OBJModel) model.retexture(ImmutableMap.of(toReplace, "silentgems:blocks/" + suffix)))
        .process(ImmutableMap.of("flip-v", "true")));
  }

  public static IBakedModel bake(IModel model) {

    return model.bake(TRSRTransformation.identity(), Attributes.DEFAULT_BAKED_FORMAT,
        ModelLoader.defaultTextureGetter());
  }

  public static void renderModel(IBakedModel model, int color) {

    Tessellator tessellator = Tessellator.getInstance();
    BufferBuilder buffer = tessellator.getBuffer();
    buffer.begin(GL11.GL_QUADS, DefaultVertexFormats.ITEM); //don't ask me why this fixes it...

    List<BakedQuad> quads = model.getQuads(null,null,0);

    for (BakedQuad bakedQuad : quads) {
      LightUtil.renderQuadColor(buffer, bakedQuad, color);
    }

    tessellator.draw();
  }
}
package net.silentchaos512.gems.client.render.models;

import net.minecraft.client.renderer.block.model.IBakedModel;
import net.minecraftforge.client.model.IModel;
import net.minecraftforge.client.model.obj.OBJModel;

public class ModelPylon {

    private IBakedModel pylonPassiveModel;
    private IBakedModel pylonBurnerModel;


    public ModelPylon()
    {
        //loading the model
        OBJModel model = ModelHelper.loadModel("chaospylon");

        //apply textures and orient correctly
        IModel pylonPassive = ModelHelper.retexture(model,"#chaospylon","chaospylonpassive");
        IModel pylonBurner = ModelHelper.retexture(model,"#chaospylon","chaospylonburner");

        //"turn on" the models
        pylonPassiveModel = ModelHelper.bake(pylonPassive);
        pylonBurnerModel = ModelHelper.bake(pylonBurner);
    }

    public void renderPylon(int pylonType)
    {
        switch (pylonType)
        {
            case 1:
                renderModel(pylonBurnerModel);
                break;
            default:
                renderModel(pylonPassiveModel);
        }
    }

    private void renderModel(IBakedModel model)
    {
        renderModel(model,-1);
    }

    private void renderModel(IBakedModel model, int color)
    {
        ModelHelper.renderModel(model,color);
    }
}
package net.silentchaos512.gems.client.render.models;

import net.minecraft.client.renderer.block.model.IBakedModel;
import net.minecraftforge.client.model.IModel;
import net.minecraftforge.client.model.obj.OBJModel;

public class ModelPylonPlates {


  public ModelPylonPlates() {
    // load
    OBJModel model = ModelHelper.loadModel("chaospylonplates");
    // retexture
    IModel pylonPlatesPassive = ModelHelper.retexture(model, "#skin.001", "chaospylonpassive");
    IModel pylonPlatesBurner = ModelHelper.retexture(model, "#skin.001", "chaospylonburner");
    // activate
    pylonPlatesPassiveModel = ModelHelper.bake(pylonPlatesPassive);
    pylonPlatesBurnerModel = ModelHelper.bake(pylonPlatesBurner);
  }

  public void renderPylonPlates(int pylonType) {
private void renderModel(IBakedModel model) {

  private void renderModel(IBakedModel model, int color) {

    ModelHelper.renderModel(model, color);
  }
}
#Sat Jul 01 15:26:00 CDT 2017
BUILD_NUM=202
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import org.openide.util.NbBundle;
import org.openide.util.RequestProcessor;

@TemplateRegistration(folder = "Persistence", position = 2, displayName = "#DBImportWizardDescriptor_displayName", iconBase = "org/netbeans/jpa/modeler/reveng/database/resource/JPA_FILE_ICON.png", description = "resource/JPA_DB_IMPORT_DESC.html")
public final class DBImportWizardDescriptor implements WizardDescriptor.InstantiatingIterator<WizardDescriptor> {

    private static final String PROP_HELPER = "wizard-helper"; //NOI18N
    private final WizardDescriptor.Panel<Data> delegate;

    private WizardDescriptor wizardDescriptor;
    private Project project;

    /**
     * Create a new instance of DelegatingWizardDescriptorPanel.
public HelpCtx getHelp() {
    public void readSettings(Data settings) {
        if (wizardDescriptor == null) {
            wizardDescriptor = (WizardDescriptor) settings;
//            project = Templates.getProject((WizardDescriptor) settings);
        }
        delegate.readSettings(settings);
    }
import org.openide.windows.WindowManager;

@ServiceProvider(service = JCREProcessor.class)
@TemplateRegistration(folder = "Persistence", position = 2, displayName = "#RevEngWizardDescriptor_displayName", iconBase = "org/netbeans/jpa/modeler/jcre/wizard/resource/JPA_FILE_ICON.png", description = "resource/JPA_JCRE_DESC.html")
public final class RevEngWizardDescriptor implements WizardDescriptor.InstantiatingIterator<WizardDescriptor>, JCREProcessor {

    private int index;
 * the License.
 */
@TemplateRegistration(folder = "Persistence", content = "JPADiagram.jpa"
, position=1, displayName="#template_name", category="persistence",description="TemplateHelp.html", requireProject=false)
@Messages("template_name=JPA Modeler")
package org.netbeans.jpa.modeler.specification.model.file;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import org.openobservatory.ooniprobe.R;

public class NetworkMeasurement {
    public final String testName;
    public boolean entry = false;
    public final long test_id;
    public int progress = 0;

    public final String json_file;
    public final String log_file;
    public Boolean running;
    public Boolean viewed;
    public int anomaly;

    public NetworkMeasurement(String name){
        this.testName = name;
        this.test_id = System.currentTimeMillis();
        this.log_file = "/test-"+ test_id +".log";
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	private static final String EMAIL_TEMPLATE = "email";
	private static final String BLOG_TEMPLATE = "blog";
	private static final String TWITTER_TEMPLATE = "tweet";
	private final File emailOutput = new File("target/email.txt");
	private final File blogOutput = new File("target/blog.md");
	private final File tweetOutput = new File("target/tweet.txt");
	private final ReleaserProperties props;

	public TemplateGenerator(ReleaserProperties props) {
		this.props = props;
	}

	public File email() {
private File file(File file) {
			if (file.exists()) {
				file.delete();
			}
			if (!file.createNewFile()) {
				throw new IllegalStateException("Couldn't create a file [" + file + "]");
			}
public void should_generate_email_from_template_for_tag_with_v_prefix() {
	}

	@Test
	public void should_generate_email_from_template_for_tag_without_v_prefix() {
		ReleaserProperties props = new ReleaserProperties();
		props.getPom().setBranch("Dalston.RELEASE");
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    · Fix: Prevent crash when moving a cache freshly loaded through send2cgeo to another list\n
    · Fix: Prevent crash when logging a trackable on some Xiaomi devices\n
    · Fix: Correctly display user name containing &amp; on main screen\n
    \n
    \n
    <b>2017.03.19:</b>\n
public void handleRegularMessage(final Message msg) {

        private void updateStatusMsg(final String msg) {
            final CachePopupFragment popup = popupRef.get();
            if (popup == null) {
                return;
            }
            popup.progress.setMessage(popup.getString(progressMessage)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
 * Copyright (C) 2012 OpenIntents.org
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
import java.util.ArrayList;
import java.util.HashMap;

import static com.veniosg.dir.fragment.PreferenceFragment.getMediaScanFromPreference;
import static com.veniosg.dir.util.CopyHelper.Operation.COPY;
import static com.veniosg.dir.view.PathController.OnDirectoryChangedListener;
public void onViewCreated(View view, Bundle savedInstanceState) {

        mPathBar = (PathController) getActivity().findViewById(R.id.pathview);
        mTransitionView = (AnimatedFileListContainer) view.findViewById(R.id.zoomview);

        // Handle mPath differently if we restore state or just initially create the view.
        if (savedInstanceState == null) {
public void onViewCreated(View view, Bundle savedInstanceState) {
            @Override
            public void directoryChanged(File newCurrentDir) {
                open(new FileHolder(newCurrentDir, getActivity()));
            }
        });
        if (savedInstanceState != null && savedInstanceState.getBoolean(INSTANCE_STATE_PATHBAR_MODE)) {
private void firstTimeAnimation(@SuppressWarnings("UnusedParameters") final View
        // Everyone hates lag on launch.
    }

    /**
     * Override this to handle initialization of list item long clicks.
     */
    private void initContextualActions() {
        if (mActionsEnabled) {
            getListView().setMultiChoiceModeListener(mMultiChoiceModeListener);
protected void onListVisibilityChanged(boolean visible) {

    @Override
    protected void onEmptyViewClicked() {
        mPathBar.cd(mPathBar.getCurrentDirectory().getParentFile());
    }

    public void closeActionMode() {
/* 
 * Copyright (C) 2007-2008 OpenIntents.org
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
import android.net.Uri;
import android.provider.MediaStore.Audio;
import android.provider.MediaStore.Video;
import android.text.format.DateFormat;
import android.text.format.Formatter;
import android.util.Log;
public static Intent getViewIntentFor(FileHolder fileholder, Context c) {
        return intent;
    }

    public static boolean isOk(File file) {
        // Check file state.
        boolean isFileOK = true;
        isFileOK &= file.exists();
        isFileOK &= file.isDirectory();
        // add more filters here..

        return isFileOK;
    }

    private static void launchFileIntent(Intent intent, Context c) {
     */
    File getInitialDirectory();

    /**
     * Sets the directory the parent activity showed first so that back behavior is fixed.
     *
import static android.view.inputmethod.EditorInfo.IME_ACTION_GO;
import static com.veniosg.dir.AnimationConstants.ANIM_DURATION;
import static com.veniosg.dir.AnimationConstants.IN_INTERPOLATOR;
import static com.veniosg.dir.util.FileUtils.isOk;
import static com.veniosg.dir.util.Utils.backWillExit;
import static com.veniosg.dir.view.CheatSheet.setup;
import static com.veniosg.dir.view.PathController.Mode.MANUAL_INPUT;
public boolean cd(File file) {
    public boolean cd(File file, boolean forceNoAnim) {
        boolean result;

        if (isOk(file)) {
            File oldDir = new File(mCurrentDirectory.getAbsolutePath());
            mCurrentDirectory = file;

public File getInitialDirectory() {
    }

    @Override
    public void setInitialDirectory(File initDir) {
        mInitialDirectory = initDir;
        cd(initDir);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void put(K key, V value) {
     * @return the value to which the specified key is mapped, or null if no value is mapped for the key
     */
    public V get(K key) {
        synchronized (internal) {
            // Run lazy check to clean cache
            lazyCheck();

            return internal.get(key);
        }
    }
public V get(K key) {
     * @return true if a mapping exists for the specified key
     */
    public boolean containsKey(K key) {
        synchronized (internal) {
            // Run lazy check to clean cache
            lazyCheck();

            return internal.containsKey(key);
        }
    }
public boolean containsKey(K key) {
     * @param key key to invalidate
     */
    public void invalidate(K key) {
        synchronized (internal) {
            // Run lazy check to clean cache
            lazyCheck();

            if (!internal.containsKey(key)) {
                // Value either not present or cleaned by lazy check. Either way, we're good
                return;
public void invalidateAll() {
    private void lazyCheck() {
        long now = System.currentTimeMillis();
        long nextExpiry = now + retention;
        for (Iterator<Map.Entry<Long, K>> iterator = expiry.entries().iterator(); iterator.hasNext();) {
            Map.Entry<Long, K> entry = iterator.next();

            if (entry.getKey() > now) {
                break;
            }

            iterator.remove();

            if (inUseCheck.run(internal.get(entry.getValue()))) {
                expiry.put(nextExpiry, entry.getValue());
                continue;
            }

            V value = internal.remove(entry.getValue());

            if (value == null) {
                continue;
            }

            postRemoval.run(value);
        }
    }

      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-shade-plugin</artifactId>
        <version>2.4.3</version>
        <configuration>
          <filters>
            <filter>

      <plugin>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.5.1</version>
        <configuration>
          <source>1.6</source>
          <target>1.6</target>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import android.support.v4.util.ArraySet;
import android.util.Log;

import java.util.Set;

/**
public void onCreate() {
    public int onStartCommand(Intent intent, int flags, int startId) {
        Log.d(TAG, "onStartCommand");

        int id = intent.getIntExtra("id", -1);
        Log.d(TAG, "id: " + id);
        if (id != -1) {
            NotificationManager notificationManager =
                    (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
            notificationManager.cancel(id);
        }

        Set<String> mutedGames = sharedPreferences.getStringSet(KEY_MUTE_GAMES, null);
public int onStartCommand(Intent intent, int flags, int startId) {

        mutedGamesCopy.add(String.valueOf(id));
        editor.putStringSet(KEY_MUTE_GAMES, mutedGamesCopy);
        editor.apply();

        return START_REDELIVER_INTENT;
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private boolean failFast = true;
    private boolean isolateInternalQueries;
    private boolean autocommit;

    public String getDefaultCatalog() {
        return defaultCatalog;
public String getDataSourceName() {
    public void setDataSourceName(final String dataSourceName) {
        this.dataSourceName = dataSourceName;
    }
}
protected Beans() {

    /**
     * Get new data source, from JNDI lookup or created via direct configuration
     * of Hikari pool. If jpaProperties contains dataSourceName a lookup will be
     * attempted If datasource not found via JNDI it will be
     *
     * @param jpaProperties the jpa properties
     * @return the data source
     */
    public static DataSource newDataSource(final AbstractJpaProperties jpaProperties) {
        final HikariDataSource bean = new HikariDataSource();

        final String dataSourceName = jpaProperties.getDataSourceName();
        if (StringUtils.isNotBlank(dataSourceName)) {
            try {
                final JndiDataSourceLookup dsLookup = new JndiDataSourceLookup();
public static DataSource newDataSource(final AbstractJpaProperties jpaProperties
                  */
                dsLookup.setResourceRef(false);
                final DataSource containerDataSource = dsLookup.getDataSource(dataSourceName);
                bean.setDataSource(containerDataSource);
                return bean;
            } catch (final DataSourceLookupFailureException e) {
                LOGGER.warn("Lookup of datasource [{}] failed due to {} "
                        + "falling back to configuration via JPA properties.", dataSourceName, e.getMessage());
            }
        }

        try {
            if (StringUtils.isNotBlank(jpaProperties.getDriverClass())) {
                bean.setDriverClassName(jpaProperties.getDriverClass());
            }
            bean.setJdbcUrl(jpaProperties.getUrl());
            bean.setUsername(jpaProperties.getUser());
            bean.setPassword(jpaProperties.getPassword());

            bean.setMaximumPoolSize(jpaProperties.getPool().getMaxSize());
            bean.setMinimumIdle(jpaProperties.getPool().getMinSize());
            bean.setIdleTimeout(jpaProperties.getIdleTimeout());
public static DataSource newDataSource(final AbstractJpaProperties jpaProperties
            bean.setConnectionTestQuery(jpaProperties.getHealthQuery());
            bean.setAllowPoolSuspension(jpaProperties.getPool().isSuspension());
            bean.setAutoCommit(jpaProperties.isAutocommit());
            bean.setLoginTimeout(Long.valueOf(jpaProperties.getPool().getMaxWait()).intValue());
            bean.setValidationTimeout(jpaProperties.getPool().getTimeoutMillis());
            return bean;
        } catch (final Exception e) {
connection. When using a container configured data source, many of the pool rela
If `dataSourceName` is specified but the JNDI lookup fails, a data source will be created with the configured 
(or default) CAS pool parameters.

The `dataSourceName` property can be either a JNDI name for the datasource or a resource name prefixed with 
`java:/comp/env/`. If it is a resource name then you need an entry in a `web.xml` that you can add to your
CAS overlay. It should contain an entry like this:
security.basic.realm=CAS
# cas.adminPagesSecurity.jdbc.driverClass=org.hsqldb.jdbcDriver
# cas.adminPagesSecurity.jdbc.idleTimeout=5000
# cas.adminPagesSecurity.jdbc.dataSourceName=
```

#### LDAP Authentication
the following settings are then relevant:
# cas.authn.attributeRepository.jdbc[0].pool.maxSize=18
# cas.authn.attributeRepository.jdbc[0].pool.maxWait=2000
# cas.authn.attributeRepository.jdbc[0].dataSourceName=
```

### Grouper
same IP address.
# cas.authn.throttle.jdbc.pool.maxSize=18
# cas.authn.throttle.jdbc.pool.maxWait=2000
# cas.authn.throttle.jdbc.dataSourceName=
```

## Adaptive Authentication
against the password on record determined by a configurable database query.
# cas.authn.jdbc.query[0].name=
# cas.authn.jdbc.query[0].order=0
# cas.authn.jdbc.query[0].dataSourceName=

# cas.authn.jdbc.query[0].fieldPassword=password
# cas.authn.jdbc.query[0].fieldExpired=
Searches for a user record by querying against a username and password; the user
# cas.authn.jdbc.search[0].name=
# cas.authn.jdbc.search[0].order=0
# cas.authn.jdbc.search[0].dataSourceName=

# cas.authn.jdbc.search[0].passwordEncoder.type=NONE|DEFAULT|STANDARD|BCRYPT|SCRYPT|PBKDF2|com.example.CustomPasswordEncoder
# cas.authn.jdbc.search[0].passwordEncoder.characterEncoding=
Authenticates a user by attempting to create a database connection using the use
# cas.authn.jdbc.bind[0].name=
# cas.authn.jdbc.bind[0].order=0
# cas.authn.jdbc.bind[0].dataSourceName=
# cas.authn.jdbc.bind[0].passwordEncoder.type=NONE|DEFAULT|STANDARD|BCRYPT|SCRYPT|PBKDF2|com.example.CustomPasswordEncoder
# cas.authn.jdbc.bind[0].passwordEncoder.characterEncoding=
# cas.authn.jdbc.bind[0].passwordEncoder.encodingAlgorithm=
is converted to hex before comparing it to the database value.
# cas.authn.jdbc.encode[0].name=
# cas.authn.jdbc.encode[0].order=0
# cas.authn.jdbc.encode[0].dataSourceName=
# cas.authn.jdbc.encode[0].passwordEncoder.type=NONE|DEFAULT|STANDARD|BCRYPT|SCRYPT|PBKDF2|com.example.CustomPasswordEncoder
# cas.authn.jdbc.encode[0].passwordEncoder.characterEncoding=
# cas.authn.jdbc.encode[0].passwordEncoder.encodingAlgorithm=
The encryption algorithm is set to `AES_128_CBC_HMAC_SHA_256`.
# cas.authn.mfa.trusted.jpa.driverClass=org.hsqldb.jdbcDriver
# cas.authn.mfa.trusted.jpa.idleTimeout=5000
# cas.authn.mfa.trusted.jpa.dataSourceName=

# cas.authn.mfa.trusted.jpa.pool.suspension=false
# cas.authn.mfa.trusted.jpa.pool.minSize=6
To learn more about this topic, [please review this guide](GoogleAuthenticator-A
# cas.authn.mfa.gauth.jpa.database.driverClass=org.hsqldb.jdbcDriver
# cas.authn.mfa.gauth.jpa.database.idleTimeout=5000
# cas.authn.mfa.gauth.jpa.database.dataSourceName=

# cas.authn.mfa.gauth.jpa.database.pool.suspension=false
# cas.authn.mfa.gauth.jpa.database.pool.minSize=6
Store audit logs inside a database.
# cas.audit.jdbc.driverClass=org.hsqldb.jdbcDriver
# cas.audit.jdbc.idleTimeout=5000
# cas.audit.jdbc.dataSourceName=

# cas.audit.jdbc.pool.suspension=false
# cas.audit.jdbc.pool.minSize=6
for authentication or attribute retrieval.
# cas.monitor.jdbc.driverClass=org.hsqldb.jdbcDriver
# cas.monitor.jdbc.idleTimeout=5000
# cas.monitor.jdbc.dataSourceName=
```

### LDAP Connection Pool
Decide how CAS should store authentication events inside a database instance.
# cas.events.jpa.driverClass=org.hsqldb.jdbcDriver
# cas.events.jpa.idleTimeout=5000
# cas.events.jpa.dataSourceName=

# cas.events.jpa.pool.suspension=false
# cas.events.jpa.pool.minSize=6
To learn more about this topic, [please review this guide](JPA-Service-Managemen
# cas.serviceRegistry.jpa.driverClass=org.hsqldb.jdbcDriver
# cas.serviceRegistry.jpa.idleTimeout=5000
# cas.serviceRegistry.jpa.dataSourceName=

# cas.serviceRegistry.jpa.pool.suspension=false
# cas.serviceRegistry.jpa.pool.minSize=6
To learn more about this topic, [please review this guide](JPA-Ticket-Registry.h
# cas.ticket.registry.jpa.driverClass=org.hsqldb.jdbcDriver
# cas.ticket.registry.jpa.idleTimeout=5000
# cas.ticket.registry.jpa.dataSourceName=

# cas.ticket.registry.jpa.pool.suspension=false
# cas.ticket.registry.jpa.pool.minSize=6
The following LDAP types are supported:
# cas.authn.pm.jdbc.driverClass=org.hsqldb.jdbcDriver
# cas.authn.pm.jdbc.idleTimeout=5000
# cas.authn.pm.jdbc.dataSourceName=

# cas.authn.pm.jdbc.passwordEncoder.type=NONE|DEFAULT|STANDARD|BCRYPT|SCRYPT|PBKDF2|com.example.CustomPasswordEncoder
# cas.authn.pm.jdbc.passwordEncoder.characterEncoding=
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public boolean accept(File dir, String name) {
            org.apache.commons.io.IOUtils.copy(
                new URL(ConfigurationManager.getProperty("dspace.url")
                    + "/discojuice/feeds").openStream(), writer);
            String jsonp = writer.toString();
            // end download
            String json = jsonp.substring(jsonp.indexOf("(") + 1,
                jsonp.lastIndexOf(")")); // strip the dj_md_1()
            Set<String> entities = new HashSet<String>();
            JSONParser parser = new JSONParser();
            JSONArray entityArray = (JSONArray) parser.parse(json);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * E013 - Validate schedule_relationship is UNSCHEDULED or empty
                     */
                    if (!(tripUpdate.getTrip().hasScheduleRelationship() || tripUpdate.getTrip().getScheduleRelationship().equals(GtfsRealtime.TripDescriptor.ScheduleRelationship.UNSCHEDULED))) {
                        OccurrenceModel om = new OccurrenceModel("trip_id " + tripUpdate.getTrip().getTripId() + " schedule_relationship " + tripUpdate.getTrip().getScheduleRelationship());
                        errorListE013.add(om);
                        _log.debug(om.getPrefix() + " " + E013.getOccurrenceSuffix());
                    /**
                     * E013 - Validate schedule_relationship is UNSCHEDULED or empty
                     */
                    if (!(vehiclePosition.getTrip().hasScheduleRelationship() || vehiclePosition.getTrip().getScheduleRelationship().equals(GtfsRealtime.TripDescriptor.ScheduleRelationship.UNSCHEDULED))) {
                        OccurrenceModel om = new OccurrenceModel("vehicle_id " + vehiclePosition.getVehicle().getId() + " trip_id " + vehiclePosition.getTrip().getTripId() + " schedule_relationship " + vehiclePosition.getTrip().getScheduleRelationship());
                        errorListE013.add(om);
                        _log.debug(om.getPrefix() + " " + E013.getOccurrenceSuffix());
public FrequencyTypeZeroTest() throws IOException {
    @Test
    public void testMissingStartDateAndTimeE006() {
        FrequencyTypeZero frequencyTypeZero = new FrequencyTypeZero();
        GtfsRealtime.TripDescriptor.Builder tripDescriptorBuilder = GtfsRealtime.TripDescriptor.newBuilder();

        feedHeaderBuilder.setTimestamp(MIN_POSIX_TIME);
        feedMessageBuilder.setHeader(feedHeaderBuilder.build());

        tripUpdateBuilder.setTimestamp(MIN_POSIX_TIME);
        tripUpdateBuilder.setTrip(tripDescriptorBuilder.build());
        feedEntityBuilder.setTripUpdate(tripUpdateBuilder);

        vehiclePositionBuilder.setTimestamp(MIN_POSIX_TIME);
        vehiclePositionBuilder.setTrip(tripDescriptorBuilder.build());
        feedEntityBuilder.setVehicle(vehiclePositionBuilder.build());

        feedMessageBuilder.setEntity(0, feedEntityBuilder.build());

        // Start with no start date or time - 2 errors
        results = frequencyTypeZero.validate(MIN_POSIX_TIME, bullRunnerGtfs, bullRunnerGtfsMetadata, feedMessageBuilder.build(), null);
        TestUtils.assertResults(E006, results, 2);

        // Set start date - 1 error
        tripDescriptorBuilder.setStartDate("4-24-2016");

        tripUpdateBuilder.setTrip(tripDescriptorBuilder.build());
public void testMissingStartDateAndTimeE006() {

        feedMessageBuilder.setEntity(0, feedEntityBuilder.build());

        // No start_time - 1 error
        results = frequencyTypeZero.validate(MIN_POSIX_TIME, bullRunnerGtfs, bullRunnerGtfsMetadata, feedMessageBuilder.build(), null);
        TestUtils.assertResults(E006, results, 1);

        // Set start time - 0 error
        tripDescriptorBuilder.setStartTime("08:00:00AM");
public void testMissingStartDateAndTimeE006() {
    @Test
    public void testScheduleRelationshipE013() {
        FrequencyTypeZero frequencyTypeZero = new FrequencyTypeZero();
        GtfsRealtime.TripDescriptor.Builder tripDescriptorBuilder = GtfsRealtime.TripDescriptor.newBuilder();

        feedHeaderBuilder.setTimestamp(MIN_POSIX_TIME);
        feedMessageBuilder.setHeader(feedHeaderBuilder.build());

        tripUpdateBuilder.setTimestamp(MIN_POSIX_TIME);
        tripUpdateBuilder.setTrip(tripDescriptorBuilder.build());
        feedEntityBuilder.setTripUpdate(tripUpdateBuilder);

        vehiclePositionBuilder.setTimestamp(MIN_POSIX_TIME);
        vehiclePositionBuilder.setTrip(tripDescriptorBuilder.build());
        feedEntityBuilder.setVehicle(vehiclePositionBuilder.build());

        feedMessageBuilder.setEntity(0, feedEntityBuilder.build());

        // Start with an empty schedule relationship - that should be fine for exact_times=0 trips - no errors
        results = frequencyTypeZero.validate(MIN_POSIX_TIME, bullRunnerGtfs, bullRunnerGtfsMetadata, feedMessageBuilder.build(), null);
        TestUtils.assertResults(E013, results, 0);

        // Change to UNSCHEDULED schedule relationship - this is also ok for exact_times=0 trips
        tripDescriptorBuilder.setScheduleRelationship(GtfsRealtime.TripDescriptor.ScheduleRelationship.UNSCHEDULED);
public void testScheduleRelationshipE013() {
        results = frequencyTypeZero.validate(MIN_POSIX_TIME, bullRunnerGtfs, bullRunnerGtfsMetadata, feedMessageBuilder.build(), null);
        TestUtils.assertResults(E013, results, 0);

        // Change to ADDED schedule relationship - not allowed for exact_times=0 trips - 1 error
        tripDescriptorBuilder.setScheduleRelationship(GtfsRealtime.TripDescriptor.ScheduleRelationship.ADDED);

        tripUpdateBuilder.setTrip(tripDescriptorBuilder.build());
public void testScheduleRelationshipE013() {
        feedMessageBuilder.setEntity(0, feedEntityBuilder.build());

        results = frequencyTypeZero.validate(MIN_POSIX_TIME, bullRunnerGtfs, bullRunnerGtfsMetadata, feedMessageBuilder.build(), null);
        TestUtils.assertResults(E013, results, 1);

        // Change to CANCELED schedule relationship - not allowed for exact_times=0 trips - 1 error
        tripDescriptorBuilder.setScheduleRelationship(GtfsRealtime.TripDescriptor.ScheduleRelationship.CANCELED);

        tripUpdateBuilder.setTrip(tripDescriptorBuilder.build());
public void testScheduleRelationshipE013() {
        feedMessageBuilder.setEntity(0, feedEntityBuilder.build());

        results = frequencyTypeZero.validate(MIN_POSIX_TIME, bullRunnerGtfs, bullRunnerGtfsMetadata, feedMessageBuilder.build(), null);
        TestUtils.assertResults(E013, results, 1);

        // Change to SCHEDULED schedule relationship - not allowed for exact_times=0 trips - 1 error
        tripDescriptorBuilder.setScheduleRelationship(GtfsRealtime.TripDescriptor.ScheduleRelationship.SCHEDULED);

        tripUpdateBuilder.setTrip(tripDescriptorBuilder.build());
public void testScheduleRelationshipE013() {
        feedMessageBuilder.setEntity(0, feedEntityBuilder.build());

        results = frequencyTypeZero.validate(MIN_POSIX_TIME, bullRunnerGtfs, bullRunnerGtfsMetadata, feedMessageBuilder.build(), null);
        TestUtils.assertResults(E013, results, 1);

        clearAndInitRequiredFeedFields();
    }
public void testScheduleRelationshipE013() {
    public void testMissingVehicleIdW005() {
        FrequencyTypeZero frequencyTypeZero = new FrequencyTypeZero();
        GtfsRealtime.TripDescriptor.Builder tripDescriptorBuilder = GtfsRealtime.TripDescriptor.newBuilder();
        GtfsRealtime.VehicleDescriptor.Builder vehicleDescriptorBuilder = GtfsRealtime.VehicleDescriptor.newBuilder();

        feedHeaderBuilder.setTimestamp(MIN_POSIX_TIME);
public void testMissingVehicleIdW005() {

        // Both have vehicle_id - no warnings
        results = frequencyTypeZero.validate(MIN_POSIX_TIME, bullRunnerGtfs, bullRunnerGtfsMetadata, feedMessageBuilder.build(), null);
        TestUtils.assertResults(W005, results, 1);

        clearAndInitRequiredFeedFields();
    }
public void testTripIdAndRouteIdValidation() {
        results = tripIdValidator.validate(MIN_POSIX_TIME, gtfsData, gtfsDataMetadata, feedMessageBuilder.build(), null);
        TestUtils.assertResults(ValidationRules.W006, results, 2);

        // setting valid trip_id = 1.1, route_id 1.1 that match with IDs in static Gtfs data
        tripDescriptorBuilder.setTripId("1.1");
        tripDescriptorBuilder.setRouteId("1");
        tripUpdateBuilder.setTrip(tripDescriptorBuilder.build());
public void testTripIdAndRouteIdValidation() {
        results = tripIdValidator.validate(MIN_POSIX_TIME, gtfsData, gtfsDataMetadata, feedMessageBuilder.build(), null);
        TestUtils.assertResults(ValidationRules.E003, results, 2);

        // Set that trip_id is ADDED - should go back to 1 error, as it's ok for trip_id to not be in the GTFS data
        tripDescriptorBuilder.setScheduleRelationship(GtfsRealtime.TripDescriptor.ScheduleRelationship.ADDED);
        tripUpdateBuilder.setTrip(tripDescriptorBuilder.build());
        vehiclePositionBuilder.setTrip(tripDescriptorBuilder.build());
public void testTripIdAndRouteIdValidation() {
        feedMessageBuilder.setEntity(0, feedEntityBuilder.build());

        results = tripIdValidator.validate(MIN_POSIX_TIME, gtfsData, gtfsDataMetadata, feedMessageBuilder.build(), null);
        TestUtils.assertResults(ValidationRules.E003, results, 2);

        clearAndInitRequiredFeedFields();
    }
public void testTimestampValidationW008() {
        // Set valid trip_id = 1.1
        tripDescriptorBuilder.setTripId("1.1");

        long currentTimeSec = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis());

        /**
         * Use current time - no warnings
public void testTimestampValidationW008() {

        GtfsRealtime.FeedMessage currentIteration = feedMessageBuilder.setEntity(0, feedEntityBuilder.build()).build();

        results = timestampValidation.validate(MIN_POSIX_TIME, gtfsData, gtfsDataMetadata, currentIteration, null);
        TestUtils.assertResults(W008, results, 0);

        /**
public void testTimestampValidationW008() {

        currentIteration = feedMessageBuilder.setEntity(0, feedEntityBuilder.build()).build();

        results = timestampValidation.validate(MIN_POSIX_TIME, gtfsData, gtfsDataMetadata, currentIteration, null);
        TestUtils.assertResults(W008, results, 1);

        clearAndInitRequiredFeedFields();
public void testTimestampValidationE001() {
        /**
         * Header isn't POSIX - should be 1 error
         */
        feedHeaderBuilder.setTimestamp(TimeUnit.SECONDS.toMillis(MIN_POSIX_TIME));
        feedMessageBuilder.setHeader(feedHeaderBuilder.build());
        feedMessageBuilder.setEntity(0, feedEntityBuilder.build());

        TestUtils.assertResults(E001, results, 1);

        /**
         * Header and TripUpdate aren't POSIX - 2 errors
         */
        tripUpdateBuilder.setTimestamp(TimeUnit.SECONDS.toMillis(MIN_POSIX_TIME));
        tripUpdateBuilder.setTrip(tripDescriptorBuilder.build());
        feedEntityBuilder.setTripUpdate(tripUpdateBuilder);

public void testTimestampValidationE001() {
        /**
         * Header, TripUpdate, and VehiclePosition aren't POSIX - 3 errors
         */
        vehiclePositionBuilder.setTimestamp(TimeUnit.SECONDS.toMillis(MIN_POSIX_TIME));
        feedEntityBuilder.setVehicle(vehiclePositionBuilder.build());

        feedMessageBuilder.setEntity(0, feedEntityBuilder.build());
public void testTimestampValidationE001() {
         */

        // First StopTimeUpdate
        stopTimeUpdateBuilder.setArrival(stopTimeEventBuilder.setTime(TimeUnit.SECONDS.toMillis(MIN_POSIX_TIME)));
        stopTimeUpdateBuilder.setDeparture(stopTimeEventBuilder.setTime(TimeUnit.SECONDS.toMillis(MIN_POSIX_TIME)));
        tripUpdateBuilder.addStopTimeUpdate(0, stopTimeUpdateBuilder.build());

        // Second StopTimeUpdate
        stopTimeUpdateBuilder.setArrival(stopTimeEventBuilder.setTime(TimeUnit.SECONDS.toMillis(MAX_POSIX_TIME)));
        stopTimeUpdateBuilder.setDeparture(stopTimeEventBuilder.setTime(TimeUnit.SECONDS.toMillis(MAX_POSIX_TIME)));
        tripUpdateBuilder.addStopTimeUpdate(1, stopTimeUpdateBuilder.build());

        feedEntityBuilder.setTripUpdate(tripUpdateBuilder);
public void testTimestampValidationE001() {
        /**
         * Alert active_period ranges - neither start nor end are valid POSIX, so 2 errors
         */
        timeRangeBuilder.setStart(MIN_POSIX_TIME - 1);
        timeRangeBuilder.setEnd(MIN_POSIX_TIME - 1);

        alertBuilder.addActivePeriod(timeRangeBuilder.build());
        feedEntityBuilder.setAlert(alertBuilder);
public void testTimestampValidationE012() {
        /**
         * Header timestamp equal to other entities - no error
         */
        tripUpdateBuilder.setTimestamp(MIN_POSIX_TIME);
        tripUpdateBuilder.setTrip(tripDescriptorBuilder.build());
        feedEntityBuilder.setTripUpdate(tripUpdateBuilder);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import static com.afollestad.aesthetic.Util.setLightStatusBarCompat;
import static com.afollestad.aesthetic.Util.setNavBarColorCompat;

/**
 * @author Aidan Follestad (afollestad)
 */
@SuppressWarnings({"WeakerAccess", "unused"})
public class Aesthetic {

private static String key(@Nullable AppCompatActivity activity) {
    return key;
  }

  /**
   * Should be called before super.onCreate() in each Activity.
   */
  @NonNull
  public static Aesthetic attach(@NonNull AppCompatActivity activity) {
    if (instance == null) {
public static Aesthetic get() {
    return instance;
  }

  /**
   * Should be called in onPause() of each Activity.
   */
  public static void pause(@NonNull AppCompatActivity activity) {
    if (instance == null) {
      return;
public static void pause(@NonNull AppCompatActivity activity) {
    }
  }

  /**
   * Should be called in onResume() of each Activity.
   */
  public static void resume(@NonNull AppCompatActivity activity) {
    if (instance == null) {
      return;
public void accept(@io.reactivex.annotations.NonNull Integer themeId) {
                onErrorLogAndRethrow()));
    instance.subs.add(
        Observable.combineLatest(
            instance.colorStatusBar(),
            instance.lightStatusBarMode(),
            new BiFunction<Integer, Integer, Pair<Integer, Integer>>() {
              @Override
              public Pair<Integer, Integer> apply(Integer integer, Integer integer2) {
                return Pair.create(integer, integer2);
              }
            })
            .compose(Rx.<Pair<Integer, Integer>>distinctToMainThread())
            .subscribe(
                new Consumer<Pair<Integer, Integer>>() {
static int resolveColor(Context context, @AttrRes int attr, int fallback) {
    TypedArray a = context.getTheme().obtainStyledAttributes(new int[] {attr});
    try {
      return a.getColor(0, fallback);
    } finally {
      a.recycle();
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
package medic.gateway.alert;

import android.os.Bundle;
import android.util.SparseArray;
import android.view.View;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.ListView;

import android.support.v4.app.FragmentActivity;

import static medic.gateway.alert.GatewayLog.*;
import static medic.gateway.alert.Utils.*;
import static medic.gateway.alert.WoMessage.Status.*;

public class WoListActivity extends FragmentActivity {
	private SparseArray<String> checklist;

	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.message_list_wo);

		((Button) findViewById(R.id.btnRefreshWoMessageList))
				.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) { refreshList(); }
public void onCreate(Bundle savedInstanceState) {
			public void onClick(View v) { retrySelected(); }
		});

		((Button) findViewById(R.id.btnSelectNewer))
				.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) { selectNewer(); }
		});

		refreshList();
	}

	void updateChecked(String id, int position, boolean isChecked) {
		if(isChecked) checklist.put(position, id);
		else checklist.delete(position);

		findViewById(R.id.btnRetrySelected).setEnabled(checklist.size() > 0);
		findViewById(R.id.btnSelectNewer).setEnabled(checklist.size() > 0);
	}

	private void refreshList() {
		checklist = new SparseArray<String>();

		getSupportLoaderManager().restartLoader(WoListFragment.LOADER_ID, null, getFragment());

		findViewById(R.id.btnRetrySelected).setEnabled(false);
		findViewById(R.id.btnSelectNewer).setEnabled(false);
	}

	private void retrySelected() {
		for(int i=checklist.size()-1; i>=0; --i) {
			getFragment().retry(checklist.valueAt(i), checklist.keyAt(i));
		}
	}

	private void selectNewer() {
		int lastSelectedIndex = checklist.keyAt(checklist.size() - 1);
		for(int i=lastSelectedIndex-1; i>=0; --i) {
			((CheckBox) getList().getChildAt(i).findViewById(R.id.cbxMessage)).setChecked(true);
		}
	}

	private WoListFragment getFragment() {
		return (WoListFragment) getSupportFragmentManager()
				.findFragmentById(R.id.lstWoMessages);
	}

	private ListView getList() {
		return getFragment().getListView();
	}
}
package medic.gateway.alert;

import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.database.Cursor;
import android.os.AsyncTask;
import android.os.Bundle;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.ListView;
import android.support.v4.widget.CursorAdapter;
import android.support.v4.widget.ResourceCursorAdapter;

import java.util.Collections;
import java.util.List;
import java.util.LinkedList;

import static medic.gateway.alert.GatewayLog.logException;
import static medic.gateway.alert.GatewayLog.trace;
import static medic.gateway.alert.Utils.absoluteTimestamp;
import static medic.gateway.alert.Utils.relativeTimestamp;
import static medic.gateway.alert.Utils.setText;
import static medic.gateway.alert.Utils.showSpinner;
import static medic.gateway.alert.WoMessage.Status.FAILED;
import static medic.gateway.alert.WoMessage.Status.UNSENT;

public class WoListFragment extends ListFragment implements LoaderCallbacks<Cursor> {
	public static final int LOADER_ID = 3;

	private static final DialogInterface.OnClickListener NO_CLICK_LISTENER = null;

	private Db db;

	@Override public void onActivityCreated(Bundle savedInstanceState) {
		super.onActivityCreated(savedInstanceState);

		this.db = Db.getInstance(getActivity());

		WoCursorAdapter adapter = new WoCursorAdapter(getCastActivity());
		setListAdapter(adapter);
		getLoaderManager().initLoader(LOADER_ID, null, this);
public void onListItemClick(ListView list, View view, int position, long id) {
		// more recently than the list
		WoMessage m = Db.getInstance(getActivity()).getWoMessage(c.getString(0));

		showMessageDetailDialog(m, position);
	}

	private void showMessageDetailDialog(final WoMessage m, final int position) {
		final ProgressDialog spinner = showSpinner(getContext());
		AsyncTask.execute(new Runnable() {
			public void run() {
				try {
					LinkedList<String> content = new LinkedList<>();

					content.add(string(R.string.lblTo, m.to));
					content.add(string(R.string.lblContent, m.content));
					content.add(string(R.string.lblStatusUpdates));

					List<WoMessage.StatusUpdate> updates = db.getStatusUpdates(m);
					Collections.reverse(updates);
					for(WoMessage.StatusUpdate u : updates) {
						String status;
						if(u.newStatus == FAILED) {
							status = String.format("%!s(MISSING) (%!s(MISSING))", u.newStatus, u.failureReason);
						} else {
							status = u.newStatus.toString();
						}
						content.add(String.format("%!s(MISSING): %!s(MISSING)", absoluteTimestamp(u.timestamp), status));
					}

					final AlertDialog.Builder dialog = new AlertDialog.Builder(getActivity());

					if(m.status.canBeRetried()) {
						dialog.setPositiveButton(R.string.btnRetry, new DialogInterface.OnClickListener() {
							@Override
							public void onClick(DialogInterface dialog, int which) {
								retry(m.id, position);
							}
						});
					}

					dialog.setItems(content.toArray(new String[content.size()]), NO_CLICK_LISTENER);

					getActivity().runOnUiThread(new Runnable() {
						public void run() { dialog.create().show(); }
					});
				} catch(Exception ex) {
					logException(getContext(), ex, "Failed to load WO message details.");
				} finally {
					spinner.dismiss();
				}
			}
		});
	}

	void retry(String id, int position) {
		trace(this, "Retrying message at %!d(MISSING) with id %!s(MISSING)...", position, id);

		WoMessage m = db.getWoMessage(id);

		if(m.status.canBeRetried()) {
			db.updateStatus(m, UNSENT);

			WoMessage updated = db.getWoMessage(id);

			View v = getListView().getChildAt(position);
			setText(v, R.id.txtWoStatus, updated.status.toString());
			setText(v, R.id.txtWoLastAction, relativeTimestamp(updated.lastAction));
		}
	}

	private final String string(int stringId, Object...args) {
		return String.format(getActivity().getString(stringId), args);
	}
}

public void bindView(View v, final Context ctx, Cursor c) {
		CheckBox cbx = (CheckBox) v.findViewById(R.id.cbxMessage);
		// Old list items get re-used, so we need to make sure that the
		// checkbox is de-checked.
		cbx.setChecked(false);
		cbx.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
			@Override
			public void onCheckedChanged(CompoundButton btn, boolean isChecked) {
				View listItem = (View) btn.getParent();
				ViewGroup parent = (ViewGroup) listItem.getParent();

				if(parent == null) return;

				int listIndex = parent.indexOfChild(listItem);

				trace(this, "Changed checkbox at %!d(MISSING) to %!s(MISSING)", listIndex, isChecked);

				activity.updateChecked(m.id, listIndex, isChecked);
			}
		});
	}
package medic.gateway.alert;

import android.os.Bundle;
import android.util.SparseArray;
import android.view.View;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.ListView;

import android.support.v4.app.FragmentActivity;

import static medic.gateway.alert.GatewayLog.*;
import static medic.gateway.alert.Utils.*;
import static medic.gateway.alert.WtMessage.Status.*;

public class WtListActivity extends FragmentActivity {
	private SparseArray<String> checklist;

	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.message_list_wt);

		((Button) findViewById(R.id.btnRefreshWtMessageList))
				.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) { refreshList(); }
public void onCreate(Bundle savedInstanceState) {
			public void onClick(View v) { retrySelected(); }
		});

		((Button) findViewById(R.id.btnSelectNewer))
				.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) { selectNewer(); }
		});

		refreshList();
	}

	void updateChecked(String id, int position, boolean isChecked) {
		if(isChecked) checklist.put(position, id);
		else checklist.delete(position);

		findViewById(R.id.btnRetrySelected).setEnabled(checklist.size() > 0);
		findViewById(R.id.btnSelectNewer).setEnabled(checklist.size() > 0);
	}

	private void refreshList() {
		checklist = new SparseArray<String>();

		getSupportLoaderManager().restartLoader(WtListFragment.LOADER_ID, null, getFragment());

		findViewById(R.id.btnRetrySelected).setEnabled(false);
		findViewById(R.id.btnSelectNewer).setEnabled(false);
	}

	private void retrySelected() {
		for(int i=checklist.size()-1; i>=0; --i) {
			getFragment().retry(checklist.valueAt(i), checklist.keyAt(i));
		}
	}

	private void selectNewer() {
		int lastSelectedIndex = checklist.keyAt(checklist.size() - 1);
		for(int i=lastSelectedIndex-1; i>=0; --i) {
			((CheckBox) getList().getChildAt(i).findViewById(R.id.cbxMessage)).setChecked(true);
		}
	}

	private WtListFragment getFragment() {
		return (WtListFragment) getSupportFragmentManager()
				.findFragmentById(R.id.lstWtMessages);
	}

	private ListView getList() {
		return getFragment().getListView();
	}
}
package medic.gateway.alert;

import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.database.Cursor;
import android.os.AsyncTask;
import android.os.Bundle;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.ListView;
import android.support.v4.widget.CursorAdapter;
import android.support.v4.widget.ResourceCursorAdapter;

import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

import medic.gateway.alert.WtMessage.Status;

import static medic.gateway.alert.GatewayLog.logException;
import static medic.gateway.alert.GatewayLog.trace;
import static medic.gateway.alert.Utils.absoluteTimestamp;
import static medic.gateway.alert.Utils.relativeTimestamp;
import static medic.gateway.alert.Utils.setText;
import static medic.gateway.alert.Utils.showSpinner;
import static medic.gateway.alert.WtMessage.Status.WAITING;

public class WtListFragment extends ListFragment implements LoaderCallbacks<Cursor> {
	public static final int LOADER_ID = 2;

	private static final DialogInterface.OnClickListener NO_CLICK_LISTENER = null;

	private Db db;

	@Override public void onActivityCreated(Bundle savedInstanceState) {
		super.onActivityCreated(savedInstanceState);

		this.db = Db.getInstance(getActivity());

		WtCursorAdapter adapter = new WtCursorAdapter(getCastActivity());
		setListAdapter(adapter);
		getLoaderManager().initLoader(LOADER_ID, null, this);
public void onListItemClick(ListView list, View view, int position, long id) {
		// more recently than the list
		WtMessage m = Db.getInstance(getActivity()).getWtMessage(c.getString(0));

		showMessageDetailDialog(m, position);
	}

	private void showMessageDetailDialog(final WtMessage m, final int position) {
		final ProgressDialog spinner = showSpinner(getContext());
		AsyncTask.execute(new Runnable() {
			public void run() {
				try {
					LinkedList<String> content = new LinkedList<>();

					content.add(string(R.string.lblFrom, m.from));
					content.add(string(R.string.lblContent, m.content));
					content.add(string(R.string.lblStatusUpdates));

					List<WtMessage.StatusUpdate> updates = db.getStatusUpdates(m);
					Collections.reverse(updates);
					for(WtMessage.StatusUpdate u : updates) {
						content.add(String.format("%!s(MISSING): %!s(MISSING)", absoluteTimestamp(u.timestamp), u.newStatus));
					}

					final AlertDialog.Builder dialog = new AlertDialog.Builder(getActivity());

					if(m.getStatus().canBeRetried()) {
						dialog.setPositiveButton(R.string.btnRetry, new DialogInterface.OnClickListener() {
							@Override
							public void onClick(DialogInterface dialog, int which) {
								retry(m.id, position);
							}
						});
					}

					dialog.setItems(content.toArray(new String[content.size()]), NO_CLICK_LISTENER);

					getActivity().runOnUiThread(new Runnable() {
						public void run() { dialog.create().show(); }
					});
				} catch(Exception ex) {
					logException(getContext(), ex, "Failed to load WO message details.");
				} finally {
					spinner.dismiss();
				}
			}
		});
	}

	void retry(String id, int position) {
		trace(this, "Retrying message at %!d(MISSING) with id %!s(MISSING)...", position, id);

		WtMessage m = db.getWtMessage(id);

		if(m.getStatus().canBeRetried()) {
			Status oldStatus = m.getStatus();
			m.setStatus(WAITING);
			db.updateStatusFrom(oldStatus, m);

			WtMessage updated = db.getWtMessage(id);

			View v = getListView().getChildAt(position);
			setText(v, R.id.txtWtStatus, updated.getStatus().toString());
			setText(v, R.id.txtWtLastAction, relativeTimestamp(updated.getLastAction()));
		}
	}

	private final String string(int stringId, Object...args) {
		return String.format(getActivity().getString(stringId), args);
	}
}

class WtCursorAdapter extends ResourceCursorAdapter {
	private static final int NO_FLAGS = 0;

	public WtCursorAdapter(Context ctx) {
		super(ctx, R.layout.wt_list_item, null, NO_FLAGS);
	}

	public void bindView(View v, final Context ctx, Cursor c) {
public void bindView(View v, final Context ctx, Cursor c) {
		CheckBox cbx = (CheckBox) v.findViewById(R.id.cbxMessage);
		// Old list items get re-used, so we need to make sure that the
		// checkbox is de-checked.
		cbx.setChecked(false);
		cbx.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
			@Override
			public void onCheckedChanged(CompoundButton btn, boolean isChecked) {
				View listItem = (View) btn.getParent();
				ViewGroup parent = (ViewGroup) listItem.getParent();

				if(parent == null) return;

				int listIndex = parent.indexOfChild(listItem);

				trace(this, "Changed checkbox at %!d(MISSING) to %!s(MISSING)", listIndex, isChecked);

				((WtListActivity) ctx).updateChecked(m.id, listIndex, isChecked);
			}
		});
	}
				android:layout_width="wrap_content"
				android:layout_height="wrap_content"
				/>
		<Button android:id="@+id/btnSelectNewer"
				android:text="@string/btnSelectNewer"
				android:layout_width="wrap_content"
				android:layout_height="wrap_content"
				/>
		<Button android:id="@+id/btnRetrySelected"
				android:text="@string/btnRetrySelected"
				android:layout_width="wrap_content"
				android:layout_width="wrap_content"
				android:layout_height="wrap_content"
				/>
		<Button android:id="@+id/btnSelectNewer"
				android:text="@string/btnSelectNewer"
				android:layout_width="wrap_content"
				android:layout_height="wrap_content"
				/>
		<Button android:id="@+id/btnRetrySelected"
				android:text="@string/btnRetrySelected"
				android:layout_width="wrap_content"
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private AudioFragment getAudioFragment() {
            FragmentActivity parent = getActivity();
            if (parent != null) {
                fragment = new AudioFragment();
                FragmentManager fm = parent.getSupportFragmentManager();
                fm.beginTransaction()
                    .add(fragment, "audio")
                    .commit();
                // commit immediately please
                fm.executePendingTransactions();
            }
        }

protected boolean isNormalUpNavigation() {

    private void setComposeFragment(@NonNull AbstractComposeFragment f) {
        mFragment = f;
        FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
        ft.replace(R.id.fragment_compose_message, f);
        ft.setTransition(FragmentTransaction.TRANSIT_NONE);
        ft.commitAllowingStateLoss();
        getSupportFragmentManager().executePendingTransactions();
    }

    @Override
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
protected void updateView()
		if(lastDisplayedRect != null && lastDisplayedRect.equals(tilesRect)) return;
		lastDisplayedRect = tilesRect;

		// TODO remove when error has been found and fixed
		// normally should be <= 4 on small screens, but crash happens at 10000k+, so be generous here (large tablet screens)
		if(tilesRect.width() * tilesRect.height() > 32)
		{
			throw new RuntimeException("Tried to display quests in a rectangle of "
					+ tilesRect.width() + "x" + tilesRect.height() + " tiles, current zoom is " +
					controller.getZoom() + ". Currently displayed area by screen borders is minlat=" +
					displayedArea.getMinLatitude() + ", minlon=" + displayedArea.getMinLongitude() +
					", maxlat=" + displayedArea.getMaxLatitude() + ", maxlon=" + displayedArea.getMaxLongitude());
		}

		List<Point> tiles = SlippyMapMath.asTileList(tilesRect);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    · Fix: Prevent crash when logging a trackable on some Xiaomi devices\n
    · Fix: Correctly display user name containing &amp; on main screen\n
    · Fix: Fix crash when dismissing cache popup dialog at the wrong time\n
    \n
    \n
    <b>2017.03.19:</b>\n
public void handleRegularMessage(final Message msg) {
            if (waitDialog != null) {
                if (msg.what == UPDATE_PROGRESS) {
                    final int secondsElapsed = (int) ((System.currentTimeMillis() - detailProgressTime) / 1000);
                    final int secondsRemaining = (detailTotal - detailProgress) * secondsElapsed / detailProgress;

                    waitDialog.setProgress(detailProgress);
                    if (secondsRemaining < 40) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
apply plugin: 'net.minecraftforge.gradle.forge'
//    id "net.minecraftforge.gradle.forge" version "2.0.2"
//}

version = "2.4.0"
def silentlib_version = "2.2.5"
def buildNum = 0
group = "net.silentchaos512.gems"
archivesBaseName = "SilentsGems-1.12"
package net.silentchaos512.gems.client.render.models;

import java.util.List;

import org.lwjgl.opengl.GL11;

import com.google.common.collect.ImmutableMap;

import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.block.model.BakedQuad;
import net.minecraft.client.renderer.block.model.IBakedModel;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.crash.CrashReport;
import net.minecraft.util.ReportedException;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.client.model.Attributes;
import net.minecraftforge.client.model.IModel;
import net.minecraftforge.client.model.ModelLoader;
import net.minecraftforge.client.model.obj.OBJLoader;
import net.minecraftforge.client.model.obj.OBJModel;
import net.minecraftforge.client.model.pipeline.LightUtil;
import net.minecraftforge.common.model.TRSRTransformation;

public class ModelHelper {

  public static OBJModel loadModel(String suffix) {

    OBJModel model;
    try {
      model = ((OBJModel) OBJLoader.INSTANCE
          .loadModel(new ResourceLocation("silentgems:models/block/" + suffix + ".obj")));
      return model;
    } catch (Exception e) {
      throw new ReportedException(new CrashReport("Error making the mode for " + suffix + "!", e));
    }
  }

  public static IModel retexture(OBJModel model, String toReplace, String suffix) {

    return (((OBJModel) model.retexture(ImmutableMap.of(toReplace, "silentgems:blocks/" + suffix)))
        .process(ImmutableMap.of("flip-v", "true")));
  }

  public static IBakedModel bake(IModel model) {

    return model.bake(TRSRTransformation.identity(), Attributes.DEFAULT_BAKED_FORMAT,
        ModelLoader.defaultTextureGetter());
  }

  public static void renderModel(IBakedModel model, int color) {

    Tessellator tessellator = Tessellator.getInstance();
    BufferBuilder buffer = tessellator.getBuffer();
    buffer.begin(GL11.GL_QUADS, DefaultVertexFormats.ITEM); //don't ask me why this fixes it...

    List<BakedQuad> quads = model.getQuads(null,null,0);

    for (BakedQuad bakedQuad : quads) {
      LightUtil.renderQuadColor(buffer, bakedQuad, color);
    }

    tessellator.draw();
  }
}
package net.silentchaos512.gems.client.render.models;

import net.minecraft.client.renderer.block.model.IBakedModel;
import net.minecraftforge.client.model.IModel;
import net.minecraftforge.client.model.obj.OBJModel;

public class ModelPylon {

    private IBakedModel pylonPassiveModel;
    private IBakedModel pylonBurnerModel;


    public ModelPylon()
    {
        //loading the model
        OBJModel model = ModelHelper.loadModel("chaospylon");

        //apply textures and orient correctly
        IModel pylonPassive = ModelHelper.retexture(model,"#chaospylon","chaospylonpassive");
        IModel pylonBurner = ModelHelper.retexture(model,"#chaospylon","chaospylonburner");

        //"turn on" the models
        pylonPassiveModel = ModelHelper.bake(pylonPassive);
        pylonBurnerModel = ModelHelper.bake(pylonBurner);
    }

    public void renderPylon(int pylonType)
    {
        switch (pylonType)
        {
            case 1:
                renderModel(pylonBurnerModel);
                break;
            default:
                renderModel(pylonPassiveModel);
        }
    }

    private void renderModel(IBakedModel model)
    {
        renderModel(model,-1);
    }

    private void renderModel(IBakedModel model, int color)
    {
        ModelHelper.renderModel(model,color);
    }
}
package net.silentchaos512.gems.client.render.models;

import net.minecraft.client.renderer.block.model.IBakedModel;
import net.minecraftforge.client.model.IModel;
import net.minecraftforge.client.model.obj.OBJModel;

public class ModelPylonPlates {


  public ModelPylonPlates() {
    // load
    OBJModel model = ModelHelper.loadModel("chaospylonplates");
    // retexture
    IModel pylonPlatesPassive = ModelHelper.retexture(model, "#skin.001", "chaospylonpassive");
    IModel pylonPlatesBurner = ModelHelper.retexture(model, "#skin.001", "chaospylonburner");
    // activate
    pylonPlatesPassiveModel = ModelHelper.bake(pylonPlatesPassive);
    pylonPlatesBurnerModel = ModelHelper.bake(pylonPlatesBurner);
  }

  public void renderPylonPlates(int pylonType) {
private void renderModel(IBakedModel model) {

  private void renderModel(IBakedModel model, int color) {

    ModelHelper.renderModel(model, color);
  }
}
#Sat Jul 01 15:26:00 CDT 2017
BUILD_NUM=202
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import static com.alpha.pineapple.docker.DockerConstants.BUILD_IMAGE_URI;
import static com.alpha.pineapple.docker.DockerConstants.CONTENT_TYPE_KEY;
import static com.alpha.pineapple.docker.DockerConstants.CONTENT_TYPE_TAR;
import static com.alpha.pineapple.docker.utils.ModelUtils.containsErrorMessage;
import static com.alpha.pineapple.docker.utils.ModelUtils.containsStatusUpdate;
import static com.alpha.pineapple.docker.utils.ModelUtils.containsStreamUpdate;
import static com.alpha.pineapple.docker.utils.ModelUtils.isImageCreationSuccessful;
import static com.alpha.pineapple.docker.utils.ModelUtils.remoteLfFromStreamUpdate;
import static com.alpha.pineapple.execution.ExecutionResult.MSG_MESSAGE;

import com.alpha.pineapple.command.initialization.ValidationPolicy;
import com.alpha.pineapple.docker.DockerClient;
import com.alpha.pineapple.docker.model.ImageInfo;
import com.alpha.pineapple.docker.model.rest.ErrorDetail;
import com.alpha.pineapple.docker.model.rest.ImageCreation;
import com.alpha.pineapple.docker.session.DockerSession;
import com.alpha.pineapple.execution.ExecutionResult;
import com.alpha.pineapple.i18n.MessageProvider;
import com.alpha.pineapple.session.SessionException;
 */
public class BuildImageCommand implements Command {

    /**
     * Null image creation info's.
     */
    static final ImageCreation[] NULL_INFOS = {};

    /**
     * Single digit string representation for boolean true.
     */
    static final String TRUE_AS_DIGIT = "1";

    /**
     * Single digit string representation for boolean false.
     */
    static final String FALSE_AS_DIGIT = "0";

    /**
     * Key used to identify property in context: Image info.
     */
    public static final String IMAGE_INFO_KEY = "image-info";

    /**
     * Key used to identify property in context: Pull image behavior.
     */
    public static final String PULL_IMAGE_KEY = "pull-image";

    /**
     * Key used to identify property in context: Path to TAR archive.
     */
    public static final String TAR_ARCHIVE_KEY = "tar-archive";

    /**
     * Key used to identify property in context: plugin session object.
     */
    public static final String SESSION_KEY = "session";

    /**
     * Key used to identify property in context: Contains execution result
     * object,.
     */
    public static final String EXECUTIONRESULT_KEY = "execution-result";

    /**
     * Key used to identify property in context: array of image creation info
     * objects.
     */
    public static final String IMAGE_CREATION_INFOS_KEY = "image-creation-infos";

    /**
     * Logger object.
     */
    Logger logger = Logger.getLogger(this.getClass().getName());

    /**
     * Image info.
     */
    @Initialize(IMAGE_INFO_KEY)
    @ValidateValue(ValidationPolicy.NOT_NULL)
    ImageInfo imageInfo;

    /**
     * TAR archive.
     */
    @Initialize(TAR_ARCHIVE_KEY)
    @ValidateValue(ValidationPolicy.NOT_NULL)
    File tarArchive;

    /**
     * Pull image behavior.
     */
    @Initialize(PULL_IMAGE_KEY)
    @ValidateValue(ValidationPolicy.NOT_NULL)
    Boolean pullImage;

    /**
     * Plugin session.
     */
    @Initialize(SESSION_KEY)
    @ValidateValue(ValidationPolicy.NOT_NULL)
    DockerSession session;

    /**
     * Defines execution result object.
     */
    @Initialize(EXECUTIONRESULT_KEY)
    @ValidateValue(ValidationPolicy.NOT_NULL)
    ExecutionResult executionResult;

    /**
     * Docker client.
     */
    @Resource
    DockerClient dockerClient;

    /**
     * Message provider for I18N support.
     */
    @Resource(name = "dockerMessageProvider")
    MessageProvider messageProvider;

    public boolean execute(Context context) throws Exception {
	// initialize command
	CommandInitializer initializer = new CommandInitializerImpl();
	initializer.initialize(context, this);

	buildImage(context);

	return Command.CONTINUE_PROCESSING;
    }

    /**
     * Build image.
     * 
     * @param context
     *            command context.
     * 
     * @throws SessionException
     *             if HTTP post fails.
     */
    @SuppressWarnings("unchecked")
    void buildImage(Context context) throws SessionException {

	// exit if image exists in repository
	if (dockerClient.imageExists(session, imageInfo)) {

	    // store null creation info's
	    context.put(IMAGE_CREATION_INFOS_KEY, NULL_INFOS);

	    Object[] args = { imageInfo.getFullyQualifiedName() };
	    executionResult.completeAsSuccessful(messageProvider, "bic.image_already_exists_success", args);
	    String message = messageProvider.getMessage("bic.image_already_exists_note");
	    executionResult.addMessage(ExecutionResult.MSG_MESSAGE, message);
	    return;
	}

	// validate TAR archive exist
	Matcher<File> matcher = PineappleMatchers.doesFileExist();
	if (matcher.matches(tarArchive)) {
	    Object[] args = { tarArchive };
	    String message = messageProvider.getMessage("bic.validate_tar_exist_info", args);
	    executionResult.addMessage(MSG_MESSAGE, message);
	} else {
	    // complete with failure
	    Object[] args = { tarArchive };
	    executionResult.completeAsFailure(messageProvider, "bic.validate_tar_exist_failure", args);
	    return;
	}

	// set URI variables
	Map<String, String> uriVariables = new HashMap<String, String>();
	uriVariables.put("tag", imageInfo.getFullyQualifiedName());
	uriVariables.put("pull", getPullImageBehavior());

	// create HTTP request object
	HttpHeaders requestHeaders = new HttpHeaders();
	requestHeaders.set(CONTENT_TYPE_KEY, CONTENT_TYPE_TAR);
	HttpEntity<byte[]> requestEntity;
	FileInputStream openInputStream = null;

	try {
	    // read TAR archive into HTTP request
	    openInputStream = FileUtils.openInputStream(tarArchive);
	    byte[] byteArray = IOUtils.toByteArray(openInputStream);
	    requestEntity = new HttpEntity<byte[]>(byteArray, requestHeaders);

	    // close stream
	    IOUtils.closeQuietly(openInputStream);

	} catch (IOException e) {

	    // complete with error
	    executionResult.completeAsError(messageProvider, "bic.read_tar_archive_error", e);

	    // close stream
	    IOUtils.closeQuietly(openInputStream);

	    return;
	}

	// post to create image
	ImageCreation[] infos = null;
	infos = session.httpPostForObjectWithMultipleRootElements(BUILD_IMAGE_URI, uriVariables, requestEntity,
		ImageCreation[].class, CONTENT_TYPE_TAR);

	// add messages
	ImageCreation failedInfo = null;
	Object[] args = { infos.length };
	String message = messageProvider.getMessage("bic.list_image_info", args);
	executionResult.addMessage(ExecutionResult.MSG_MESSAGE, message);

	for (ImageCreation info : infos) {

	    // handle normal status update
	    if (containsStatusUpdate(info)) {
		Object[] args2 = { info.getStatus() };
		String message2 = messageProvider.getMessage("bic.list_single_info", args2);
		executionResult.addMessage(ExecutionResult.MSG_MESSAGE, message2);
		continue;
	    }

	    if (containsStreamUpdate(info)) {
		Object[] args2 = { remoteLfFromStreamUpdate(info.getStream()) };
		String message2 = messageProvider.getMessage("bic.list_single_stream_info", args2);
		executionResult.addMessage(ExecutionResult.MSG_MESSAGE, message2);
		continue;
	    }

	    // handle error and skip the loop
	    if (containsErrorMessage(info)) {
		failedInfo = info;
		break;
	    }
	}

	// store creation info's
	context.put(IMAGE_CREATION_INFOS_KEY, infos);

	// complete successfully
	if (isImageCreationSuccessful(infos)) {
	    Object[] args2 = { imageInfo.getFullyQualifiedName() };
	    executionResult.completeAsSuccessful(messageProvider, "bic.build_image_completed", args2);
	    return;
	}

	// complete with failure
	ErrorDetail errorDetail = failedInfo.getErrorDetail();
	Object[] args2 = { errorDetail.getCode(), errorDetail.getMessage() };
	executionResult.completeAsFailure(messageProvider, "bic.build_image_failed", args2);
    }

    /**
     * Return the pull image behavior as a string.
     * 
     * @return the pull image behavior as a string.
     */
    String getPullImageBehavior() {
	if (!pullImage.booleanValue())
	    return FALSE_AS_DIGIT;
	return TRUE_AS_DIGIT;
    }

}

import static com.alpha.pineapple.docker.DockerConstants.CREATE_IMAGE_URI;
import static com.alpha.pineapple.docker.DockerConstants.CREATE_TAGGED_IMAGE_URI;
import static com.alpha.pineapple.docker.utils.ModelUtils.containsErrorMessage;
import static com.alpha.pineapple.docker.utils.ModelUtils.containsStatusUpdate;
import static com.alpha.pineapple.docker.utils.ModelUtils.isImageCreationSuccessful;
import static com.alpha.pineapple.docker.utils.ModelUtils.isTaggedImage;

import java.util.HashMap;
import com.alpha.pineapple.docker.model.ImageInfo;
import com.alpha.pineapple.docker.model.rest.ImageCreation;
import com.alpha.pineapple.docker.session.DockerSession;
import com.alpha.pineapple.execution.ExecutionResult;
import com.alpha.pineapple.i18n.MessageProvider;

 * <ul>
 * 
 * <li><code>image-creation-infos</code> contains array of image creation info's
 * from Docker. If image already exists then no info's are returned. The type is
 * <code>com.alpha.pineapple.docker.model.ImageCreation[]</code>.</li>
 * 
 * <li>The the state of the supplied <code>ExecutionResult</code> is updated
 */
public class CreateImageCommand implements Command {

    /**
     * Null image creation info's.
     */
    static final ImageCreation[] NULL_INFOS = {};

    /**
     * Key used to identify property in context: Image info.
     */
    public static final String IMAGE_INFO_KEY = "image-info";

    /**
     * Key used to identify property in context: plugin session object.
     */
    public static final String SESSION_KEY = "session";

    /**
     * Key used to identify property in context: Contains execution result
     * object,.
     */
    public static final String EXECUTIONRESULT_KEY = "execution-result";

    /**
     * Key used to identify property in context: array of image creation info
     * objects.
     */
    public static final String IMAGE_CREATION_INFOS_KEY = "image-creation-infos";

    /**
     * Logger object.
     */
    Logger logger = Logger.getLogger(this.getClass().getName());

    /**
     * Image info.
     */
    @Initialize(IMAGE_INFO_KEY)
    @ValidateValue(ValidationPolicy.NOT_NULL)
    ImageInfo imageInfo;

    /**
     * Plugin session.
     */
    @Initialize(SESSION_KEY)
    @ValidateValue(ValidationPolicy.NOT_NULL)
    DockerSession session;

    /**
     * Defines execution result object.
     */
    @Initialize(EXECUTIONRESULT_KEY)
    @ValidateValue(ValidationPolicy.NOT_NULL)
    ExecutionResult executionResult;

    /**
     * Message provider for I18N support.
     */
    @Resource(name = "dockerMessageProvider")
    MessageProvider messageProvider;

    /**
     * Docker client.
     */
    @Resource
    DockerClient dockerClient;

    @SuppressWarnings("unchecked")
    public boolean execute(Context context) throws Exception {

	// initialize command
	CommandInitializer initializer = new CommandInitializerImpl();
	initializer.initialize(context, this);

	// exit if image exists in repository
	if (dockerClient.imageExists(session, imageInfo)) {

	    // store null creation info's
	    context.put(IMAGE_CREATION_INFOS_KEY, NULL_INFOS);

	    // set state
	    Object[] args = { imageInfo.getFullyQualifiedName() };
	    executionResult.completeAsSuccessful(messageProvider, "cic.image_already_exists_success", args);
	    String message = messageProvider.getMessage("cic.image_already_exists_note");
	    executionResult.addMessage(ExecutionResult.MSG_MESSAGE, message);
	    return Command.CONTINUE_PROCESSING;
	}

	// set variables
	Map<String, String> uriVariables = new HashMap<String, String>(3);
	uriVariables.put("image", imageInfo.getRepository());

	// post to create image
	ImageCreation[] infos = null;
	if (isTaggedImage(imageInfo)) {
	    uriVariables.put("tag", imageInfo.getTag());
	    infos = session.httpPostForObjectWithMultipleRootElements(CREATE_TAGGED_IMAGE_URI, uriVariables,
		    ImageCreation[].class);
	} else {
	    infos = session.httpPostForObjectWithMultipleRootElements(CREATE_IMAGE_URI, uriVariables,
		    ImageCreation[].class);
	}

	// add messages
	ImageCreation failedInfo = null;
	Object[] args = { infos.length };
	String message = messageProvider.getMessage("cic.list_image_info", args);
	executionResult.addMessage(ExecutionResult.MSG_MESSAGE, message);
	for (ImageCreation info : infos) {

	    // handle normal status update
	    if (containsStatusUpdate(info)) {
		Object[] args2 = { info.getStatus() };
		String message2 = messageProvider.getMessage("cic.list_single_info", args2);
		executionResult.addMessage(ExecutionResult.MSG_MESSAGE, message2);
		continue;
	    }

	    // handle error and skip the loop
	    if (containsErrorMessage(info)) {
		failedInfo = info;
		break;
	    }
	}

	// store creation info's
	context.put(IMAGE_CREATION_INFOS_KEY, infos);

	// complete result
	if (isImageCreationSuccessful(infos)) {
	    Object[] args2 = { imageInfo.getFullyQualifiedName() };
	    executionResult.completeAsSuccessful(messageProvider, "cic.create_image_completed", args2);
	} else {
	    Object[] args2 = { failedInfo.getError() };
	    executionResult.completeAsFailure(messageProvider, "cic.create_image_failed", args2);
	}

	return Command.CONTINUE_PROCESSING;
    }

}
public static boolean containsStreamUpdate(ImageCreation info) {
    }

    /**
     * Returns true if image creation object contains error information in the
     * error field, i.e. it is defined with a non-null or non-empty value.
     * 
     * @param info
     *            image creation object.
     * 
     * @return true if image creation object contains error information in the
     *         error field, i.e. it is defined with a non-null or non-empty
     *         value.
     */
    public static boolean containsErrorMessage(ImageCreation info) {
	Validate.notNull(info, "info is undefined");

	if (info.getError() == null)
	    return false;
	if (info.getError().isEmpty())
	    return false;
	return true;
    }

    /**
     * Returns true if image creation was successful, i.e. no errors was
     * returned.
     * 
     * @param infos
     *            image creation objects.
     * 
     * @return true if image creation was successful, i.e. no errors was
     *         returned.
     */
    public static boolean isImageCreationSuccessful(ImageCreation[] infos) {
	Validate.notNull(infos, "infos is undefined");

	for (ImageCreation info : infos) {
	    if (containsErrorMessage(info))
		return false;
	}

	return true;
    }

    /**
     * Create truncated ID which is reduced to 12 characters long.
     * 
     * @param id
import org.springframework.web.client.RestTemplate;

/**
 * Exception class for signaling a captured error from {@linkplain RestTemplate}
 * .
 */
public class RestResponseException extends RuntimeException {
	<!-- Generic definitions -->

	<jaxb:bindings schemaLocation="docker_1_0.xsd" >
		<jaxb:bindings node="//xs:complexType[@name='graphDriverType']" >
			<jaxb:class name="GraphDriver" />				
		</jaxb:bindings>		 
	</jaxb:bindings>

	<jaxb:bindings schemaLocation="docker_1_0.xsd" >
		<jaxb:bindings node="//xs:complexType[@name='errorDetailType']" >
			<jaxb:class name="ErrorDetail" />				
		</jaxb:bindings>		 
	</jaxb:bindings>

	<jaxb:bindings schemaLocation="docker_1_0.xsd" >
		<jaxb:bindings node="//xs:complexType[@name='listedImageType']" >
			<jaxb:class name="ListedImage" />				
		</jaxb:bindings>		 
ds.parse_json_failure=HTTP Post at URL [{0}] failed to parse returned JSON with

# CreateImageCommand
cic.create_image_completed=Successfully created image: {0}.
cic.create_image_failed=Failed to create image with error: {0}.
cic.list_image_info=Docker returned [{0}] image creation info updates.
cic.list_single_info=Status: {0}
cic.image_already_exists_success=Image already exist: {0}. Will skip image creation. 
  		<xs:list itemType="xs:int"/>
	</xs:simpleType>

	<!-- 
		Container for graphDriverDataType (implemented as map using JAXB binding)   
	 -->
		<xs:attribute name="total" type="xs:string" use="optional"/>		
	</xs:complexType>

	<xs:complexType name="errorDetailType" >
		<xs:annotation>
			<xs:documentation>Detailed info about errors during image creation.</xs:documentation>
		</xs:annotation>
		<xs:attribute name="code" type="xs:int" use="optional"/>		
		<xs:attribute name="message" type="xs:string" use="optional"/>		
	</xs:complexType>

	<xs:complexType name="listedImageType" >
		<xs:annotation>
			<xs:documentation>Info about a listed Docker image (Output from the "List images" operation).</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="progressDetail" type="progressDetailType" minOccurs="0" maxOccurs="1" />
			<xs:element name="errorDetail" type="errorDetailType" minOccurs="0" maxOccurs="1" />
		</xs:sequence>
		<xs:attribute name="id" type="xs:string" use="optional"/>		
		<xs:attribute name="status" type="xs:string" use="optional"/>		
		<xs:attribute name="progress" type="xs:string" use="optional"/>		
		<xs:attribute name="error" type="xs:string" use="optional"/>		
		<xs:attribute name="stream" type="xs:string" use="optional"/>		
	</xs:complexType>

Development documentation
	
	Type for list of integers.
	
*** graphDriverType	

	Container for <<<graphDriverDataType>>> 
Development documentation
	* <<<inspectedContainerNetworkSettingsType>>> - Info about the network configuration of a 
	Docker container (Partial output from inspecting a containers).
	






	* <<<inspectedContainerVolumesType>>> - Info about volumes from a container inspection info 
	(Partial output from inspecting a container).
	Has role comparable to <<<containerConfigurationVolumesType>>> but for inspected container.
public void testFailsToCreateImageFromUnknownRepository() throws Exception {

	// test
	assertFalse(executionResult.isSuccess());
	assertTrue(context.containsKey(CreateImageCommand.IMAGE_CREATION_INFOS_KEY));
	assertNotNull(context.get(CreateImageCommand.IMAGE_CREATION_INFOS_KEY));
	ImageCreation[] infos = (ImageCreation[]) context.get(CreateImageCommand.IMAGE_CREATION_INFOS_KEY);
	assertTrue(infos.length != 0);
	assertFalse(dockerClient.imageExists(session, imageInfo));
    }

public void testFailsToCreateImageWithUnknownTag() throws Exception {

	// test
	assertFalse(executionResult.isSuccess());
	assertTrue(context.containsKey(CreateImageCommand.IMAGE_CREATION_INFOS_KEY));
	assertNotNull(context.get(CreateImageCommand.IMAGE_CREATION_INFOS_KEY));
	ImageCreation[] infos = (ImageCreation[]) context.get(CreateImageCommand.IMAGE_CREATION_INFOS_KEY);
	assertTrue(infos.length != 0);
	assertFalse(dockerClient.imageExists(session, imageInfo));
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void discard() {

    @Override
    public String toString() {
        return FileDownloadUtils.formatString("%!d(MISSING):%!s(MISSING)", mTask.getOrigin().getId(), super.toString());
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            <h1 class="page-sub-title device-id device-select"
                data-deviceid="{{device.deviceIdentifier}}" data-type="{{device.type}}"
                data-ownership="{{device.ownership}}"
                data-owner="{{device.owner}}">
                Device {{device.name}}
                {{#if device.model}}
                    <span class="lbl-device">
var InitiateViewOption = null;
    var deviceIdentifier = deviceId.data("deviceid");
    var deviceType = deviceId.data("type");
    var ownership = deviceId.data("ownership");
    var payload = [deviceIdentifier];
    var operationTable;
    var serviceUrl;
var InitiateViewOption = null;
        serviceUrl = "/api/device-mgt/android/v1.0/admin/devices/info";
        serviceUrlLocal = "/api/device-mgt/android/v1.0/admin/devices/location";
    }
    if (serviceUrl) {
        invokerUtil.post(
            serviceUrl,
            payload,
            <h1 class="page-sub-title device-id device-select"
                data-deviceid="{{device.deviceIdentifier}}" data-type="{{device.type}}"
                data-ownership="{{device.ownership}}"
                data-owner="{{device.owner}}">
                Device {{device.name}}
                {{#if device.model}}
                    <span class="lbl-device">
var InitiateViewOption = null;
    var deviceIdentifier = deviceId.data("deviceid");
    var deviceType = deviceId.data("type");
    var ownership = deviceId.data("ownership");
    var payload = [deviceIdentifier];
    var operationTable;
    var serviceUrl;
var InitiateViewOption = null;
        serviceUrl = "/api/device-mgt/android/v1.0/admin/devices/info";
    }

    if (serviceUrl) {
        invokerUtil.post(
            serviceUrl,
            payload,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void injectAtArrayField(Target target, FieldInsnNode fieldNode, int opCo
    private void injectAtGetArray(Target target, FieldInsnNode fieldNode, AbstractInsnNode varNode, Type ownerType, Type fieldType) {
        String handlerDesc = Bytecode.generateDescriptor(this.returnType, (Object[])RedirectInjector.getArrayArgs(fieldType));
        boolean withArgs = this.checkDescriptor(handlerDesc, target, "array getter");
        this.injectArrayRedirect(target, fieldNode, varNode, withArgs);
    }

    /**
private void injectAtGetArray(Target target, FieldInsnNode fieldNode, AbstractIn
    private void injectAtSetArray(Target target, FieldInsnNode fieldNode, AbstractInsnNode varNode, Type ownerType, Type fieldType) {
        String handlerDesc = Bytecode.generateDescriptor(null, (Object[])RedirectInjector.getArrayArgs(fieldType, fieldType.getElementType()));
        boolean withArgs = this.checkDescriptor(handlerDesc, target, "array setter");
        this.injectArrayRedirect(target, fieldNode, varNode, withArgs);
    }

    /**
private void injectAtSetArray(Target target, FieldInsnNode fieldNode, AbstractIn
     * @param varNode array access node
     * @param withArgs true if the descriptor includes captured arguments from
     *      the target method signature
     */
    public void injectArrayRedirect(Target target, FieldInsnNode fieldNode, AbstractInsnNode varNode, boolean withArgs) {
        if (!this.isStatic) {
            target.insns.insertBefore(fieldNode, new VarInsnNode(Opcodes.ALOAD, 0));
            target.addToStack(1);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public JaxRsJavaMethodParameterMetadata(java.lang.reflect.Parameter javaMethodPa
							.orElseGet(() -> Optional.ofNullable(queryParameter)
								.map(QueryParam::value).filter(s -> !s.trim().isEmpty())
									.orElseGet(() -> Optional.ofNullable(javaMethodParameter.getName())
											.orElseThrow(() -> new IllegalStateException("Could not get the name of the parameter " + javaMethodParameter)))));

		this.serializer = (queryParameter != null) ? new EndpointMethodQueryParameterSerializer()
				: new SimpleEndpointMethodParameterSerializer();
public SpringWebJavaMethodParameterMetadata(java.lang.reflect.Parameter javaMeth
							.orElseGet(() -> Optional.ofNullable(queryParameter)
								.map(RequestParam::value).filter(s -> !s.trim().isEmpty())
									.orElseGet(() -> Optional.ofNullable(javaMethodParameter.getName())
											.orElseThrow(() -> new IllegalStateException("Could not get the name of the parameter " + javaMethodParameter)))));

		this.serializerType = SpringWebEndpointMethodParameterSerializer.of(this);
	}
public JavaMethodParameterMetadata(java.lang.reflect.Parameter javaMethodParamet
							.orElseGet(() -> Optional.ofNullable(queryParameter)
								.map(QueryParameter::value).filter(s -> !s.trim().isEmpty())
									.orElseGet(() -> Optional.ofNullable(javaMethodParameter.getName())
											.orElseThrow(() -> new IllegalStateException("Could not get the name of the parameter " + javaMethodParameter)))));

		this.serializerType = pathParameter != null ? pathParameter.serializer()
				: queryParameter != null ? queryParameter.serializer()
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    <include path="org/apache/cxf/binding/**" />
                    <include path="org/apache/cxf/bus**" />
                    <include path="org/apache/cxf/headers" />
                    <include path="org/apache/cxf/interceptor**" />
                    <include path="org/apache/cxf/message" />
                    <include path="org/apache/cxf/sts" />
                    <include path="org/apache/cxf/transport/http**" />
                    <include path="org/apache/cxf/ws/discovery" />
        <include path="org/apache/cxf/binding/**" />
        <include path="org/apache/cxf/bus**" />
        <include path="org/apache/cxf/headers" />
        <include path="org/apache/cxf/interceptor**" />
        <include path="org/apache/cxf/message" />
        <include path="org/apache/cxf/sts" />
        <include path="org/apache/cxf/transport/http**" />
        <include path="org/apache/cxf/ws/discovery" />
	^org/apache/cxf/binding(.*)
	^org/apache/cxf/bus(.*)
	^org/apache/cxf/headers(.*)
	^org/apache/cxf/interceptor(.*)
	^org/apache/cxf/message(.*)
	^org/apache/cxf/sts(.*)
	^org/apache/cxf/transport
	^org/apache/cxf/transport/http(.*)
org/apache/cxf/bus/resource
org/apache/cxf/bus/spring
org/apache/cxf/buslifecycle
org/apache/cxf/headers
org/apache/cxf/interceptor
org/apache/cxf/interceptor/security
org/apache/cxf/interceptor/security/callback
org/apache/cxf/interceptor/transform
org/apache/cxf/message
org/apache/cxf/sts
org/apache/cxf/transport
org/apache/cxf/transport/http
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import android.provider.ContactsContract.Contacts;
import android.provider.MediaStore;
import android.support.annotation.NonNull;
import android.support.v4.app.FragmentActivity;
import android.support.v4.app.FragmentManager;
import android.support.v4.content.ContextCompat;
import android.support.v4.content.LocalBroadcastManager;
public int getValue() {
    private Handler mHandler;
    private Runnable mMediaPlayerUpdater;
    private AudioContentViewControl mAudioControl;

    /** Audio recording dialog. */
    private AudioDialog mAudioDialog;
void selectAudioAttachment() {
    }

    private AudioFragment getAudioFragment() {
        AudioFragment fragment = findAudioFragment();
        if (fragment == null) {
            FragmentActivity parent = getActivity();
            if (parent != null) {
                fragment = new AudioFragment();
                FragmentManager fm = getFragmentManager();
                fm.beginTransaction()
                    .add(fragment, "audio")
                    .commit();
            }
        }

        return fragment;
    }

    private AudioFragment findAudioFragment() {
        FragmentManager fm = getFragmentManager();
        return fm != null ? (AudioFragment) fm
            .findFragmentByTag("audio") : null;
    }

    protected abstract void deleteConversation();
public void onPause() {
        MessageCenterService.release(getActivity());

        // release audio player
        AudioFragment audio = findAudioFragment();
        if (audio != null) {
            stopMediaPlayerUpdater();

private boolean prepareAudio(File audioFile, final AudioContentViewControl view,
                public void onCompletion(MediaPlayer mp) {
                    stopMediaPlayerUpdater();
                    view.end();
                    AudioFragment audio = findAudioFragment();
                    if (audio != null) {
                        // this is mainly to get the wake lock released
                        audio.pausePlaying();
public void onCompletion(MediaPlayer mp) {
    @Override
    public void playAudio(AudioContentViewControl view, long messageId) {
        view.play();
        findAudioFragment().startPlaying();
        setAudioStatus(AudioContentView.STATUS_PLAYING);
        startMediaPlayerUpdater(view);
    }

    private void updatePosition(AudioContentViewControl view) {
        // we don't use getElapsedTime() here because it might get moved by seeking
        view.updatePosition(findAudioFragment().getPlayer().getCurrentPosition());
    }

    @Override
    public void pauseAudio(AudioContentViewControl view) {
        view.pause();
        findAudioFragment().pausePlaying();
        stopMediaPlayerUpdater();
        setAudioStatus(AudioContentView.STATUS_PAUSED);
    }
private void resetAudio(AudioContentViewControl view) {
            stopMediaPlayerUpdater();
            view.end();
        }
        AudioFragment audio = findAudioFragment();
        if (audio != null) {
            audio.resetPlayer();
            audio.setMessageId(-1);
public void stopAllSounds() {

    @Override
    public void onBind(long messageId, final AudioContentViewControl view) {
        final AudioFragment audio = findAudioFragment();
        if (audio != null && audio.getMessageId() == messageId) {
            mAudioControl = view;
            audio.getPlayer().setOnCompletionListener(new MediaPlayer.OnCompletionListener() {
public void onCompletion(MediaPlayer mp) {

    @Override
    public void onUnbind(long messageId, AudioContentViewControl view) {
        AudioFragment audio = findAudioFragment();
        if (audio != null && audio.getMessageId() == messageId) {
            mAudioControl = null;
            MediaPlayer player = audio.getPlayer();
public void onCompletion(MediaPlayer mp) {

    @Override
    public boolean isPlaying() {
        AudioFragment audio = findAudioFragment();
        return audio != null && audio.isPlaying();
    }

    @Override
    public void seekTo(int position) {
        AudioFragment audio = findAudioFragment();
        if (audio != null)
            audio.seekPlayerTo(position);
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void resolveScope(Annotation annotation, Injector injector) {
        if (stopInheritedScope) {
            return;
        }
        Genie genie = (Genie) injector;
        Class<? extends Annotation> annoClass = annotation.annotationType();
        if (injector.isInheritedScopeStopper(annoClass)) {
            stopInheritedScope = true;
            scope = null;
        } else if (injector.isScope(annoClass)) {
            if (null != scope) {
                Class<? extends Annotation> newScope = genie.scopeByAlias(annoClass);
                if (newScope != scope) {
                    throw new InjectException("Incompatible scope annotation found: %!s(MISSING)", this);
                }
            } else {
                scope = genie.scopeByAlias(annoClass);
            }
        }
    }
private void init(boolean noPlugin, Object... modules) {
                registerModule(module);
            }
        }
    }

    public void supportInjectionPoint(boolean enabled) {
public boolean isPostConstructProcessor(Class<? extends Annotation> annoClass) {
        return postConstructProcessors.containsKey(annoClass) || annoClass.isAnnotationPresent(PostConstructProcess.class);
    }

    Class<? extends Annotation> scopeByAlias(Class<? extends Annotation> alias) {
        Class<? extends Annotation> annoType = scopeAliases.get(alias);
        return null == annoType ? alias : annoType;
    }
private void tryRegisterPlugin(String pluginClass) {
        }
    }

    private void registerModule(Object module) {
        boolean isClass = module instanceof Class;
        Class moduleClass = isClass ? (Class) module : module.getClass();

    /**
     * Returns a provider of given type
     * @param type the class of the bean that provider provides
     * @param <T> the generic type of the bean
     * @return the provider that provides the bean
     */
    <T> Provider<T> getProvider(Class<T> type);

    /**
     * Check if a supplied annotation class is a {@link javax.inject.Qualifier}
     * @param annoClass
     * @return `true` if the annotation type is a qualifier or `false` otherwise
     */
    boolean isQualifier(Class<? extends Annotation> annoClass);

    /**
     * Check if a supplied annotation class specifies a {@link PostConstructProcessor}
     * @param annoClass the annotation type
     * @return `true` if the annotation type specifies post construct processor
     */
    boolean isPostConstructProcessor(Class<? extends Annotation> annoClass);

    /**
     * Check if a supplied annotation class is a {@link javax.inject.Scope} annotation
     * @param annoClass the annotation type
     * @return `true` if the annotation type indicate a scope
     */
    boolean isScope(Class<? extends Annotation> annoClass);

    /**
     * Check if a supplied annotation class is a {@link org.osgl.inject.annotation.StopInheritedScope} annotation or alias of that annotation
     * @param annoClass the annotation type
     * @return `true` if the annotation type is inherited scope stopper
     */
    boolean isInheritedScopeStopper(Class<? extends Annotation> annoClass);
}
static ScopeCache resolve(Class<? extends Annotation> annoClass, Genie genie) {
            return cache;
        }
        Class<? extends Annotation> alias = genie.scopeByAlias(annoClass);
        if (annoClass == alias) {
            cache = resolveBuiltIn(alias, genie);
        }
        if (null == cache) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private volatile File tmpDir;
    private boolean restarting;
    private Result blockIssue;
    private RequestHandler blockIssueHandler = new FastRequestHandler() {
        @Override
        public void handle(ActionContext context) {
public synchronized void setBlockIssue(Exception e) {
        if (e instanceof ActErrorResult) {
            blockIssue = (ActErrorResult) e;
        } else {
            blockIssue = ActErrorResult.of(e);
        }
    }

public synchronized void refresh() {
        LOGGER.info("App starting ....");
        profile = null;
        blockIssue = null;

        initScanlist();
        initServiceResourceManager();
public synchronized void refresh() {
        emit(PRE_START);
        emit(START);
        daemonKeeper();
        LOGGER.info("App[%!s(MISSING)] loaded in %!s(MISSING)ms", name(), $.ms() - ms);
        emit(POST_START);
    }
package act.route;

import org.osgl.http.H;
import org.osgl.http.util.Path;
import org.osgl.util.C;
public void build(Router router) {
            String line = lines.get(i).trim();
            if (line.startsWith("#")) continue;
            if (S.blank(line)) continue;
            process(line, router);
        }
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
     public static void func_149671_p()
     {
         func_176215_a(0, field_176230_a, (new BlockAir()).func_149663_c("air"));
@@ -1247,14 +2511,7 @@
             }
             else
             {
-                UnmodifiableIterator unmodifiableiterator = block16.func_176194_O().func_177619_a().iterator();
-
-                while (unmodifiableiterator.hasNext())
-                    int k = field_149771_c.func_148757_b(block16) << 4 | block16.func_176201_c(iblockstate);
-                    field_176229_d.func_148746_a(iblockstate, k);
-                }
+//              Handled in GameData.BlockCallbacks - leaving tripwire as it seems to be special cased
             }
         }
     }
public void onAdd(IForgeRegistryInternal<Block> owner, RegistryManager stage, in
            @SuppressWarnings("unchecked")
            ClearableObjectIntIdentityMap<IBlockState> blockstateMap = owner.getSlaveMap(BLOCKSTATE_TO_ID, ClearableObjectIntIdentityMap.class);

            //So, due to blocks having more in-world states then metadata allows, we have to turn the map into a semi-milti-bimap.
            //We can do this however because the implementation of the map is last set wins. So we can add all states, then fix the meta bimap.
            //Multiple states -> meta. But meta to CORRECT state.
public void onAdd(IForgeRegistryInternal<Block> owner, RegistryManager stage, in
                    blockstateMap.put(block.getStateFromMeta(meta), id << 4 | meta); // Put the CORRECT thing!
            }


            if (oldBlock != null)
            {
                @SuppressWarnings("unchecked")
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
package net.minecraft.server;

import com.google.common.collect.Lists;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.Nullable;
import com.google.common.collect.ImmutableList;
import org.bukkit.craftbukkit.block.CraftBlock;
import org.bukkit.event.block.BlockPistonRetractEvent;
import org.bukkit.event.block.BlockPistonExtendEvent;
// CraftBukkit end

public BlockPiston(boolean flag) {
        this.a(CreativeModeTab.d);
    }

    public boolean u(IBlockData iblockdata) {
        return !((Boolean) iblockdata.get(BlockPiston.EXTENDED)).booleanValue();
    }

    public AxisAlignedBB b(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
        if (((Boolean) iblockdata.get(BlockPiston.EXTENDED)).booleanValue()) {
            switch ((EnumDirection) iblockdata.get(BlockPiston.FACING)) {
            case DOWN:
                return BlockPiston.g;

public AxisAlignedBB b(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPo
        }
    }

    public boolean k(IBlockData iblockdata) {
        return !((Boolean) iblockdata.get(BlockPiston.EXTENDED)).booleanValue() || iblockdata.get(BlockPiston.FACING) == EnumDirection.DOWN;
    }

    public void a(IBlockData iblockdata, World world, BlockPosition blockposition, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list, @Nullable Entity entity, boolean flag) {
        a(blockposition, axisalignedbb, list, iblockdata.d(world, blockposition));
    }

    public boolean b(IBlockData iblockdata) {
        return false;
    }

    public void postPlace(World world, BlockPosition blockposition, IBlockData iblockdata, EntityLiving entityliving, ItemStack itemstack) {
        world.setTypeAndData(blockposition, iblockdata.set(BlockPiston.FACING, EnumDirection.a(blockposition, entityliving)), 2);
        if (!world.isClientSide) {
public void postPlace(World world, BlockPosition blockposition, IBlockData ibloc

    }

    public void a(IBlockData iblockdata, World world, BlockPosition blockposition, Block block, BlockPosition blockposition1) {
        if (!world.isClientSide) {
            this.e(world, blockposition, iblockdata);
        }

    }

    public void onPlace(World world, BlockPosition blockposition, IBlockData iblockdata) {
        if (!world.isClientSide && world.getTileEntity(blockposition) == null) {
            this.e(world, blockposition, iblockdata);
        }

    }

    public IBlockData getPlacedState(World world, BlockPosition blockposition, EnumDirection enumdirection, float f, float f1, float f2, int i, EntityLiving entityliving) {
        return this.getBlockData().set(BlockPiston.FACING, EnumDirection.a(blockposition, entityliving)).set(BlockPiston.EXTENDED, Boolean.valueOf(false));
    }

    private void e(World world, BlockPosition blockposition, IBlockData iblockdata) {
        EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockPiston.FACING);
        boolean flag = this.a(world, blockposition, enumdirection);

        if (flag && !((Boolean) iblockdata.get(BlockPiston.EXTENDED)).booleanValue()) {
            if ((new PistonExtendsChecker(world, blockposition, enumdirection, true)).a()) {
                world.playBlockAction(blockposition, this, 0, enumdirection.a());
            }
        } else if (!flag && ((Boolean) iblockdata.get(BlockPiston.EXTENDED)).booleanValue()) {
            // CraftBukkit start
            if (!this.sticky) {
                org.bukkit.block.Block block = world.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ());
private boolean a(World world, BlockPosition blockposition, EnumDirection enumdi
        }
    }

    public boolean a(IBlockData iblockdata, World world, BlockPosition blockposition, int i, int j) {
        EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockPiston.FACING);

        if (!world.isClientSide) {
            boolean flag = this.a(world, blockposition, enumdirection);
public boolean a(IBlockData iblockdata, World world, BlockPosition blockposition
        return true;
    }

    public boolean c(IBlockData iblockdata) {
        return false;
    }
public static boolean a(IBlockData iblockdata, World world, BlockPosition blockp
                    if (iblockdata.p() == EnumPistonReaction.DESTROY) {
                        return flag;
                    }
                } else if (((Boolean) iblockdata.get(BlockPiston.EXTENDED)).booleanValue()) {
                    return false;
                }

public static boolean a(IBlockData iblockdata, World world, BlockPosition blockp
        }
    }

    private boolean a(World world, BlockPosition blockposition, EnumDirection enumdirection, boolean flag) {
        if (!flag) {
            world.setAir(blockposition.shift(enumdirection));
        }

        PistonExtendsChecker pistonextendschecker = new PistonExtendsChecker(world, blockposition, enumdirection, flag);

        if (!pistonextendschecker.a()) {
            return false;
        } else {
            List list = pistonextendschecker.getMovedBlocks();
            ArrayList arraylist = Lists.newArrayList();

            for (int i = 0; i < list.size(); ++i) {
                BlockPosition blockposition1 = (BlockPosition) list.get(i);

                arraylist.add(world.getType(blockposition1).b((IBlockAccess) world, blockposition1));
            }

            List list1 = pistonextendschecker.getBrokenBlocks();
            int j = list.size() + list1.size();
            IBlockData[] aiblockdata = new IBlockData[j];
            EnumDirection enumdirection1 = flag ? enumdirection : enumdirection.opposite();
            // CraftBukkit start
            final org.bukkit.block.Block bblock = world.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ());

            final List<BlockPosition> moved = pistonextendschecker.getMovedBlocks();
            final List<BlockPosition> broken = pistonextendschecker.getBrokenBlocks();

            List<org.bukkit.block.Block> blocks = new AbstractList<org.bukkit.block.Block>() {

                @Override
                public int size() {
                    return moved.size() + broken.size();
                }

                @Override
                public org.bukkit.block.Block get(int index) {
                    if (index >= size() || index < 0) {
                        throw new ArrayIndexOutOfBoundsException(index);
                    }
                    BlockPosition pos = (BlockPosition) (index < moved.size() ? moved.get(index) : broken.get(index - moved.size()));
                    return bblock.getWorld().getBlockAt(pos.getX(), pos.getY(), pos.getZ());
                }
            };
            org.bukkit.event.block.BlockPistonEvent event;
            if (flag) {
                event = new BlockPistonExtendEvent(bblock, blocks, CraftBlock.notchToBlockFace(enumdirection1));
            } else {
                event = new BlockPistonRetractEvent(bblock, blocks, CraftBlock.notchToBlockFace(enumdirection1));
            }
            world.getServer().getPluginManager().callEvent(event);

            if (event.isCancelled()) {
                for (BlockPosition b : broken) {
                    world.notify(b, Blocks.AIR.getBlockData(), world.getType(b), 3);
                }
                for (BlockPosition b : moved) {
                    world.notify(b, Blocks.AIR.getBlockData(), world.getType(b), 3);
                    b = b.shift(enumdirection1);
                    world.notify(b, Blocks.AIR.getBlockData(), world.getType(b), 3);
                }
                return false;
            }
            // CraftBukkit end

            int k;
            BlockPosition blockposition2;
            IBlockData iblockdata;

            for (k = list1.size() - 1; k >= 0; --k) {
                blockposition2 = (BlockPosition) list1.get(k);
                iblockdata = world.getType(blockposition2);
                iblockdata.getBlock().b(world, blockposition2, iblockdata, 0);
                world.setTypeAndData(blockposition2, Blocks.AIR.getBlockData(), 4);
                --j;
                aiblockdata[j] = iblockdata;
            }

            for (k = list.size() - 1; k >= 0; --k) {
                blockposition2 = (BlockPosition) list.get(k);
                iblockdata = world.getType(blockposition2);
                world.setTypeAndData(blockposition2, Blocks.AIR.getBlockData(), 2);
                blockposition2 = blockposition2.shift(enumdirection1);
                world.setTypeAndData(blockposition2, Blocks.PISTON_EXTENSION.getBlockData().set(BlockPiston.FACING, enumdirection), 4);
                world.setTileEntity(blockposition2, BlockPistonMoving.a((IBlockData) arraylist.get(k), enumdirection, flag, false));
                --j;
                aiblockdata[j] = iblockdata;
            }

            BlockPosition blockposition3 = blockposition.shift(enumdirection);

            if (flag) {
                BlockPistonExtension.EnumPistonType blockpistonextension_enumpistontype = this.sticky ? BlockPistonExtension.EnumPistonType.STICKY : BlockPistonExtension.EnumPistonType.DEFAULT;

                iblockdata = Blocks.PISTON_HEAD.getBlockData().set(BlockPistonExtension.FACING, enumdirection).set(BlockPistonExtension.TYPE, blockpistonextension_enumpistontype);
                IBlockData iblockdata1 = Blocks.PISTON_EXTENSION.getBlockData().set(BlockPistonMoving.FACING, enumdirection).set(BlockPistonMoving.TYPE, this.sticky ? BlockPistonExtension.EnumPistonType.STICKY : BlockPistonExtension.EnumPistonType.DEFAULT);

                world.setTypeAndData(blockposition3, iblockdata1, 4);
                world.setTileEntity(blockposition3, BlockPistonMoving.a(iblockdata, enumdirection, true, true));
            }

            int l;

            for (l = list1.size() - 1; l >= 0; --l) {
                world.applyPhysics((BlockPosition) list1.get(l), aiblockdata[j++].getBlock(), false);
            }

            for (l = list.size() - 1; l >= 0; --l) {
                world.applyPhysics((BlockPosition) list.get(l), aiblockdata[j++].getBlock(), false);
            }

            if (flag) {
                world.applyPhysics(blockposition3, Blocks.PISTON_HEAD, false);
            }

            return true;
        }
    }

    public IBlockData fromLegacyData(int i) {
        return this.getBlockData().set(BlockPiston.FACING, e(i)).set(BlockPiston.EXTENDED, Boolean.valueOf((i & 8) > 0));
    }

    public int toLegacyData(IBlockData iblockdata) {
        byte b0 = 0;
        int i = b0 | ((EnumDirection) iblockdata.get(BlockPiston.FACING)).a();

        if (((Boolean) iblockdata.get(BlockPiston.EXTENDED)).booleanValue()) {
            i |= 8;
        }

        return i;
    }

    public IBlockData a(IBlockData iblockdata, EnumBlockRotation enumblockrotation) {
        return iblockdata.set(BlockPiston.FACING, enumblockrotation.a((EnumDirection) iblockdata.get(BlockPiston.FACING)));
    }

    public IBlockData a(IBlockData iblockdata, EnumBlockMirror enumblockmirror) {
        return iblockdata.a(enumblockmirror.a((EnumDirection) iblockdata.get(BlockPiston.FACING)));
    }

    protected BlockStateList getStateList() {
        return new BlockStateList(this, new IBlockState[] { BlockPiston.FACING, BlockPiston.EXTENDED});
    }

import java.util.Random;
import javax.annotation.Nullable;
import org.bukkit.event.block.BlockPhysicsEvent;
// CraftBukkit end

public class BlockPlant extends Block {

protected BlockPlant(Material material, MaterialMapColor materialmapcolor) {
    }

    @Override
	public boolean canPlace(World world, BlockPosition blockposition) {
        return super.canPlace(world, blockposition) && this.i(world.getType(blockposition.down()));
    }

protected boolean i(IBlockData iblockdata) {
    }

    @Override
	public void a(IBlockData iblockdata, World world, BlockPosition blockposition, Block block, BlockPosition blockposition1) {
        super.a(iblockdata, world, blockposition, block, blockposition1);
        this.e(world, blockposition, iblockdata);
    }

    @Override
	public void b(World world, BlockPosition blockposition, IBlockData iblockdata, Random random) {
        this.e(world, blockposition, iblockdata);
    }

    protected void e(World world, BlockPosition blockposition, IBlockData iblockdata) {
        if (!this.f(world, blockposition, iblockdata)) {
        	// CraftBukkit start
        	if (org.bukkit.craftbukkit.event.CraftEventFactory.callBlockPhysicsEvent(world, blockposition).isCancelled()) {
                return;
            }
            // CraftBukkit end
public boolean f(World world, BlockPosition blockposition, IBlockData iblockdata
    }

    @Override
	public AxisAlignedBB b(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
        return BlockPlant.b;
    }

    @Override
	@Nullable
    public AxisAlignedBB a(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
        return BlockPlant.k;
    }

    @Override
	public boolean b(IBlockData iblockdata) {
        return false;
    }

    @Override
	public boolean c(IBlockData iblockdata) {
        return false;
    }
}
public BlockTallPlant() {
    }

    @Override
	public AxisAlignedBB b(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
        return BlockTallPlant.j;
    }

public AxisAlignedBB b(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPo
    }

    @Override
	public boolean canPlace(World world, BlockPosition blockposition) {
        return super.canPlace(world, blockposition) && world.isEmpty(blockposition.up());
    }

    @Override
	public boolean a(IBlockAccess iblockaccess, BlockPosition blockposition) {
        IBlockData iblockdata = iblockaccess.getType(blockposition);

        if (iblockdata.getBlock() != this) {
public boolean a(IBlockAccess iblockaccess, BlockPosition blockposition) {
    }

    @Override
	protected void e(World world, BlockPosition blockposition, IBlockData iblockdata) {
        if (!this.f(world, blockposition, iblockdata)) {
        	// CraftBukkit start
        	if (org.bukkit.craftbukkit.event.CraftEventFactory.callBlockPhysicsEvent(world, blockposition).isCancelled()) {
        		return;
        	}
        	// CraftBukkit end
            boolean flag = iblockdata.get(BlockTallPlant.HALF) == BlockTallPlant.EnumTallPlantHalf.UPPER;
            BlockPosition blockposition1 = flag ? blockposition : blockposition.up();
            BlockPosition blockposition2 = flag ? blockposition.down() : blockposition;
protected void e(World world, BlockPosition blockposition, IBlockData iblockdata
    }

    @Override
	public boolean f(World world, BlockPosition blockposition, IBlockData iblockdata) {
        if (iblockdata.get(BlockTallPlant.HALF) == BlockTallPlant.EnumTallPlantHalf.UPPER) {
            return world.getType(blockposition.down()).getBlock() == this;
        } else {
public boolean f(World world, BlockPosition blockposition, IBlockData iblockdata
    }

    @Override
	public Item getDropType(IBlockData iblockdata, Random random, int i) {
        if (iblockdata.get(BlockTallPlant.HALF) == BlockTallPlant.EnumTallPlantHalf.UPPER) {
            return Items.a;
        } else {
public Item getDropType(IBlockData iblockdata, Random random, int i) {
    }

    @Override
	public int getDropData(IBlockData iblockdata) {
        return iblockdata.get(BlockTallPlant.HALF) != BlockTallPlant.EnumTallPlantHalf.UPPER && iblockdata.get(BlockTallPlant.VARIANT) != BlockTallPlant.EnumTallFlowerVariants.GRASS ? iblockdata.get(BlockTallPlant.VARIANT).a() : 0;
    }

public void a(World world, BlockPosition blockposition, BlockTallPlant.EnumTallF
    }

    @Override
	public void postPlace(World world, BlockPosition blockposition, IBlockData iblockdata, EntityLiving entityliving, ItemStack itemstack) {
        world.setTypeAndData(blockposition.up(), this.getBlockData().set(BlockTallPlant.HALF, BlockTallPlant.EnumTallPlantHalf.UPPER), 2);
    }

    @Override
	public void a(World world, EntityHuman entityhuman, BlockPosition blockposition, IBlockData iblockdata, @Nullable TileEntity tileentity, ItemStack itemstack) {
        if (world.isClientSide || itemstack.getItem() != Items.SHEARS || iblockdata.get(BlockTallPlant.HALF) != BlockTallPlant.EnumTallPlantHalf.LOWER || !this.b(world, blockposition, iblockdata, entityhuman)) {
            super.a(world, entityhuman, blockposition, iblockdata, tileentity, itemstack);
        }
    }

    @Override
	public void a(World world, BlockPosition blockposition, IBlockData iblockdata, EntityHuman entityhuman) {
        if (iblockdata.get(BlockTallPlant.HALF) == BlockTallPlant.EnumTallPlantHalf.UPPER) {
            if (world.getType(blockposition.down()).getBlock() == this) {
                if (entityhuman.abilities.canInstantlyBuild) {
private boolean b(World world, BlockPosition blockposition, IBlockData iblockdat
    }

    @Override
	public ItemStack a(World world, BlockPosition blockposition, IBlockData iblockdata) {
        return new ItemStack(this, 1, this.a((IBlockAccess) world, blockposition, iblockdata).a());
    }

    @Override
	public boolean a(World world, BlockPosition blockposition, IBlockData iblockdata, boolean flag) {
        BlockTallPlant.EnumTallFlowerVariants blocktallplant_enumtallflowervariants = this.a((IBlockAccess) world, blockposition, iblockdata);

        return blocktallplant_enumtallflowervariants != BlockTallPlant.EnumTallFlowerVariants.GRASS && blocktallplant_enumtallflowervariants != BlockTallPlant.EnumTallFlowerVariants.FERN;
    }

    @Override
	public boolean a(World world, Random random, BlockPosition blockposition, IBlockData iblockdata) {
        return true;
    }

    @Override
	public void b(World world, Random random, BlockPosition blockposition, IBlockData iblockdata) {
        a(world, blockposition, new ItemStack(this, 1, this.a((IBlockAccess) world, blockposition, iblockdata).a()));
    }

    @Override
	public IBlockData fromLegacyData(int i) {
        return (i & 8) > 0 ? this.getBlockData().set(BlockTallPlant.HALF, BlockTallPlant.EnumTallPlantHalf.UPPER) : this.getBlockData().set(BlockTallPlant.HALF, BlockTallPlant.EnumTallPlantHalf.LOWER).set(BlockTallPlant.VARIANT, BlockTallPlant.EnumTallFlowerVariants.a(i & 7));
    }

    @Override
	public IBlockData updateState(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
        if (iblockdata.get(BlockTallPlant.HALF) == BlockTallPlant.EnumTallPlantHalf.UPPER) {
            IBlockData iblockdata1 = iblockaccess.getType(blockposition.down());

public IBlockData updateState(IBlockData iblockdata, IBlockAccess iblockaccess,
    }

    @Override
	public int toLegacyData(IBlockData iblockdata) {
        return iblockdata.get(BlockTallPlant.HALF) == BlockTallPlant.EnumTallPlantHalf.UPPER ? 8 | iblockdata.get(BlockTallPlant.d).get2DRotationValue() : iblockdata.get(BlockTallPlant.VARIANT).a();
    }

    @Override
	protected BlockStateList getStateList() {
        return new BlockStateList(this, new IBlockState[] { BlockTallPlant.HALF, BlockTallPlant.VARIANT, BlockTallPlant.d});
    }

    @Override
	public Block.EnumRandomOffset u() {
        return Block.EnumRandomOffset.XZ;
    }

protected BlockStateList getStateList() {
        private EnumTallPlantHalf() {}

        @Override
		public String toString() {
            return this.getName();
        }

        @Override
		public String getName() {
            return this == BlockTallPlant.EnumTallPlantHalf.UPPER ? "upper" : "lower";
        }
    }
public int a() {
        }

        @Override
		public String toString() {
            return this.i;
        }

public String toString() {
        }

        @Override
		public String getName() {
            return this.i;
        }

package net.minecraft.server;

import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import javax.annotation.Nullable;

// CraftBukkit start
import com.google.common.collect.Maps;
import java.util.HashMap; // Paper
import java.util.Map;
import org.bukkit.Bukkit;
import org.bukkit.block.BlockState;
import org.bukkit.craftbukkit.CraftServer;
import org.bukkit.craftbukkit.CraftWorld;
import org.bukkit.craftbukkit.event.CraftEventFactory;
import org.bukkit.craftbukkit.util.CraftMagicNumbers;
import org.bukkit.craftbukkit.util.LongHashSet; // Paper
import org.bukkit.event.block.BlockCanBuildEvent;
import org.bukkit.event.block.BlockPhysicsEvent;
import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

// Paper start
import java.util.Set;
import com.google.common.collect.Sets;
// Paper end
import com.koloboke.collect.map.hash.HashObjFloatMaps;
import com.koloboke.collect.map.hash.HashObjObjMaps;
protected World(IDataManager idatamanager, WorldData worlddata, WorldProvider wo
        // From PlayerList.setPlayerFileData
        getWorldBorder().a(new IWorldBorderListener() {
            @Override
			public void a(WorldBorder worldborder, double d0) {
                getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_SIZE), worldborder.world);
            }

            @Override
			public void a(WorldBorder worldborder, double d0, double d1, long i) {
                getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.LERP_SIZE), worldborder.world);
            }

            @Override
			public void a(WorldBorder worldborder, double d0, double d1) {
                getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_CENTER), worldborder.world);
            }

            @Override
			public void a(WorldBorder worldborder, int i) {
                getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_WARNING_TIME), worldborder.world);
            }

            @Override
			public void b(WorldBorder worldborder, int i) {
                getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_WARNING_BLOCKS), worldborder.world);
            }

            @Override
			public void b(WorldBorder worldborder, double d0) {}

            @Override
			public void c(WorldBorder worldborder, double d0) {}
        });
        this.getServer().addWorld(this.world);
        // CraftBukkit end
        timings = new co.aikar.timings.WorldTimingsHandler(this); // Paper - code below can generate new world and access timings
        this.keepSpawnInMemory = this.paperConfig.keepSpawnInMemory; // Paper
                this.entityLimiter = new org.spigotmc.TickLimiter(spigotConfig.entityMaxTickTime);
        this.tileLimiter = new org.spigotmc.TickLimiter(spigotConfig.tileMaxTickTime);
    }

public String a() throws Exception {
                    }

                    @Override
					public Object call() throws Exception {
                        return this.a();
                    }
                });
private static boolean E(BlockPosition blockposition) { // Paper - unused but in
    }

    @Override
	public boolean isEmpty(BlockPosition blockposition) {
        return this.getType(blockposition).getMaterial() == Material.AIR;
    }

public boolean b(StructureBoundingBox structureboundingbox, boolean flag) {
    private boolean isAreaLoaded(int i, int j, int k, int l, int i1, int j1, boolean flag) {
        if (i1 >= 0 && j < 256) {
            i >>= 4;
            k >>= 4;
            l >>= 4;
            j1 >>= 4;

            for (int k1 = i; k1 <= l; ++k1) {
                for (int l1 = k; l1 <= j1; ++l1) {
                    if (!this.isChunkLoaded(k1, l1, flag)) {
                        return false;
                    }
                }
            }

            return true;
        } else {
            return false;
        }
public boolean b(int i, int j) {
        return this.isChunkLoaded(i, j, false) ? true : this.chunkProvider.e(i, j);
    }

    public boolean setTypeAndData(BlockPosition blockposition, IBlockData iblockdata, int i) {
        // CraftBukkit start - tree generation
        if (this.captureTreeGeneration) {
            BlockState blockstate = null;
public boolean setTypeAndData(BlockPosition blockposition, IBlockData iblockdata
                }
            }
            if (blockstate == null) {
                blockstate = org.bukkit.craftbukkit.block.CraftBlockState.getBlockState(this, blockposition.getX(), blockposition.getY(), blockposition.getZ(), i);
            }
            blockstate.setTypeId(CraftMagicNumbers.getId(iblockdata.getBlock()));
            blockstate.setRawData((byte) iblockdata.getBlock().toLegacyData(iblockdata));
public boolean setTypeAndData(BlockPosition blockposition, IBlockData iblockdata
            // CraftBukkit start - capture blockstates
            BlockState blockstate = null;
            if (this.captureBlockStates) {
                blockstate = org.bukkit.craftbukkit.block.CraftBlockState.getBlockState(this, blockposition.getX(), blockposition.getY(), blockposition.getZ(), i);
                this.capturedBlockStates.add(blockstate);
            }
            // CraftBukkit end
public boolean setTypeAndData(BlockPosition blockposition, IBlockData iblockdata
                } else if (!this.isClientSide && (i & 16) == 0) {
                    this.c(blockposition, block);
                }
                */

                // CraftBukkit start
                if (!this.captureBlockStates) { // Don't notify clients or update physics while capturing blockstates
                    // Modularize client and physic updates
                    notifyAndUpdatePhysics(blockposition, chunk, iblockdata1, iblockdata, i);
                }
                // CraftBukkit end

public void a(BlockPosition blockposition, final Block block, BlockPosition bloc
                if (world != null && !((WorldServer)this).stopPhysicsEvent) { // Paper
                    BlockPhysicsEvent event = new BlockPhysicsEvent(world.getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()), CraftMagicNumbers.getId(block));
                    this.getServer().getPluginManager().callEvent(event);

                    if (event.isCancelled()) {
                        return;
                    }
public String a() throws Exception {
                    }

                    @Override
					public Object call() throws Exception {
                        return this.a();
                    }
                });
public String a() throws Exception {
                        }

                        @Override
						public Object call() throws Exception {
                            return this.a();
                        }
                    });
public IBlockData getTypeIfLoaded(BlockPosition blockposition) {
    // Paper end

    @Override
	public IBlockData getType(BlockPosition blockposition) {
        // CraftBukkit start - tree generation
        // Paper start - optimize getType lookup to reduce instructions - getBlockData already enforces valid Y, move tree out
        final int x = blockposition.getX();
public void removeEntity(Entity entity) {
        }

        if (!guardEntityList) { // Spigot - It will get removed after the tick if we are ticking
        int i = entity.ab;
        int j = entity.ad;

        if (entity.aa && this.isChunkLoaded(i, j, true)) {
            this.getChunkAt(i, j).b(entity);
        }

        // CraftBukkit start - Decrement loop variable field if we've already ticked this entity
        int index = this.entityList.indexOf(entity);
        if (index != -1) {
            if (index <= this.tickPosition) {
                this.tickPosition--;
            }
            this.entityList.remove(index);
        }
        // CraftBukkit end
        } // Spigot
        this.c(entity);
    }
public void h(Entity entity) {
    }

    public void entityJoinedWorld(Entity entity, boolean flag) {
    	//int i = MathHelper.floor(entity.locX);
        //int j = MathHelper.floor(entity.locZ);
    	//boolean flag1 = true;

        // Spigot start
        if (flag && !org.spigotmc.ActivationRange.checkIfActive(entity)) {
public boolean douseFire(@Nullable EntityHuman entityhuman, BlockPosition blockp

    public Map<BlockPosition, TileEntity> capturedTileEntities = HashObjObjMaps.newMutableMap();
    @Override
	@Nullable
    public TileEntity getTileEntity(BlockPosition blockposition) {
        if (blockposition.isInvalidYLocation()) { // Paper
            return null;
private TileEntity F(BlockPosition blockposition) {
    public void setTileEntity(BlockPosition blockposition, @Nullable TileEntity tileentity) {
        if (!blockposition.isInvalidYLocation()) {
            if (tileentity != null && !tileentity.y()) {
            // CraftBukkit start
            if (captureBlockStates) {
                tileentity.a(this);
                tileentity.setPosition(blockposition);
                capturedTileEntities.put(blockposition, tileentity);
                return;
            }
            // CraftBukkit end
                if (this.M) {
                    tileentity.setPosition(blockposition);
                    Iterator iterator = this.b.iterator();
public boolean c(EnumSkyBlock enumskyblock, BlockPosition blockposition) {
                    j2 = (l1 >> 6 & 63) - 32 + j1;
                    k2 = (l1 >> 12 & 63) - 32 + k1;
                    int l3 = l1 >> 18 & 15;
                    BlockPosition blockposition1 = new BlockPosition(i2, j2, k2);

                    l2 = this.getBrightness(enumskyblock, blockposition1);
                    if (l2 == l3) {
                        this.a(enumskyblock, blockposition1, 0);
                        if (l3 > 0) {
                            i3 = MathHelper.a(i2 - i1);
                            j3 = MathHelper.a(j2 - j1);
                            k3 = MathHelper.a(k2 - k1);
                            if (i3 + j3 + k3 < 17) {
                                BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
                                EnumDirection[] aenumdirection = EnumDirection.values();
                                int i4 = aenumdirection.length;

                                for (int j4 = 0; j4 < i4; ++j4) {
                                    EnumDirection enumdirection = aenumdirection[j4];
                                    int k4 = i2 + enumdirection.getAdjacentX();
                                    int l4 = j2 + enumdirection.getAdjacentY();
                                    int i5 = k2 + enumdirection.getAdjacentZ();

                                    blockposition_pooledblockposition.f(k4, l4, i5);
                                    int j5 = Math.max(1, this.getType(blockposition_pooledblockposition).c());

                                    l2 = this.getBrightness(enumskyblock, blockposition_pooledblockposition);
                                    if (l2 == l3 - j5 && j < this.H.length) {
                                        this.H[j++] = k4 - i1 + 32 | l4 - j1 + 32 << 6 | i5 - k1 + 32 << 12 | l3 - j5 << 18;
                                    }
                                }

                                blockposition_pooledblockposition.t();
                            }
                        }
                    }
                }

                i = 0;
            }
public int a(Class<?> oclass) {
                    continue;
                }
            }
            
            if (oclass.isAssignableFrom(entity.getClass())) {
            // if ((!(entity instanceof EntityInsentient) || !((EntityInsentient) entity).isPersistent()) && oclass.isAssignableFrom(entity.getClass())) {
                // CraftBukkit end
                ++i;
            }
public void b(int i) {
    }

    @Override
	public int getBlockPower(BlockPosition blockposition, EnumDirection enumdirection) {
        return this.getType(blockposition).b(this, blockposition, enumdirection);
    }

public String a() {
            }

            @Override
			public Object call() throws Exception {
                return this.a();
            }
        });
public String a() {
            }

            @Override
			public Object call() throws Exception {
                return this.a();
            }
        });
import com.avaje.ebean.config.dbplatform.SQLitePlatform;
import com.avaje.ebeaninternal.server.lib.sql.TransactionIsolation;
import com.google.common.base.Charsets;
import com.google.common.base.Function;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.common.collect.MapMaker;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Sets;
import com.koloboke.collect.map.hash.HashObjObjMaps;
import com.koloboke.collect.set.hash.HashObjSets;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Collection;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
public CraftMetaItem clone() {
            builder.put(REPAIR.BUKKIT, repairCost);
        }

        Set<String> hideFlags = HashObjSets.newMutableSet();
        for (ItemFlag hideFlagEnum : getItemFlags()) {
            hideFlags.add(hideFlagEnum.name());
        }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void postProcessItems(final Map<Integer, Object> id2obj) throws Exceptio
                    continue;
                }

                final String ammoType = weapon.getAmmoKey().toLowerCase();
                final String ammoTypeHalf = ammoType + "half";

                final Ammunition ammo = ammoMap.get(ammoType);
public Ammunition getAmmoHalfType() {
    /**
     * @return The {@link String} name of the ammo type required for this weapon.
     */
    public String getAmmoKey() {
        return ammoTypeId;
    }

    public Ammunition getAmmoType() {
        return ammoType;
    }

    /**
     * @return <code>true</code> if the weapon has builtin ammo.
     */
public boolean isCompatibleAmmo(Ammunition aAmmunition) {
        if (hasBuiltInAmmo()) {
            return false;
        }
        return ammoTypeId.equals(aAmmunition.getAmmoType());
    }
}
public Ammunition(String aName, String aDesc, String aMwoName, int aMwoId, int a
    /**
     * @return The type name of this {@link Ammunition}. Used to match with {@link Weapon} ammo type.
     */
    public String getAmmoType() {
        return ammoType;
    }

public double getCoolDown(Collection<Modifier> aModifiers) {
        return coolDown.value(aModifiers);
    }

    public double getDamagePerShot() {
        return damagePerProjectile * projectilesPerRound * roundsPerShot;
    }
import org.lisoft.lsml.command.CmdSetArmour;
import org.lisoft.lsml.messages.ArmourMessage;
import org.lisoft.lsml.messages.ArmourMessage.Type;
import org.lisoft.lsml.messages.PilotSkillMessage;
import org.lisoft.lsml.messages.ItemMessage;
import org.lisoft.lsml.messages.LoadoutMessage;
import org.lisoft.lsml.messages.Message;
import org.lisoft.lsml.messages.MessageReceiver;
import org.lisoft.lsml.messages.MessageXBar;
import org.lisoft.lsml.messages.OmniPodMessage;
import org.lisoft.lsml.messages.UpgradesMessage;
import org.lisoft.lsml.model.chassi.ArmourSide;
import org.lisoft.lsml.model.chassi.Location;
protected String computeValue() {

                @Override
                protected String computeValue() {
                    return df.format(value.roundsProperty().get() / value.volleySizeProperty().get());
                }
            };
        });
//@formatter:on
package org.lisoft.lsml.view_fx.controls;

import org.lisoft.lsml.messages.PilotSkillMessage;
import org.lisoft.lsml.messages.ItemMessage;
import org.lisoft.lsml.messages.ItemMessage.Type;
import org.lisoft.lsml.messages.LoadoutMessage;
import org.lisoft.lsml.messages.Message;
import org.lisoft.lsml.messages.MessageReceiver;
import org.lisoft.lsml.messages.MessageReception;
import org.lisoft.lsml.messages.OmniPodMessage;
import org.lisoft.lsml.model.item.Ammunition;
import org.lisoft.lsml.model.item.Item;
import org.lisoft.lsml.model.item.Weapon;

/**
 * This provides an observable view over the weapon summary state of a {@link Loadout}.
 * 
 * @author Emily Björk
 */
public class WeaponSummaryList extends ObservableListBase<WeaponSummary> implements MessageReceiver {

    private final ObservableList<WeaponSummary> entries = FXCollections.observableArrayList();
    private Loadout loadout;

    private void add(Item aItem) {
        for (WeaponSummary summary : entries) {
            if (summary.consume(aItem)) {
                beginChange();
                nextUpdate(entries.indexOf(summary));
                endChange();
                return;
            }
        }

        beginChange();
        int idx = entries.size();
        entries.add(new WeaponSummary(loadout, aItem));
        nextAdd(idx, idx + 1);
        endChange();
    }

    public WeaponSummaryList(MessageReception aReception, Loadout aLoadoutBase) {
        aReception.attach(this);
        loadout = aLoadoutBase;
        for (Ammunition ammunition : aLoadoutBase.items(Ammunition.class)) {
            add(ammunition);
        }
        for (Weapon weapon : aLoadoutBase.items(Weapon.class)) {
            add(weapon);
        }
    }
public WeaponSummary get(int aArg0) {
    }

    @Override
    public int size() {
        return entries.size();
    }

    @Override
    public void receive(Message aMsg) {
        if (aMsg instanceof ItemMessage) {
            ItemMessage itemMessage = (ItemMessage) aMsg;
            if (!(itemMessage.item instanceof Ammunition || itemMessage.item instanceof Weapon)) {
                return;
            }

            if (itemMessage.type == Type.Added) {
                boolean consumed = false;
                for (WeaponSummary summary : entries) {
                    if (summary.consume(itemMessage.item)) {
                        beginChange();
                        nextUpdate(entries.indexOf(summary));
public void receive(Message aMsg) {
                }
                if (!consumed) {
                    beginChange();
                    int idx = entries.size();
                    entries.add(new WeaponSummary(loadout, itemMessage.item));
                    nextAdd(idx, idx + 1);
                    endChange();
                }
            }
            else if (itemMessage.type == Type.Removed) {
                for (WeaponSummary summary : entries) {
                    if (summary.remove(itemMessage.item)) {
                        int idx = entries.indexOf(summary);
                        if (summary.empty()) {
                            beginChange();
                            nextRemove(idx, entries.remove(idx));
else if (aMsg instanceof LoadoutMessage || aMsg instanceof OmniPodMessage
                || aMsg instanceof PilotSkillMessage) {
            // Efficiencies or quirks changed, update values.
            beginChange();
            int sz = size();
            for (int i = 0; i < sz; ++i) {
                get(i).battleTimeProperty().invalidate();
                nextUpdate(i);
else if (aMsg instanceof LoadoutMessage || aMsg instanceof OmniPodMessage
        }
    }

}
//@formatter:on
package org.lisoft.lsml.view_fx.util;

import org.lisoft.lsml.model.item.AmmoWeapon;
import org.lisoft.lsml.model.item.Ammunition;
import org.lisoft.lsml.model.item.Item;
import org.lisoft.lsml.model.item.Weapon;
import org.lisoft.lsml.model.loadout.Loadout;

import javafx.beans.binding.DoubleBinding;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;

/**
 * This class holds the summary of a weapon type for the weapon table.
 *
 * @author Emily Björk
 */
public class WeaponSummary {
    private class BattleTimeBinding extends DoubleBinding {
        private Weapon weapon;

        BattleTimeBinding(Weapon aWeapon) {
            weapon = aWeapon;
            bind(ammoRounds);
            bind(volleySize);
        }

        public Weapon getWeapon() {
            return weapon;
        }

        @Override
        protected double computeValue() {
            if (weapon != null) {
                return weapon.getSecondsPerShot(loadout.getModifiers()) * ammoRounds.get() / volleySize.get();
            }
            return 0;
        }

        /**
         * Updates the weapon used for calculating the battle time.
         *
         * Note that the battle time itself is automatically updated when the multiplicity or rounds changes.
         *
         * @param aWeapon
         *            The new weapon to potentially use for calculating battle time.
         */
        void offer(Weapon aWeapon) {
            if (volleySizeProperty().get() <= 0) {
                weapon = null;
                invalidate();
            }
            else {
                if (weapon == null
                        || battleTime.getWeapon().getSecondsPerShot(null) < aWeapon.getSecondsPerShot(null)) {
                    weapon = aWeapon;
                    invalidate();
                }
            }
        }
    }

    private final Loadout loadout;
    /**
     * How many of the given weapon are equipped, for missile weapons this is tube count.
     */
    private final IntegerProperty multiplicity = new SimpleIntegerProperty(0);

    /**
     * How much ammo is consumed in one "firing" of the weapon.
     */
    private final IntegerProperty volleySize = new SimpleIntegerProperty(0);

    /**
     * The display text to show for this weapon summary.
     */
    private final StringProperty name = new SimpleStringProperty();

    /**
     * The total amount of ammo available for this weapon type.
     */
    private final DoubleProperty ammoRounds = new SimpleDoubleProperty();

    /**
     * The amount of time that this weapon summary can be used in combat.
     */
    private final BattleTimeBinding battleTime;

    /**
     * The total amount of damage that can be done using the given ammo.
     */
    private final DoubleBinding totalDamage;

    private String selectorName;

    /**
     * Creates a new weapon summary based on an Item.
     *
     * @param aItem
     *            The {@link Item} to base this {@link WeaponSummary} on initially.
     * @param aLoadout
     *            A {@link Loadout} that this {@link WeaponSummary} is calculated for.
     */
    public WeaponSummary(Loadout aLoadout, Item aItem) {
        loadout = aLoadout;

        if (aItem instanceof Weapon) {
            final Weapon weapon = (Weapon) aItem;
            if (aItem instanceof AmmoWeapon) {
                selectorName = ((AmmoWeapon) weapon).getAmmoKey();
                ammoRounds.set(0);
            }
            else {
                selectorName = aItem.getName();
                ammoRounds.setValue(Double.POSITIVE_INFINITY);
            }
            battleTime = new BattleTimeBinding(weapon);
        }
        else if (aItem instanceof Ammunition) {
            final Ammunition ammunition = (Ammunition) aItem;
            selectorName = ammunition.getAmmoType();
            ammoRounds.set(ammunition.getNumRounds());
            battleTime = new BattleTimeBinding(null);
        }
        else {
            throw new IllegalArgumentException("Item must be ammo or weapon!");
        }

        totalDamage = new DoubleBinding() {
            {
                bind(ammoRounds);
                bind(battleTime); // Not on the time itself but the weapon.
            }

            @Override
            protected double computeValue() {
                final Weapon weapon = battleTime.weapon;
                if (null != weapon) {
                    return ammoRounds.get() * weapon.getDamagePerShot() / weapon.getAmmoPerPerShot();
                }
                return 0.0;
            }
        };

        addItem(aItem);
    }

    /**
public DoubleBinding battleTimeProperty() {
     *         otherwise.
     */
    public boolean consume(Item aItem) {
        if (aItem instanceof Ammunition) {
            final Ammunition ammunition = (Ammunition) aItem;
            if (selectorName.equals(ammunition.getAmmoType())) {
                ammoRounds.set(ammoRounds.get() + ammunition.getNumRounds());
                return true;
            }
        }
        else {
            if (selectorName.equals(getSelectorFor(aItem))) {
                addItem(aItem);
                battleTime.offer((Weapon) aItem);
                return true;
            }
        }
        return false;
    }
public boolean consume(Item aItem) {
     *         removed.
     */
    public boolean empty() {
        return volleySizeProperty().get() <= 0 && (ammoRounds.get() < 1 || Double.isInfinite(ammoRounds.get()));
    }

    /**
     * @return A {@link StringProperty} that represents the display name of this {@link WeaponSummary}. Based on the
     *         volley size and weapon/ammo type.
     */
    public StringProperty nameProperty() {
        return name;
    }

public StringProperty nameProperty() {
     * @return <code>true</code> if the item was successfully split from this, <code>false</code> otherwise.
     */
    public boolean remove(Item aItem) {
        if (aItem instanceof Ammunition) {
            final Ammunition ammunition = (Ammunition) aItem;
            if (selectorName.equals(ammunition.getAmmoType())) {
                ammoRounds.set(ammoRounds.get() - ammunition.getNumRounds());
                return true;
            }
        }
        else {
            final Weapon weapon = (Weapon) aItem;
            if (selectorName.equals(getSelectorFor(weapon))) {
                volleySize.set(volleySizeProperty().get() - weapon.getAmmoPerPerShot());
                multiplicity.set(multiplicity.get() - getMultiplicityFor(weapon));
                battleTime.offer(weapon);
                updateName(weapon);
                return true;
            }
        }
        return false;
    }
public boolean remove(Item aItem) {
     *         {@link WeaponSummary}. The property will have the value {@link Double#POSITIVE_INFINITY} for weapons that
     *         don't use ammo.
     */
    public DoubleProperty roundsProperty() {
        return ammoRounds;
    }

public DoubleBinding totalDamageProperty() {
     *         weapons that fire simultaneously. If this {@link WeaponSummary} doesn't have a weapon associated, i.e.
     *         only ammo without a matching weapon, then the volley size property will be <code>zero</code>.
     */
    public IntegerProperty volleySizeProperty() {
        return volleySize;
    }

    private void addItem(Item aItem) {
        if (aItem instanceof Weapon) {
            final Weapon weapon = (Weapon) aItem;
            volleySize.set(volleySize.get() + weapon.getAmmoPerPerShot());
            multiplicity.set(multiplicity.get() + getMultiplicityFor(weapon));
            updateName(aItem);
        }
        else {
            name.set(aItem.getShortName());
        }
    }

    private int getMultiplicityFor(Weapon aWeapon) {
        if (shouldCountTubes(aWeapon)) {
            return aWeapon.getAmmoPerPerShot();
        }
        return 1;
    }

    private String getSelectorFor(Item aItem) {
        return aItem instanceof AmmoWeapon ? ((AmmoWeapon) aItem).getAmmoKey() : aItem.getName();
    }

    private boolean shouldCountTubes(Item aItem) {
        return aItem.getName().matches(".*[LS]RM \\d+.*");
    }

    private void updateName(Item aItem) {
        if (shouldCountTubes(aItem)) { // Implies missile weapon -> ammo weapon
            final AmmoWeapon aAmmoWeapon = (AmmoWeapon) aItem;
            name.set(aAmmoWeapon.getShortName().replaceFirst("\\d+", Integer.toString(multiplicity.get())));
        }
        else {
            if (multiplicity.get() > 1) {
                name.set(multiplicity.get() + "x " + aItem.getShortName());
            }
            else {
                name.set(aItem.getShortName());
            }
        }
    }

}
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
//@formatter:on
package org.lisoft.lsml.view_fx.loadout;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;
import org.lisoft.lsml.model.NoSuchItemException;
import org.lisoft.lsml.model.database.ItemDB;
import org.lisoft.lsml.model.item.AmmoWeapon;
import org.lisoft.lsml.model.item.Ammunition;
import org.lisoft.lsml.model.item.Item;
import org.lisoft.lsml.model.loadout.Loadout;
import org.lisoft.lsml.view_fx.util.WeaponSummary;
import org.mockito.Mockito;

public class WeaponSummaryTest {

    private final Item llas;
    private final Item lrm20;
    private final AmmoWeapon ac20;
    private final Ammunition ac20ammo;
    private final Ammunition ac20ammoHalf;
    private final AmmoWeapon srm6;
    private final AmmoWeapon srm4;
    private final AmmoWeapon srm2;
    private final AmmoWeapon srm6Artemis;
    private final AmmoWeapon srm4Artemis;
    private final AmmoWeapon srm2Artemis;
    private final Item mllas;
    private final Loadout loadout = Mockito.mock(Loadout.class);

    public WeaponSummaryTest() throws NoSuchItemException {
        llas = ItemDB.lookup("LARGE LASER");
        lrm20 = ItemDB.lookup("LRM 20");
        ac20 = (AmmoWeapon) ItemDB.lookup("AC/20");
        ac20ammo = (Ammunition) ItemDB.lookup("AC/20 AMMO");
        ac20ammoHalf = (Ammunition) ItemDB.lookup("AC/20 AMMO (1/2)");
public WeaponSummaryTest() throws NoSuchItemException {
    }

    @Test
    public void testBattleTime_Complex() throws Exception {
        final Ammunition srmAmmo = (Ammunition) ItemDB.lookup("SRM AMMO");

        final WeaponSummary cut = new WeaponSummary(loadout, srmAmmo);
        assertEquals(0, cut.battleTimeProperty().get(), 0.0);

        final int rounds = 2 * srmAmmo.getNumRounds();
public void testBug495() throws Exception {
        final AmmoWeapon cuac10 = (AmmoWeapon) ItemDB.lookup("C-ULTRA AC/10");
        final Ammunition cuac10ammo = (Ammunition) ItemDB.lookup("C-U-AC/10 AMMO");

        final WeaponSummary cut = new WeaponSummary(loadout, cuac10);
        cut.consume(cuac10ammo);
        cut.consume(cuac10ammo);

public void testBug495() throws Exception {
    public void testBug550() throws Exception {
        final AmmoWeapon cuac10 = (AmmoWeapon) ItemDB.lookup("C-ULTRA AC/10");

        final WeaponSummary cut = new WeaponSummary(loadout, cuac10);
        cut.consume(cuac10);
        cut.remove(cuac10);

public void testBug550() throws Exception {

    @Test
    public void testConsume_Ammo2Ammo_CorrectType() {
        final WeaponSummary cut = new WeaponSummary(loadout, ac20ammo);
        assertTrue(cut.consume(ac20ammo));
        assertEquals(ac20ammo.getNumRounds() * 2, cut.roundsProperty().get(), 0.0);
        assertEquals(0, cut.volleySizeProperty().get());
public void testConsume_Ammo2Ammo_CorrectType() {
    @Test
    public void testConsume_Ammo2Ammo_CorrectTypeHalfTon() {
        final int expectedRounds = ac20ammo.getNumRounds() + ac20ammoHalf.getNumRounds();
        final WeaponSummary cut = new WeaponSummary(loadout, ac20ammo);
        assertTrue(cut.consume(ac20ammoHalf));
        assertEquals(expectedRounds, cut.roundsProperty().get(), 0.0);
        assertEquals(0, cut.volleySizeProperty().get());
    }

    @Test
    public void testConsume_Ammo2Ammo_WrongType() {
        final WeaponSummary cut = new WeaponSummary(loadout, ac20ammo);
        assertFalse(cut.consume(ac10ammo));
        assertEquals(0, cut.volleySizeProperty().get());
    }

    @Test
    public void testConsume_Ammo2AmmolessWeapon_CorrectType() {
        final WeaponSummary cut = new WeaponSummary(loadout, llas);
        assertFalse(cut.consume(ac10ammo));
        assertEquals(llas.getShortName(), cut.nameProperty().get());
        assertTrue(Double.isInfinite(cut.roundsProperty().get()));
public void testConsume_Ammo2AmmolessWeapon_CorrectType() {

    @Test
    public void testConsume_Ammo2AmmoWeapon_CorrectType() {
        final WeaponSummary cut = new WeaponSummary(loadout, ac20);
        assertTrue(cut.consume(ac20ammo));
        assertEquals(ac20ammo.getNumRounds(), cut.roundsProperty().get(), 0.0);
        assertEquals(1, cut.volleySizeProperty().get());
public void testConsume_Ammo2AmmoWeapon_CorrectType() {

    @Test
    public void testConsume_Ammo2AmmoWeapon_WrongType() {
        final WeaponSummary cut = new WeaponSummary(loadout, ac20);
        assertFalse(cut.consume(ac10ammo));
        assertEquals(0, cut.roundsProperty().get(), 0.0);
        assertEquals(1, cut.volleySizeProperty().get());
    }

    @Test
    public void testConsume_AmmolessWeapon2Ammo() {
        final WeaponSummary cut = new WeaponSummary(loadout, ac10ammo);
        assertFalse(cut.consume(llas));
        assertEquals(ac10ammo.getNumRounds(), cut.roundsProperty().get(), 0.0);
        assertEquals(0, cut.volleySizeProperty().get());
    }

    @Test
    public void testConsume_AmmolessWeapon2AmmolessWeapon_CorrectType() {
        final WeaponSummary cut = new WeaponSummary(loadout, llas);
        assertTrue(cut.consume(llas));
        assertEquals("2x " + llas.getShortName(), cut.nameProperty().get());
        assertTrue(Double.isInfinite(cut.roundsProperty().get()));
public void testConsume_AmmolessWeapon2AmmolessWeapon_CorrectType() {

    @Test
    public void testConsume_AmmolessWeapon2AmmolessWeapon_WrongType() {
        final WeaponSummary cut = new WeaponSummary(loadout, llas);
        assertFalse(cut.consume(mllas));
        assertEquals(llas.getShortName(), cut.nameProperty().get());
        assertTrue(Double.isInfinite(cut.roundsProperty().get()));
public void testConsume_AmmolessWeapon2AmmolessWeapon_WrongType() {

    @Test
    public void testConsume_AmmolessWeapon2AmmoWeapon() {
        final WeaponSummary cut = new WeaponSummary(loadout, ac20);
        assertFalse(cut.consume(llas));
        assertEquals(ac20.getShortName(), cut.nameProperty().get());
        assertEquals(1, cut.volleySizeProperty().get());
    }

    @Test
    public void testConsume_AmmoWeapon2Ammo_CorrectType() {
        final WeaponSummary cut = new WeaponSummary(loadout, ac20ammo);
        assertTrue(cut.consume(ac20));
        assertEquals(ac20ammo.getNumRounds(), cut.roundsProperty().get(), 0.0);
        assertEquals(ac20.getShortName(), cut.nameProperty().get());
public void testConsume_AmmoWeapon2Ammo_CorrectType() {

    @Test
    public void testConsume_AmmoWeapon2Ammo_WrongType() {
        final WeaponSummary cut = new WeaponSummary(loadout, ac10ammo);
        assertFalse(cut.consume(ac20));
        assertEquals(ac10ammo.getNumRounds(), cut.roundsProperty().get(), 0.0);
        assertEquals(0, cut.volleySizeProperty().get());
public void testConsume_AmmoWeapon2Ammo_WrongType() {

    @Test
    public void testConsume_AmmoWeapon2AmmoWeapon_CorrectType() {
        final WeaponSummary cut = new WeaponSummary(loadout, ac20);
        assertTrue(cut.consume(ac20));
        assertEquals("2x " + ac20.getShortName(), cut.nameProperty().get());
        assertEquals(2, cut.volleySizeProperty().get());
public void testConsume_AmmoWeapon2AmmoWeapon_CorrectType() {

    @Test
    public void testConsume_AmmoWeapon2AmmoWeapon_VariantType() {
        final WeaponSummary cut = new WeaponSummary(loadout, srm6);
        assertTrue(cut.consume(srm4));
        assertEquals(10, cut.volleySizeProperty().get());
        assertEquals(0, cut.battleTimeProperty().get(), 0.0);
    }

    @Test
    public void testConsume_AmmoWeapon2AmmoWeapon_WrongType() {
        final WeaponSummary cut = new WeaponSummary(loadout, ac20);
        assertFalse(cut.consume(ac10));
        assertEquals(ac20.getShortName(), cut.nameProperty().get());
        assertEquals(1, cut.volleySizeProperty().get());
    }

    @Test
    public void testConsume_MissileNames() {
        final WeaponSummary cut = new WeaponSummary(loadout, srm2Artemis);
        assertTrue(cut.consume(srm4Artemis));
        assertTrue(cut.consume(srm6Artemis));
        assertEquals("SRM 12 + A.", cut.nameProperty().get());
public void testConsume_MissileNames() {

    @Test
    public void testCreateAmmo() {
        final WeaponSummary cut = new WeaponSummary(loadout, ac20ammo);
        assertEquals(ac20ammo.getNumRounds(), cut.roundsProperty().get(), 0.0);
        assertEquals(ac20ammo.getShortName(), cut.nameProperty().get());
        assertEquals(0, cut.volleySizeProperty().get());
public void testCreateAmmo() {

    @Test
    public void testCreateAmmolessWeapon() {
        final WeaponSummary cut = new WeaponSummary(loadout, llas);
        assertTrue(Double.isInfinite(cut.roundsProperty().get()));
        assertEquals(llas.getShortName(), cut.nameProperty().get());
        assertEquals(1, cut.volleySizeProperty().get());
public void testCreateAmmolessWeapon() {

    @Test
    public void testCreateAmmoWeapon() {
        final WeaponSummary cut = new WeaponSummary(loadout, c_mg);
        assertEquals(0, cut.roundsProperty().get(), 0.0);
        assertEquals(1, cut.volleySizeProperty().get());
        assertEquals(c_mg.getShortName(), cut.nameProperty().get());
public void testCreateAmmoWeapon() {

    @Test
    public void testCreateMissileWeapon() {
        final WeaponSummary cut = new WeaponSummary(loadout, lrm20);
        assertEquals(0.0, cut.roundsProperty().get(), 0.0);
        assertEquals(lrm20.getShortName(), cut.nameProperty().get());
        assertEquals(20, cut.volleySizeProperty().get());
public void testCreateMissileWeapon() {

    @Test
    public void testRemove_AmmoFromAmmo_WrongType() {
        final WeaponSummary cut = new WeaponSummary(loadout, ac20ammo);
        assertFalse(cut.remove(ac10ammo));
        assertFalse(cut.empty());
    }

    @Test
    public void testRemove_AmmoFromManyAmmo_CorrectType() {
        final WeaponSummary cut = new WeaponSummary(loadout, ac20ammo);
        cut.consume(ac20ammo);
        cut.consume(ac20ammo);

public void testRemove_AmmoFromManyAmmo_CorrectType() {

    @Test
    public void testRemove_AmmoWeaponFromAmmoAndAmmoWeapon_WrongType() {
        final WeaponSummary cut = new WeaponSummary(loadout, ac20ammo);
        cut.consume(ac20);

        assertFalse(cut.remove(ac10));
public void testRemove_AmmoWeaponFromAmmoAndAmmoWeapon_WrongType() {

    @Test
    public void testRemove_AmmoWeaponFromManyAmmoAndAmmoWeapon_CorrectType() {
        final WeaponSummary cut = new WeaponSummary(loadout, ac20ammo);
        cut.consume(ac20ammo);
        cut.consume(ac20);
        cut.consume(ac20);
public void testRemove_AmmoWeaponFromManyAmmoAndAmmoWeapon_CorrectType() {

    @Test
    public void testRemove_LastAmmoWeaponFromAmmoWeapon_CorrectType() {
        final WeaponSummary cut = new WeaponSummary(loadout, ac20);
        assertTrue(cut.remove(ac20));
        assertTrue(cut.empty());
        assertEquals(0.0, cut.battleTimeProperty().get(), 0.0);
    }

    @Test
    public void testRemove_LastAmmoWeaponFromAmmoWeaponRemainingAmmo_CorrectType() {
        final WeaponSummary cut = new WeaponSummary(loadout, ac20);
        cut.consume(ac20ammo);

        assertTrue(cut.remove(ac20));
public void testRemove_LastAmmoWeaponFromAmmoWeaponRemainingAmmo_CorrectType() {
    }

    @Test
    public void testRemove_Srm_Bug528() {
        final WeaponSummary cut = new WeaponSummary(loadout, srm6);
        assertTrue(cut.remove(srm6));
        assertEquals(0, cut.volleySizeProperty().get(), 0.0);
        assertEquals(0, cut.roundsProperty().get(), 0.0);
        assertTrue(cut.empty());
    }

    @Test
    public void testRemove_SrmName_Bug528() {
        final WeaponSummary cut = new WeaponSummary(loadout, srm6);
        assertTrue(cut.consume(srm6));
        assertEquals("SRM 12", cut.nameProperty().get());
        assertTrue(cut.remove(srm6));
public void testRemove_SrmName_Bug528() {

    @Test
    public void testRemove_WeaponFromAmmoAndAmmoWeapon() {
        final WeaponSummary cut = new WeaponSummary(loadout, ac20ammo);
        cut.consume(ac20);

        assertFalse(cut.remove(llas));
public void testRemove_WeaponFromAmmoAndAmmoWeapon() {

    @Test
    public void testRemove_WeaponFromManyWeapon() {
        final WeaponSummary cut = new WeaponSummary(loadout, llas);
        cut.consume(llas);
        cut.consume(llas);

public void testRemove_WeaponFromManyWeapon() {
    }

    @Test
    public void testTotalDamage_BallisticNoAmmo() {
        final WeaponSummary cut = new WeaponSummary(loadout, ac20);
        assertEquals(0.0, cut.totalDamageProperty().get(), 0.0);
    }

    @Test
    public void testTotalDamage_BallisticWithAmmo() {
        final WeaponSummary cut = new WeaponSummary(loadout, ac20);
        cut.consume(ac20ammo);
        cut.consume(ac20ammo);
        cut.consume(ac20);
        assertEquals(ac20ammo.getNumRounds() * 2 * ac20.getDamagePerShot(), cut.totalDamageProperty().get(), 0.0);
    }

    @Test
    public void testTotalDamage_Energy() {
        final WeaponSummary cut = new WeaponSummary(loadout, llas);
        assertTrue(Double.isInfinite(cut.totalDamageProperty().get()));
    }

    @Test
    public void testTotalDamage_OnlyAmmo() {
        final WeaponSummary cut = new WeaponSummary(loadout, ac20ammo);
        assertEquals(0, cut.totalDamageProperty().get(), 0.0);
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      <snapshots><enabled>true</enabled></snapshots>
    </repository>
  </repositories>
  
  <profiles>
    <profile>
      <id>merge</id>
private TarArchiver createArchiver(File outputDir, File archive) throws NoSuchAr
        archiver.setLongfile(TarLongFileMode.posix);

        DefaultArchivedFileSet archiveSet =
                DefaultArchivedFileSet.archivedFileSet(new File(outputDir,"maven.tar"));
        archiveSet.setPrefix("maven/");
        archiveSet.setIncludingEmptyDirectories(true);
        archiver.addArchivedFileSet(archiveSet);
private void createAssemblyTarArchive(AssemblyConfiguration assemblyConfig, Mojo

        try {
            assembly.setId("docker");
            assemblyArchiver.createArchive(assembly, "maven", "tar", source, false);
        } catch (ArchiveCreationException | AssemblyFormattingException e) {
            throw new MojoExecutionException( "Failed to create assembly for docker image: " + e.getMessage(), e );
        } catch (InvalidAssemblerConfigurationException e) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void showVisitorBoxScore(BoxScoreValues values) {
        List<String> players = new ArrayList<>();

        for (StatLine statLine : values.getVls().getPstsg()) {
            players.add(statLine.getFn().substring(0, 1) + ". " + statLine.getLn());
        }

        playerAdapter.setData(players);
public void showHomeBoxScore(BoxScoreValues values) {
        List<String> players = new ArrayList<>();

        for (StatLine statLine : values.getHls().getPstsg()) {
            players.add(statLine.getFn().substring(0, 1) + ". " + statLine.getLn());
        }

        playerAdapter.setData(players);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public boolean isSink(Stmt sCallSite, InterproceduralCFG<Unit, SootMethod> cfg,
		if (def == null) {
			// If we don't have a sink definition for the direct callee, we
			// check the CFG.
			boolean found = false;
			for (SootMethod sm : cfg.getCalleesOfCallAt(sCallSite)) {
				String signature = methodToSignature.getUnchecked(sm);
				if (this.sinkMethods.containsKey(signature)) {
					found = true;
					break;
				}
			}
			if (!found)
				return false;
		}
		
		// If we have no precise information, we conservatively assume that
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import javax.sql.DataSource;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.context.annotation.Configuration;

import lombok.extern.slf4j.Slf4j;
import net.ttddyy.dsproxy.listener.logging.SystemOutQueryLoggingListener;
import net.ttddyy.dsproxy.support.ProxyDataSourceBuilder;

@Slf4j
@Configuration
public class DataSourceProxyBeanConfig implements BeanPostProcessor {

    public Object postProcessAfterInitialization(Object bean, String beanName)
            throws BeansException {

        if (bean instanceof DataSource) {
            System.out.println("AfterInitialization : " + beanName);

            log.info("Inside Proxy Creation");

            // use pretty formatted query with multiline enabled
            final PrettyQueryEntryCreator creator = new PrettyQueryEntryCreator();
            creator.setMultiline(true);

            final SystemOutQueryLoggingListener listener = new SystemOutQueryLoggingListener();
            listener.setQueryLogEntryCreator(creator);

            return ProxyDataSourceBuilder.create((DataSource) bean).countQuery()
                    .name("MyDS").listener(listener)
                    .logSlowQueryToSysOut(1, TimeUnit.MINUTES).build();

        }
        return bean; // you can return any other object as well
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void triggerSyncIfNeeded() {
                getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
                startService(serviceIntent);

                Log.d(TAG, String.format("triggerSyncIfNeeded: hasOldOBs: %!d(MISSING); syncCount: %!d(MISSING); photoSyncCount: %!d(MISSING); mUserCanceledSync: %!s(MISSING)",
                        hasOldObs, syncCount, photoSyncCount, mUserCanceledSync));


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	private final int FLASH_OFF = 1;
	private final int FLASH_AUTO = 2;

	@Nullable
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
else if (locationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER)!
		buttonClick.setOnClickListener( new OnClickListener() {
			public void onClick(View v) {
				//progress = ProgressDialog.show(ctx, "", "");
				preview.mCamera.takePicture(shutterCallback, null, jpegCallback);
			}
		});
		camera_switch = (ImageButton)view.findViewById(R.id.switch_camera);
else if (degrees < -90 && degrees >= -180 ){
			_intent.putExtra("longtitude",lon);*/
			_intent.putExtra("scale", true);
			_intent.putExtra("activityName", "Camera2");
			startActivityForResult(_intent, 1);
			//progress.dismiss();

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private Bundle processIntent(Bundle savedInstanceState) {
            mLostFocus = savedInstanceState.getBoolean("lostFocus");

            Uri uri = savedInstanceState.getParcelable(Uri.class.getName());
            intent = new Intent(ACTION_VIEW_USERID, uri);
        }
        else {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import org.kontalk.BuildConfig;
import org.kontalk.Log;
import org.kontalk.client.EndpointServer;
import org.kontalk.client.ServerList;
import org.kontalk.crypto.Coder;
import org.kontalk.message.CompositeMessage;
import org.kontalk.message.GroupCommandComponent;
import org.kontalk.message.TextComponent;
import org.kontalk.provider.MyMessages.CommonColumns;
import org.kontalk.provider.MyMessages.Messages.Fulltext;
import org.kontalk.provider.MyMessages.Threads;
import org.kontalk.provider.MyMessages.Threads.Conversations;
import org.kontalk.service.ServerListUpdater;
import org.kontalk.util.SystemUtils;


            DELETE_GROUP_MEMBERS      + ";" +
            "END";

        private static final String[] SCHEMA_UPGRADE_V4 = {
            // create temporary messages tables without msg_id UNIQUE constraint
            "CREATE TABLE " + TABLE_MESSAGES + "_new " + _SCHEMA_MESSAGES,
            // create temporary threads tables without msg_id UNIQUE constraint
            "CREATE TABLE " + TABLE_THREADS + "_new " + _SCHEMA_THREADS,
            // copy contents of messages table
            "INSERT INTO " + TABLE_MESSAGES + "_new SELECT " +
            "_id, thread_id, msg_id, SUBSTR(peer, 1, ?) || '@' || ?, direction, unread, 0, timestamp, status_changed, status, 'text/plain', " +
            "CASE WHEN mime <> 'text/plain' THEN NULL ELSE content END, "+
            "CASE WHEN mime <> 'text/plain' THEN 0 ELSE length(content) END, " +
            "CASE WHEN mime <> 'text/plain' THEN mime ELSE NULL END, preview_path, fetch_url, local_uri, length, 0, 0, 0, encrypted, " +
            "CASE WHEN encrypt_key IS NOT NULL THEN " + Coder.SECURITY_LEGACY_ENCRYPTED + " ELSE " + Coder.SECURITY_CLEARTEXT + " END, "+
            "strftime('%!s(MISSING)', server_timestamp)*1000" +
                " FROM " + TABLE_MESSAGES + " WHERE encrypted = 0",
            // copy contents of threads table
            "INSERT INTO " + TABLE_THREADS + "_new SELECT " +
            "_id, msg_id, SUBSTR(peer, 1, ?) || '@' || ?, direction, count, unread, 0, 'text/plain', content, timestamp, status_changed, status, 0, draft, 0" +
                " FROM " + TABLE_THREADS,
            // drop table messages
            "DROP TABLE " + TABLE_MESSAGES,
            // drop table threads
            "DROP TABLE " + TABLE_THREADS,
            // rename messages_new to messages
            "ALTER TABLE " + TABLE_MESSAGES + "_new RENAME TO " + TABLE_MESSAGES,
            // rename threads_new to threads
            "ALTER TABLE " + TABLE_THREADS + "_new RENAME TO " + TABLE_THREADS,
            // unique message index
            SCHEMA_MESSAGES_INDEX,
            // timestamp message index (for sorting)
            SCHEMA_MESSAGES_TIMESTAMP_IDX,
            // triggers
            TRIGGER_THREADS_INSERT_COUNT,
            TRIGGER_THREADS_UPDATE_COUNT,
            TRIGGER_THREADS_DELETE_COUNT
        };

        private static final String[] SCHEMA_UPGRADE_V8 = {
            SCHEMA_GROUPS,
            SCHEMA_GROUPS_MEMBERS,
            SCHEMA_MESSAGES_GROUPS,
            TRIGGER_GROUPS_DELETE_MEMBERS,
        };

        private static final String[] SCHEMA_UPGRADE_V9 = {
            "ALTER TABLE groups ADD COLUMN membership INTEGER NOT NULL DEFAULT 1",
            "DROP VIEW " + TABLE_MESSAGES_GROUPS,
            SCHEMA_MESSAGES_GROUPS,
        };

        private static final String[] SCHEMA_UPGRADE_V10 = {
            "ALTER TABLE threads ADD COLUMN sticky INTEGER NOT NULL DEFAULT 0",
        };

        private static final String SCHEMA_UPGRADE_V11 =
            "ALTER TABLE " + TABLE_THREADS + " ADD COLUMN encryption INTEGER NOT NULL DEFAULT 1";

        private Context mContext;

public void onCreate(SQLiteDatabase db) {

        @Override
        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
            if (oldVersion != 4 && oldVersion < 8) {
                // unsupported version
                throw new SQLException("database can only be upgraded from version 4 or versions greather than 7");
            }

            if (oldVersion == 4) {
                // take the first server from the builtin list
                ServerList list = ServerListUpdater.getCurrentList(mContext);
                EndpointServer server = list.get(0);
                String host = server.getNetwork();

                for (String sql : SCHEMA_UPGRADE_V4) {
                    if (sql.startsWith("INSERT ")) {
                        db.execSQL(sql, new Object[]{
                            CompositeMessage.USERID_LENGTH,
                            host
                        });
                    }
                    else {
                        db.execSQL(sql);
                    }
                }

                // fallback to next upgrade
                oldVersion = 8;
            }

            if (oldVersion == 8) {
                for (String sql : SCHEMA_UPGRADE_V8) {
                    db.execSQL(sql);
                }
                // fallback to next upgrade
                oldVersion = 10;
            }
            else if (oldVersion == 9) {
                for (String sql : SCHEMA_UPGRADE_V9) {
                    db.execSQL(sql);
                }
                // fallback to next upgrade
                oldVersion = 10;
            }

            if (oldVersion == 10) {
                for (String sql : SCHEMA_UPGRADE_V10) {
                    db.execSQL(sql);
                }
                // fallback to next upgrade
                oldVersion = 11;
            }

            if (oldVersion == 11) {
                db.execSQL(SCHEMA_UPGRADE_V11);
            }
        }
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    private static final Logger log = LoggerFactory.getLogger(TjwsServer.class);

    private Application application;

    private Serve server;
    private PippoServlet pippoServlet;

    @Override
    public PippoFilter getPippoFilter() {
        return null;
    }

    @Override
    public WebServer setPippoFilter(PippoFilter pippoFilter) {
        this.application = pippoFilter.getApplication();

        return this;
    }

    @Override
    public void start() {
        pippoServlet = new PippoServlet();
        pippoServlet.setApplication(application);

        Map<String, Object> arguments = new HashMap<>();
        arguments.put(Serve.ARG_BINDADDRESS, getSettings().getHost());
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import org.junit.Before;

import java.io.File;
import java.util.UUID;

/**

    protected final File TESTS_ROOT_DIRECTORY = new File(System.getProperty("java.io.tmpdir"), "auditing-tests-" + UUID.randomUUID().toString());
    protected final File OUTPUT_DIRECTORY = new File(TESTS_ROOT_DIRECTORY, "output");
    protected final File TEMPLATES_DIRECTORY = new File(AuditingTestsUtils.class.getClassLoader().getResource("templates").getFile());
    protected final File CONFIGURATION_DIRECTORY = new File(TESTS_ROOT_DIRECTORY, "configuration");
    protected final File CONFIGURATION_FILE_PATH = new File(CONFIGURATION_DIRECTORY, "auditing.properties");

    @Before
    public void before() {
        AuditingTestsUtils.initDirectory(TESTS_ROOT_DIRECTORY);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private JsToolkit(String identifier, String expr) {
		this.identifier = identifier;
		this.expr = expr;
	}


	public String waitCondition() {
		return "return (!" + identifier + " || " + expr + ");";
	}

	public static String globalWaitCondition() {
		StringBuilder sb = new StringBuilder("return ");
		for(JsToolkit toolkit: JsToolkit.values()){
			sb.append(" (!"+ toolkit.identifier + " || " + toolkit.expr + ") &&");
		}
		sb.append(";");
		return sb.toString().replace(" &&;", ";");
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.util.List;
import java.util.Locale;

/**
 * A placeholder fragment containing a simple view.
 */
public void success(final Recipe recipe) {
                    etServing.setText(String.valueOf(recipe.getServing()));
                    if (recipe.getSteps() != null) {
                        for (String step : recipe.getSteps()) {
                            EditText et = addDynamicEditTexts(R.id.llStepListCompose, "Add Step");
                            et.setText(step);
                        }
                    }
public void onClick(View v) {
                if (Integer.parseInt(v.getTag().toString()) == 1) {
                    Toast.makeText(getContext(), "ADD", Toast.LENGTH_SHORT).show();
                    v.setTag(2);
                    addDynamicEditTexts(R.id.llStepListCompose, "Step(s)");
                    v.setBackgroundResource(R.drawable.cancel);
                } else {
                    LinearLayout linearParent = (LinearLayout) v.getParent().getParent();
public void onClick(View v) {
            public void onClick(View v) {
                // TODO: Required field value check

                if (validateFields(R.id.llStepListCompose)) {
                    return;
                }

public void onClick(View v) {
                //iterarte over the linear layout and get steps added


                ArrayList<String> steps = getDataFromDynamicEditText(R.id.llStepListCompose);
                ArrayList<String> ingridients = getDataFromDynamicEditText(R.id.llIngridentsCompose);

                recipe.setSteps(steps);
public void onClick(View v) {
    }

    public ArrayList<String> getDataFromDynamicEditText(int llResourceId) {

        ArrayList<String> steps = new ArrayList<>();
        LinearLayout ll = (LinearLayout) view.findViewById(llResourceId);
        for (int i = 0; i < ll.getChildCount(); i++) {
            View llView = ll.getChildAt(i);
            if (llView instanceof LinearLayout) {
                EditText et = (EditText) ((LinearLayout) llView).getChildAt(0);
                if (et != null && !et.getText().toString().isEmpty())
                    steps.add(et.getText().toString());
            }
        }

        return steps;
    }

    public boolean validateFields(int linearLayoutResourceId) {
            android:layout_alignParentStart="true"
            android:layout_alignParentEnd="true"
            android:layout_alignParentRight="true"
            android:layout_alignTop="@+id/btnCancel"
            android:layout_below="@+id/vBorder"
            android:background="@color/colorPrimary"
            android:text="Publish"
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import com.alpha.pineapple.docker.model.InfoBuilder;
import com.alpha.pineapple.docker.model.rest.ContainerConfiguration;
import com.alpha.pineapple.docker.model.rest.CreatedContainer;
import com.alpha.pineapple.docker.model.rest.ImageCreation;
import com.alpha.pineapple.docker.session.DockerSession;
import com.alpha.pineapple.execution.ExecutionResult;
import com.alpha.pineapple.execution.ExecutionResultImpl;
public void testCanExecuteWithMinimalModel() throws Exception {
    @Test
    public void testCanExecuteWithModelWithImageCommandWithEmptyTag() throws Exception {
	// complete session initialization
	ImageCreation[] imageCreationInfos = {};
	expect(session.httpPostForObjectWithMultipleRootElements(eq(CREATE_IMAGE_URI), isA(Map.class),
		isA(ImageCreation[].class.getClass()))).andReturn(imageCreationInfos);
	replay(session);

	// create content
public void testCanExecuteWithModelWithImageCommandWithEmptyTag() throws Excepti
    public void testCanExecuteWithModelWithImageCommandWithUndefinedTag() throws Exception {

	// complete session initialization
	ImageCreation[] imageCreationInfos = {};
	expect(session.httpPostForObjectWithMultipleRootElements(eq(CREATE_TAGGED_IMAGE_URI), isA(Map.class),
		isA(ImageCreation[].class.getClass()))).andReturn(imageCreationInfos);
	replay(session);

	// create content
public void testCanExecuteWithModelWithImageCommandWithUndefinedTag() throws Exc
    public void testCanExecuteWithModelWithImageCommand() throws Exception {

	// complete session initialization
	ImageCreation[] imageCreationInfos = {};
	expect(session.httpPostForObjectWithMultipleRootElements(eq(CREATE_TAGGED_IMAGE_URI), isA(Map.class),
		isA(ImageCreation[].class.getClass()))).andReturn(imageCreationInfos);
	replay(session);

	// create content
public void testCanExecuteWithModelWithImageFromDockerfileCommand() throws Excep
	replay(coreRuntimeDirectoryProvider);

	// complete session initialization
	ImageCreation[] imageCreationInfos = {};
	expect(session.httpPostForObjectWithMultipleRootElements(eq(BUILD_IMAGE_URI), isA(Map.class),
		isA(HttpEntity.class), isA(ImageCreation[].class.getClass()), eq(CONTENT_TYPE_TAR)))
			.andReturn(imageCreationInfos);
	replay(session);

	// create content
import com.alpha.pineapple.command.initialization.ValidationPolicy;
import com.alpha.pineapple.docker.DockerClient;
import com.alpha.pineapple.docker.model.ImageInfo;
import com.alpha.pineapple.docker.model.rest.ImageCreation;
import com.alpha.pineapple.docker.session.DockerSession;
import com.alpha.pineapple.docker.utils.RestResponseException;
import com.alpha.pineapple.execution.ExecutionResult;
 * 
 * <li><code>image-creation-infos</code> contains array of image creation info's
 * from Docker. The type is
 * <code>com.alpha.pineapple.docker.model.ImageCreation[]</code>.</li>
 * 
 * <li>The the state of the supplied <code>ExecutionResult</code> is updated
 * with <code>ExecutionState.SUCCESS</code> if the test succeeded. If the test
	/**
	 * Null image creation info's.
	 */
	static final ImageCreation[] NULL_INFOS = {};

	/**
	 * Single digit string representation for boolean true.
void buildImage(Context context) throws SessionException {
		}

		// post to create image
		ImageCreation[] infos = null;

		try {

			infos = session.httpPostForObjectWithMultipleRootElements(BUILD_IMAGE_URI, uriVariables, requestEntity,
					ImageCreation[].class, CONTENT_TYPE_TAR);

		} catch (RestResponseException rre) {
			Object[] args2 = { rre.getStatusCode(), rre.getMessage() };
void buildImage(Context context) throws SessionException {
		String message = messageProvider.getMessage("bic.list_image_info", args);
		executionResult.addMessage(ExecutionResult.MSG_MESSAGE, message);

		for (ImageCreation info : infos) {

			// handle normal status update
			if (containsStatusUpdate(info)) {
import com.alpha.pineapple.command.initialization.ValidationPolicy;
import com.alpha.pineapple.docker.DockerClient;
import com.alpha.pineapple.docker.model.ImageInfo;
import com.alpha.pineapple.docker.model.rest.ImageCreation;
import com.alpha.pineapple.docker.session.DockerSession;
import com.alpha.pineapple.docker.utils.RestResponseException;
import com.alpha.pineapple.execution.ExecutionResult;
 * <li><code>image-creation-infos</code> contains array of image creation info's
 * from Docker. If image already exists then no info's are returned. If the
 * creation fails then no no info's are returned. The type is
 * <code>com.alpha.pineapple.docker.model.ImageCreation[]</code>.</li>
 * 
 * <li>The the state of the supplied <code>ExecutionResult</code> is updated
 * with <code>ExecutionState.SUCCESS</code> if the test succeeded. If the test
	/**
	 * Null image creation info's.
	 */
	static final ImageCreation[] NULL_INFOS = {};

	/**
	 * Key used to identify property in context: Image info.
public boolean execute(Context context) throws Exception {
		uriVariables.put("image", imageInfo.getRepository());

		// post to create image
		ImageCreation[] infos = null;

		try {

			if (isTaggedImage(imageInfo)) {
				uriVariables.put("tag", imageInfo.getTag());
				infos = session.httpPostForObjectWithMultipleRootElements(CREATE_TAGGED_IMAGE_URI, uriVariables,
						ImageCreation[].class);
			} else {
				infos = session.httpPostForObjectWithMultipleRootElements(CREATE_IMAGE_URI, uriVariables,
						ImageCreation[].class);
			}

		} catch (RestResponseException rre) {
public boolean execute(Context context) throws Exception {
		Object[] args = { infos.length };
		String message = messageProvider.getMessage("cic.list_image_info", args);
		executionResult.addMessage(ExecutionResult.MSG_MESSAGE, message);
		for (ImageCreation info : infos) {

			// handle normal status update
			if (containsStatusUpdate(info)) {
import org.apache.commons.lang.Validate;

import com.alpha.pineapple.docker.model.ImageInfo;
import com.alpha.pineapple.docker.model.rest.ImageCreation;
import com.alpha.pineapple.docker.model.rest.ListedContainer;
import com.alpha.pineapple.docker.model.rest.ListedImage;

 */
public class ModelUtils {

    /**
     * String index for removal of prefix.
     */
    static final int INDEX_FOR_PREFIX_REMOVAL = 1;

    /**
     * Start index for truncated Id.
     */
    static final int START_INDEX = 0;

    /**
     * End index for truncated Id.
     */
    static final int END_INDEX = 12;

    /**
     * First list index.
     */
    static final int FIRST_INDEX = 0;

    /**
     * Returns true if image object is defined with a non-null or non-empty tag
     * parameter.
     * 
     * @param info
     *            image info object.
     * 
     * @return true if the tag parameter is defined and not empty.
     */
    public static boolean isTaggedImage(ImageInfo info) {
	Validate.notNull(info, "info is undefined");

	if (info.getTag() == null)
	    return false;
	if (info.getTag().isEmpty())
	    return false;
	return true;
    }

    /**
     * Returns true if image creation object contains a regular status update
     * information in the status field, i.e. it is defined with a non-null or
     * non-empty value.
     * 
     * @param info
     *            image creation object.
     * 
     * @return true if image creation object contains regular status update
     *         information in the status field. Returns false if the status
     *         field is null or empty.
     */
    public static boolean containsStatusUpdate(ImageCreation info) {
	Validate.notNull(info, "info is undefined");

	if (info.getStatus() == null)
	    return false;
	if (info.getStatus().isEmpty())
	    return false;
	return true;
    }

    /**
     * Returns true if image creation object contains a stream update
     * information in the stream field, i.e. it is defined with a non-null or
     * non-empty value.
     * 
     * @param info
     *            image creation object.
     * 
     * @return true if image creation object contains stream update information
     *         in the stream field. Returns false if the status field is null or
     *         empty.
     */
    public static boolean containsStreamUpdate(ImageCreation info) {
	Validate.notNull(info, "info is undefined");

	if (info.getStream() == null)
	    return false;
	if (info.getStream().isEmpty())
	    return false;
	return true;
    }

    /**
     * Create truncated ID which is reduced to 12 characters long.
     * 
     * @param id
     *            id to be truncated. If the id is null or empty then the empty
     *            string is returned.
     */
    public static String createTruncatedId(String id) {
	if (id == null)
	    return "";
	if (id.isEmpty())
	    return "";
	return id.substring(START_INDEX, END_INDEX);
    }

    /**
     * Remove LF from Docker stream update.
     * 
     * @param update
     *            stream update.
     */
    public static String remoteLfFromStreamUpdate(String update) {
	if (update == null)
	    return update;
	return StringUtils.trim(update);
    }

    /**
     * Returns true if no repository tags are defined.
     * 
     * @param image
     *            listed Docker image.
     * 
     * @return true if no repository tags are defined.
     */
    public static boolean isNoImageRepoTagsDefined(ListedImage image) {
	if (image == null)
	    return true;
	if (image.getRepoTags() == null)
	    return true;

	List<String> tagsList = image.getRepoTags();
	if (tagsList.isEmpty())
	    return true;
	for (String tag : tagsList) {
	    if (!UNDEFINED_REPO_TAG.equals(tag))
		return false;
	}
	return true;
    }

    /**
     * Returns true if tag is defined in image name in container.
     * The tag is defined using the ":" separator.
     * 
     * @param image
     *            Docker image name .
     * 
     * @return true if repository tag is defined in image name.
     */
    public static boolean isImageRepoTagDefined(ListedContainer container) {
	Validate.notNull(container, "container is undefined.");
	return containsSeparator(container.getImage());
    }
    
    /**
     * Return true if string message is not null or empty.
     * 
     * @param stringMessage
     *            optional string message.
     * 
     * @return true if string message is not null or empty.
     */
    public static boolean isStringMessageDefined(String stringMessage) {
	if (stringMessage == null)
	    return false;
	return (!stringMessage.isEmpty());
    }

    /**
     * Return true if container name is prefixed with "/".
     * 
     * @param name
     *            container name.
     * 
     * @return true if container name is prefixed with "/"..
     */
    public static boolean isContainerNamePrefixed(String name) {
	if (name == null)
	    return false;
	if (name.isEmpty())
	    return false;
	return name.startsWith("/");
    }

    /**
     * If container name is prefixed with "/" then the prefix is removed.
     * 
     * @param name
     *            container name.
     * 
     * @return container name with prefix removed.
     */
    public static String removeContainerNamePrefix(String name) {
	if (!isContainerNamePrefixed(name))
	    return name;
	return name.substring(INDEX_FOR_PREFIX_REMOVAL);
    }

    /**
     * Get first list entry. If list is empty the null is returned.
     * 
     * @param list
     *            string list.
     * 
     * @return first list entry.
     */
    public static String getFirstListEntry(List<String> list) {
	if (list.isEmpty())
	    return null;
	return list.get(FIRST_INDEX);
    }

    /**
     * Returns true if name contains separator ":".
     * 
     * @param name name to test.
     * 
     * @return true if string contains separator ":".
     */
    public static boolean containsSeparator(String name) {
	Validate.notNull(name, "name is undefined.");
	int index = name.indexOf(":");
	return (index != -1);
    }
    
}
		</jaxb:bindings>		 
	</jaxb:bindings>

	<!-- Image definitions -->

	<jaxb:bindings schemaLocation="docker_1_0.xsd" >
		<jaxb:bindings node="//xs:complexType[@name='progressDetailType']" >
			<jaxb:class name="ProgressDetail" />				
		</jaxb:bindings>		 
	</jaxb:bindings>

	<jaxb:bindings schemaLocation="docker_1_0.xsd" >
		<jaxb:bindings node="//xs:complexType[@name='listedImageType']" >
			<jaxb:class name="ListedImage" />				
	</jaxb:bindings>

	<jaxb:bindings schemaLocation="docker_1_0.xsd" >
		<jaxb:bindings node="//xs:complexType[@name='imageCreationType']" >
			<jaxb:class name="ImageCreation" />				
		</jaxb:bindings>		 
	</jaxb:bindings>

	<xs:element name="listedContainer" type="listedContainerType" />	
	<xs:element name="inspectedContainer" type="containerJsonType" />
	<xs:element name="inspectedImage" type="imageInspectType" />
	<xs:element name="imageCreationInfo" type="imageCreationType" />
	<xs:element name="imageDeletionInfo" type="imageDeletionType" />
	<xs:element name="version" type="versionType" />

		<xs:attribute name="rw" type="xs:boolean" use="optional"/>										
	</xs:complexType>

	<!-- Image definitions -->

	<xs:complexType name="progressDetailType" >
		<xs:annotation>
			<xs:documentation>Detailed info about progress during image creation.</xs:documentation>
		</xs:annotation>
		<xs:attribute name="start" type="xs:string" use="optional"/>		
		<xs:attribute name="current" type="xs:string" use="optional"/>		
		<xs:attribute name="total" type="xs:string" use="optional"/>		
	</xs:complexType>

	<xs:complexType name="listedImageType" >
		<xs:annotation>
			<xs:documentation>Info about a listed Docker image (Output from the "List images" operation).</xs:documentation>
		<xs:attribute name="virtualSize" type="xs:long" use="optional"/>	
	</xs:complexType>

	<xs:complexType name="imageCreationType" >
		<xs:annotation>
			<xs:documentation>Info about Docker image creation progress.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="progressDetail" type="progressDetailType" minOccurs="0" maxOccurs="1" />
		</xs:sequence>
		<xs:attribute name="error" type="xs:string" use="optional"/>		
		<xs:attribute name="id" type="xs:string" use="optional"/>		
		<xs:attribute name="progress" type="xs:string" use="optional"/>		
		<xs:attribute name="status" type="xs:string" use="optional"/>		
		<xs:attribute name="stream" type="xs:string" use="optional"/>		
	</xs:complexType>

	<xs:complexType name="imageDeletionType" >
Development documentation

** Schema types for images

*** progressDetailType

	Detailed info about progress during image creation.
	
	Partial output from image creation.

*** errorDetailType

	Detailed info about errors during image creation.	
	
	Partial output from image creation.

*** listedImageType

Development documentation
	
	Defined Docker type: {{{https://github.com/docker/docker/blob/04295d26df3034a9a92da8400418f843d7c48780/api/types/types.go}ImageInspect}}
	
*** imageCreationType	
	
	Info about Docker image creation progress.
	
*** imageDeletionType

	Info about Docker image deletion progress.
Development documentation
	Input to container creation and output from container and image inspection. 
	Used by these schema types:
	
	* <<<ImageInspectType>>>
	
	[]

import static com.alpha.pineapple.docker.DockerConstants.DEFAULT_CENTOS_REPOSITORY;
import static com.alpha.pineapple.docker.DockerConstants.LATEST_IMAGE_TAG;
import static com.alpha.testutils.DockerTestConstants.TEST_DOCKER_ROOT_BUSYBOX_IMAGE;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import com.alpha.pineapple.docker.DockerClient;
import com.alpha.pineapple.docker.model.ImageInfo;
import com.alpha.pineapple.docker.model.InfoBuilder;
import com.alpha.pineapple.docker.model.rest.ImageCreation;
import com.alpha.pineapple.docker.session.DockerSession;
import com.alpha.pineapple.execution.ExecutionResult;
import com.alpha.pineapple.execution.ExecutionResultImpl;
public void testCreateTaggedCentosImage() throws Exception {
	assertTrue(executionResult.isSuccess());
	assertTrue(context.containsKey(CreateImageCommand.IMAGE_CREATION_INFOS_KEY));
	assertNotNull(context.get(CreateImageCommand.IMAGE_CREATION_INFOS_KEY));
	ImageCreation[] infos = (ImageCreation[]) context.get(CreateImageCommand.IMAGE_CREATION_INFOS_KEY);
	assertTrue(infos.length != 0);
	assertTrue(dockerClient.imageExists(session, imageInfo));
    }
public void testCreateTaggedTinyImage() throws Exception {
	assertTrue(executionResult.isSuccess());
	assertTrue(context.containsKey(CreateImageCommand.IMAGE_CREATION_INFOS_KEY));
	assertNotNull(context.get(CreateImageCommand.IMAGE_CREATION_INFOS_KEY));
	ImageCreation[] infos = (ImageCreation[]) context.get(CreateImageCommand.IMAGE_CREATION_INFOS_KEY);
	assertTrue(infos.length != 0);
	assertTrue(dockerClient.imageExists(session, imageInfo));
    }
public void testCreateTaggedTinyImageWithNewPulledImage() throws Exception {
	assertTrue(executionResult.isSuccess());
	assertTrue(context.containsKey(CreateImageCommand.IMAGE_CREATION_INFOS_KEY));
	assertNotNull(context.get(CreateImageCommand.IMAGE_CREATION_INFOS_KEY));
	ImageCreation[] infos = (ImageCreation[]) context.get(CreateImageCommand.IMAGE_CREATION_INFOS_KEY);
	assertTrue(infos.length != 0);
	assertTrue(dockerClient.imageExists(session, imageInfo));
    }
public void testCreateTaggedTinyImageWithMultipleLinesInDockerfile() throws Exce
	assertTrue(executionResult.isSuccess());
	assertTrue(context.containsKey(CreateImageCommand.IMAGE_CREATION_INFOS_KEY));
	assertNotNull(context.get(CreateImageCommand.IMAGE_CREATION_INFOS_KEY));
	ImageCreation[] infos = (ImageCreation[]) context.get(CreateImageCommand.IMAGE_CREATION_INFOS_KEY);
	assertTrue(infos.length != 0);
	assertTrue(dockerClient.imageExists(session, imageInfo));
    }
import com.alpha.pineapple.docker.DockerClient;
import com.alpha.pineapple.docker.model.ImageInfo;
import com.alpha.pineapple.docker.model.InfoBuilder;
import com.alpha.pineapple.docker.model.rest.ImageCreation;
import com.alpha.pineapple.docker.session.DockerSession;
import com.alpha.pineapple.execution.ExecutionResult;
import com.alpha.pineapple.execution.ExecutionResultImpl;
public void testCreateUntaggedImageFromUbuntuBaseRepository() throws Exception {
	assertTrue(executionResult.isSuccess());
	assertTrue(context.containsKey(CreateImageCommand.IMAGE_CREATION_INFOS_KEY));
	assertNotNull(context.get(CreateImageCommand.IMAGE_CREATION_INFOS_KEY));
	ImageCreation[] infos = (ImageCreation[]) context.get(CreateImageCommand.IMAGE_CREATION_INFOS_KEY);
	assertTrue(infos.length != 0);

	// test that image is actually is created with the "latest" tag
public void testCreateTaggedImageFromUbuntuBaseRepository() throws Exception {
	assertTrue(executionResult.isSuccess());
	assertTrue(context.containsKey(CreateImageCommand.IMAGE_CREATION_INFOS_KEY));
	assertNotNull(context.get(CreateImageCommand.IMAGE_CREATION_INFOS_KEY));
	ImageCreation[] infos = (ImageCreation[]) context.get(CreateImageCommand.IMAGE_CREATION_INFOS_KEY);
	assertTrue(infos.length != 0);
	assertTrue(dockerClient.imageExists(session, imageInfo));
    }
public void testCreateTaggedImageFromCentOsRepository() throws Exception {
	assertTrue(executionResult.isSuccess());
	assertTrue(context.containsKey(CreateImageCommand.IMAGE_CREATION_INFOS_KEY));
	assertNotNull(context.get(CreateImageCommand.IMAGE_CREATION_INFOS_KEY));
	ImageCreation[] infos = (ImageCreation[]) context.get(CreateImageCommand.IMAGE_CREATION_INFOS_KEY);
	assertTrue(infos.length != 0);
	assertTrue(dockerClient.imageExists(session, imageInfo));
    }
public void testCreateUntaggedImageFromUserRepository() throws Exception {
	assertTrue(executionResult.isSuccess());
	assertTrue(context.containsKey(CreateImageCommand.IMAGE_CREATION_INFOS_KEY));
	assertNotNull(context.get(CreateImageCommand.IMAGE_CREATION_INFOS_KEY));
	ImageCreation[] infos = (ImageCreation[]) context.get(CreateImageCommand.IMAGE_CREATION_INFOS_KEY);
	assertTrue(infos.length != 0);

	// test that image is actually is created with the "latest" tag
public void testCreateTaggedImageFromUserRepository() throws Exception {
	assertTrue(executionResult.isSuccess());
	assertTrue(context.containsKey(CreateImageCommand.IMAGE_CREATION_INFOS_KEY));
	assertNotNull(context.get(CreateImageCommand.IMAGE_CREATION_INFOS_KEY));
	ImageCreation[] infos = (ImageCreation[]) context.get(CreateImageCommand.IMAGE_CREATION_INFOS_KEY);
	assertTrue(infos.length != 0);
	assertTrue(dockerClient.imageExists(session, imageInfo));
    }
public void testSucceedsIfImageAlreadyExists() throws Exception {
	assertTrue(executionResult.isSuccess());
	assertTrue(context.containsKey(CreateImageCommand.IMAGE_CREATION_INFOS_KEY));
	assertNotNull(context.get(CreateImageCommand.IMAGE_CREATION_INFOS_KEY));
	ImageCreation[] infos = (ImageCreation[]) context.get(CreateImageCommand.IMAGE_CREATION_INFOS_KEY);
	assertEquals(0, infos.length);
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void addComment() {
        Fragment fragment = pagerAdapter.getItem(pos);

        if (pos == 0 || pos == 2) {
            ((GameThreadFragment) fragment).replyToThread();
        }
    }
}
public void onReplyToComment(final int position, final Comment parentComment) {
    }

    public void replyToThread() {
        presenter.replyToThreadBtnClick();
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
package edu.byu.suite.features.testingcenter.controller;

import android.content.Intent;
import android.os.Bundle;
import android.support.v4.widget.SwipeRefreshLayout;
	private static final int RECYCLER_VIEW = 0;
	private static final int TEXT_VIEW = 1;
	private boolean makeCall = false;
	private final ByuCallback<ScoresResponseWrapper> scoresCallback = new ByuCallback<ScoresResponseWrapper>(this) {
		@Override
		public void onSuccess(Call<ScoresResponseWrapper> call, Response<ScoresResponseWrapper> response) {
public void onNothingSelected(AdapterView<?> parent) {
		if (result == null) { // When the activity is first created
			loadInitialData();
		} else { // When you return to the ScoresFragment from a different fragment in the activity
			updateSpinnerAdapter(spinnerItemSelected);
		}
	}

public void onSuccess(Call<ScoresResponseWrapper> call, Response<ScoresResponseW
				result = response.body();
				// YearTerm.equals() doesn't include description, so indexOf(...) will find the index of the YearTerm that matches the current year term
				spinnerItemSelected = result.getContent().getYearTermsWithDescriptions().indexOf(new YearTerm(result.getContent().getCurrentYearTerm(), null));
				updateSpinnerAdapter(spinnerItemSelected);
				swipeRefreshLayout.setEnabled(true);
				showScores();
			}
private void showScores() {
		viewSwitcher.setDisplayedChild(studentTests.isEmpty() ? TEXT_VIEW : RECYCLER_VIEW);
	}

	private void updateSpinnerAdapter(int yearTermSelected) {
		SpinnerUtils.setUpAdapter(getActivity(), spinner, result.getContent().getYearTermsWithDescriptions(), null);
		// This triggers the onItemSelectedListener, and calls loadScores()
		spinner.setSelection(yearTermSelected);
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private static boolean isBlockOre(Block block, int meta) {
		Boolean cached = oreBlockCache.get(type);
		if (cached != null) return cached;

		ItemStack stack = new ItemStack(block, meta);
		for (int id : OreDictionary.getOreIDs(stack)) {
			String oreName = OreDictionary.getOreName(id);
			if (oreName.contains("ore")) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="PreferredVcsStorage">
    <preferredVcsName>ApexVCS</preferredVcsName>
  </component>
  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_8" default="true" project-jdk-name="1.8" project-jdk-type="JavaSDK" />
</project>
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Created by jmanrocks152 on 5/22/17.
 */
public class Main {
    public static void main(String[] args) {
        //Variable initialization
        Scanner scanner = new Scanner(System.in);
        int testCases = scanner.nextInt();
        String delims = "[ ]+";
        int numberOfSnakes,  currentQuery, largestSnakeLength = 0, numberOfPassingSnakes = 0, queries = 0;
        int arrayListOffset = 0;
public static void main(String[] args) {
        ArrayList<Integer> results = new ArrayList<>();

        for(int i = 0; i < testCases; i++) {
            String nqString = scanner.nextLine();
            String[] nqArray = nqString.split(delims);
            String snakeLengthsString = scanner.nextLine();
            String[] snakeLengthsArray = snakeLengthsString.split(delims);

            try {
public static void main(String[] args) {

            //For loop that ensures the program only activates for as many test cases there are

                for(int x = 0; x < queries; x++) {
                    currentQuery = scanner.nextInt();
                    for(int s : snakeLengthsArrayList) {
                        if(s >= currentQuery) {
                            numberOfPassingSnakes++;
                            snakeLengthsArrayList.remove(s - arrayListOffset);
                            arrayListOffset++;
                        }


                    }
                    for(int z = 0; z < snakeLengthsArrayList.size(); z++) {
                        if(z == 0) {
                            largestSnakeLength = snakeLengthsArrayList.get(0);
                        }
                        if(snakeLengthsArrayList.get(z) > largestSnakeLength) {
                            largestSnakeLength = snakeLengthsArrayList.get(z);
                        }
                        if(largestSnakeLength + (snakeLengthsArrayList.size() - 1) > currentQuery) {
                            numberOfPassingSnakes++;
                        }
                    }
                    results.add(numberOfPassingSnakes);
                }
                arrayListOffset = 0;
                numberOfPassingSnakes = 0;
            }

        for(Integer i : results) {
            System.out.println(results.get(i));
        }
        }
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void setupFab() {
        fab = (FloatingActionButton) findViewById(R.id.fab);
        chatBox = (SwipeRemoveLinearLayout) findViewById(R.id.messageBoxContainer);
        chatBox.registerToSwipeEvents(this);
        fabHidder = new CountDownTimer(Constants.HIDE_FAB_AFTER_SEC * 1000, Constants.HIDE_FAB_AFTER_SEC * 1000) {
            public void onTick(long millisUntilFinished) {
            }
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;

import com.zulip.android.R;

public Dialog onCreateDialog(Bundle savedInstanceState) {
        View rootView = inflater.inflate(R.layout.list_dialog, null);
        View cameraListItem = rootView.findViewById(R.id.picture_dialog);
        View fileListItem = rootView.findViewById(R.id.pick_file_dialog);

        // if device doesn't have camera, disable camera option
        if (!getActivity().getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA)) {
            android:layout_height="wrap_content"
            android:contentDescription="@string/stream_private_content_desp"
            android:padding="3dp"
            android:src="@drawable/ic_action_person"
            android:tint="@color/colorTextSecondary" />
    </LinearLayout>

    <LinearLayout
            android:paddingLeft="8dp"
            android:paddingRight="4dp"
            android:paddingTop="4dp"
            android:src="@drawable/ic_add_circle_outline_black_24dp"
            android:tint="@color/colorTextSecondary" />

        <AutoCompleteTextView
            android:id="@+id/message_et"
            android:alpha="0.7"
            android:contentDescription="@string/send_content_desp"
            android:padding="4dp"
            android:src="@drawable/ic_send_24dp"
            android:tint="@color/colorTextSecondary" />

    </LinearLayout>

        android:layout_marginBottom="16dp"
        android:orientation="horizontal">
    <ImageView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_vertical"
        android:src="@drawable/ic_photo_camera_black_24dp"
        android:tint="?attr/colorControlNormal"
        android:alpha="0.7"/>
    <TextView
        android:layout_width="wrap_content"
        android:orientation="horizontal"
        android:layout_marginTop="8dp">
    <ImageView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_vertical"
        android:src="@drawable/ic_insert_drive_file_black_24dp"
        android:tint="?attr/colorControlNormal"
        android:alpha="0.7"/>
    <TextView
        android:layout_width="wrap_content"
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void run() {
    public boolean deleteRecursive(File fileOrDirectory) {
        boolean recursive = true;
        if (fileOrDirectory.isDirectory())
            for (File child : fileOrDirectory.listFiles())
                recursive = deleteRecursive(child);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public synchronized void refreshCache() {
                    bctx.getServiceReferences(Runnable.class.getCanonicalName(), filter),
                    bctx.getServiceReferences(EventHandler.class.getCanonicalName(), filter));

            log.debug("Found {} registered services", serviceReferences.length);
            for (ServiceReference reference : serviceReferences) {
                try {
                    String configurationId = (String) reference.getProperty(CONFIGURATION_ID_KEY);
                    if (!configuredIds.contains(configurationId)) {
                        log.debug("Unregistering service for configuration {}", configurationId);
                        this.unregisterService(configurationId);
                    }
                } catch (Exception e) {
                    log.warn("Exception unregistering reference " + reference, e);
                }
            }

        } catch (InvalidSyntaxException e) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import micro.gui.PhysicalGameStatePanel;
import micro.rts.GameState;
import micro.rts.PhysicalGameState;
import micro.rts.units.UnitTypeTable;

/**
public void preEval() {
				try {
					// The new map is in the new initial game state
					initialPgs = PhysicalGameState.load("data/microRTS/maps/" + newMapName, utt);
					mapName = newMapName;
				} catch (JDOMException | IOException e) {
					e.printStackTrace(); System.exit(1);
public void preEval() {
		}
	}

	/**
	 * all actions performed in a single evaluation of a genotype
	 * loop taken from GameVisualSimulationTest, the rest based on MsPacManTask.oneEval()
public void preEval() {
	 */
	@Override
	public Pair<double[], double[]> oneEval(Genotype<T> individual, int num) {
		reset();
		gs = new GameState(pgs, utt);
		if(!AiInitialized)
			initializeAI();
		else{
public void preEval() {
		
		for(int i = 0; i < enemySet.size(); i++){
			reset();
			ai2 = enemySet.get(i);
			if(CommonConstants.watch){
				System.out.println("Current Enemy: "+ ai2.getClass().getName());
private void reset(){
				utt = new UnitTypeTable();
				averageUnitDifference = 0;
				baseUpTime = 0;
//				System.out.println("setting h e i to 0");
				harvestingEfficiencyIndex = 0;
				// Clone the initial game state; start from beginning
				pgs = initialPgs.clone();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

public class MatrixID implements _MatrixID {

    private static final Pattern matrixIdLaxPattern = Pattern.compile("@(.+):(.+)");
    private static final Pattern matrixIdStrictPattern = Pattern.compile("@([0-9a-z-.=_]+):(.+)");

    private String id;
    private static String invalidMxId3 = "john.doe";
    private static String invalidMxId4 = "@:";
    private static String invalidMxId5 = "@john.doe:";
    private static String invalidMxId6 = "@:example.org";


    @Test
public void invalidMatrixIDs5() {
        new MatrixID(invalidMxId5);
    }

    @Test(expected = IllegalArgumentException.class)
    public void invalidMatrixIDs6() {
        new MatrixID(invalidMxId6);
    }

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

public class DockerMachineRequirement implements Requirement<RequiresDockerMachine> {

    private final CommandLineExecutor commandLineExecutor = new CommandLineExecutor();

    @Override
    public void check(RequiresDockerMachine context) throws UnsatisfiedRequirementException {
package org.arquillian.cube.docker.impl.requirement;

import com.github.dockerjava.api.DockerClient;
import com.github.dockerjava.api.model.Version;
import com.github.dockerjava.core.DockerClientBuilder;
import com.google.common.base.Strings;
import java.util.HashMap;
import java.util.Map;
import org.arquillian.cube.docker.impl.client.CubeDockerConfiguration;
import org.arquillian.cube.docker.impl.client.CubeDockerConfigurationResolver;
import org.arquillian.cube.docker.impl.util.Boot2Docker;
import org.arquillian.cube.docker.impl.util.Top;
import org.arquillian.cube.spi.requirement.Requirement;
import org.arquillian.cube.spi.requirement.UnsatisfiedRequirementException;

public class DockerRequirement implements Requirement<RequiresDocker> {

    private final CommandLineExecutor commandLineExecutor = new CommandLineExecutor();
    private final CubeDockerConfigurationResolver resolver = new CubeDockerConfigurationResolver(new Top(),
        new DockerMachine(commandLineExecutor),
        new Boot2Docker(commandLineExecutor),
        new OperatingSystemResolver().currentOperatingSystem().getFamily()
    );

    /**
     * @param serverUrl
private static Version getDockerVersion(String serverUrl) {

    @Override
    public void check(RequiresDocker context) throws UnsatisfiedRequirementException {
        Map<String, String> config = resolver.resolve(new HashMap<String, String>());
        String serverUrl = config.get(CubeDockerConfiguration.DOCKER_URI);
        if (Strings.isNullOrEmpty(serverUrl)) {
            throw new UnsatisfiedRequirementException("Could not resolve the docker server url.");
        } else if (!isDockerRunning(serverUrl)) {
            throw new UnsatisfiedRequirementException("No server is running on url:[" + serverUrl + "].");
        }
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import de.westnordost.streetcomplete.data.download.QuestAutoDownloadStrategy;
import de.westnordost.streetcomplete.data.download.WifiAutoDownloadStrategy;
import de.westnordost.streetcomplete.data.osm.upload.ChangesetAutoCloserReceiver;
import de.westnordost.streetcomplete.util.SphericalEarthMath;

import static android.app.PendingIntent.FLAG_CANCEL_CURRENT;

public void startPositionTracking()

	public void stopPositionTracking()
	{
		if(lostApiClient.isConnected())
		{
			LocationServices.FusedLocationApi.removeLocationUpdates(lostApiClient, this);
			lostApiClient.disconnect();
		}
	}

public void startRequest(int priority, Callback listener)

	public void stopRequest()
	{
		Handler h = new Handler(Looper.getMainLooper());
		h.post(new Runnable()
		{
			@Override public void run()
			{
				if(lostApiClient.isConnected())
				{
					LocationServices.FusedLocationApi.removeLocationUpdates(lostApiClient, SingleLocationRequest.this);
					lostApiClient.disconnect();
				}
			}
		});

	}

	@Override public void onConnected() throws SecurityException
public void stopPositionTracking()
		lastLocation = null;
		zoomedYet = false;

		if(lostApiClient.isConnected())
		{
			LocationServices.FusedLocationApi.removeLocationUpdates(lostApiClient, this);
			lostApiClient.disconnect();
		}
	}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public DescribeResult call() throws GitAPIException {
    }

    // get commits, up until the nearest tag
    List<RevCommit> commits = jGitCommon.findCommitsUntilSomeTag(repo, headCommit, tagObjectIdToName);

    // if there is no tags or any tag is not on that branch then return generic describe
    if (foundZeroTags(tagObjectIdToName) || commits.isEmpty()) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public final View onCreateView(LayoutInflater inflater, @Nullable ViewGroup cont
    @Override
    public void applyLocale() {
        Context context = getContext();
        Locale currentLocale = LocaleManager.getInstance().getCurrentLocale(context);
        Locale.setDefault(currentLocale);
        final Resources resources = context.getResources();
        final Configuration config = resources.getConfiguration();
        config.setLocale(currentLocale);
        context.getResources().updateConfiguration(config, null);
        // We create and destroy a new WebView here to force the internal state of WebView to know
        // about the new language. See issue #666.
        final WebView unneeded = new WebView(getContext());
private String updateLocale(Context context, final Locale locale) {
        return locale.toString();
    }

    private boolean isMirroringSystemLocale(final Context context) {
        return getPersistedLocale(context) == null;
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void onClick(View v) {
            if (previousInputContentInfo != null) {
                onCommitContentInternal(previousInputContentInfo, previousFlags);
            }
        } else {
            showMarkSensitive = false;
            startingVisibility = preferences.getString("rememberedVisibility", "public");
            statusMarkSensitive = false;
            startingHideText = false;
        }

        /* If the composer is started up as a reply to another post, override the "starting" state
protected void onSaveInstanceState(Bundle outState) {
        }
        currentInputContentInfo = null;
        currentFlags = 0;
        super.onSaveInstanceState(outState);
    }

public void onClick(View v) {
        }
    }

    private File createNewImageFile() throws IOException {
        // Create an image file name
        String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss", Locale.US).format(new Date());
private void cancelReadyingMedia(QueuedMedia item) {
    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (requestCode == MEDIA_PICK_RESULT && resultCode == RESULT_OK && data != null) {
            Uri uri = data.getData();
            long mediaSize = MediaUtils.getMediaSize(getContentResolver(), uri);
            pickMedia(uri, mediaSize);
        } else if (requestCode == MEDIA_TAKE_PHOTO_RESULT && resultCode == RESULT_OK) {
            long mediaSize = MediaUtils.getMediaSize(getContentResolver(), photoUploadUri);
            pickMedia(photoUploadUri, mediaSize);
        }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# Refined Storage Changelog

### 1.5.13
- Fixed Wireless Fluid Grid not using up energy (raoulvdberge)
- Fixed Wireless Crafting Monitor remaining in network item list (raoulvdberge)
public void init(int x, int y) {

    @Override
    public void update(int x, int y) {
        scrollbar.setEnabled(getRows() > VISIBLE_ROWS);
        scrollbar.setMaxOffset(getRows() - VISIBLE_ROWS);
    }

    @Override
public void init(int x, int y) {

    @Override
    public void update(int x, int y) {
        scrollbar.setEnabled(getRows() > VISIBLE_ROWS);
        scrollbar.setMaxOffset(getRows() - VISIBLE_ROWS);

        if (itemSelected >= getElements().size()) {
            itemSelected = -1;
        }

        cancelButton.enabled = itemSelected != -1 && getElements().get(itemSelected).getTaskId() != -1;
        cancelAllButton.enabled = getElements().size() > 0;
    }

    @Override
public void init(int x, int y) {

    @Override
    public void update(int x, int y) {
        scrollbar.setEnabled(getRows() > VISIBLE_ROWS);
        scrollbar.setMaxOffset(getRows() - VISIBLE_ROWS);

        if (!startButton.enabled && isCtrlKeyDown() && isShiftKeyDown()) {
            startButton.enabled = true;
        }
    }
public void init(int x, int y) {

    @Override
    public void update(int x, int y) {
        scrollbar.setEnabled(getRows() > VISIBLE_ROWS);
        scrollbar.setMaxOffset(getRows() - VISIBLE_ROWS);

        if (itemSelected >= getChannels().size()) {
            itemSelected = -1;
private void sortItems() {

        STACKS = stacks;

        scrollbar.setEnabled(getRows() > getVisibleRows());
        scrollbar.setMaxOffset(getRows() - getVisibleRows());
    }

    @Override
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void showLatestMessages() {
        }
    }

    public boolean scrolledToLastMessage() {
        Object object = adapter.getItem(linearLayoutManager.findLastVisibleItemPosition());
        return object instanceof Message && (((Message) object).getId() >= app.getMaxMessageId() - 2);
    }

public void onNewMessages(Message[] messages) {
        if (narrowedList != null) {
            narrowedList.onNewMessages(messages);
        }
        if (!currentList.scrolledToLastMessage())
            showSnackbarNotification(messages); //Show notification
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.util.List;
import java.util.ListIterator;

import org.eclipse.swt.custom.CLabel;
import org.eclipse.swt.layout.FormData;
import org.eclipse.swt.widgets.Control;
public Control run() {

				@Override
				public List<Widget> run() {
					return WidgetResolver.getInstance().getChildren(parentWidget);
				}
			});
			controls.addAll(findControlsUI(children, matcher, recursive));
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
repositories {
        name = "CoFH Maven"
        url = "http://maven.covers1624.net"
    }
	maven {
        url = "http://chickenbones.net/maven"
    }
}

dependencies {
processResources
    }
}

sourceSets {
    main {
		java {
            exclude '**/me/jacky1356400/exchangers/item/powered/*'
		}
	}
}
org.gradle.jvmargs=-Xmx4G
mc_version=1.12
forge_version=14.21.1.2396
mod_version=2.1
@Mod(modid = Data.MODID, version = Data.VERSION, name = Data.MODNAME, dependencies = Exchangers.DEPENDS, useMetadata = true)
public class Exchangers {

	public static final String DEPENDS = "after:redstoneflux;after:enderio;after:thermalfoundation;after:thermalexpansion;after:mekanism;";

	public static Logger logger = LogManager.getLogger("Exchangers");


import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.common.capabilities.CapabilityInject;
import net.minecraftforge.energy.IEnergyStorage;

public class EnergyHelper {

    @CapabilityInject (IEnergyStorage.class)

    public static ItemStack setDefaultEnergyTag(ItemStack container, int energy) {

        if (!container.hasTagCompound()) {
public void onItemRegistry(RegistryEvent.Register<Item> e) {

	@SubscribeEvent
	public void onRecipeRegistry(RegistryEvent.Register<IRecipe> e) {
		initRecipes();
		e.getRegistry().registerAll(Data.RECIPES.toArray(new IRecipe[0]));
	}
public void preInit(FMLPreInitializationEvent e) {
		File configDir = e.getModConfigurationDirectory();
		config = new Configuration(new File(configDir.getPath(), "exchangers.cfg"));
		Config.readConfig();
		/*
		if ((Config.enderIOModule = true) && (Loader.isModLoaded(Data.EIO))) {
			EnderIOIntegration.init();
		}
		*/
		if ((Config.thermalExpansionModule = true) && (Loader.isModLoaded(Data.THERMAL))) {
			ThermalExpansionIntegration.init();
		}
		/*
		if ((Config.mekanismModule = true) && (Loader.isModLoaded(Data.MEK))) {
			MekanismIntegration.init();
		}
		*/
		MinecraftForge.EVENT_BUS.register(new ModRegistry());
		PacketHandler.registerMessages(Data.MODID);
	}
	public static final String EIO = "enderio";
	public static final String MEK = "mekanism";
	public static final String THERMAL = "thermalexpansion";
	public static final String VERSION = "1.12-2.1";
	public static final String MODID = "exchangers";
	public static final String MODNAME = "Exchangers";
	public static final CreativeTabs TAB = new CreativeTabs(MODID) {
  "modid": "exchangers",
  "name": "Exchangers",
  "description": "Block Exchangers.",
  "version": "1.12-2.1",
  "mcversion": "1.12",
  "url": "https://github.com/Jacky1356400/Exchangers",
  "updateUrl": "",
  "authorList": ["Jacky1356400", "Shadows_of_Fire", "Turkey2349"],
  "credits": "ThatGamerBlue, ColossalPercy, JCOnline_ and many other people that helped the development of this mod!",
  "logoFile": "assets/exchangers/logo.png",
  "screenshots": [],
  "dependencies": []
}
]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    private static AppDatabase db;

    public static DatabaseFactory getInstance(Context context){
        if(instance == null){
            createDb(context);
            instance = new DatabaseFactory();
        }
        return instance;
    }

    private static void createDb(Context context){
        if(db == null){
            db = Room.databaseBuilder(context, AppDatabase.class, "bookbase-db").allowMainThreadQueries().build();
        }
        return;
    }

    public static AppDatabase getDb(){
        return db;
    }

public void onAttach(Context context) {
        super.onAttach(context);
        if (context instanceof OnFragmentInteractionListener) {
            mListener = (OnFragmentInteractionListener) context;
            database = DatabaseFactory.getInstance(this.getContext()).getDb();
        } else {
            throw new RuntimeException(context.toString()
                    + " must implement OnFragmentInteractionListener");
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import vn.mbm.phimp.me.PhimpMe;
import vn.mbm.phimp.me.R;

//import vn.mbm.phimp.me.UploadMap;
//import android.media.MediaScannerConnection;
//import android.view.View.OnClickListener;

/**
 * The activity can crop specific region of interest from an image.
 */
public class CropImage extends MonitoredActivity 
{
	
	private static int brightnessValue = 0;
	private static float toDegree = 90;
	private static float fromDegree = 0;
    // These are various options can be specified in the intent.
    private Bitmap.CompressFormat mOutputFormat =
	Bitmap.CompressFormat.JPEG; // only used with mSaveUri
    private Uri mSaveUri = null;
    private int mAspectX, mAspectY;
    private boolean mCircleCrop = false;

    private final int GET_POSITION_ON_MAP = 5;
    private String mImagePath;
    static int position ;
    private static boolean check=false;
   // private String activityName;
    ProgressDialog gpsloading;
    ImageButton btnUseMap;
    EditText txtPhotoTitle;	
	EditText txtLongtitude;
	EditText txtLatitude;
	EditText txtTags;
	static Context ctx;
	static String p[] = null;
    private String newpath;


    @Override
    public void onCreate(Bundle icicle) 
    {
    	try
    	{
    		super.onCreate(icicle);
    		mContentResolver = getContentResolver();
    		ctx = this;    		
    		Log.d("crop image","start");
    		requestWindowFeature(Window.FEATURE_NO_TITLE);
    		setContentView(R.layout.cropimage);
    		setRequestedOrientation (ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);		
    		btnSave=(Button)findViewById(R.id.save);
    		
    		txtPhotoTitle = (EditText) findViewById(R.id.txtUploadPhotoTitle);
    		
    		txtLongtitude = (EditText) findViewById(R.id.txtUploadPhotoLongtitude);
    		
    		txtLatitude = (EditText) findViewById(R.id.txtUploadPhotoLatitude);
    		
    		txtTags = (EditText) findViewById(R.id.txtUploadPhotoTags);
    		btnUseMap = (ImageButton) findViewById(R.id.btnUploadPhotoPutPos);
    		/*btnUseMap.setOnClickListener(new OnClickListener() {
    			
    			@Override
    			public void onClick(View v) 
    			{
    				Intent _itent = new Intent(ctx, UploadMap.class);
    				
    				_itent.putExtra("latitude", txtLatitude.getText().toString());
    				_itent.putExtra("longitude", txtLongtitude.getText().toString());
    				startActivityForResult(_itent, GET_POSITION_ON_MAP);
    			}
    		});*/
    		mImageView = (CropImageView) findViewById(R.id.image);
    		gpsloading = new ProgressDialog(ctx);
    		gpsloading.setCancelable(true);
    		gpsloading.setCanceledOnTouchOutside(false);
    		gpsloading.setTitle(getString(R.string.loading));
    		gpsloading.setMessage(getString(R.string.infor_upload_loading_current_position));
    		gpsloading.setIndeterminate(true);
    		Log.d("cropimage","cropimage running..");
    		//showStorageToast(this);
			Intent intent = getIntent();
			Bundle extras = intent.getExtras();
			if (extras != null) 
			{
				if (extras.getString("circleCrop") != null) 
				{
					mCircleCrop = true;
					mAspectX = 1;
					mAspectY = 1;
				}
				
				mImagePath = extras.getString("image-path");
				p = mImagePath.split(";");
				
				if (p.length == 2){
					JSONObject js = new JSONObject(p[1]);
					txtLatitude.setText(js.getString("lati"));
					txtLongtitude.setText(js.getString("logi"));
					txtPhotoTitle.setText(js.getString("name"));
					txtTags.setText(js.getString("tags"));
				}
				Log.d("path",mImagePath);
				//mSaveUri = getImageUri(mImagePath);
				Date date = new Date();
				Long longTime = new Long(date.getTime()/1000);
				newpath = PhimpMe.DataDirectory+"/PhimpMe_Photo_Effect"+"/tmp_"+longTime+".jpg";
				mSaveUri = getImageUri(newpath);
				Log.d("mSaveUri",mSaveUri.toString());
				Log.d("p[0]",p[0]);	
				
				BitmapFactory.Options options = new BitmapFactory.Options();
		        options.inSampleSize = 4;		    	
		        mBitmap = BitmapFactory.decodeFile( p[0], options );
		        if(mBitmap.getWidth() %! (MISSING)!= 0||mBitmap.getHeight() %! (MISSING)!= 0){
		        	//bitmap width , height must even
		        	Log.i("CropImage","mBitmap width or height not even");			        	
		        	mBitmap=Bitmap.createScaledBitmap(mBitmap, mBitmap.getWidth()*4, mBitmap.getHeight()*4, false);
	        				        	
		        }
				modifiedBitmap= flippedImaged = mBitmap;
				
				Log.i("CropImage", "mBitmap Width :"+mBitmap.getWidth()+" mBitmap Height : "+mBitmap.getHeight());
				mAspectX = extras.getInt("aspectX");
			    mAspectY = extras.getInt("aspectY");
			    mOutputX = extras.getInt("outputX");
			    mOutputY = extras.getInt("outputY");
			    mScale = extras.getBoolean("scale", true);
			    mScaleUp = extras.getBoolean("scaleUpIfNeeded", true);	
			    position = extras.getInt("position");
			}
			if (mBitmap == null) 
			{
			    Log.d("null", "finish!!!");
				setResult(RESULT_CANCELED);
			    finish();
			    return;
			}
		
			// Make UI fullscreen.
			getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);

			findViewById(R.id.discard).setOnClickListener(
				new View.OnClickListener() 
				{
				    public void onClick(View v) 
				    {
				    	if (btnSave.getVisibility() != View.VISIBLE)
				    		{
				    		//mBitmapSave.recycle();
				    		//mBitmap.recycle();
				    		//mBitmapResize.recycle();
				    		//modifiedBitmap.recycle();
				    		//flippedImaged.recycle();
				    		}
				    		setResult(RESULT_CANCELED);
				    		//System.exit(0);
							finish();				    					    								
				    }
				});
		
			/*
			 * Thong - Add event for button rotate image
			 */
			findViewById(R.id.btnRotateLeftRight).setOnClickListener(
					new View.OnClickListener() {
					    public void onClick(View v) 
					    {
					    	check=true;
					    	try{
					    		doRotate(mImageView, fromDegree, toDegree);
								fromDegree = (toDegree == 360) ? 0 : toDegree;
								toDegree += 90;
								if (toDegree > 360) {
									toDegree = 90;
								}
								
					    	}catch(OutOfMemoryError o){
					    		o.printStackTrace();
					    	}
					    	
					    }
					});
			/*
			 * Thong - Add event for button rotate image - End
			 */
						
			/*
			 * Danh - Add event for button rotate top-down image
			 */
			findViewById(R.id.btnRotateTopDown).setOnClickListener(
					new View.OnClickListener() {
					    public void onClick(View v) 
					    {
					    	check=true;
					    	try{
					    		modifiedBitmap = doVerticalFlip(modifiedBitmap);
								flippedImaged = doVerticalFlip(flippedImaged);
								mImageView.setImageBitmap(changeBrightness(
										modifiedBitmap, brightnessValue));
								mBitmapSave = modifiedBitmap;
								
					    	}catch(OutOfMemoryError o){
					    		mBitmapResize=getResizedBitmap(mBitmap, (mBitmap.getHeight()/4), (mBitmap.getWidth()/4));
					    		//mBitmapResize=getResizedBitmap(p[0], (mBitmap.getHeight()/2), (mBitmap.getWidth()/2));
					    		modifiedBitmap=flippedImaged=mBitmapResize;
					    	}
					    	
					    }
					});
			/*
			 * Danh - Add event for button rotate top-down image - End
			 */
			/*
			 * Danh - Add event for button black white image effect
			 */
			findViewById(R.id.btnBlackAndWhite).setOnClickListener(
					new View.OnClickListener() {
					    public void onClick(View v) 
					    {
					    	check=true;
					    	try{

					    		modifiedBitmap = null;
								modifiedBitmap = ImagesFilter.convertToBW(flippedImaged);
								mImageView.setImageBitmap(changeBrightness(
										modifiedBitmap, brightnessValue));
								mBitmapSave = modifiedBitmap;
								
					    	}catch(OutOfMemoryError o){								

					    		mBitmapResize=getResizedBitmap(mBitmap, (mBitmap.getHeight()/4), (mBitmap.getWidth()/4));
					    		//mBitmapResize=getResizedBitmap(p[0], (mBitmap.getHeight()/2), (mBitmap.getWidth()/2));
					    		modifiedBitmap=flippedImaged=mBitmapResize;
				    		

					    	}
					    	
					    }
					});
			/*
			 * Danh - Add event for button black white image effect - End
			 */
			/*
			 * Danh - Add event for button Sepia image effect
			 */
			findViewById(R.id.btnSaphia).setOnClickListener(
					new View.OnClickListener() {
					    public void onClick(View v) 
					    {
					    	check=true;
					    	try{

					    		modifiedBitmap = null;
								modifiedBitmap = ImagesFilter.convertToSepia(flippedImaged);
								mImageView.setImageBitmap(changeBrightness(
										modifiedBitmap, brightnessValue));
								mBitmapSave = modifiedBitmap;
								
					    	}catch(OutOfMemoryError o){
					    		mBitmapResize=getResizedBitmap(mBitmap, (mBitmap.getHeight()/4), (mBitmap.getWidth()/4));
					    		//mBitmapResize=getResizedBitmap(p[0], (mBitmap.getHeight()/2), (mBitmap.getWidth()/2));
								modifiedBitmap=flippedImaged=mBitmapResize;

					    	}
					    
					    }
					});

			/*
			 * Danh - Add event for button Sepia image effect - End
			 */

            findViewById(R.id.btnalpha).setOnClickListener(
                    new View.OnClickListener() {
                        public void onClick(View v) {
                            check=true;
                            try {
                                modifiedBitmap = null;
                                modifiedBitmap = ImagesFilter.convertToAlpha(flippedImaged);
                                mImageView.setImageBitmap(changeBrightness(modifiedBitmap, brightnessValue));
                                mBitmap = modifiedBitmap;
                            } catch (OutOfMemoryError o) {
                                mBitmapResize=getResizedBitmap(mBitmap, (mBitmap.getHeight()/4), (mBitmap.getWidth()/4));
                                modifiedBitmap=flippedImaged=mBitmapResize;
                            }
                        }
                    });
            findViewById(R.id.btnpink).setOnClickListener(
                    new View.OnClickListener() {
                        public void onClick(View v) {
                            check=true;
                            try {
                                modifiedBitmap = null;
                                modifiedBitmap = ImagesFilter.convertToPink(flippedImaged);
                                mImageView.setImageBitmap(changeBrightness(modifiedBitmap, brightnessValue));
                                mBitmap = modifiedBitmap;
                            } catch (OutOfMemoryError o) {
                                mBitmapResize=getResizedBitmap(mBitmap, (mBitmap.getHeight()/4), (mBitmap.getWidth()/4));
                                modifiedBitmap=flippedImaged=mBitmapResize;
                            }
                        }
                    });
            findViewById(R.id.btnpolaroid).setOnClickListener(
                    new View.OnClickListener() {
                        public void onClick(View v) {
                            check=true;
                            try {
                                modifiedBitmap = null;
                                modifiedBitmap = ImagesFilter.convertToPolaroid(flippedImaged);
                                mImageView.setImageBitmap(changeBrightness(modifiedBitmap, brightnessValue));
                                mBitmap = modifiedBitmap;
                            } catch (OutOfMemoryError o) {
                                mBitmapResize=getResizedBitmap(mBitmap, (mBitmap.getHeight()/4), (mBitmap.getWidth()/4));
                                modifiedBitmap=flippedImaged=mBitmapResize;
                            }
                        }
                    });
            findViewById(R.id.btnblur).setOnClickListener(
                    new View.OnClickListener() {
                        public void onClick(View v) {
                            check=true;
                            try {
                                modifiedBitmap = null;
                                modifiedBitmap = ImagesFilter.converttoBlur(flippedImaged,9,getApplicationContext());
                                mImageView.setImageBitmap(changeBrightness(modifiedBitmap, brightnessValue));
                                mBitmap = modifiedBitmap;
                            } catch (OutOfMemoryError o) {
                                mBitmapResize=getResizedBitmap(mBitmap, (mBitmap.getHeight()/4), (mBitmap.getWidth()/4));
                                modifiedBitmap=flippedImaged=mBitmapResize;
                            }
                        }
                    });
            findViewById(R.id.btnsharp).setOnClickListener(
                    new View.OnClickListener() {
                        public void onClick(View v) {
                            check=true;
                            try {
                                modifiedBitmap = null;
                                modifiedBitmap = ImagesFilter.convertToSharp(flippedImaged,getApplicationContext());
                                mImageView.setImageBitmap(changeBrightness(modifiedBitmap, brightnessValue));
                                mBitmap = modifiedBitmap;
                            } catch (OutOfMemoryError o) {
                                mBitmapResize=getResizedBitmap(mBitmap, (mBitmap.getHeight()/4), (mBitmap.getWidth()/4));
                                modifiedBitmap=flippedImaged=mBitmapResize;
                            }
                        }
                    });
            findViewById(R.id.btnedge).setOnClickListener(
                    new View.OnClickListener() {
                        public void onClick(View v) {
                            check=true;
                            try {
                                modifiedBitmap = null;
                                modifiedBitmap = ImagesFilter.convertToEdge(flippedImaged,getApplicationContext());
                                mImageView.setImageBitmap(changeBrightness(modifiedBitmap, brightnessValue));
                                mBitmap = modifiedBitmap;
                            } catch (OutOfMemoryError o) {
                                mBitmapResize=getResizedBitmap(mBitmap, (mBitmap.getHeight()/4), (mBitmap.getWidth()/4));
                                modifiedBitmap=flippedImaged=mBitmapResize;
                            }
                        }
                    });
            findViewById(R.id.btnfuzz).setOnClickListener(
                    new View.OnClickListener() {
                        public void onClick(View v) {
                            check=true;
                            try {
                                modifiedBitmap = null;
                                modifiedBitmap = ImagesFilter.convertToFuzz(flippedImaged,getApplicationContext());
                                mImageView.setImageBitmap(changeBrightness(modifiedBitmap, brightnessValue));
                                mBitmap = modifiedBitmap;
                            } catch (OutOfMemoryError o) {
                                mBitmapResize=getResizedBitmap(mBitmap, (mBitmap.getHeight()/4), (mBitmap.getWidth()/4));
                                modifiedBitmap=flippedImaged=mBitmapResize;
                            }
                        }
                    });
			/*
			 * Danh - Add event for button Negative image effect
			 */
			findViewById(R.id.btnNegative).setOnClickListener(
					new View.OnClickListener() {
					    public void onClick(View v) 
					    {
					    	check=true;
					    	try{
					    		
					    		modifiedBitmap = null;
								modifiedBitmap = ImagesFilter.convertToNegative(flippedImaged);
								mImageView.setImageBitmap(changeBrightness(
										modifiedBitmap, brightnessValue));
								mBitmapSave = modifiedBitmap;
								
					    	}catch(OutOfMemoryError o){

					    		mBitmapResize=getResizedBitmap(mBitmap, (mBitmap.getHeight()/4), (mBitmap.getWidth()/4));
					    		//mBitmapResize=getResizedBitmap(p[0], (mBitmap.getHeight()/2), (mBitmap.getWidth()/2));
					    		modifiedBitmap=flippedImaged=mBitmapResize;

					    	}
					    	
					    }
					});
			/*
			 * Danh - Add event for button Negative image effect - End
			 */
			btnSave.setOnClickListener(
					new View.OnClickListener() {
					    public void onClick(View v)
					    {
					    	if(check==true){
					    		onSaveClicked();
					    		//finish();
						    	Intent intent=new Intent(ctx, PhimpMe.class);
						    	intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
						    	startActivity(intent);
					    	}else{
					    		
					    		//finish();
					    		Intent intent=new Intent(ctx, PhimpMe.class);
						    	intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
						    	startActivity(intent);
					    	}
					    	
					    }
				});			
			startFaceDetection();
	    }
    	catch (Exception e)
    	{
    	}
    }

    @Override
public void onClick(DialogInterface dialog, int id) {
                .setNegativeButton(R.string.go_back, new DialogInterface.OnClickListener() {
                    public void onClick(DialogInterface dialog, int id) {

                    }})
                .create()
                .show();
    }

    public static void ConvertToOriginal() {
    	try{

			doRotate(mImageView, 0, 0);
			fromDegree = 0;
			toDegree = 90;
			mImageView.setImageBitmap(mBitmap);
			modifiedBitmap = flippedImaged = mBitmap;
    	}catch(OutOfMemoryError o){

			doRotate(mImageView, 0, 0);
			fromDegree = 0;
			toDegree = 90;
			mImageView.setImageBitmap(mBitmapResize);
			modifiedBitmap = flippedImaged = mBitmapResize;
    	}
	}
    public static void doRotate(ImageView im, float fromDegree, float toDegree) {
		RotateAnimation ra1 = new RotateAnimation(fromDegree, toDegree,
				RotateAnimation.RELATIVE_TO_SELF, 0.5f,
				RotateAnimation.RELATIVE_TO_SELF, 0.5f);
		ra1.setStartOffset(0);
		ra1.setDuration(0);
		ra1.setFillAfter(true);
		ra1.setFillEnabled(true);
		im.startAnimation(ra1);
	}
    public static Bitmap doHorizontalFlip(Bitmap sampleBitmap) {
		Matrix matrixHorizontalFlip = new Matrix();
		matrixHorizontalFlip.preScale(-1.0f, 1.0f);
		Bitmap des = sampleBitmap.copy(Bitmap.Config.ARGB_8888, true);
		des = Bitmap.createBitmap(sampleBitmap, 0, 0, sampleBitmap.getWidth(), sampleBitmap.getHeight(),
				matrixHorizontalFlip, true);
		return des;
	}

	public static Bitmap doVerticalFlip(Bitmap sampleBitmap) {
		Matrix matrixVerticalFlip = new Matrix();
		matrixVerticalFlip.preScale(1.0f, -1.0f);
		Bitmap des = sampleBitmap.copy(Bitmap.Config.ARGB_8888, true);
		des = Bitmap.createBitmap(sampleBitmap, 0, 0, sampleBitmap.getWidth(), sampleBitmap.getHeight(),
				matrixVerticalFlip, true);
		return des;
	}

	public static Bitmap changeBrightness(Bitmap sampleBitmap,
			int brightnessValue) {
		ColorMatrix sepiaMatrix = new ColorMatrix();
		float[] sepMat = { 1, 0, 0, 0, brightnessValue, 0, 1, 0, 0,
				brightnessValue, 0, 0, 1, 0, brightnessValue, 0, 0, 0, 1,
				brightnessValue };
		sepiaMatrix.set(sepMat);
		final ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(
				sepiaMatrix);
		Bitmap rBitmap = sampleBitmap.copy(Bitmap.Config.ARGB_8888, true);
		Paint paint = new Paint();
		paint.setColorFilter(colorFilter);
		Canvas myCanvas = new Canvas(rBitmap);
		myCanvas.drawBitmap(rBitmap, 0, 0, paint);
		return rBitmap;
	}

    
    OnSeekBarChangeListener brightnessBarSeekListener = new OnSeekBarChangeListener() {

		public void onStopTrackingTouch(SeekBar seekBar) {
			// TODO Auto-generated method stub

		}

		public void onStartTrackingTouch(SeekBar seekBar) {
			// TODO Auto-generated method stub

		}

		public void onProgressChanged(SeekBar seekBar, int progress,boolean fromUser) {
			try{
				brightnessValue = progress;
				ColorMatrix sepiaMatrix = new ColorMatrix();
				float[] sepMat = { 1, 0, 0, 0, brightnessValue, 0, 1, 0, 0,
						brightnessValue, 0, 0, 1, 0, brightnessValue, 0, 0, 0, 1,
						brightnessValue };
				sepiaMatrix.set(sepMat);
				final ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(
						sepiaMatrix);
				Bitmap rBitmap = mBitmap.copy(Bitmap.Config.ARGB_8888, true);
				Paint paint = new Paint();
				paint.setColorFilter(colorFilter);
				Canvas myCanvas = new Canvas(rBitmap);
				myCanvas.drawBitmap(rBitmap, 0, 0, paint);
				
				mImageView.setImageBitmap(rBitmap);
				
			}
			catch(OutOfMemoryError o){
				mBitmapResize=getResizedBitmap(mBitmap, (mBitmap.getHeight()/4), (mBitmap.getWidth()/4));
				brightnessValue = progress;
				ColorMatrix sepiaMatrix = new ColorMatrix();
				float[] sepMat = { 1, 0, 0, 0, brightnessValue, 0, 1, 0, 0,
						brightnessValue, 0, 0, 1, 0, brightnessValue, 0, 0, 0, 1,
						brightnessValue };
				sepiaMatrix.set(sepMat);
				final ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(
						sepiaMatrix);
				Bitmap rBitmap = mBitmapResize.copy(Bitmap.Config.ARGB_8888, true);
				Paint paint = new Paint();
				paint.setColorFilter(colorFilter);
				Canvas myCanvas = new Canvas(rBitmap);
				myCanvas.drawBitmap(rBitmap, 0, 0, paint);
				
				mImageView.setImageBitmap(rBitmap);
			}
			btnSave.setVisibility(View.INVISIBLE);
		}
	};
    private Uri getImageUri(String path) 
    {
    	return Uri.fromFile(new File(path));
    }

    public Bitmap getBitmap(String path) {
	Uri uri = getImageUri(path);
	InputStream in = null;
	try {
	    in = mContentResolver.openInputStream(uri);
	    return BitmapFactory.decodeStream(in);
	} catch (FileNotFoundException e) {
	}
	return null;
    }

    @Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data) 
	{
		switch (requestCode) 
		{			
			case GET_POSITION_ON_MAP:
			{
				if (resultCode == Activity.RESULT_OK)
				{
					Log.d("thong", "Upload: Result OK");
					
					int lat = data.getIntExtra("latitude", 0);
					int log = data.getIntExtra("longitude", 0);
					
					float _lat = (float) (lat / 1E6);
					float _log = (float) (log / 1E6);
					
					txtLatitude.setText(String.valueOf(_lat));
					
					txtLongtitude.setText(String.valueOf(_log));
				}
				break;
			}
		}
	}
    private void startFaceDetection() 
    {
    	if (isFinishing()) 
    	{
    		return;
    	}
    	if(mBitmap.getWidth()>1800){
    		mBitmapResize=getResizedBitmap(mBitmap, (mBitmap.getHeight()/2), (mBitmap.getWidth()/2));
        	mBitmap = mBitmapResize;
        	mImageView.setImageBitmapResetBase(mBitmap, true);
        	ConvertToOriginal();
    	}else
    	ConvertToOriginal();
    	
    	Util.startBackgroundJob(this, null, "Please wait\u2026", new Runnable() 
    		{
	    		public void run() 
	    		{
	    			final CountDownLatch latch = new CountDownLatch(1);
	    			final Bitmap b = (mImage != null) ? mImage.fullSizeBitmap(IImage.UNCONSTRAINED, 1024 * 1024) : mBitmap;
	    			mHandler.post(new Runnable() 
		    			{
		    				public void run() 
		    				{
		    					//vn.mbm.postmail.Util.WriteLog("d", "startFaceDetection()", "Runnable");
		    					if (b != mBitmap && b != null) 
		    					{
		    						mImageView.setImageBitmapResetBase(b, true);
		    						mBitmap.recycle();
		    						mBitmap = b;
		    					}
		    					if (mImageView.getScale() == 1F) 
		    					{
		    						mImageView.center(true, true);
		    					}
		    					latch.countDown();
		    				}
		    			});
	    			try 
	    			{
	    				latch.await();
	    			} 
	    			catch (InterruptedException e) 
	    			{
	    				throw new RuntimeException(e);
	    			}
	    			mRunFaceDetection.run();
	    		}
	    	}, mHandler);
    }
    private void onSaveClicked() 
    {
		// TODO this code needs to change to use the decode/crop/encode single
		// step api so that we don't require that the whole (possibly large)
		// bitmap doesn't have to be read into memory
    	if (mSaving) return;

    	if (mCrop == null) 
    	{
    		return;
    	}

    	mSaving = true;

    	Rect r = mCrop.getCropRect();

    	int width = r.width();
    	int height = r.height();

    	// If we are circle cropping, we want alpha channel, which is the
    	// third param here.
    	Bitmap croppedImage = null;
    	try
    	{
	    	croppedImage = Bitmap.createBitmap(width, height, mCircleCrop ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565);
	    	{
	    		Canvas canvas = new Canvas(croppedImage);
	    		Rect dstRect = new Rect(0, 0, width, height);
	    		canvas.drawBitmap(mBitmapSave, r, dstRect, null);
	    	}	    	
    	}
    	catch (OutOfMemoryError o) 
    	{
    		mBitmapSave.recycle();
    		croppedImage.recycle();
    		setResult(RESULT_CANCELED,new Intent());
    		finish();
		}

    	if (mCircleCrop) 
    	{
    		// OK, so what's all this about?
    		// Bitmaps are inherently rectangular but we want to return
    		// something that's basically a circle.  So we fill in the
    		// area around the circle with alpha.  Note the all important
    		// PortDuff.Mode.CLEAR.
    		Canvas c = new Canvas(croppedImage);
    		Path p = new Path();
    		p.addCircle(width / 2F, height / 2F, width / 2F, Path.Direction.CW);
    		c.clipPath(p, Region.Op.DIFFERENCE);
	    	c.drawColor(0x00000000, PorterDuff.Mode.CLEAR);
    	}

    	/* If the output is required to a specific size then scale or fill */
    	if (mOutputX != 0 && mOutputY != 0) 
    	{
    		if (mScale) 
    		{
    			/* Scale the image to the required dimensions */
    			Bitmap old = croppedImage;
    			croppedImage = Util.transform(new Matrix(), croppedImage, mOutputX, mOutputY, mScaleUp);
    			if (old != croppedImage) 
    			{
    				old.recycle();
    			}
    		} 
    		else 
    		{
    			try{
    				/* Don't scale the image crop it to the size requested.
    				 * Create an new image with the cropped image in the center and
    				 * the extra space filled.
    				 */

        			// Don't scale the image but instead fill it so it's the
        			// required dimension
        			Bitmap b = Bitmap.createBitmap(mOutputX, mOutputY, Bitmap.Config.RGB_565);
        			Canvas canvas = new Canvas(b);

        			Rect srcRect = mCrop.getCropRect();
        			Rect dstRect = new Rect(0, 0, mOutputX, mOutputY);

        			int dx = (srcRect.width() - dstRect.width()) / 2;
        			int dy = (srcRect.height() - dstRect.height()) / 2;

        			/* If the srcRect is too big, use the center part of it. */
        			srcRect.inset(Math.max(0, dx), Math.max(0, dy));

        			/* If the dstRect is too big, use the center part of it. */
        			dstRect.inset(Math.max(0, -dx), Math.max(0, -dy));

        			/* Draw the cropped bitmap in the center */
        			canvas.drawBitmap(mBitmapSave, srcRect, dstRect, null);

        			/* Set the cropped bitmap as the new bitmap */
        			croppedImage.recycle();
        			croppedImage = b;
        			
        			b.recycle();
    			}catch(OutOfMemoryError o){
    				o.printStackTrace();
    			}
				
    		}
    	}

    	// Return the cropped image directly or save it to the specified URI.
    	Bundle myExtras = getIntent().getExtras();
    	if (myExtras != null && (myExtras.getParcelable("data") != null || myExtras.getBoolean("return-data"))) 
    	{
    		Bundle extras = new Bundle();
    		extras.putParcelable("data", croppedImage);
    		setResult(RESULT_OK,(new Intent()).setAction("inline-data").putExtras(extras));
    		finish();
    		
    	} 
    	else 
    	{
    		final Bitmap b = croppedImage;
    		Util.startBackgroundJob(this, null,"Please wait ...", new Runnable() 
    		{
    			public void run() {
    				saveOutput(b);
    			}
    		}, mHandler);
    	}
    }
    private boolean isMediaScannerRunning() {
    	Cursor query = getContentResolver().query(MediaStore.getMediaScannerUri(),
                                                       new String[]{MediaStore.MEDIA_SCANNER_VOLUME}, null, null, null);
            if(query!=null){
            	if(query.moveToFirst()){
            		int columnIndex = query.getColumnIndex(MediaStore.MEDIA_SCANNER_VOLUME);
            		String volumeName = query.getString(columnIndex);
            		if(volumeName!=null){
            			return true;
            		}
            	}
            	query.close();
            }
            return false;
    }
    private void saveOutput(Bitmap croppedImage) 
    {
		if (mSaveUri != null) 
		{
		    OutputStream outputStream = null;
		    try 
		    {
				outputStream = mContentResolver.openOutputStream(mSaveUri);
				if (outputStream != null) 
				{
				    croppedImage.compress(mOutputFormat, 100, outputStream);
				}
		    } 
		    catch (IOException ex) 
		    {
		    } 
		    finally 
		    {
		    	mBitmapSave.recycle();
		    	croppedImage.recycle();
		    	Util.closeSilently(outputStream);
		    }
		    		
		}		                      
        sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, mSaveUri));
        sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE,
                Uri.parse("file://" + Environment.getExternalStorageDirectory())));

		mBitmapSave.recycle();
		croppedImage.recycle();
		Intent intent = this.getIntent();
		while(isMediaScannerRunning())
		{
				new Thread(){
					public void run(){
						try{
						sleep(1000);
						}catch(Exception e)
						{e.printStackTrace();}
					}
				}.start();
			
		}
		intent.putExtra("Impath", mImagePath);
		intent.putExtra("saveUri",newpath);
		intent.putExtra("lati", txtLatitude.getText().toString());
		intent.putExtra("logi",txtLongtitude.getText().toString());
		intent.putExtra("tags",txtTags.getText().toString());
		intent.putExtra("name", txtPhotoTitle.getText().toString());		
		Log.i("Danh","Image path output save : "+mImagePath);
		setResult(RESULT_OK,intent);		
		finish();
    }

    @Override
    protected void onPause() {
	super.onPause();
    }

    @Override
    protected void onDestroy() 
    {
    	super.onDestroy();
    	
    	System.gc();
    }


    Runnable mRunFaceDetection = new Runnable() 
    {
    	float mScale = 1F;
    	Matrix mImageMatrix;
    	FaceDetector.Face[] mFaces = new FaceDetector.Face[3];
    	int mNumFaces;

    	// For each face, we create a HightlightView for it.
    	private void handleFace(FaceDetector.Face f) 
    	{
    		PointF midPoint = new PointF();

		    int r = ((int) (f.eyesDistance() * mScale)) * 2;
		    f.getMidPoint(midPoint);
		    midPoint.x *= mScale;
		    midPoint.y *= mScale;
	
		    int midX = (int) midPoint.x;
		    int midY = (int) midPoint.y;
	
		    HighlightView hv = new HighlightView(mImageView);
	
		    int width = mBitmap.getWidth();
		    int height = mBitmap.getHeight();
	
		    Rect imageRect = new Rect(0, 0, width, height);
	
		    RectF faceRect = new RectF(midX, midY, midX, midY);
		    faceRect.inset(-r, -r);
		    if (faceRect.left < 0) 
		    {
		    	faceRect.inset(-faceRect.left, -faceRect.left);
		    }
	
		    if (faceRect.top < 0)
		    {
		    	faceRect.inset(-faceRect.top, -faceRect.top);
		    }
	
		    if (faceRect.right > imageRect.right) 
		    {
		    	faceRect.inset(faceRect.right - imageRect.right, faceRect.right - imageRect.right);
		    }
	
		    if (faceRect.bottom > imageRect.bottom) 
		    {
		    	faceRect.inset(faceRect.bottom - imageRect.bottom, faceRect.bottom - imageRect.bottom);
		    }
	
		    hv.setup(mImageMatrix, imageRect, faceRect, mCircleCrop, mAspectX != 0 && mAspectY != 0);
		    mImageView.add(hv);
    	}

		private void makeDefault() 
		{
		    HighlightView hv = new HighlightView(mImageView);
	
		    int width = mBitmap.getWidth();
		    int height = mBitmap.getHeight();
			    
			
		    Rect imageRect = new Rect(0, 0, width, height);
	
		    // make the default size about 4/5 of the width or height
		    int cropWidth = Math.min(width, height) * 4 / 5;
		    int cropHeight = cropWidth;
		    
		    if (mAspectX != 0 && mAspectY != 0) 
		    {
		    	if (mAspectX > mAspectY) 
		    	{
		    		cropHeight = cropWidth * mAspectY / mAspectX;
		    	} 
		    	else 
		    	{
		    		cropWidth = cropHeight * mAspectX / mAspectY;
		    	}
		    }		    
		    int x = (width - cropWidth) / 2;
		    int y = (height - cropHeight) / 2;
		    RectF cropRect = new RectF(x, y, x + cropWidth, y + cropHeight);
		    hv.setup(mImageMatrix, imageRect, cropRect, mCircleCrop, mAspectX != 0 && mAspectY != 0);
		    mImageView.mHighlightViews.clear(); // Thong
		    mImageView.add(hv);
		}

		// Scale the image down for faster face detection.
		private Bitmap prepareBitmap() 
		{
		    if (mBitmap == null) 
		    {
		    	return null;
		    }
	
		    // 256 pixels wide is enough.
		    if (mBitmap.getWidth() > 256) 
		    {
		    	mScale = 256.0F / mBitmap.getWidth();
		    }
		    Matrix matrix = new Matrix();
		    matrix.setScale(mScale, mScale);
		    Bitmap faceBitmap = Bitmap.createBitmap(mBitmap, 0, 0, mBitmap.getWidth(), mBitmap.getHeight(), matrix, true);
		    return faceBitmap;
		}

		public void run() 
		{
		    mImageMatrix = mImageView.getImageMatrix();
		    Bitmap faceBitmap = prepareBitmap();
	
		    mScale = 1.0F / mScale;
		    if (faceBitmap != null && mDoFaceDetection) 
		    {
		    	FaceDetector detector = new FaceDetector(faceBitmap.getWidth(), faceBitmap.getHeight(), mFaces.length);
		    	mNumFaces = detector.findFaces(faceBitmap, mFaces);
		    }
	
		    if (faceBitmap != null && faceBitmap != mBitmap) 
		    {
		    	faceBitmap.recycle();
		    }
	
		    mHandler.post(new Runnable() 
		    {
				public void run() 
				{
				    mWaitingToPick = mNumFaces > 1;
				    if (mNumFaces > 0) 
				    {
						for (int i = 0; i < mNumFaces; i++) 
						{
						    handleFace(mFaces[i]);
						}
				    } 
				    else 
				    {
				    	makeDefault();
				    }
				    mImageView.invalidate();
				    if (mImageView.mHighlightViews.size() == 1) 
				    {
				    	mCrop = mImageView.mHighlightViews.get(0);
				    	mCrop.setFocus(true);
				    }
		
				    if (mNumFaces > 1) 
				    {
						Toast t = Toast.makeText(CropImage.this, "Multi face crop help", Toast.LENGTH_SHORT);
						t.show();
				    }
				}
		    });
		}
		
    };

    public static final int NO_STORAGE_ERROR = -1;
    public static final int CANNOT_STAT_ERROR = -2;

    public static void showStorageToast(Activity activity) 
    {
    	try
    	{
    		showStorageToast(activity, calculatePicturesRemaining());
    	}
    	catch (Exception e)
    	{
    	}
    }

    public static void showStorageToast(Activity activity, int remaining) 
    {
		String noStorageText = null;
	
		if (remaining == NO_STORAGE_ERROR) 
		{
		    String state = Environment.getExternalStorageState();
		    if (state == Environment.MEDIA_CHECKING) 
		    {
		    	noStorageText = "Preparing card";
		    } 
		    else 
		    {
		    	noStorageText = "No storage card";
		    }
		} 
		else if (remaining < 1) 
		{
		    noStorageText = "Not enough space";
		}
	
		if (noStorageText != null) 
		{
		}
    }

    public static int calculatePicturesRemaining() {
	try {
	    String storageDirectory =
		Environment.getExternalStorageDirectory().toString();
	    StatFs stat = new StatFs(storageDirectory);
	    float remaining = ((float) stat.getAvailableBlocks()
		    * (float) stat.getBlockSize()) / 400000F;
	    return (int) remaining;
	    //}
	} catch (Exception ex) {
	    // if we can't stat the filesystem then we don't know how many
	    // pictures are remaining.  it might be zero but just leave it
	    // blank since we really don't know.
	    return CANNOT_STAT_ERROR;
	}
    }

   public Bitmap getResizedBitmap(Bitmap bm, int newHeight, int newWidth) {
        int width = bm.getWidth();
        int height = bm.getHeight();
        float scaleWidth = ((float) newWidth) / width;
public Bitmap getResizedBitmap(Bitmap bm, int newHeight, int newWidth) {


        // RECREATE THE NEW BITMAP
        try{
        	Bitmap resizedBitmap = Bitmap.createBitmap(bm, 0, 0, width, height, matrix, false);
        	return resizedBitmap;
        }catch(OutOfMemoryError o){
        	Bitmap resizedBitmap = Bitmap.createBitmap(bm, 0, 0, width/2, height/2, matrix, false);
        	return resizedBitmap;
        }
        }
        
 
}


class CropImageView extends ImageViewTouchBase
{
    ArrayList<HighlightView> mHighlightViews = new ArrayList<HighlightView>();
    HighlightView mMotionHighlightView = null;
    float mLastX, mLastY;
public Bitmap getResizedBitmap(Bitmap bm, int newHeight, int newWidth) {
    private Context mContext;

    @Override
    protected void onLayout(boolean changed, int left, int top, int right, int bottom) 
    {
		super.onLayout(changed, left, top, right, bottom);
		if (mBitmapDisplayed.getBitmap() != null) 
		{
		    for (HighlightView hv : mHighlightViews) 
		    {
		    	hv.mMatrix.set(getImageMatrix());
		    	hv.invalidate();
		    	if (hv.mIsFocused) 
		    	{
		    		centerBasedOnHighlightView(hv);
		    	}
		    }
		}
    }

    public CropImageView(Context context, AttributeSet attrs) 
    {
    	super(context, attrs);
    	this.mContext = context;
    }

    @Override
    protected void zoomTo(float scale, float centerX, float centerY) 
    {
    	super.zoomTo(scale, centerX, centerY);
    	for (HighlightView hv : mHighlightViews) 
    	{
    		hv.mMatrix.set(getImageMatrix());
    		hv.invalidate();
    	}
    }

    @Override
    protected void zoomIn() 
    {
		super.zoomIn();
		for (HighlightView hv : mHighlightViews) 
		{
		    hv.mMatrix.set(getImageMatrix());
		    hv.invalidate();
		}
    }

    @Override
    protected void zoomOut() 
    {
		super.zoomOut();
		for (HighlightView hv : mHighlightViews) 
		{
		    hv.mMatrix.set(getImageMatrix());
		    hv.invalidate();
		}
    }

    @Override
    protected void postTranslate(float deltaX, float deltaY) 
    {
		super.postTranslate(deltaX, deltaY);
		for (int i = 0; i < mHighlightViews.size(); i++) 
		{
		    HighlightView hv = mHighlightViews.get(i);
		    hv.mMatrix.postTranslate(deltaX, deltaY);
		    hv.invalidate();
		}
    }

    // According to the event's position, change the focus to the first
    // hitting cropping rectangle.
    private void recomputeFocus(MotionEvent event) 
    {
		for (int i = 0; i < mHighlightViews.size(); i++) 
		{
		    HighlightView hv = mHighlightViews.get(i);
		    hv.setFocus(false);
		    hv.invalidate();
		}

		for (int i = 0; i < mHighlightViews.size(); i++) 
		{
		    HighlightView hv = mHighlightViews.get(i);
		    int edge = hv.getHit(event.getX(), event.getY());
		    if (edge != HighlightView.GROW_NONE) 
		    {
				if (!hv.hasFocus()) 
				{
				    hv.setFocus(true);
				    hv.invalidate();
				}
				break;
		    }
		}
		invalidate();
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) 
    {
    	CropImage cropImage = (CropImage) mContext;
		if (cropImage.mSaving)
		{
		    return false;
		}

		switch (event.getAction()) 
		{
			case MotionEvent.ACTION_DOWN:
			    if (cropImage.mWaitingToPick) 
			    {
			    	recomputeFocus(event);
			    } 
			    else 
			    {
					for (int i = 0; i < mHighlightViews.size(); i++) 
					{
					    HighlightView hv = mHighlightViews.get(i);
					    int edge = hv.getHit(event.getX(), event.getY());
					    if (edge != HighlightView.GROW_NONE) 
					    {
							mMotionEdge = edge;
							mMotionHighlightView = hv;
							mLastX = event.getX();
							mLastY = event.getY();
							mMotionHighlightView.setMode(
								(edge == HighlightView.MOVE)
								? HighlightView.ModifyMode.Move
									: HighlightView.ModifyMode.Grow);
							break;
					    }
					}
			    }
			    break;
			case MotionEvent.ACTION_UP:
			    if (cropImage.mWaitingToPick) 
			    {
					for (int i = 0; i < mHighlightViews.size(); i++) 
					{
					    HighlightView hv = mHighlightViews.get(i);
					    if (hv.hasFocus()) 
					    {
					    	cropImage.mCrop = hv;
							for (int j = 0; j < mHighlightViews.size(); j++) 
							{
							    if (j == i) 
							    {
							    	continue;
							    }
							    mHighlightViews.get(j).setHidden(true);
							}
							centerBasedOnHighlightView(hv);
							((CropImage) mContext).mWaitingToPick = false;
							return true;
					    }
					}
			    } 
			    else if (mMotionHighlightView != null) 
			    {
			    	centerBasedOnHighlightView(mMotionHighlightView);
			    	mMotionHighlightView.setMode(HighlightView.ModifyMode.None);
			    }
			    mMotionHighlightView = null;
			    break;
			case MotionEvent.ACTION_MOVE:
			    if (cropImage.mWaitingToPick) 
			    {
			    	recomputeFocus(event);
			    } 
			    else if (mMotionHighlightView != null) 
			    {
			    	mMotionHighlightView.handleMotion(mMotionEdge,
			    			event.getX() - mLastX,
			    			event.getY() - mLastY);
			    	mLastX = event.getX();
			    	mLastY = event.getY();

			    	if (true)
			    	{
					    // This section of code is optional. It has some user
					    // benefit in that moving the crop rectangle against
					    // the edge of the screen causes scrolling but it means
					    // that the crop rectangle is no longer fixed under
					    // the user's finger.
			    		ensureVisible(mMotionHighlightView);
			    	}
			    }
			    break;
		}
		switch (event.getAction()) 
		{
			case MotionEvent.ACTION_UP:
				center(true, true);
				break;
			case MotionEvent.ACTION_MOVE:
			    // if we're not zoomed then there's no point in even allowing
			    // the user to move the image around.  This call to center puts
			    // it back to the normalized location (with false meaning don't
			    // animate).
				if (getScale() == 1F) 
				{
					center(true, true);
				}
				break;
		}
		return true;
    }

    // Pan the displayed image to make sure the cropping rectangle is visible.
    private void ensureVisible(HighlightView hv) 
    {
		Rect r = hv.mDrawRect;
	
		int panDeltaX1 = Math.max(0, mLeft - r.left);
		int panDeltaX2 = Math.min(0, mRight - r.right);
	
		int panDeltaY1 = Math.max(0, mTop - r.top);
		int panDeltaY2 = Math.min(0, mBottom - r.bottom);
	
		int panDeltaX = panDeltaX1 != 0 ? panDeltaX1 : panDeltaX2;
		int panDeltaY = panDeltaY1 != 0 ? panDeltaY1 : panDeltaY2;
	
		if (panDeltaX != 0 || panDeltaY != 0) 
		{
		    panBy(panDeltaX, panDeltaY);
		}
    }

    // If the cropping rectangle's size changed significantly, change the
    // view's center and scale according to the cropping rectangle.
    private void centerBasedOnHighlightView(HighlightView hv) 
    {
		Rect drawRect = hv.mDrawRect;
	
		float width = drawRect.width();
		float height = drawRect.height();
	
		float thisWidth = getWidth();
		float thisHeight = getHeight();
	
		float z1 = thisWidth / width * .6F;
		float z2 = thisHeight / height * .6F;
	
		float zoom = Math.min(z1, z2);
		zoom = zoom * this.getScale();
		zoom = Math.max(1F, zoom);
		if ((Math.abs(zoom - getScale()) / zoom) > .1) 
		{
		    float [] coordinates = new float[] { hv.mCropRect.centerX(), hv.mCropRect.centerY()};
		    getImageMatrix().mapPoints(coordinates);

			// Disabling zoom as it causes disappearance of image
			//zoomTo(zoom, coordinates[0], coordinates[1], 300F);
		}
		ensureVisible(hv);
    }

    @Override
    protected void onDraw(Canvas canvas) 
    {
		try
		{
	    	super.onDraw(canvas);
	    	for (int i = 0; i < mHighlightViews.size(); i++) 
	    	{
	    		mHighlightViews.get(i).draw(canvas);
	    	}
		}
		catch(Exception ce)
		{
		}
    }

    public void add(HighlightView hv) 
    {
		mHighlightViews.add(hv);
		invalidate();
    }

	@Override
	protected void onMeasure(int widthM, int heightM)
	{
		super.onMeasure(widthM, heightM);
		int width = getMeasuredWidth();
		setMeasuredDimension(width, width);
	}
}
git config --global user.name "Travis CI"
# git clone --quiet --branch=apk htpps://username:authentiToken@github.com/username/phimpme-android apk > /dev/null
# replacing username with your github username and authentiToken with a personal token for your account.***
# Your token is advised to have only access to public repositories. Its only needed.
git clone --quiet --branch=apk https://$USERNAME:$API_TOKEN@github.com/$USERNAME/phimpme-android  apk > /dev/null
cp -Rf $HOME/buildApk/*
cd apk

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public Double getCapacitance() {
                return C;
            else if (V < GOOD_VOLTS[0] && V > 0.01 && CT < 40000) {
                if (GOOD_VOLTS[0] / V > 1.1 && iterations < 10) {
                    CT = CT * (int) GOOD_VOLTS[0] / (int) V;
                    iterations += 1;
                    Log.v(TAG, "Increased CT " + CT);
                } else if (iterations == 10)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public class Alliances implements Serializable {
    private static Alliances instance = null;
    private static final String dataFileName = "overlordalliances.dat";
    private static final File saveDir = DimensionManager.getCurrentSaveRootDirectory();

    private ArrayList<Alliance> alliances;

public static void load() {
        readFromFile();
    }

    @SuppressWarnings("TryWithIdenticalCatches")
    private static void readFromFile() {
        File f = new File(saveDir, dataFileName);
        if (f.exists()) {
            try {
                ObjectInputStream stream = new ObjectInputStream(new FileInputStream(f));
                instance = (Alliances) stream.readObject();
                stream.close();
            } catch (IOException e) {
                e.printStackTrace();
                instance = new Alliances();
                f.delete();
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
                instance = new Alliances();
                f.delete();
private static void readFromFile() {

    private static void saveToFile() {
        try {
            ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(new File(saveDir, dataFileName)));
            out.writeObject(instance);
            out.close();
public class Enemies implements Serializable {
    private static Enemies instance = null;
    private static final String dataFileName = "overlordenemies.dat";
    private static final File saveDir = DimensionManager.getCurrentSaveRootDirectory();

    private ArrayList<Alliance> enemies;

public static void load() {
        readFromFile();
    }

    @SuppressWarnings("TryWithIdenticalCatches")
    private static void readFromFile() {
        File f = new File(saveDir, dataFileName);
        if (f.exists()) {
            try {
                ObjectInputStream stream = new ObjectInputStream(new FileInputStream(f));
                instance = (Enemies) stream.readObject();
                stream.close();
            } catch (IOException e) {
                e.printStackTrace();
                instance = new Enemies();
                f.delete();
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
                instance = new Enemies();
                f.delete();
private static void readFromFile() {

    private static void saveToFile() {
        try {
            ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(new File(saveDir, dataFileName)));
            out.writeObject(instance);
            out.close();
public class Squads implements Serializable {
    private static Squads instance = null;
    private static final String dataFileName = "overlordplayersquads.dat";
    private static final File saveDir = DimensionManager.getCurrentSaveRootDirectory();

    private ArrayList<SquadData> squads;

public static void load() {
    }

    private static void readFromFile() {
        File f = new File(saveDir, dataFileName);
        if (f.exists()) {
            try {
private static void readFromFile() {

    private static void saveToFile() {
        try {
            ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(new File(saveDir, dataFileName)));
            out.writeObject(instance);
            out.close();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
protected void onResume() {
        checkGps();
    }

    protected void refreshView() {
        nearbyAsyncTask = new NearbyAsyncTask(this);
        nearbyAsyncTask.execute();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public AbstractHTTP2ServerConnectionFactory(@Name("config") HttpConfiguration ht
        this(httpConfiguration,"h2");
    }

    protected AbstractHTTP2ServerConnectionFactory(@Name("config") HttpConfiguration httpConfiguration, String... protocols)
    {
        super(protocols);
        for (String p:protocols)
public HTTP2CServerConnectionFactory(@Name("config") HttpConfiguration httpConfi
        this(httpConfiguration,"h2c");
    }
    
    public HTTP2CServerConnectionFactory(@Name("config") HttpConfiguration httpConfiguration, String... protocols)
    {
        super(httpConfiguration,protocols);
        for (String p:protocols)
public HTTP2ServerConnectionFactory(@Name("config") HttpConfiguration httpConfig
        super(httpConfiguration);
    }

    public HTTP2ServerConnectionFactory(@Name("config") HttpConfiguration httpConfiguration,String... protocols)
    {
        super(httpConfiguration,protocols);
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void run() {
        throw e;
      }
    } finally {
      TraceCompat.endSection();
    }
  }
void cancel() {

    isCancelled = true;
    decodeJob.cancel();
    boolean isPendingJobRemoved = diskCacheExecutor.remove(decodeJob)
        || sourceExecutor.remove(decodeJob)
        || sourceUnlimitedExecutor.remove(decodeJob);
    listener.onEngineJobCancelled(this, key);

    if (isPendingJobRemoved) {
      release(true /*isRemovedFromQueue*/);
    }
  }

  // Exposed for testing.
public void onLoadFailed(GlideException e) {

  @Override
  public void reschedule(DecodeJob<?> job) {
    if (isCancelled) {
      MAIN_THREAD_HANDLER.obtainMessage(MSG_CANCELLED, this).sendToTarget();
    } else {
      getActiveSourceExecutor().execute(job);
    }
  }

  @Synthetic
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import net.minecraft.item.ItemBlock;
import net.minecraft.item.ItemStack;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.common.ForgeModContainer;
import net.minecraftforge.fluids.*;
import net.minecraftforge.fml.common.registry.GameRegistry;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import squeek.veganoption.content.recipes.ShapelessMatchingOreRecipe;
import squeek.veganoption.content.registry.DescriptionRegistry;
import squeek.veganoption.content.registry.PistonCraftingRegistry;
import squeek.veganoption.content.registry.RelationshipRegistry;
import squeek.veganoption.helpers.LangHelper;
import squeek.veganoption.integration.IntegrationBase;
import squeek.veganoption.integration.IntegrationHandler;

public class PlantMilk implements IContentModule
{
public void create()
		FluidRegistry.addBucketForFluid(fluidPlantMilk);

		bucketPlantMilk = new ItemStack(Items.MILK_BUCKET);
		bucketPlantMilk.setStackDisplayName(LangHelper.translateRaw("item.VeganOption.bucketPlantMilk.name"));
	}

	@Override
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void removeQuests(Collection<Long> questIds, QuestGroup group)

	@UiThread private void closeQuestDetails()
	{
		getFragmentManager().popBackStack(BOTTOM_SHEET, FragmentManager.POP_BACK_STACK_INCLUSIVE);

		mapFragment.removeQuestGeometry();

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
interface IPlayerService {
    void pause();
    void setPreferences(in ImmutablePreferenceStore preferences);
    void setQueue(in List<Song> newQueue, int newPosition);
    void changeSong(int position);
    void editQueue(in List<Song> newQueue, int newPosition);
    void queueNext(in Song song);
interface IPlayerService {
    List<Song> getQueue();
    int getQueuePosition();
    int getQueueSize();
    int getCurrentPosition();
    int getDuration();

 */
public interface PlayerController {

    /**
     * Gets error messages from the service that can be displayed on the UI
     * @return An observable stream of user-presentable error messages
import com.marverenic.music.utils.MediaStyleHelper;

import java.io.IOException;
import java.util.Collections;
import java.util.List;

import timber.log.Timber;

public class PlayerService extends Service implements MusicPlayer.OnPlaybackChangeListener {
public void onPlaybackChange() {
    public static class Stub extends IPlayerService.Stub {

        private PlayerService mService;

        public Stub(PlayerService service) {
            mService = service;
public void setQueue(List<Song> newQueue, int newPosition) throws RemoteExceptio
        }

        @Override
        public void changeSong(int position) throws RemoteException {
            if (!isMusicPlayerReady()) {
                Timber.i("PlayerService.changeSong(): Service is not ready. Dropping command");
public int getQueueSize() throws RemoteException {
        }

        @Override
        public int getCurrentPosition() throws RemoteException {
            if (!isMusicPlayerReady()) {
                return 0;
import com.marverenic.music.utils.Optional;
import com.marverenic.music.utils.Util;

import java.util.Collections;
import java.util.List;
import java.util.concurrent.TimeUnit;
private void releaseAllProperties() {
    private void initAllProperties() {
        mPlaying.setFunction(mBinding::isPlaying);
        mNowPlaying.setFunction(mBinding::getNowPlaying);
        mQueue.setFunction(mBinding::getQueue);
        mQueuePosition.setFunction(mBinding::getQueuePosition);
        mCurrentPosition.setFunction(mBinding::getCurrentPosition);
        mDuration.setFunction(mBinding::getDuration);
public void updatePlayerPreferences(ReadOnlyPreferenceStore preferenceStore) {

    @Override
    public void setQueue(List<Song> newQueue, int newPosition) {
        execute(() -> {
            try {
                mBinding.setQueue(newQueue, newPosition);
public void setQueue(List<Song> newQueue, int newPosition) {
        });
    }

    @Override
    public void clearQueue() {
        setQueue(Collections.emptyList(), 0);
public void changeSong(int newPosition) {

    @Override
    public void editQueue(List<Song> queue, int newPosition) {
        execute(() -> {
            try {
                mBinding.editQueue(queue, newPosition);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
and adjust the build number accordingly -->
                                <includes>
                                    <include>com.feildmaster.lib:EnhancedConfiguration</include>
                                    <include>com.dumptruckman.minecraft:Logging</include>
                                    <include>net.minidev:json-smart</include>
                                </includes>
                            </artifactSet>
and adjust the build number accordingly -->
                                    </shadedPattern>
                                </relocation>
                                <relocation>
                                    <pattern>com.dumptruckman.minecraft.util.DebugLog</pattern>
                                    <shadedPattern>com.onarandombox.MultiverseCore.utils.DebugFileLogger</shadedPattern>
                                </relocation>
and adjust the build number accordingly -->
            <scope>provided</scope>
        </dependency>
        <!-- End of WorldInventories Dependency -->
        <!-- Start of jsonsmart Dependency -->
        <dependency>
            <groupId>net.minidev</groupId>
            <artifactId>json-smart</artifactId>
            <version>1.1.1</version>
            <type>jar</type>
            <scope>compile</scope>
        </dependency>
        <!-- End of jsonsmart Dependency -->
        <!-- Start of Test Dependencies -->
        <dependency>
            <groupId>junit</groupId>
package com.onarandombox.multiverseinventories.util;

import com.google.common.io.Files;
import org.apache.commons.lang.Validate;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.nio.charset.Charset;
import java.nio.charset.IllegalCharsetNameException;

public class EncodedJsonConfiguration extends JsonConfiguration {

    private final Charset charset;

    public EncodedJsonConfiguration(File file, String charset) throws UnsupportedEncodingException, IllegalCharsetNameException {
        super(file);
        this.charset = Charset.forName(charset);
    }

    @Override
    public void save(File file) throws IOException {
        Validate.notNull(file, "File cannot be null");

        Files.createParentDirs(file);

        String data = saveToString();

        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), charset));

        try {
            writer.write(data);
        } finally {
            writer.close();
        }
    }
}
package com.onarandombox.multiverseinventories.util;

import com.dumptruckman.minecraft.util.Logging;
import net.minidev.json.parser.JSONParser;
import net.minidev.json.parser.ParseException;
import org.apache.commons.lang.Validate;
import org.bukkit.Bukkit;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.InvalidConfigurationException;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.configuration.serialization.ConfigurationSerializable;
import org.bukkit.configuration.serialization.ConfigurationSerialization;
import org.json.simple.JSONValue;
import org.yaml.snakeyaml.error.YAMLException;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;

public class JsonConfiguration extends FileConfiguration {

    protected static final String BLANK_CONFIG = "{}\n";
    //private static final JSONParser JSON_PARSER = ;

    @Override
    public String saveToString() {
        String dump = JSONValue.toJSONString(buildMap(getValues(false)));

        if (dump.equals(BLANK_CONFIG)) {
            dump = "";
        }

        return dump;
    }

    private Map<String, Object> buildMap(final Map<?, ?> map) {
        final Map<String, Object> result = new LinkedHashMap<String, Object>(map.size());
        try {
            for (final Map.Entry<?, ?> entry : map.entrySet()) {
                if (entry.getValue() instanceof ConfigurationSection) {
                    result.put(entry.getKey().toString(), buildMap(((ConfigurationSection) entry.getValue()).getValues(false)));
                } else if (entry.getValue() instanceof Map) {
                    result.put(entry.getKey().toString(), buildMap(((Map) entry.getValue())));
                } else if (entry.getValue() instanceof List) {
                    result.put(entry.getKey().toString(), buildList((List) entry.getValue()));
                } else if (entry.getValue() instanceof ConfigurationSerializable) {
                    ConfigurationSerializable serializable = (ConfigurationSerializable) entry.getValue();
                    Map<String, Object> values = new LinkedHashMap<String, Object>();
                    values.put(ConfigurationSerialization.SERIALIZED_TYPE_KEY, ConfigurationSerialization.getAlias(serializable.getClass()));
                    values.putAll(serializable.serialize());
                    result.put(entry.getKey().toString(), buildMap(values));
                } else {
                    result.put(entry.getKey().toString(), entry.getValue());
                }
            }
        } catch (Exception e) {
            Logging.getLogger().log(Level.WARNING, "Error while building configuration map.", e);
        }
        return result;
    }

    private List<Object> buildList(final List<?> list) {
        final List<Object> result = new ArrayList<Object>(list.size());
        try {
            for (final Object o : list) {
                if (o instanceof ConfigurationSection) {
                    result.add(buildMap(((ConfigurationSection) o).getValues(false)));
                } else if (o instanceof Map) {
                    result.add(buildMap(((Map) o)));
                } else if (o instanceof List) {
                    result.add(buildList((List) o));
                } else if (o instanceof ConfigurationSerializable) {
                    ConfigurationSerializable serializable = (ConfigurationSerializable) o;
                    Map<String, Object> values = new LinkedHashMap<String, Object>();
                    values.put(ConfigurationSerialization.SERIALIZED_TYPE_KEY, ConfigurationSerialization.getAlias(serializable.getClass()));
                    values.putAll(serializable.serialize());
                    result.add(buildMap(values));
                } else {
                    result.add(o);
                }
            }
        } catch (Exception e) {
            Logging.getLogger().log(Level.WARNING, "Error while building configuration list.", e);
        }
        return result;
    }

    @Override
    public void loadFromString(String contents) throws InvalidConfigurationException {
        Validate.notNull(contents, "Contents cannot be null");
        if (contents.isEmpty()) {
            return;
        }

        Map<?, ?> input;
        try {
            input = (Map<?, ?>) new JSONParser(JSONParser.USE_INTEGER_STORAGE).parse(contents);
        } catch (ParseException e) {
            throw new InvalidConfigurationException("Invalid JSON detected.");
        } catch (ClassCastException e) {
            throw new InvalidConfigurationException("Top level is not a Map.");
        }

        if (input != null) {
            convertMapsToSections(input, this);
        }
    }

    protected void convertMapsToSections(Map<?, ?> input, ConfigurationSection section) {
        Object result = dealWithSerializedObjects(input);
        if (result instanceof Map) {
            input = (Map<?, ?>) result;
            for (Map.Entry<?, ?> entry : input.entrySet()) {
                String key = entry.getKey().toString();
                Object value = entry.getValue();

                if (value instanceof Map) {
                    convertMapsToSections((Map<?, ?>) value, section.createSection(key));
                } else {
                    section.set(key, value);
                }
            }
        } else {
            section.set("", result);
        }
    }

    protected Object dealWithSerializedObjects(final Map<?, ?> input) {
        final Map<String, Object> output = new LinkedHashMap<String, Object>(input.size());
        for (final Map.Entry<?, ?> e : input.entrySet()) {
            if (e.getValue() instanceof Map) {
                output.put(e.getKey().toString(), dealWithSerializedObjects((Map<?, ?>) e.getValue()));
            }  else if (e.getValue() instanceof List) {
                output.put(e.getKey().toString(), dealWithSerializedObjects((List<?>) e.getValue()));
            } else {
                output.put(e.getKey().toString(), e.getValue());
            }
        }
        if (output.containsKey(ConfigurationSerialization.SERIALIZED_TYPE_KEY)) {
            try {
                return ConfigurationSerialization.deserializeObject(output);
            } catch (IllegalArgumentException ex) {
                throw new YAMLException("Could not deserialize object", ex);
            }
        }
        return output;
    }

    protected Object dealWithSerializedObjects(final List<?> input) {
        final List<Object> output = new ArrayList<Object>(input.size());
        for (final Object o : input) {
            if (o instanceof Map) {
                output.add(dealWithSerializedObjects((Map<?, ?>) o));
            } else if (o instanceof List) {
                output.add(dealWithSerializedObjects((List<?>) o));
            } else {
                output.add(o);
            }
        }
        return output;
    }

    @Override
    protected String buildHeader() {
        return "";
    }

    @Override
    public JsonConfigurationOptions options() {
        if (options == null) {
            options = new JsonConfigurationOptions(this);
        }

        return (JsonConfigurationOptions) options;
    }

    public JsonConfiguration(final File file) {
        try {
            load(file);
        } catch (FileNotFoundException ex) {
        } catch (IOException ex) {
            Bukkit.getLogger().log(Level.SEVERE, "Cannot load " + file, ex);
        } catch (InvalidConfigurationException ex) {
            Bukkit.getLogger().log(Level.SEVERE, "Cannot load " + file , ex);
        }
    }
}
package com.onarandombox.multiverseinventories.util;

import org.bukkit.configuration.file.FileConfigurationOptions;

public class JsonConfigurationOptions extends FileConfigurationOptions {

    protected JsonConfigurationOptions(JsonConfiguration configuration) {
        super(configuration);
    }

    @Override
    public JsonConfiguration configuration() {
        return (JsonConfiguration) super.configuration();
    }

    @Override
    public JsonConfigurationOptions copyDefaults(boolean value) {
        super.copyDefaults(value);
        return this;
    }

    @Override
    public JsonConfigurationOptions pathSeparator(char value) {
        super.pathSeparator(value);
        return this;
    }

    @Override
    public JsonConfigurationOptions header(String value) {
        super.header(value);
        return this;
    }

    @Override
    public JsonConfigurationOptions copyHeader(boolean value) {
        super.copyHeader(value);
        return this;
    }
}
package com.onarandombox.multiverseinventories.util.data;

import com.dumptruckman.minecraft.util.Logging;
import com.feildmaster.lib.configuration.EnhancedConfiguration;
import com.onarandombox.multiverseinventories.ProfileTypes;
import com.onarandombox.multiverseinventories.api.profile.PlayerProfile;
import com.onarandombox.multiverseinventories.api.profile.ProfileType;
import com.onarandombox.multiverseinventories.util.EncodedConfiguration;
import com.onarandombox.multiverseinventories.util.EncodedJsonConfiguration;
import com.onarandombox.multiverseinventories.util.JsonConfiguration;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.FileConfiguration;

private FileConfiguration getConfigHandle(File file) {
            }
        } else {
            try {
                return new EncodedJsonConfiguration(file, "UTF-8");
            } catch (UnsupportedEncodingException e) {
                return new JsonConfiguration(file);
            }
        }
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
apply plugin: 'com.android.application'

android {
    compileSdkVersion 23
    buildToolsVersion "23.0.3"

    defaultConfig {
        applicationId "com.dimorinny.sample"
        minSdkVersion 14
        targetSdkVersion 23
        versionCode 1
        versionName "1.0"
    }
android {

repositories {
    maven {
        url  "http://dl.bintray.com/lukaville/maven"
    }
}

dependencies {
    compile fileTree(include: ['*.jar'], dir: 'libs')
    testCompile 'junit:junit:4.12'
    compile project(':library')
    compile 'com.android.support:appcompat-v7:23.4.0'
}
package com.dimorinny.sample;

import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.util.Log;

import com.nbsp.materialfilepicker.MaterialFilePicker;
import com.nbsp.materialfilepicker.ui.FilePickerActivity;

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        new MaterialFilePicker()
                .withActivity(this)
                .withRequestCode(1)
                .withFilterDirectories(false)
                .withFilter(Pattern.compile(".*\\.txt$"))
                .withHiddenFiles(true)
                .start();
    }
protected void onCreate(Bundle savedInstanceState) {
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);

        if (requestCode == 1 && resultCode == RESULT_OK) {
            Log.d("File", String.valueOf(data.getStringExtra(FilePickerActivity.RESULT_FILE_PATH)));
        }
    }
}
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    >

    <FrameLayout
        android:id="@+id/container"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/>
</RelativeLayout>
<resources>
    <string name="app_name">sample</string>
</resources>
buildscript {
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:2.1.0'
        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.2'
        classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'
    }
ext {
    siteUrl = 'https://github.com/nbsp-team/MaterialFilePicker'
    gitUrl = 'https://github.com/nbsp-team/MaterialFilePicker'

    libraryVersion = '1.09'

    developerId = 'lukaville'
    developerName = 'Nickolay Chameev'
ext {
}

android {
    compileSdkVersion 23
    buildToolsVersion "23.0.3"

    defaultConfig {
        minSdkVersion 14
        targetSdkVersion 23
        versionCode 10
        versionName "1.09"
    }
    buildTypes {
        release {
dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    testCompile 'junit:junit:4.12'

    compile 'com.android.support:appcompat-v7:23.4.0'
    compile 'com.android.support:recyclerview-v7:23.4.0'
    compile 'com.android.support:design:23.4.0'
}

apply from: 'https://raw.githubusercontent.com/nuuneoi/JCenter/master/installv1.gradle'
package com.nbsp.materialfilepicker;

import android.app.Application;
import android.test.ApplicationTestCase;

/**
 * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
 */
public class ApplicationTest extends ApplicationTestCase<Application> {
    public ApplicationTest() {
        super(Application.class);
    }
}
package com.nbsp.materialfilepicker;

import android.app.Activity;
import android.content.Intent;

import com.nbsp.materialfilepicker.filter.CompositeFilter;
import java.util.ArrayList;
import java.util.regex.Pattern;

/**
 * Created by Dimorinny on 25.02.16.
 */
public class MaterialFilePicker {
    private Activity mActivity;
    private Integer mRequestCode;
    private Pattern mFileFilter;
    private Boolean mDirectoriesFilter = false;
    private String mRootPath;
    private String mCurrentPath;
    private Boolean mShowHidden = false;

    public MaterialFilePicker() {}

    public MaterialFilePicker withActivity(Activity activity) {
        mActivity = activity;
        return this;
    }

    public MaterialFilePicker withRequestCode(int requestCode) {
        mRequestCode = requestCode;
        return this;
    }

    public MaterialFilePicker withFilter(Pattern pattern) {
        mFileFilter = pattern;
        return this;
    }

    public MaterialFilePicker withFilterDirectories(boolean directoriesFilter) {
        mDirectoriesFilter = directoriesFilter;
        return this;
    }

    public MaterialFilePicker withRootPath(String rootPath) {
        mRootPath = rootPath;
        return this;
    }

    public MaterialFilePicker withPath(String path) {
        mCurrentPath = path;
        return this;
    }

    public MaterialFilePicker withHiddenFiles(boolean show) {
        mShowHidden = show;
        return this;
    }

    private CompositeFilter getFilter() {
        ArrayList<FileFilter> filters = new ArrayList<>();

        if (!mShowHidden) {
private CompositeFilter getFilter() {
        return new CompositeFilter(filters);
    }

    public void start() {
        if (mActivity == null) {
            throw new RuntimeException("You must pass activity by calling withActivity method");
        }

        if (mRequestCode == null) {
            throw new RuntimeException("You must pass request code by calling withRequestCode method");
        }

        CompositeFilter filter = getFilter();

        Intent intent = new Intent(mActivity, FilePickerActivity.class);
        intent.putExtra(FilePickerActivity.ARG_FILTER, filter);

        if (mRootPath != null) {
public void start() {
        if (mCurrentPath != null) {
            intent.putExtra(FilePickerActivity.ARG_CURRENT_PATH, mCurrentPath);
        }
        mActivity.startActivityForResult(intent, mRequestCode);
    }
}

    public class DirectoryViewHolder extends RecyclerView.ViewHolder {
        private ImageView mFileImage;
        private TextView mFileTite;
        private TextView mFileSubtitle;

        public DirectoryViewHolder(View itemView, final OnItemClickListener clickListener) {
public void onClick(View v) {
            });

            mFileImage = (ImageView) itemView.findViewById(R.id.item_file_image);
            mFileTite = (TextView) itemView.findViewById(R.id.item_file_title);
            mFileSubtitle = (TextView) itemView.findViewById(R.id.item_file_subtitle);
        }
    }
public void onBindViewHolder(DirectoryViewHolder holder, int position) {
        FileTypeUtils.FileType fileType = FileTypeUtils.getFileType(currentFile);
        holder.mFileImage.setImageResource(fileType.getIcon());
        holder.mFileSubtitle.setText(fileType.getDescription());
        holder.mFileTite.setText(currentFile.getName());
    }

    @Override

import com.nbsp.materialfilepicker.R;
import com.nbsp.materialfilepicker.filter.CompositeFilter;
import com.nbsp.materialfilepicker.utils.FileUtils;

import java.io.File;
import java.lang.reflect.Field;

/**
 * Created by Dimorinny on 24.10.15.
protected void onCreate(Bundle savedInstanceState) {
    @SuppressWarnings("unchecked")
    private void initArguments() {
        if (getIntent().hasExtra(ARG_FILTER)) {
            mFilter = (CompositeFilter) getIntent().getSerializableExtra(ARG_FILTER);
        }

        if (getIntent().hasExtra(ARG_START_PATH)) {
private void initArguments() {
        }

        if (getIntent().hasExtra(ARG_CURRENT_PATH)) {
            String currentPath = getIntent().getStringExtra(ARG_START_PATH);

            if (currentPath.startsWith(mStartPath)) {
                mCurrentPath = currentPath;

import org.junit.Test;

import static org.junit.Assert.*;

/**
 * To work on unit tests, switch the Test Artifact in the Build Variants view.
 */
public class ExampleUnitTest {
    @Test
    public void addition_isCorrect() throws Exception {
        assertEquals(4, 2 + 2);
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
protected static Location createAppLocation(final Configuration conf, String fsU
        @Override
        public Location run() throws Exception {
          Configuration hConf = new Configuration(conf);
          URI defaultURI = new URI(appDir.getScheme(), appDir.getAuthority(), null, null, null);
          hConf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY, defaultURI.toString());
          return new FileContextLocationFactory(hConf).create(appDir);
        }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import net.milkbowl.vault.economy.EconomyResponse;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Material;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;
import org.bukkit.event.inventory.ClickType;
				if (!kit.getFlag(VISIBLE, world)) continue;
				if (kit.getFlag(FREE, world) || user.isUnlocked(kit)) continue;

				menuObject = new MenuObject(Material.SULPHUR, (byte) 0, ChatColor.RED + kit.getDisplayName(player.getWorld().getName()), KitManager.getKitDescription(player, kit, world));
				menuObject.setActionListener(buyInventoryListener);

				menu.addMenuObject(menuObject);
import java.util.*;
import java.util.stream.Collectors;

import static hu.tryharddevs.advancedkits.utils.localization.I18n.getMessage;

public class EditCommand implements ActionListener
	@CommandManager.Cmd(cmd = "edit", help = "Edit kit", longhelp = "This command opens up a gui where you can edit kits.", permission = "edit", args = "[kitname] [world]", only = CommandManager.CommandOnly.PLAYER)
	public static CommandManager.CommandFinished editCommand(CommandSender sender, Object[] args)
	{
		if (args.length == 0) {
			Player    player    = (Player) sender;
			Inventory inventory = Bukkit.createInventory(player, !inEdit.containsKey(player.getUniqueId()) ? ((int) (Math.ceil((double) KitManager.getKits().size() / 9)) * 9) : 9, "AdvancedKitsReborn - Edit kit");
			MenuObject menuObject;
			if (!inEdit.containsKey(player.getUniqueId())) {
				for (Kit kit : KitManager.getKits()) {
					menuObject = new MenuObject(Material.STORAGE_MINECART, (byte) 0, ChatColor.GREEN + kit.getDisplayName(player.getWorld().getName()), Arrays.asList(ChatColor.BLACK + "", ChatColor.GREEN + "Click to edit"));
					menuObject.setActionListener(editCommandListener);

					menu.addMenuObject(menuObject);
			return CommandManager.CommandFinished.DONE;
		}

		String world = "global";
		if (args.length == 2) {
			world = String.valueOf(args[1]);
		}
import hu.tryharddevs.advancedkits.kits.flags.Flag;
import hu.tryharddevs.advancedkits.kits.flags.InvalidFlagValueException;
import org.bukkit.Bukkit;
import org.bukkit.Material;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;
		}
		Flag flag = DefaultFlags.fuzzyMatchFlag(String.valueOf(args[1]));
		if (String.valueOf(args[1]).equalsIgnoreCase("help")) {
			if (Objects.isNull(flag)) {
				player.sendMessage(AdvancedKitsMain.advancedKits.chatPrefix + " " + getMessage("flagNotFound"));
			}
			player.sendMessage(AdvancedKitsMain.advancedKits.chatPrefix + " " + getMessage("availableFlags", Arrays.stream(DefaultFlags.getFlags()).map(Flag::getName).collect(Collectors.joining(","))));
			return CommandManager.CommandFinished.DONE;
		}
		Object value = args[2];
		String world = "global";
		if (args.length > 3) {
			world = String.valueOf(args[3]);
			if (Objects.isNull(Bukkit.getWorld(world))) {
			}
		}

		if (flag.getName().equalsIgnoreCase("firework")) {
			if (Objects.isNull(player.getInventory().getItemInMainHand()) || !player.getInventory().getItemInMainHand().getType().equals(Material.FIREWORK)) {
				player.sendMessage(AdvancedKitsMain.advancedKits.chatPrefix + " " + getMessage("notFirework"));
				return CommandManager.CommandFinished.DONE;
			}
			kit.setFlag(flag, world, flag.parseItem(player));
		}
		else {
			try {
				kit.setFlag(flag, world, flag.parseInput(String.valueOf(value)));
			}
			catch (InvalidFlagValueException e) {
				player.sendMessage(e.getMessages());
				return CommandManager.CommandFinished.DONE;
			}
		}

		player.sendMessage(AdvancedKitsMain.advancedKits.chatPrefix + " " + getMessage("flagSet", flag.getName(), value, kit.getDisplayName(world), world));
		return CommandManager.CommandFinished.DONE;
	}
				if (!kit.getFlag(VISIBLE, world)) continue;
				if (!kit.getFlag(FREE, world) && !user.isUnlocked(kit)) continue;

				menuObject = new MenuObject(Material.STORAGE_MINECART, (byte) 0, ChatColor.GREEN + kit.getDisplayName(player.getWorld().getName()), KitManager.getKitDescription(player, kit, world));
				menuObject.setActionListener(useInventoryListener);

				menu.addMenuObject(menuObject);

import java.util.Objects;

import static hu.tryharddevs.advancedkits.kits.flags.DefaultFlags.VISIBLE;
import static hu.tryharddevs.advancedkits.utils.localization.I18n.getMessage;

	private static ViewCommand viewInventoryListener = new ViewCommand();

	@CommandManager.Cmd(cmd = "view", help = "View kits", longhelp = "This command opens up a gui where you can view kits.", permission = "view", args = "[kitname]", only = CommandManager.CommandOnly.PLAYER)
	public static CommandManager.CommandFinished buyCommand(CommandSender sender, Object[] args)
	{
		Player player = (Player) sender;
		User   user   = User.getUser(player.getUniqueId());
			for (Kit kit : KitManager.getKits()) {
				if (!kit.getFlag(VISIBLE, world)) continue;

				menuObject = new MenuObject(Material.SULPHUR, (byte) 0, ChatColor.WHITE + kit.getDisplayName(player.getWorld().getName()), KitManager.getKitDescription(player, kit, world));
				menuObject.setActionListener(viewInventoryListener);

				menu.addMenuObject(menuObject);
package hu.tryharddevs.advancedkits.kits.flags;

import org.bukkit.Sound;
import org.bukkit.potion.PotionEffect;
import org.inventivetalent.particle.ParticleEffect;

	public static final DoubleFlag DELAY = new DoubleFlag("delay", 0.0);

	public static final ItemStackFlag FIREWORK = new ItemStackFlag("firework");

	public static final ListFlag<String>         CUSTOMDESCRIPTION = new ListFlag<>("customdescription", new StringFlag(null));
	public static final ListFlag<ParticleEffect> PARTICLEEFFECTS   = new ListFlag<>("particleeffects", new ParticleEffectFlag(null));
	public static final ListFlag<Sound>          SOUNDEFFECTS      = new ListFlag<>("soundeffects", new SoundEffectFlag(null));

	public static final Flag<?>[] flagsList = new Flag<?>[]{VISIBLE, FIRSTJOIN, AUTOEQUIPARMOR, FREE, USEONBUY, CLEARINVENTORY, SPEWITEMS, DISPLAYNAME, PERUSECOST, COST, MAXUSES, DELAY, FIREWORK, CUSTOMDESCRIPTION, COMMANDS, MESSAGES, DISABLEDWORLDS, POTIONEFFECTS, PARTICLEEFFECTS, SOUNDEFFECTS};

	public static Flag<?>[] getFlags()
	{
public T chooseValue(Collection<T> values)
	public abstract T parseInput(String input) throws InvalidFlagValueException;

	@Nullable
	public T parseItem(Player player)
	{
		return null;
	}
noPermission=&cYou don''t have the permission for this.
flagNotFound=&cFlag not found.
worldNotFound=&cWorld not found.
notFirework=&cYou need to hold the firework in your hand.
notEnoughMoney=&cYou don''t have enought money. &7({0})
notEnoughSpace=&cYou need &f{0}&c space in your inventory.
emptyInventory=&cYou don''t have anything in your inventory.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void renderGliderFirstPersonPerspective(RenderWorldLastEvent event){

        EntityPlayer entityPlayer = Minecraft.getMinecraft().thePlayer;
        ItemStack gliderStack = GliderHelper.getGlider(Minecraft.getMinecraft().thePlayer);
        ResourceLocation resourceLocation = ((IGlider)gliderStack.getItem()).getModelTexture(gliderStack);
        Minecraft.getMinecraft().getTextureManager().bindTexture(resourceLocation); //bind texture

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import org.springframework.expression.Expression;
import org.springframework.expression.ParserContext;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.web.client.RestTemplate;

import de.codecentric.boot.admin.event.ClientApplicationEvent;
public void setRestTemplate(RestTemplate restTemplate) {
		this.restTemplate = restTemplate;
	}

	protected Object createMessage(ClientApplicationEvent event) {
		Map<String, Object> messageJson = new HashMap<>();
		messageJson.put("username", username);
		if (icon != null) {
protected Object createMessage(ClientApplicationEvent event) {
		attachments.put("color", getColor(event));
		attachments.put("mrkdwn_in", Collections.singletonList("text"));
		messageJson.put("attachments", Collections.singletonList(attachments));
		return messageJson;
	}

	protected String getText(ClientApplicationEvent event) {

import org.junit.Before;
import org.junit.Test;
import org.springframework.web.client.RestTemplate;

import de.codecentric.boot.admin.event.ClientApplicationStatusChangedEvent;
private ClientApplicationStatusChangedEvent getEvent(StatusInfo infoDown, Status
				infoDown, infoUp);
	}

	private Object expectedMessage(String color, String user, @Nullable String icon,
			@Nullable String channel, String message) {
		Map<String, Object> messageJson = new HashMap<>();
		messageJson.put("username", user);
private Object expectedMessage(String color, String user, @Nullable String icon,

		messageJson.put("attachments", Collections.singletonList(attachments));

		return messageJson;
	}

	private String standardMessage(String status, String appName, String id) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<crescendo.version>2.2.2</crescendo.version>
		<intocps.shm.version>0.2.1-SNAPSHOT</intocps.shm.version>
	</properties>


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
package com.wolfgoes.popularmovies.ui;

import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.text.TextUtils;

import com.wolfgoes.popularmovies.R;
import com.wolfgoes.popularmovies.utils.Utility;

public class MainActivity extends AppCompatActivity {

    private static final String STATE_MOVIE_ORDER = "extra_movie_order";

    private String mOrder;

    @Override
    protected void onSaveInstanceState(Bundle outState) {
protected void onCreate(Bundle savedInstanceState) {

        setContentView(R.layout.activity_main);

        if (findViewById(R.id.fragment_container) != null) {
            MoviesFragment moviesFragment = new MoviesFragment();

protected void onResume() {
        }
        mOrder = order;
    }
}
import android.widget.TextView;
import android.widget.Toast;

import com.wolfgoes.popularmovies.BuildConfig;
import com.wolfgoes.popularmovies.R;
import com.wolfgoes.popularmovies.api.MovieApi;
import com.wolfgoes.popularmovies.data.MoviesContract;
public boolean onOptionsItemSelected(MenuItem item) {
    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putParcelableArrayList(STATE_MOVIE_LIST, mMovies);
        outState.putString(STATE_MOVIE_ORDER, mOrder);
    }

public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        if (savedInstanceState != null) {
            mMovies = savedInstanceState.getParcelableArrayList(STATE_MOVIE_LIST);

            synchronized (lock) {
                if (mMovies != null && mMovies.size() > 0 && mMovies.get(mMovies.size() - 1) == null) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private static void initEnderIO() {
	}
	
	private static void initTF() {
		if ((Config.thermalFoundation && Loader.isModLoaded("thermalfoundation")) || (Config.substratum && Loader.isModLoaded("substratum"))) {
			Material signalum = new Material("signalum_plustic", TextFormatting.RED);
			signalum.addTrait(BloodyMary.bloodymary);
			signalum.addItem("ingotSignalum", 1, Material.VALUE_Ingot);
private static void initTF() {
			signalumFluid.setTemperature(930);
			Utils.initFluidMetal(signalumFluid);
			signalum.setFluid(signalumFluid);
			TinkerRegistry.registerAlloy(new FluidStack(signalumFluid, 72), new FluidStack(TinkerFluids.copper, 54),
					new FluidStack(TinkerFluids.silver, 18), new FluidStack(FluidRegistry.getFluid("redstone"), 125));
			
			TinkerRegistry.addMaterialStats(signalum, new HeadMaterialStats(690, 7.5f, 5.2f, OBSIDIAN),
					new HandleMaterialStats(1.2f, 0), new ExtraMaterialStats(55),
private static void initTF() {
			enderium.setFluid(enderiumFluid);
			TinkerRegistry.registerAlloy(new FluidStack(enderiumFluid, 144), new FluidStack(TinkerFluids.tin, 72),
					new FluidStack(TinkerFluids.silver, 36), new FluidStack(platinumFluid, 36),
					new FluidStack(FluidRegistry.getFluid("ender"), 250));
			
			TinkerRegistry.addMaterialStats(enderium, new HeadMaterialStats(800, 7.5f, 7, COBALT),
					new HandleMaterialStats(1.05f, -5), new ExtraMaterialStats(65), new BowMaterialStats(0.9f, 1.9f, 8),
					new ArrowShaftMaterialStats(1, 12));
			
			materials.put("enderium", enderium);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 */
package org.jooby.ebean;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Properties;
import java.util.Set;
import java.util.function.Consumer;

import org.jooby.Env;
import org.jooby.internal.ebean.EbeanManaged;
import org.jooby.jdbc.Jdbc;

import com.google.inject.Binder;
import com.google.inject.Key;
import com.typesafe.config.Config;
import io.ebean.EbeanServer;
import io.ebean.config.ContainerConfig;
import io.ebean.config.ServerConfig;

/**
 * <h1>ebean module</h1>
 */
public class Ebeanby extends Jdbc {

  private Set<String> packages = new HashSet<>();

  static {
    // Turn off ebean shutdown hook:
public Ebeanby(final String name) {
  public Ebeanby() {
  }

  /**
   * <p>
   * Add one ore more packages. Packages are used by the agent enhancement (if present) and to
   * search for entities via class path search when classes have not been explicitly specified.
   * </p>
   *
   * @param packages Packages to enhancement and search for.
   * @return This module.
   */
  public Ebeanby packages(final String... packages) {
    Arrays.stream(packages).forEach(this.packages::add);
    return this;
  }

  @Override
  public void configure(final Env env, final Config conf, final Binder binder) {
    configure(env, conf, binder, (name, ds) -> {
      ServerConfig config = new ServerConfig();

      this.packages.add(conf.getString("application.ns"));

      EbeanEnhancer.newEnhancer().run(packages);

      config.setName(name);

      packages.forEach(config::addPackage);

      Config cprops = conf.getConfig("ebean");
      if (conf.hasPath("ebean." + name)) {
        cprops = conf.getConfig("ebean." + name)
public void configure(final Env env, final Config conf, final Binder binder) {

      callback(config, conf);

      EbeanManaged server = new EbeanManaged(conf, config);
      env.onStart(server::start);
      env.onStop(server::stop);
public void configure(final Env env, final Config conf, final Binder binder) {
      }
      keys.generate(EbeanServer.class, name, provider);
    });
  }

  @Override
private Properties props(final Config config) {
    });
    return props;
  }
}
ebean.debug.sql=true
ebean.debug.lazyload=false

ebean.disableClasspathSearch = true
ebean.search.packages = ${application.ns}

# -------------------------------------------------------------
# Transaction Logging
import static org.easymock.EasyMock.expect;
import static org.easymock.EasyMock.isA;

import java.util.Properties;

import javax.sql.DataSource;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.modules.junit4.PowerMockRunner;

import com.google.common.collect.Sets;
import com.google.inject.Binder;
import com.google.inject.Key;
    expect(env.onStop(isA(CheckedRunnable.class))).andReturn(env);
  };

  @Test
  public void configure() throws Exception {
    new MockUnit(Env.class, Binder.class)
public void configure() throws Exception {
        .expect(hikariDataSource())
        .expect(serviceKey("db"))
        .expect(containerConfig)
        .expect(serverConfig(true))
        .expect(enhancer("my.model"))
        .expect(ebeanProperties())
        .expect(binder)
        .expect(onStop)
        .run(unit -> {
          new Ebeanby("db")
              .configure(unit.get(Env.class), config(), unit.get(Binder.class));
public void configureWith2Names() throws Exception {
          ServerConfig serverConfig = unit.mockConstructor(ServerConfig.class);

          serverConfig.setName("mydb");
          serverConfig.addPackage("my.model");
          serverConfig.setContainerConfig(unit.get(ContainerConfig.class));
          serverConfig.setDataSource(isA(DataSource.class));
          serverConfig.loadFromProperties(isA(Properties.class));
public void configureWith2Names() throws Exception {

          unit.registerMock(ServerConfig.class, serverConfig);
        })
        .expect(enhancer("my.model"))
        .expect(ebeanProperties())
        .expect(unit -> {
          Binder binder = unit.get(Binder.class);
public void configureWith2Names() throws Exception {
          expect(binder.bind(Key.get(EbeanServer.class, Names.named("mydb")))).andReturn(lbbES);
        })
        .expect(onStop)
        .run(unit -> {
          new Ebeanby("db")
              .configure(unit.get(Env.class), config()
public void configureWith2Names() throws Exception {
  }

  @Test
  public void configureWithPackages() throws Exception {
    new MockUnit(Env.class, Binder.class)
        .expect(props("com.ibm.db2.jcc.DB2SimpleDataSource", "jdbc:db2://127.0.0.1/db",
            "db2.db", null, "", false))
        .expect(hikariConfig())
        .expect(hikariDataSource())
        .expect(serviceKey("db"))
        .expect(ebeanProperties())
        .expect(containerConfig)
        .expect(serverConfig(true))
        .expect(enhancer("otro.package", "my.model"))
        .expect(binder)
        .expect(unit -> {
          ServerConfig conf = unit.get(ServerConfig.class);
          conf.addPackage("otro.package");
        })
        .expect(onStop)
        .run(unit -> {
          new Ebeanby()
              .packages("otro.package")
              .configure(unit.get(Env.class), config(), unit.get(Binder.class));
        });
  }

  @Test
  public void configureCallback() throws Exception {
    new MockUnit(Env.class, Binder.class)
        .expect(props("com.ibm.db2.jcc.DB2SimpleDataSource", "jdbc:db2://127.0.0.1/db",
public void configureCallback() throws Exception {
        .expect(serviceKey("db"))
        .expect(ebeanProperties())
        .expect(containerConfig)
        .expect(serverConfig(true))
        .expect(enhancer("my.model"))
        .expect(binder)
        .expect(unit -> {
          ServerConfig conf = unit.get(ServerConfig.class);
          conf.setName("xx");
        })
        .expect(onStop)
        .run(unit -> {
          new Ebeanby()
              .doWith((final ServerConfig conf) -> {
public void configureCustomOption() throws Exception {
          expect(props.setProperty("ebean.debug.sql", "true")).andReturn(null);
          expect(props.setProperty("ebean.debug.lazyload", "false")).andReturn(null);
          expect(props.setProperty("ebean.disableClasspathSearch", "true")).andReturn(null);
          expect(props.setProperty("ebean.search.packages", "my.model")).andReturn(null);
          unit.registerMock(Properties.class, props);
        })
        .expect(containerConfig)
        .expect(serverConfig(false))
        .expect(enhancer("my.model"))
        .expect(binder)
        .expect(onStop)
        .run(unit -> {
          Config customConfig = config().withValue("ebean.db.defaultServer",
              ConfigValueFactory.fromAnyRef(false));
private Block enhancer(final String... packages) {
    };
  }

  private Block serverConfig(final boolean defaultServer) {
    return unit -> {
      ServerConfig serverConfig = unit.mockConstructor(ServerConfig.class);

      serverConfig.setName("db");
      serverConfig.addPackage("my.model");
      serverConfig.setContainerConfig(unit.get(ContainerConfig.class));
      serverConfig.setDataSource(isA(DataSource.class));
      serverConfig.loadFromProperties(isA(Properties.class));
private Block ebeanProperties() {
      expect(props.setProperty("ebean.debug.sql", "true")).andReturn(null);
      expect(props.setProperty("ebean.debug.lazyload", "false")).andReturn(null);
      expect(props.setProperty("ebean.disableClasspathSearch", "true")).andReturn(null);
      expect(props.setProperty("ebean.search.packages", "my.model")).andReturn(null);
      unit.registerMock(Properties.class, props);
    };
  }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
apply plugin: 'net.minecraftforge.gradle.forge'
//Only edit below this line, the above code adds and enables the nessasary things for Forge to be setup.


version = "4.2.0.0"
group= "landmaster.plustic" // http://maven.apache.org/guides/mini/guide-naming-conventions.html
archivesBaseName = "plustic"

import org.apache.logging.log4j.*;

import com.brandon3055.draconicevolution.DEFeatures;
import com.progwml6.natura.nether.*;
import com.progwml6.natura.nether.block.logs.*;
import com.progwml6.natura.nether.block.planks.*;
import com.progwml6.natura.shared.*;

import landmaster.plustic.api.*;
import landmaster.plustic.proxy.*;
import landmaster.plustic.config.*;
import landmaster.plustic.fluids.*;
import landmaster.plustic.net.*;
import landmaster.plustic.util.*;
import landmaster.plustic.traits.*;
public class PlusTiC {
	public static final String MODID = "plustic";
	public static final String NAME = "PlusTiC";
	public static final String VERSION = "4.2.0.0";
	public static final String DEPENDS = "required-after:mantle;"
			+ "required-after:tconstruct;required-after:CodeChickenLib;"
			+ "after:Mekanism;after:BiomesOPlenty;after:Botania;after:advancedRocketry;"
private void initNatura() {
			Material darkwood = new Material("darkwood_plustic", TextFormatting.DARK_BLUE);
			darkwood.addTrait(DarkTraveler.darktraveler);
			darkwood.addTrait(ecological);
			ItemStack darkwoodPlankStack = new ItemStack(NaturaNether.netherPlanks,
					1, BlockNetherPlanks.PlankType.DARKWOOD.getMeta());
			ItemStack darkwoodLogStack = new ItemStack(NaturaNether.netherLog,
					1, BlockNetherLog.LogType.DARKWOOD.getMeta());
			darkwood.addItem(darkwoodPlankStack, 1, Material.VALUE_Ingot);
			darkwood.addItem(darkwoodLogStack, 1, 4*Material.VALUE_Ingot);
			try {
				darkwood.addItem(NaturaCommons.darkwood_stick, 1, Material.VALUE_Shard);
			} catch (NoSuchFieldError e) {
				warned = warnNatura(warned);
			}
			darkwood.setRepresentativeItem(darkwoodPlankStack);
			darkwood.setCraftable(true);
			proxy.setRenderInfo(darkwood, 0x000044);
			TinkerRegistry.addMaterialStats(darkwood,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private boolean declaringTypeIsLocalOrImported(CtTypeReference declaringType) {
	private boolean isInCollisionWithLocalMethod(CtExecutableReference ref) {
		CtType<?> typeDecl = ref.getParent(CtType.class);

		String methodName = ref.getSimpleName();

		for (CtMethod<?> method : typeDecl.getAllMethods()) {
			if (method.getSimpleName().equals(methodName)) {
				return true;
			}
		}
		return false;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	<artifactId>section-sort</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<parent>
		<groupId>sc.fiji</groupId>
		<artifactId>pom-fiji</artifactId>
		<version>8.2.0</version>
		<relativePath />
	</parent>
	<repositories>
		<!-- NB: for project parent -->
		<repository>
		<dependency>
			<groupId>mpicbg</groupId>
			<artifactId>mpicbg</artifactId>
			<version>1.0.1</version>
		</dependency>
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>
</project>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				} else if (mapKeyType instanceof WildcardType) {
					candidates.add(Void.class);
				} else {
					candidates.addAll(buildJSONDocObjectsCandidates(candidates, (Class<?>) ((ParameterizedType) mapKeyType).getRawType(), mapKeyType, reflections));
				}

				if (mapValueType instanceof Class) {
					candidates.add((Class<?>) mapValueType);
				} else if (mapValueType instanceof WildcardType) {
					candidates.add(Void.class);
				} else {
					candidates.addAll(buildJSONDocObjectsCandidates(candidates, (Class<?>) ((ParameterizedType) mapValueType).getRawType(), mapValueType, reflections));
				}

			}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
********************************************
*            version history
********************************************
1.0.3

- update act-sql-common to 1.0.1
- #3 It doesn't start with MySQL jdbc driver 5.x
- #4 Ebean Agent loaded twice if there are two ebean2 db services
- #5 The datasource created in sql-common not used when creating ebean server

1.0.2

- #2 does not work when app start in PROD mode

1.0.1

- #1 It should use ebean's naming convention by default

1.0.0 - baseline version
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
    <git.url>git@github.com:actframework/act-ebean2.git</git.url>
    <act.version>1.1.1</act.version>
    <act-sql-common.version>1.0.1</act-sql-common.version>
    <ebean.version>10.2.1</ebean.version>
    <ebean-agent.version>10.1.7</ebean-agent.version>
    <ebean-agent-loader.version>2.1.2</ebean-agent-loader.version>
protected boolean supportDdl() {
    }

    @Override
    protected void dataSourceInitialized() {
        ebeanConfig = new EbeanConfigAdaptor().adaptFrom(this.config, this);
        app().eventBus().trigger(new EbeanConfigLoaded(ebeanConfig));
        ebean = EbeanServerFactory.create(ebeanConfig);
    }

    @Override
    protected DataSource createDataSource() {
        // Ebean has set the datasource to config while creating ebean server
        return ebeanConfig.getDataSource();
    }

import org.osgl.util.S;

import javax.inject.Singleton;
import javax.sql.DataSource;
import java.util.Properties;
import java.util.Set;

public ServerConfig adaptFrom(SqlDbServiceConfig actConfig, SqlDbService svc) {
        ServerConfig config = new ServerConfig();

        config.setName(svc.id());
        DataSource dataSource = svc.dataSource();
        if (null == dataSource) {
            config.setDataSourceConfig(adaptFrom(actConfig.dataSourceConfig, svc));
        } else {
            config.setDataSource(svc.dataSource());
        }

        config.setDdlGenerate(actConfig.ddlGeneratorConfig.create);
        config.setDdlRun(actConfig.ddlGeneratorConfig.create);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
JvmMemoryMetrics jvmMemoryMetrics() {
    }

    @Bean
    @ConditionalOnClass(ch.qos.logback.classic.Logger.class)
    LogbackMetrics logbackMetrics() {
        return new LogbackMetrics();
    }
import java.util.List;

@Configuration
@ConditionalOnClass(RestTemplate.class)
class RestTemplateMetricsConfiguration {
    @Autowired(required = false)
    RestTemplateTagConfigurer tagConfigurer;
package io.micrometer.spring.export.prometheus;

import io.micrometer.core.instrument.prometheus.PrometheusMeterRegistry;
import org.springframework.boot.actuate.endpoint.Endpoint;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@ConditionalOnClass(Endpoint.class)
@Configuration
public class PrometheusEndpointConfiguration {
    @Bean
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.List;
import java.util.function.Consumer;
import javax.annotation.Nonnull;

public final boolean isSameMaterial(TileEntityCustomWood tileEntity) {
	 *
	 * @param type: the type to set the block's MATERIAL to.
	 */
	public final void setMaterial(CustomWoodType type) {
        this.woodType = type;
	}

    public final void setMaterial(ItemStack stack) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	private transient volatile Consumer<News> handler;
	private transient volatile Instant lastTrigger;

	public NewsList() {
	}

	public NewsList(Collection<News> news) {
		for (News n : news) {
			int i = (n.getNumber() - 1) %!s(MISSING)lots.length;
			slots[i] = n;
		}
	}

public void setHandler(Consumer<News> handler) {
	public void add(News news) {
		synchronized (lockObj) {
			if (news.getNumber() < 1) {
				for (int i = 0; i < slots.length - 1; ++i) {
					if (news != null) {
						news.setNumber(i + 1);
					}

					News next = slots[i];
					slots[i] = news;
					slots[i + 1] = next;
					news = next;
				}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import net.ndrei.teslacorelib.gui.FluidTankPiece
import net.ndrei.teslacorelib.inventory.BoundingRectangle
import net.ndrei.teslacorelib.inventory.FluidTank
import net.ndrei.teslacorelib.tileentities.SidedTileEntity
import net.ndrei.teslapoweredthingies.TeslaThingiesMod

/**
 * Created by CF on 2017-07-16.
class MultiTankEntity
            else
                !initialFluids[it]!!.isFluidStackIdentical(finalFluids[it])
        }) {
            TeslaThingiesMod.logger.info("Marked for render update: ${this.pos}")
            this.getWorld().markBlockRangeForRenderUpdate(this.pos, this.pos)
        }
    }
import net.minecraftforge.common.model.IModelState
import net.minecraftforge.fml.common.Loader
import net.minecraftforge.fml.common.discovery.ASMDataTable
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent
import net.ndrei.teslacorelib.annotations.BaseAnnotationHandler
import net.ndrei.teslacorelib.annotations.IRegistryHandler
import net.ndrei.teslacorelib.annotations.RegistryHandler
import java.util.function.Function

@RegistryHandler
object SelfRenderingBlocksRegistry : IRegistryHandler, ICustomModelLoader {
    private lateinit var blocks: List<ISelfRenderingBlock>
    private val models = mutableMapOf<String, IModel>()

    override fun preInit(asm: ASMDataTable) {
        MinecraftForge.EVENT_BUS.register(this)
        ModelLoaderRegistry.registerLoader(this)

        val blocks = mutableListOf<ISelfRenderingBlock>()
        object: BaseAnnotationHandler<ISelfRenderingBlock>({ it, _, _ ->
            blocks.add(it)
        }, SelfRenderingBlock::class) {}.process(asm, Loader.instance().activeModContainer())
        this.blocks = blocks.toList()
    }

    override fun loadModel(modelLocation: ResourceLocation?): IModel {
        // TODO: maybe throw an error if the location is not accepted?
        val block = this.blocks.first { it.getRegistryName() == modelLocation }
        return this.models.getOrPut(modelLocation.toString()) {
            if (modelLocation is ModelResourceLocation) {
                if (modelLocation.variant == "inventory") {
                    return SelfRenderingInventoryModel(block)
                }
                return SelfRenderingModel(block)
            }
            else return SelfRenderingInventoryModel(block)
        }
    }

    override fun accepts(modelLocation: ResourceLocation?): Boolean {
        val rl = modelLocation ?: return false
        return this.blocks.any { it.getRegistryName() == rl }
    }

    override fun onResourceManagerReload(resourceManager: IResourceManager?) {
        // TODO: rebake all the thing!
    }

    @SubscribeEvent
    fun stitchEvent(ev: TextureStitchEvent) {
        val stuff = mutableListOf<String>()
        if (ev.map == Minecraft.getMinecraft().textureMapBlocks) {
            // ev.map.registerSprite(Textures.MULTI_TANK_SIDE.resource)
            this.blocks.forEach {
                it.getTextures().forEach {
                    if (!stuff.contains(it.toString())) {
                        // try to avoid double registering same resource
                        ev.map.registerSprite(it)
                        stuff.add(it.toString())
                    }
                }
            }
        }
        // TODO: rebake all the thing!... maybe?... I don't know...
    }

    class SelfRenderingModel(val block: ISelfRenderingBlock): IModel {
        override fun bake(state: IModelState, format: VertexFormat, bakedTextureGetter: Function<ResourceLocation, TextureAtlasSprite>): IBakedModel {
            return SelfRenderingBakedModel(this.block, format)
        }
    }

    class SelfRenderingInventoryModel(val block: ISelfRenderingBlock): IModel {
        override fun bake(state: IModelState, format: VertexFormat, bakedTextureGetter: Function<ResourceLocation, TextureAtlasSprite>): IBakedModel {
            return SelfRenderingInventoryBakedModel(this.block, format)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
subprojects { project ->
            options.compilerArgs << '-Xlint:unchecked' << '-Xlint:deprecation'
        }
    }

    // We generate a combined javadoc, no need to create javadocs for each library independently.
    if (!project.name.equals('glide')) {
        tasks.withType(Javadoc).all { enabled = false }
    }
}

task wrapper(type: Wrapper) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import android.app.Dialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.graphics.Color;
import android.graphics.drawable.ColorDrawable;
import android.net.Uri;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;
import android.text.TextUtils;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
 */
public class MaoniActivity extends AppCompatActivity {

    public static final String APPLICATION_INFO_VERSION_CODE = "APPLICATION_INFO_VERSION_CODE";
    public static final String APPLICATION_INFO_VERSION_NAME = "APPLICATION_INFO_VERSION_NAME";
    public static final String APPLICATION_INFO_PACKAGE_NAME = "APPLICATION_INFO_PACKAGE_NAME";
private void validateAndSubmitForm() {

            if (intent.hasExtra(FILE_PROVIDER_AUTHORITY)) {
                final String fileProviderAuthority = intent.getStringExtra(FILE_PROVIDER_AUTHORITY);
                if (mScreenshotFilePath != null) {
                    screenshotFile = new File(mScreenshotFilePath.toString());
                    screenshotUri = FileProvider
                            .getUriForFile(this, fileProviderAuthority, screenshotFile);
                    grantUriPermission(intent.getComponent().getPackageName(),
                            screenshotUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
                }
                if (logsFile != null) {
                    logsUri = FileProvider
                            .getUriForFile(this, fileProviderAuthority, logsFile);
                    grantUriPermission(intent.getComponent().getPackageName(),
                            logsUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
                }
            }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import android.content.res.Configuration;
import android.net.Uri;
import android.os.Bundle;
import android.support.v4.app.LoaderManager;
import android.support.v4.content.Loader;
import android.view.ContextMenu;
private void refreshTrackable() {
        // Initialize the UI
        init();

        createDisposables.add(AndroidRxUtils.bindActivity(this, ConnectorFactory.loadTrackable(geocode, null, null, brand)).subscribe(new Consumer<Trackable>() {
            @Override
            public void accept(final Trackable newTrackable) {
                if (trackingCode != null) {
public void accept(final Trackable newTrackable) {
        }, new Consumer<Throwable>() {
            @Override
            public void accept(final Throwable throwable) throws Exception {
                Log.e("refreshTrackable", throwable);
            }
        }, new Action() {
            @Override
            public void run() throws Exception {
                startLoader(null);
            }
        }));
    }

    private void startLoader(final Trackable newTrackable) {
        trackable = newTrackable;
        // Start loading in background
        getSupportLoaderManager().initLoader(connector.getTrackableLoggingManagerLoaderId(), null, LogTrackableActivity.this).forceLoad();
        displayTrackable();
    }

    private void displayTrackable() {
        if (trackable == null) {
            Log.e("LogTrackableActivity.onCreate, cannot load trackable: " + geocode);
            showProgress(false);

            if (StringUtils.isNotBlank(geocode)) {
                showToast(res.getString(R.string.err_tb_find) + ' ' + geocode + '.');
            } else {
                showToast(res.getString(R.string.err_tb_find_that));
            }

            setResult(RESULT_CANCELED);
            finish();
            return;
        }

        // We're in LogTrackableActivity, so trackable must be loggable ;)
        if (!trackable.isLoggable()) {
            showProgress(false);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import org.junit.runner.manipulation.Sortable;
import org.junit.runner.manipulation.Sorter;

public class JUnit4TestAdapter implements Test, Filterable, Sortable, Describable {
    private final Class<?> fNewTestClass;

public class AllDefaultPossibilitiesBuilder extends RunnerBuilder {
    private final boolean canUseSuiteMethod;

    public AllDefaultPossibilitiesBuilder(boolean canUseSuiteMethod) {
        this.canUseSuiteMethod = canUseSuiteMethod;
    }
package org.junit.internal.requests;

import org.junit.internal.builders.AllDefaultPossibilitiesBuilder;
import org.junit.runner.Request;
import org.junit.runner.Runner;

public class ClassRequest extends Request {
    private final Object runnerLock = new Object();
public Runner getRunner() {
        if (runner == null) {
            synchronized (runnerLock) {
                if (runner == null) {
                    runner = new AllDefaultPossibilitiesBuilder(canUseSuiteMethod).safeRunnerForClass(fTestClass);
                }
            }
        }
        return runner;
    }
}
public static Request classWithoutSuiteMethod(Class<?> clazz) {
     */
    public static Request classes(Computer computer, Class<?>... classes) {
        try {
            AllDefaultPossibilitiesBuilder builder = new AllDefaultPossibilitiesBuilder(true);
            Runner suite = computer.getSuite(builder, classes);
            return runner(suite);
        } catch (InitializationError e) {
public Suite(RunnerBuilder builder, Class<?>[] classes) throws InitializationErr
     * @param suiteClasses the classes in the suite
     */
    protected Suite(Class<?> klass, Class<?>[] suiteClasses) throws InitializationError {
        this(new AllDefaultPossibilitiesBuilder(true), klass, suiteClasses);
    }

    /**
        ForwardCompatibilityTest.class,
        InitializationErrorForwardCompatibilityTest.class,
        JUnit38ClassRunnerTest.class,
        OldTestClassAdaptingListenerTest.class,
        OldTests.class,
        SuiteMethodTest.class
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void init() {
    }

    public void destroy() {
        notification.hide();
        session.release();

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public FileDownloadTask saveFromFirebase(StorageReference storageReference,
        }
    }

    public void saveFromFirebase(StorageReference storageReference,
                                 final String fileLocation,
                                 final Runnable onSuccess,
                                 final Runnable onFailure,
                                 Activity activity) {
        // permission check
        boolean hasPermission = ContextCompat.checkSelfPermission(
                activity,
public void removeLocalPreset(String presetName) {
    public void removeLocalPreset(String presetName, Runnable onSuccess, Runnable onFailure) {
        if (fileHelper.deleteRecursive(new File(PROJECT_LOCATION_PRESETS + "/" + presetName))) {
            Log.d(TAG, "Successfully removed preset folder");
            onSuccess.run();
        } else {
            Log.d(TAG, "Failed to remove preset folder");
            onFailure.run();
        }
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public Dialog onCreateDialog(Bundle savedInstanceState)
        else
        {
            dialogCache.getTitleTextView().setText(getActivity().getResources().getString(R.string.product_name_new));
            Bitmap bitmap = BitmapFactory.decodeResource(getContext().getResources(), R.drawable.ic_menu_camera);
            dialogCache.getProductImage().setImageBitmap(bitmap);
            dialogCache.getProductCheckBox().setVisibility(View.GONE);
        }

        dialogCache.getButtonPlus().setOnClickListener(new View.OnClickListener()
        {
            int value;
            String newQuantity;

            @Override
            public void onClick(View view)
            {

                if ( !StringUtils.isEmpty(String.valueOf(dialogCache.getQuantity().getText())) )
                {
                    value = Integer.parseInt(String.valueOf(dialogCache.getQuantity().getText()));
                    value++;
                    newQuantity = String.valueOf(value);
                    dialogCache.getQuantity().setText(newQuantity);
                }
                else
public void onClick(View view)

        dialogCache.getButtonMinus().setOnClickListener(new View.OnClickListener()
        {
            int value;
            String newQuantity;

            @Override
            public void onClick(View view)
            {
                value = Integer.parseInt(String.valueOf(dialogCache.getQuantity().getText()));
                if ( value > 0 )
                {
                    value--;
                    newQuantity = String.valueOf(value);
                    dialogCache.getQuantity().setText(newQuantity);
                }
            }
        });
buildscript {
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:2.3.0'
        classpath 'me.tatarka:gradle-retrolambda:3.2.5'

        // NOTE: Do not place your application dependencies here; they belong
#Tue Mar 07 22:06:38 CET 2017
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
         id="io.sarl.examples.plugin"
         download-size="0"
         install-size="0"
         version="0.0.0"
         unpack="false"/>

</feature>
bin.includes = META-INF/,\
               about.ini,\
               about.mappings,\
               about.properties,\
               intro/
jre.compilation.profile = JavaSE-1.8
jars.compile.order = .
source.. = src/,\
           projects/
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void run() {
			return;

		if (!this.plugin.isAntiFlyCreative() && player.getGameMode() == GameMode.CREATIVE
				|| player.getGameMode() == GameMode.SPECTATOR)
			return;

		if (plugin.isChatMessage() && (plugin.isNotifyNotFlying() || !plugin.isNotifyNotFlying() && player.isFlying()))
public void onPlayerCommandPreprocessEvent(PlayerCommandPreprocessEvent event) {
			return;

		if (!this.plugin.isAntiFlyCreative() && event.getPlayer().getGameMode() == GameMode.CREATIVE
				|| event.getPlayer().getGameMode() == GameMode.SPECTATOR)
			return;

		String command = event.getMessage().toLowerCase();
public void onPlayerCommandPreprocessEvent(PlayerToggleFlightEvent event) {
			return;

		if (!this.plugin.isAntiFlyCreative() && event.getPlayer().getGameMode() == GameMode.CREATIVE
				|| event.getPlayer().getGameMode() == GameMode.SPECTATOR)
			return;

		Player player = event.getPlayer();
public void worldJoin(PlayerChangedWorldEvent event) {
			return;

		if (!this.plugin.isAntiFlyCreative() && event.getPlayer().getGameMode() == GameMode.CREATIVE
				|| event.getPlayer().getGameMode() == GameMode.SPECTATOR)
			return;

		for (String world : plugin.getAntiFlyWorlds()) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import org.molgenis.downloader.api.metadata.Entity;
import org.molgenis.downloader.api.metadata.MolgenisVersion;


public interface MolgenisClient extends AutoCloseable {

    void login(final String username, final String password);

    boolean logout();
    
import org.molgenis.downloader.api.metadata.MolgenisVersion;
import org.molgenis.downloader.util.ConsoleWriter;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
public MolgenisRestApiClient(final HttpClient client, final URI uri)
	}

	@Override
	public final void login(final String username, final String password)
	{
		final JSONObject login = new JSONObject();
		login.put("username", username);
		login.put("password", password);
public final void login(final String username, final String password)
		{
			writeToConsole("An error occurred while logging in:\n", ex);
		}
	}

	@Override
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public static String getPeer(Cursor cursor) {
        return cursor.getString(COLUMN_PEER);
    }

    public static boolean isGroup(Cursor cursor, int requiredMembership) {
        return cursor.getString(COLUMN_GROUP_JID) != null && cursor.getInt(COLUMN_GROUP_MEMBERSHIP) == requiredMembership;
    }

    public static void deleteFromCursor(Context context, Cursor cursor, boolean leaveGroup) {
        String groupJid = cursor.getString(COLUMN_GROUP_JID);
        String[] groupPeers = null;
public static CompositeMessage fromCursor(Context context, Cursor cursor) {
        return msg;
    }

    public static void deleteFromCursor(Context context, Cursor cursor) {
        MessagesProviderUtils.deleteMessage(context, cursor.getLong(COLUMN_ID));
    }
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;
private int getCheckedItemPosition() {
    }

    private void deleteSelectedMessages(final SparseBooleanArray checked) {
        new MaterialDialog.Builder(getActivity())
            .content(R.string.confirm_will_delete_messages)
            .positiveText(android.R.string.ok)
            .positiveColorRes(R.color.button_danger)
            .onPositive(new MaterialDialog.SingleButtonCallback() {
                @Override
                public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
                    Context ctx = getActivity();
                    for (int i = 0, c = getListView().getCount()+getListView().getHeaderViewsCount(); i < c; ++i) {
                        if (checked.get(i)) {
                            Cursor cursor = (Cursor) getListView().getItemAtPosition(i);
                            // skip group command messages
                            if (!GroupCommandComponent.isCursor(cursor))
                                CompositeMessage.deleteFromCursor(ctx, cursor);
                        }
                    }
                    mListAdapter.notifyDataSetChanged();
                }

package org.kontalk.ui;

import com.afollestad.materialdialogs.DialogAction;
import com.afollestad.materialdialogs.MaterialDialog;
import com.akalipetis.fragment.ActionModeListFragment;
public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
        return true;
    }

    private void deleteSelectedThreads(final SparseBooleanArray checked) {
        boolean addGroupCheckbox = false;
        int checkedCount = 0;
        for (int i = 0, c = mListAdapter.getCount(); i < c; ++i) {
            if (checked.get(i)) {
                checkedCount++;
                if (!addGroupCheckbox && Conversation.isGroup((Cursor) mListAdapter.getItem(i),
                        MyMessages.Groups.MEMBERSHIP_MEMBER)) {
                    addGroupCheckbox = true;
                }
            }
        }

public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which)
                    Context ctx = getContext();
                    boolean promptCheckBoxChecked = false;
                    if (hasGroupCheckbox) {
                        CheckBox promptCheckbox = (CheckBox) dialog.getCustomView().findViewById(R.id.promptCheckbox);
                        promptCheckBoxChecked = promptCheckbox.isChecked();
                    }

                    for (int i = 0, c = mListAdapter.getCount(); i < c; ++i) {
                        if (checked.get(i)) {
                            Cursor cursor = (Cursor) mListAdapter.getItem(i);
                            boolean hasLeftGroup = Conversation.isGroup(cursor, MyMessages.Groups.MEMBERSHIP_PARTED) ||
                                Conversation.isGroup(cursor, MyMessages.Groups.MEMBERSHIP_KICKED);
                            Conversation.deleteFromCursor(ctx, cursor,
                                hasGroupCheckbox ? promptCheckBoxChecked : hasLeftGroup);
                        }
                    }
                    mListAdapter.notifyDataSetChanged();
                }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public static boolean doDispense2(World par0World, ItemStack par1ItemStack, int
                meta--;
            }
            System.out.println("ERROR: "+par1ItemStack.getItemDamage()+","+(int)(par4)+","+(int)(par5)+","+(int)(par6)+","); 
        return (((ItemBlock)par1ItemStack.getItem()).placeBlockAt(par1ItemStack, Minecraft.getMinecraft().thePlayer, par0World, (int)(par4), (int)(par5), (int)(par6), meta, 0.5F, 0.5F, 0.5F,  par1ItemStack.getItemDamage()));
            
        }
        else
    IIcon side;
   
    
    public static final IRegistry dispenseBehaviorRegistry = new RegistryDefaulted(new BehaviorPlaceBlock());
    protected BlockPlacer()
    {
        super();
        //Block b = (Block)(this.blockRegistry.getObject("block_placer"));
        //Field[] f = b.getClass().getDeclaredFields();
        //for (Field field : f)
        //{
        	//System.out.println(field.getName());
        //}
        /*try
        {
        	
        
            Field name = this.getClass().getDeclaredField("blockMaterial");
            name.setAccessible(true);
            name.set(this, Material.piston);
        }
        catch (IllegalArgumentException e)
        {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        catch (IllegalAccessException e)
        {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        catch (SecurityException e)
        {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        catch (NoSuchFieldException e)
        {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }*/
    }
    public TileEntity createNewTileEntity(World p_149915_1_, int p_149915_2_)
    {
public void setupMobs()
    {
        /*Registering mobs*/
        VillagerRegistry.instance().registerVillagerId(8);
        VillagerRegistry.instance().registerVillagerSkin(8, new ResourceLocation("minecraft:textures/entity/villager/villager.png"));
        VillagerRegistry.instance().registerVillageTradeHandler(8, new QuestVillagerHandler());
        EntityRegistry.registerGlobalEntityID(EntityDragonfire.class, "Dragonfire", 80, 0x000000, 0x5555FF);
        EntityRegistry.addSpawn(EntityDragonfire.class, 8, 1, 2, EnumCreatureType.monster, BiomeGenBase.sky);
import java.util.Arrays;

import com.kpabr.EndPlus.CommonProxy;

import net.minecraft.block.Block;
import net.minecraft.block.material.Material;
    static EndRecipes recipes = new EndRecipes();
    static EndWorldgen worldgen = new EndWorldgen();
    static EndSpawners spawners = new EndSpawners();
    static EndRendering rendering = new EndRendering();
    static EndMobs mobs = new EndMobs();
    static EndVersionChecker versionChecker = new EndVersionChecker();
    public static EndPlus instance;
public void preInit(FMLPreInitializationEvent event)
        {
        worldgen.dimID = EndPlus.config.getInt("OverrideDimensionID", Configuration.CATEGORY_GENERAL, EndPlus.config.get(Configuration.CATEGORY_GENERAL, "OverrideDimensionID", 6).getInt(), 2, 255, "Used to help generate the End");
        }
        if(!config.hasKey(Configuration.CATEGORY_GENERAL, "AutoUpdate"))
        {
        EndPlus.config.getBoolean("AutoUpdate", Configuration.CATEGORY_GENERAL, true, "Sets whether the auto-upater will run");
        }
        EndPlus.config.save();
        
public void preInit(FMLPreInitializationEvent event)
     	recipes.setupSmelting();
     	recipes.setupEggs();
     	worldgen.setupWorldgen();
     	rendering.setupArmorRenderers();
     	spawners.setupSpawners();
     	mobs.setupMobs();
     	proxy.registerRenderers();
     	VillagerRegistry.instance().getRegisteredVillagers(); //Does nothing at this time, to be used for quest villager   
    }
    
    @EventHandler
package com.kpabr.EndPlus;

import cpw.mods.fml.client.registry.ISimpleBlockRenderingHandler;
import net.minecraft.block.Block;
import net.minecraft.block.BlockRedstoneWire;
import net.minecraft.client.renderer.RenderBlocks;

public class EndRenderHandler extends RenderBlocks implements ISimpleBlockRenderingHandler{
 // JAVADOC METHOD $$ func_147788_h

    public boolean renderBlockEnderRedstone(IBlockAccess world, Block p_147788_1_, int p_147788_2_, int p_147788_3_, int p_147788_4_)
    {
        Tessellator tessellator = Tessellator.instance;
package com.kpabr.EndPlus;

import cpw.mods.fml.client.registry.RenderingRegistry;

public class EndRendering {
    public void setupArmorRenderers()
    {
        /*Setting up armor renderers*/
package com.kpabr.EndPlus;

import net.minecraft.client.renderer.texture.IIconRegister;
import net.minecraft.client.renderer.texture.TextureMap;
import net.minecraft.item.Item;
public ItemQuestCompass() {
	    //this.setUnlocalizedName("Creeperite");
		
	}
	public void registerIcons(IIconRegister iconRegister) {
        TextureMap map = (TextureMap)(iconRegister);
        map.setTextureEntry("endplus:questcompass", new TextureQuestCompass("endplus:questcompass"));
 * using Minecraft Forge 10.12.0.1022
 */
import com.kpabr.EndPlus.CommonProxy;
import com.kpabr.EndPlus.EndRenderHandler;
import com.kpabr.EndPlus.EntityDragonfire;
import com.kpabr.EndPlus.RenderDragonfire;

import cpw.mods.fml.client.registry.RenderingRegistry;
import net.minecraft.client.model.ModelBiped;
import net.minecraft.client.renderer.entity.RenderBiped;
import net.minecraftforge.client.MinecraftForgeClient;

public class ClientProxy extends CommonProxy {
public void registerRenderers()
                RenderingRegistry.registerEntityRenderingHandler(EntityDragonfire.class, new RenderDragonfire(new ModelBiped(), 0.5F));
//the 0.5F is the shadowsize
                RenderingRegistry.registerBlockHandler(500, erh);
        }
        
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public String toString()
	public static Class<?> forName(String className) throws ClassNotFoundException
	{
		className= className.replace("_", ".");
		
		Class<?> clazz= classesByName.get(className);
		if (clazz == null)
		{
public String toString()
					throw new ClassNotFoundException(jsClassName);

				String type= className.replaceAll("\\[", "");
				type = type.replaceAll(";", "");
				if (type.startsWith("L"))
					type= type.replaceFirst("L", "");

public String getName()

	public Class<? super T> getSuperclass()
	{
		try 
		{
			Logger.getLogger(AnnotationsAdder.class.getName()).log(Level.FINEST, "Cannot add type annotation");
			
			if (ScriptHelper.evalBoolean("this.$$$nativeClass___java_lang_Object.classname == 'java_lang_Object' ", this))
				return null;
			else
			{
				Boolean eval= ScriptHelper.evalBoolean("this.$$$nativeClass___java_lang_Object.superclass != undefined", this);
				if (eval) 
				{
					boolean javaClassExists= ScriptHelper.evalBoolean("this.$$$nativeClass___java_lang_Object.superclass.javaClass != undefined", this);
					
					if (!javaClassExists) 
					{
						String className = (String)ScriptHelper.eval("this.$$$nativeClass___java_lang_Object.superclass.classname", this);
						return (Class<? super T>) forName(className.replace("_", "."));
					} 
					else
						return (Class<? super T>) ScriptHelper.eval("this.$$$nativeClass___java_lang_Object.superclass.javaClass", this);
				} else 
				{
					return null;
				}
			}
		} 
		catch (Exception e) {
			throw new RuntimeException(e);
		}
	}
public String getName()
			ScriptHelper.put("signatures", signatures, this);
			ScriptHelper.eval("for (var e in this.$$$nativeClass___java_lang_Object.$$members) { if (typeof this.$$$nativeClass___java_lang_Object.$$members[e]  === 'function' && e.startsWith('$')) signatures.push(e); }", this);
			ScriptHelper.eval("for (var e in this.$$$nativeClass___java_lang_Object.prototype) { if (typeof this.$$$nativeClass___java_lang_Object.prototype[e]  === 'function' && e.startsWith('$')) signatures.push(e); }", this);
			signatures = (String[])ScriptHelper.eval("signatures", this);
			addMethods(signatures, Modifier.PUBLIC);
			signatures= new String[0];
			ScriptHelper.put("signatures", signatures, this);
			ScriptHelper.eval("for (var e in this.$$$nativeClass___java_lang_Object) { if (typeof this.$$$nativeClass___java_lang_Object[e]  === 'function' && e.startsWith('$')) signatures.push(e); }", this);
			signatures = (String[])ScriptHelper.eval("signatures", this);
			addMethods(signatures, Modifier.PUBLIC | Modifier.STATIC);
		}
		return declaredMethods.toArray(new Method[0]);
private static String argumentTypesToString(Class<?>[] argTypes)
		A annotation= (A) Proxy.newProxyInstance(null, new Class[] { annotationClass }, new AnnotationInvocationHandler(aClass, annotationClass, methodName, parameterIndex, fieldName));
		return annotation;
	}
	
	public static List<Annotation> getAnnotationsInternal(Class<?> aClass, String methodName, Integer parameterIndex, String fieldName)
	{
		final List<AnnotationEntryWithEntityType> annotationEntrysWithEntityType= AnnotationsHelper.getAnnotationsByClass(aClass);
		final List<Annotation> ret = new ArrayList<>();
		
		final String annotationKey= AnnotationInvocationHandler.getAnnotationKey(fieldName, parameterIndex, methodName, "");
		for (AnnotationEntryWithEntityType annotationEntryWithEntityType : annotationEntrysWithEntityType)
		{
			final AnnotationEntry annotationEntry = annotationEntryWithEntityType.getAnnotationEntry();
			if (annotationEntry.getAnnotationKey().startsWith(annotationKey) || (annotationKey == null && !annotationEntry.getAnnotationKey().contains("/")))
			{
				final Class<? extends Annotation> annotationClass = annotationEntryWithEntityType.getAnnotationType();
				final Annotation annotation= (Annotation) Proxy.newProxyInstance(null, new Class[] { annotationClass }, new AnnotationInvocationHandler(aClass, annotationClass, methodName, parameterIndex, fieldName));
				ret.add(annotation);
			}
public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass)
			ScriptHelper.put("signatures", signatures, this);
			ScriptHelper.eval("for (var e in this.$$$nativeClass___java_lang_Object.$$members) { if (e.startsWith('$$$') && e != '$$$$signatures'){ var b={}; b.e = e; signatures.push(b); }}", this);
			ScriptHelper.eval("for (var e in this.$$$nativeClass___java_lang_Object.prototype) { if (e.startsWith('$$$') && e != '$$$$signatures'){ var b={}; b.e = e; signatures.push(b); }}", this);
			ScriptHelper.eval("for (var e in this.$$$nativeClass___java_lang_Object) { if (e.startsWith('$$$') && e != '$$$$signatures'){ var b={}; b.e = e; signatures.push(b); }}", this);
			addFields(signatures, Modifier.PUBLIC);
//			signatures= new String[0];
//			ScriptHelper.eval("for (var e in this.$$$nativeClass___java_lang_Object) { if (e.startsWith('$$$')){ var b={}; b.e = e; signatures.push(b); }}", this);
//			addFields(signatures, Modifier.PUBLIC | Modifier.STATIC);
		}
		return declaredFields.toArray(new Field[0]);
	}

	private void addFields(Object[] signatures, int modifier)
	{
		for (int i= 0; i < signatures.length; i++) {
			ScriptHelper.put("sig", signatures[i], this);
			String signature = ScriptHelper.evalCasting("sig.e", String.class, this);
			
			declaredFields.add(new Field(this, signature, modifier));
		}
	}
public Object get(Object obj) throws IllegalAccessException, IllegalArgumentExce
	{
		ScriptHelper.put("obj", obj, this);
		ScriptHelper.put("sig", this.signature, this);

		Object result= ScriptHelper.eval("obj[sig]", this);
		return Method.adaptResult(result, getType());
	}

public void set(Object obj, Object value) throws IllegalAccessException, Illegal
		ScriptHelper.put("sig", this.signature, this);
		ScriptHelper.put("value", tmpArray[0], this);

		ScriptHelper.evalNoResult("obj[sig]= value", this);
	}

	public <T extends Annotation> T[] getAnnotationsByType(Class<T> annotationClass)
public void set(Object obj, Object value) throws IllegalAccessException, Illegal

	public Annotation[] getDeclaredAnnotations()
	{
		final List<Annotation> annotations = Class.getAnnotationsInternal(class1, null, null, getName());
		final Annotation[] ret = new Annotation[annotations.size()];
		annotations.toArray(ret);
		return ret;
	}
public short getShort(Object object) throws IllegalAccessException, IllegalArgum

	public int getModifiers()
	{
		return 0;
	}

	native String getSignature();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import squeek.veganoption.content.registry.DescriptionRegistry;
import squeek.veganoption.content.registry.PistonCraftingRegistry;
import squeek.veganoption.content.registry.RelationshipRegistry;
import squeek.veganoption.integration.IntegrationBase;
import squeek.veganoption.integration.IntegrationHandler;

public void create()

		FluidRegistry.addBucketForFluid(fluidPlantMilk);

		UniversalBucket bucket = ForgeModContainer.getInstance().universalBucket;
		bucketPlantMilk = new ItemStack(bucket);
		bucket.fill(bucketPlantMilk, new FluidStack(fluidPlantMilk, Fluid.BUCKET_VOLUME), true);
	}

	@Override
	public void oredict()
	{
		if (!IntegrationHandler.modExists(IntegrationBase.MODID_MINEFACTORY_RELOADED))
			OreDictionary.registerOre(ContentHelper.milkOreDict, new ItemStack(Items.MILK_BUCKET));

		OreDictionary.registerOre(ContentHelper.milkOreDict, bucketPlantMilk.copy());

		OreDictionary.registerOre(ContentHelper.plantMilkSourceOreDict, new ItemStack(Items.PUMPKIN_SEEDS));
	}

public void recipes()
	@Override
	public void finish()
	{
		RelationshipRegistry.addRelationship(bucketPlantMilk.copy(), new ItemStack(plantMilk));
		RelationshipRegistry.addRelationship(new ItemStack(plantMilk), bucketPlantMilk.copy());
	}

	@SideOnly(Side.CLIENT)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import android.net.NetworkInfo;
import android.os.Environment;
import android.preference.PreferenceManager;

import com.google.android.gms.analytics.GoogleAnalytics;
import com.google.android.gms.analytics.Tracker;
 */
public class Collect extends Application {

    static {
        PRNGFixes.apply();
    }

    // Storage paths
    public static final String ODK_ROOT = Environment.getExternalStorageDirectory()
            + File.separator + "odk";
    public static final String TMPDRAWFILE_PATH = CACHE_PATH + File.separator + "tmpDraw.jpg";
    public static final String TMPXML_PATH = CACHE_PATH + File.separator + "tmp.xml";
    public static final String LOG_PATH = ODK_ROOT + File.separator + "log";

    public static final String DEFAULT_FONTSIZE = "21";
    public static final String OFFLINE_LAYERS = ODK_ROOT + File.separator + "layers";

    // share all session cookies across all sessions...
    private CookieStore cookieStore = new BasicCookieStore();
    private ActivityLogger mActivityLogger;
    private FormController mFormController = null;
    private ExternalDataManager externalDataManager;

    private static Collect singleton = null;

    private Tracker mTracker;

    public static Collect getInstance() {
        return singleton;
    }

    public ActivityLogger getActivityLogger() {
        return mActivityLogger;
    }

    public FormController getFormController() {
        return mFormController;
    }

    public void setFormController(FormController controller) {
        mFormController = controller;
    }

    public ExternalDataManager getExternalDataManager() {
        return externalDataManager;
    }

    public void setExternalDataManager(ExternalDataManager externalDataManager) {
        this.externalDataManager = externalDataManager;
    }

    public static int getQuestionFontsize() {
        SharedPreferences settings = PreferenceManager.getDefaultSharedPreferences(Collect
                .getInstance());
public static int getQuestionFontsize() {
        return questionFontsize;
    }

    public String getVersionedAppName() {
        String versionName = "";
        try {
            versionName = getPackageManager()
                    .getPackageInfo(getPackageName(), 0)
                    .versionName;
            versionName = " " + versionName.replaceFirst("-", "\n");
        } catch (NameNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return getString(R.string.app_name) + versionName;
    }

    public boolean isNetworkAvailable() {
        ConnectivityManager manager = (ConnectivityManager) getInstance()
                .getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo currentNetworkInfo = manager.getActiveNetworkInfo();
        return currentNetworkInfo != null && currentNetworkInfo.isConnected();
    }

    /**
     * Creates required directories on the SDCard (or other external storage)
     *
public static boolean isODKTablesInstanceDataDirectory(File directory) {
        return false;
    }

    /**
     * Construct and return a session context with shared cookieStore and credsProvider so a user
     * does not have to re-enter login information.
public void onCreate() {

    /**
     * Gets the default {@link Tracker} for this {@link Application}.
     * @return tracker
     */
    synchronized public Tracker getDefaultTracker() {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void addFieldsForInheritance(List<FieldMeta> list) {
  public boolean hasPersistentFields() {
    
    for (FieldMeta fieldMeta : fields.values()) {
      if (fieldMeta.isPersistent()) {
        return true;
      }
    }

  static String oneStatic;
  
  @Transient
  String oneInstance;
  
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
>重写`onInitRefreshView()`和`onInitLoadMoreView()`方法设置视图。

* 刷新视图和加载更多视图背景色
>使用`setRefreshViewBackgroundResId(int refreshViewBackgroundResId)`方法设置刷新视图的背景色；加载更多视图背景色方法为`setLoadMoreViewBackgroundResId(int loadMoreViewBackgroundResId)`。

* 手指移动距离和刷新控件移动距离比值
>使用`setPullDistanceScale(float pullDistanceScale)` 方法设置，参数不对则抛出异常。默认比例值是`1.8f`。
### Gradle

```
compile 'com.netease.hearttouch:ht-refreshrecyclerview:1.0.0'
```

### Maven

``` 
<dependency>
  <groupId>com.netease.hearttouch</groupId>
  <artifactId>ht-refreshrecyclerview</artifactId>
  <version>1.0.0</version>
</dependency>
```

buildscript {
        jcenter()
    }
    dependencies {
        classpath "com.android.tools.build:gradle:${ANDROID_GRADLE_VERSION}"
        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
allprojects {

task clean(type: Delete) {
    delete rootProject.buildDir
}
org.gradle.daemon=true
org.gradle.configureondemand=true

SUPPORT_V4_VERSION=24.0.0
SUPPORT_V7_VERSION=24.0.0
RECYCLERVIEW_VERSION=24.0.0
JUNIT_VERSION=4.12

ANDROID_GRADLE_VERSION=2.1.2

VERSION_NAME=0.0.1-SNAPSHOT

COMPILE_SDK_VERSION=24
BUILD_TOOLS_VERSION=23.0.2
TARGET_SDK_VERSION=24
MIN_SDK_VERSION=14
#Mon Jul 11 10:39:42 CST 2016
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
apply plugin: 'com.android.library'

android {
    compileSdkVersion COMPILE_SDK_VERSION as int
    buildToolsVersion BUILD_TOOLS_VERSION as String
    defaultConfig {
        vectorDrawables.useSupportLibrary = true
        minSdkVersion MIN_SDK_VERSION as int
        targetSdkVersion TARGET_SDK_VERSION as int
        versionCode 1
        versionName VERSION_NAME as String
    }
    buildTypes {
        release {
android {

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    testCompile "junit:junit:${JUNIT_VERSION}"
    compile "com.android.support:appcompat-v7:${SUPPORT_V4_VERSION}"
    compile "com.android.support:recyclerview-v7:${RECYCLERVIEW_VERSION}"
}

import com.netease.hearttouch.htrefreshrecyclerview.HTRecyclerViewDragListener;
import com.netease.hearttouch.htrefreshrecyclerview.HTRefreshListener;
import com.netease.hearttouch.htrefreshrecyclerview.R;
import com.netease.hearttouch.htrefreshrecyclerview.viewimpl.HTDefaultHorizontalRefreshViewHolder;
import com.netease.hearttouch.htrefreshrecyclerview.viewimpl.HTDefaultVerticalRefreshViewHolder;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;

import static android.widget.LinearLayout.HORIZONTAL;
import static android.widget.LinearLayout.VERTICAL;
import static com.netease.hearttouch.htrefreshrecyclerview.base.HTOrientation.VERTICAL_DOWN;
import static com.netease.hearttouch.htrefreshrecyclerview.base.HTOrientation.VERTICAL_UP;

 */
public abstract class HTBaseRecyclerView extends ViewGroup implements HTRefreshRecyclerViewInterface {
    private static final String TAG = HTBaseRecyclerView.class.getSimpleName();
    /**
     * 设置全局的默认刷新加载样式
     */
    protected final int mTouchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop();

    private Paint mRefreshBgPaint;


    public HTBaseRecyclerView(Context context) {
private void initViews() {
            HTBaseViewHolder viewHolder;
            if (checkOrientationVertical()) {
                viewHolder = new HTDefaultVerticalRefreshViewHolder(getContext());
                ((HTDefaultVerticalRefreshViewHolder) viewHolder).setDefaultRefreshViewArrow(mHTOrientation);
            } else {
                viewHolder = new HTDefaultHorizontalRefreshViewHolder(getContext());
                ((HTDefaultHorizontalRefreshViewHolder) viewHolder).setDefaultRefreshViewArrow(mHTOrientation);
            }
            setRefreshViewHolder(viewHolder);//设置默认刷新样式
        }
private void initListeners() {
        setRecyclerViewOnScrollListener();
    }

    /**
     * 设置全局的刷新样式
     */
public static void setRefreshViewHolderClass(@NonNull Class<? extends HTBaseView
     * 设置刷新和加载更多的视图控件并初始化
     */
    public void setRefreshViewHolder(@NonNull HTBaseViewHolder refreshViewHolder) {
        mHTViewHolder = refreshViewHolder;
        mHTViewHolderTracker = mHTViewHolder.getViewHolderTracker();
        mHTViewHolderTracker.setOrientation(mHTOrientation);
        mHTViewHolder.computeViewSize(checkOrientationVertical() ? VERTICAL : HORIZONTAL);

        resetRefreshViewHolderView();
        initRefreshView();
        initLoadMoreView();
    }


    private void resetRefreshViewHolderView() {
        mRefreshContainerView.removeAllViews();
        mLoadMoreContainerView.removeAllViews();
    }


    private void initRefreshView() {
        if (mHTViewHolder == null) return;
        View refreshView = mHTViewHolder.getRefreshView();
        if (refreshView != null) {
            if (refreshView.getParent() != null) {
                ((ViewGroup) refreshView.getParent()).removeView(refreshView);
            }
            int res = mHTViewHolder.getRefreshViewBackgroundResId();
            if (res != 0) {//默认背景透明
                mRefreshContainerView.setBackgroundResource(res);
            } else {
                mRefreshContainerView.setBackgroundResource(android.R.color.transparent);
            }
            mRefreshContainerView.removeAllViews();
            setViewLayoutParams(refreshView);
            mRefreshContainerView.addView(refreshView);
//            hideRefreshView(true);
        }
        setRefreshUIChangeListener(mHTViewHolder);
    }

    private void initLoadMoreView() {
        if (mHTViewHolder == null) return;
        View loadMoreView = mHTViewHolder.getLoadMoreView();
        if (loadMoreView != null) {
            if (loadMoreView.getParent() != null) {
                ((ViewGroup) loadMoreView.getParent()).removeView(loadMoreView);
            }
            int res = mHTViewHolder.getLoadMoreViewBackgroundResId();
            if (res != 0) {//默认背景透明
                mLoadMoreContainerView.setBackgroundResource(res);
            } else {
                mLoadMoreContainerView.setBackgroundResource(android.R.color.transparent);
            }
            mLoadMoreContainerView.removeAllViews();
            setViewLayoutParams(loadMoreView);
            mLoadMoreContainerView.addView(loadMoreView);
            hideLoadMoreView(true);
        }
        setLoadMoreUIChangeListener(mHTViewHolder);
    }

    private void setViewLayoutParams(View view) {
private void setViewLayoutParams(View view) {
        view.setLayoutParams(lp);
    }

    protected boolean checkOrientationVertical() {
        return mHTOrientation == VERTICAL_UP || mHTOrientation == VERTICAL_DOWN;
    }

    protected boolean checkOrientationReverse() {
        return mHTOrientation == HTOrientation.HORIZONTAL_LEFT || mHTOrientation == VERTICAL_UP;
    }

protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        }
    }

    protected void onLayout(boolean changed, int l, int t, int r, int b) {
//        super.onLayout(changed, l, t, r, b);
        if (checkOrientationVertical()) {
public void hideLoadMoreView(boolean isHide) {
        if (mLoadMoreContainerView != null && mHTViewHolder != null) {
            int size = 0;
            if (isHide) {
                size = -mHTViewHolderTracker.getLoadMoreSize();
            }
            switch (mHTOrientation) {
                case VERTICAL_DOWN:
package com.netease.hearttouch.htrefreshrecyclerview.base;

import android.content.Context;
import android.view.View;
import android.view.ViewGroup;

import com.netease.hearttouch.htrefreshrecyclerview.utils.Utils;

import static android.R.attr.orientation;

/**
 * 刷新视图和加载更多视图的包裹基类,用户需要继承该类完成自定义视图样式
 */
public abstract class HTBaseViewHolder implements HTBaseRecyclerView.HTLoadMoreUIChangeListener, HTBaseRecyclerView.HTRefreshUIChangeListener {

    private static final int DEFAULT_ANIMATION_TIME = 500;
    private static final int DEFAULT_VIEW_SIZE = 50;

    protected Context mContext;
    /**
     * 加载更多视图对象
     */
    protected View mLoadMoreView;
    /**
     * 刷新视图的背景色
     */
    private int mRefreshViewBackgroundResId = 0;
    /**
     * 加载更多视图的背景色
     */
    private int mLoadMoreViewBackgroundResId = 0;
    /**
     * 动画时间，默认500ms
     */
    private int mAnimationTime = DEFAULT_ANIMATION_TIME;

    private HTViewHolderTracker mViewHolderTracker;

    private int mOrientation = 1;

    public HTBaseViewHolder(Context context) {
        mContext = context;
        mRefreshView = onInitRefreshView();
        mLoadMoreView = onInitLoadMoreView();
        mViewHolderTracker = new HTViewHolderTracker();
    }

    /**
     * 设置加载更多视图的背景色
     *
     * @param loadMoreViewBackgroundResId 背景色资源Id
     */
    public void setLoadMoreViewBackgroundResId(int loadMoreViewBackgroundResId) {
        if (loadMoreViewBackgroundResId > 0) {
            this.mLoadMoreViewBackgroundResId = loadMoreViewBackgroundResId;
            if (mLoadMoreView != null) {
                ViewGroup container = (ViewGroup) mLoadMoreView.getParent();
                if (container != null) {
                    container.setBackgroundResource(loadMoreViewBackgroundResId);
                }
            }
        }
    }

    protected void updateViewSize() {
        computeViewSize(orientation);
    }

    /**
     *  计算刷新视图和加载更多视图在刷新方向上的尺寸
     * @param orientation
     */
    protected void computeViewSize(int orientation) {
        mOrientation = orientation;
        int refreshSize = mRefreshView == null ? 0 : Utils.getItemViewSize(orientation, mRefreshView);
        int loadMoreSize = mRefreshView == null ? 0 : Utils.getItemViewSize(orientation, mLoadMoreView);
        mViewHolderTracker.setRefreshViewSize(refreshSize == 0 ? DEFAULT_VIEW_SIZE : refreshSize);
        mViewHolderTracker.setLoadMoreSize(loadMoreSize == 0 ? DEFAULT_VIEW_SIZE : loadMoreSize);
    }


protected void computeViewSize(int orientation) {
     *
     * @param refreshViewBackgroundResId 背景色资源Id
     */
    public void setRefreshViewBackgroundResId(int refreshViewBackgroundResId) {
        if (refreshViewBackgroundResId > 0) {
            mRefreshViewBackgroundResId = refreshViewBackgroundResId;
            if (mRefreshView != null) {
                ViewGroup container = (ViewGroup) mRefreshView.getParent();
                if (container != null) {
                    container.setBackgroundResource(refreshViewBackgroundResId);
                }
            }
        }
    }


    public HTViewHolderTracker getViewHolderTracker() {
        return mViewHolderTracker;
    }


    /**
     * 设置刷新和加载更多相关动画的执行时间
public void setSpringDistanceScale(float springDistanceScale) {
    }

    /**
     * 自定义的刷新视图
     */
    public abstract View onInitRefreshView();

    /**
     * 自定义的加载更多视图
     */
    public abstract View onInitLoadMoreView();

    public final int getAnimationTime() {
        return mAnimationTime;
    }

    public final int getLoadMoreViewBackgroundResId() {
        return mLoadMoreViewBackgroundResId;
    }

    public final int getRefreshViewBackgroundResId() {
        return mRefreshViewBackgroundResId;
    }
public final View getRefreshView() {
    public final View getLoadMoreView() {
        return mLoadMoreView;
    }

}
    private float mOffsetX;
    private float mOffsetY;
    private int mRefreshViewSize;
    private int mLoadMoreSize;
    /**刷新视图移动上一次的位置*/
    private int mLastPos = 0;
    /**刷新视图移动当前的位置*/
public boolean isIdlePosition() {
        return mCurrentPos == POSITION_IDLE;
    }

    public int getLoadMoreSize() {
        return mLoadMoreSize;
    }

    public void setLoadMoreSize(int loadMoreSize) {
        mLoadMoreSize = loadMoreSize;
    }

    public boolean hasLeftIdlePosition() {
        return mCurrentPos > POSITION_IDLE;
    }
    protected boolean mAutoRefresh;

    public HTBaseRecyclerViewImpl(Context context) {
        this(context, null);
    }

    public HTBaseRecyclerViewImpl(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public HTBaseRecyclerViewImpl(Context context, AttributeSet attrs, int defStyleAttr) {
public boolean shouldHandleLoadMore() {
                postDelayed(new Runnable() {
                    @Override
                    public void run() {
                        changeLoadMoreViewPositionWithAnimation(-mHTViewHolderTracker.getLoadMoreSize(), null);
                    }
                }, mHTViewHolder.getAnimationTime());
            }
protected void updatePos(float offset) {
                (mHTViewHolderTracker.isOverCompletePos() && mRefreshStatus == RefreshStatus.COMPLETE)*/) {
            mRefreshStatus = RefreshStatus.REFRESH_PREPARE;
            mRefreshUIChangeListener.onRefreshPrepare();
            if(mRecyclerViewDragListener!=null){
                mRecyclerViewDragListener.onRefreshViewPrepareToMove();
            }
        }
protected void endLoadMore() {
            if (mLoadMoreViewDisplay) {//一直显示没有更多提示
                if (mScreenFilled) {
                    if (mHasMore) {//还有更多数据的时候,满一屏动画隐藏,否则直接隐藏
                        changeLoadMoreViewPositionWithAnimation(-mHTViewHolderTracker.getLoadMoreSize(), null);
                    } else {
                        hideLoadMoreView(false);
                    }
protected void endLoadMore() {
                }
            } else {
                if (mScreenFilled) {
                    changeLoadMoreViewPositionWithAnimation(-mHTViewHolderTracker.getLoadMoreSize(), null);
                } else {
                    hideLoadMoreView(true);
                }
public void setRefreshCompleted(boolean hasMore) {

    @Override
    public void startAutoRefresh() {
        if (mRecyclerView != null && mHTViewHolder != null && mHTViewHolder.getRefreshView() != null) {
            if (mRefreshStatus != RefreshStatus.IDLE || mLoadMoreStatus != LoadMoreStatus.IDLE || mRefreshDelegate == null) {
                return;
            }
public void startAutoRefresh() {
                if (mRefreshUIChangeListener != null) {
                    mRefreshUIChangeListener.onRefreshPrepare();
                }
                if(mRecyclerViewDragListener!=null){
                    mRecyclerViewDragListener.onRefreshViewPrepareToMove();
                }
                mScrollJob.tryToScrollTo(mHTViewHolderTracker.getOffsetToRefresh(), mHTViewHolder.getAnimationTime());
protected void changeLoadMoreViewPositionWithAnimation(int targetPosition, @Null
                startValue = mLoadMoreContainerView.getPaddingRight();
                break;
        }
        if (startValue <= -mHTViewHolderTracker.getLoadMoreSize()) return;
        mLoadMoreAnimator = ValueAnimator.ofInt(startValue, targetPosition);
        mLoadMoreAnimator.setDuration(mHTViewHolder.getAnimationTime());
        mLoadMoreAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

import android.content.Context;
import android.view.View;
import android.view.animation.Animation;
import android.view.animation.RotateAnimation;
import android.widget.ImageView;
import com.netease.hearttouch.htrefreshrecyclerview.R;
import com.netease.hearttouch.htrefreshrecyclerview.base.HTBaseRecyclerView;
import com.netease.hearttouch.htrefreshrecyclerview.base.HTBaseViewHolder;
import com.netease.hearttouch.htrefreshrecyclerview.base.HTOrientation;
import com.netease.hearttouch.htrefreshrecyclerview.base.HTViewHolderTracker;

/**
private void initAnimation() {
        mRightAnim.setFillAfter(true);
    }

    @Override
    public View onInitRefreshView() {
        View refreshView = View.inflate(mContext, R.layout.ht_view_horizontal_refresh_default, null);
        mTvRefreshStatus = (TextView) refreshView.findViewById(R.id.tv_refresh_status);
        mIvRefreshArrow = (ImageView) refreshView.findViewById(R.id.iv_refresh_arrow);
        mRefreshProgressBar = (ProgressBar) refreshView.findViewById(R.id.pb_loading);
        return refreshView;
    }

    @Override
    public View onInitLoadMoreView() {
        View loadMoreView = View.inflate(mContext, R.layout.ht_view_horizontal_load_more_default, null);
        mVLoadMore = loadMoreView.findViewById(R.id.liner_loading);
        mVNoMore = loadMoreView.findViewById(R.id.tv_no_more);
        return loadMoreView;
    }

public void onRefreshPositionChange(float scale, float moveDistance, int refresh
        }
    }

    public void setDefaultRefreshViewArrow(int orientation) {
        if (mIvRefreshArrow == null) return;
        switch (orientation) {
            case HTOrientation.HORIZONTAL_LEFT:
                mIvRefreshArrow.setImageResource(R.drawable.ht_left_arrow_default);
                break;
            case HTOrientation.HORIZONTAL_RIGHT:
            default:
                mIvRefreshArrow.setImageResource(R.drawable.ht_right_arrow_default);
                break;
        }
    }
}

import android.content.Context;
import android.view.View;
import android.view.animation.Animation;
import android.view.animation.RotateAnimation;
import android.widget.ImageView;
import com.netease.hearttouch.htrefreshrecyclerview.R;
import com.netease.hearttouch.htrefreshrecyclerview.base.HTBaseRecyclerView;
import com.netease.hearttouch.htrefreshrecyclerview.base.HTBaseViewHolder;
import com.netease.hearttouch.htrefreshrecyclerview.base.HTOrientation;
import com.netease.hearttouch.htrefreshrecyclerview.base.HTViewHolderTracker;

/**
private void initAnimation() {
    }

    @Override
    public View onInitRefreshView() {
        View refreshView = View.inflate(mContext, R.layout.ht_view_vertical_refresh_default, null);
        mTvRefreshStatus = (TextView) refreshView.findViewById(R.id.tv_refresh_status);
        mIvRefreshArrow = (ImageView) refreshView.findViewById(R.id.iv_refresh_arrow);
        mRefreshProgressBar = (ProgressBar) refreshView.findViewById(R.id.pb_loading);
        return refreshView;
    }

    @Override
    public View onInitLoadMoreView() {
        View loadMoreView = View.inflate(mContext, R.layout.ht_view_vertical_load_more_default, null);
        mVLoadMore = loadMoreView.findViewById(R.id.liner_loading);
        mVNoMore = loadMoreView.findViewById(R.id.tv_no_more);
        return loadMoreView;
    }

public void onRefreshPositionChange(float scale, float moveDistance, int refresh
        }
    }

    public void setDefaultRefreshViewArrow(int orientation) {
        if (mIvRefreshArrow == null) return;
        switch (orientation) {
            case HTOrientation.VERTICAL_UP:
                mIvRefreshArrow.setImageResource(R.drawable.ht_up_arrow_default);
                break;
            case HTOrientation.VERTICAL_DOWN:
            default:
                mIvRefreshArrow.setImageResource(R.mipmap.refresh_down_arrow_default);
                break;
        }
    }
}
  * LICENSE file in the root directory of this source tree.
  -->
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="@dimen/default_height"
              android:layout_height="match_parent"
              android:gravity="center"
              android:orientation="vertical"
              android:paddingLeft="@dimen/default_padding"
              android:paddingRight="@dimen/default_padding">

    <FrameLayout
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginBottom="@dimen/default_space"
        android:layout_above="@+id/tv_refresh_status">

        <ImageView
            android:id="@+id/iv_refresh_arrow"
            android:layout_width="@dimen/default_arrow_width"
            android:layout_height="@dimen/default_arrow_height"
            android:layout_gravity="center"/>

        <ProgressBar
            android:id="@+id/pb_loading"
            style="?android:attr/progressBarStyle"
            android:layout_width="@dimen/default_arrow_width"
            android:layout_height="@dimen/default_arrow_height"
            android:visibility="gone"
            android:indeterminateDrawable="@drawable/ht_refresh_loading_default"
            />
    </FrameLayout>


    <TextView
        android:id="@+id/tv_refresh_status"
        android:layout_width="@dimen/default_text_line_height"
        android:layout_height="wrap_content"
        android:gravity="center_horizontal"
        android:text="@string/pull_to_refresh"
        android:textColor="#777"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:paddingLeft="@dimen/default_space"
        android:layout_toLeftOf="@+id/tv_refresh_status"
        android:layout_toStartOf="@+id/tv_refresh_status">

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
dependencies {
    compile 'com.vistrav:ask:2.4'
    compile 'com.android.support:support-v4:25.0.1'
    compile 'com.google.android.gms:play-services-maps:9.0.2'
    compile 'com.google.android.gms:play-services-ads:9.0.2'
    compile 'com.facebook.android:facebook-android-sdk:4.+'
    compile 'com.android.support:design:25.0.1'
    compile 'com.android.support:appcompat-v7:25.0.1'
import android.widget.TabHost.TabSpec;
import android.widget.Toast;

import com.google.android.gms.ads.AdView;
import com.paypal.android.MEP.PayPal;
import com.vistrav.ask.Ask;

    public static BottomNavigationView mBottomNav;
    public static boolean check_donwload = false;
    public static boolean check_donwload_local_gallery = false;
    public static AdView ad;
    public static int flashStatus = 2;

    //Gallery
public void run() {
        Display display = getWindowManager().getDefaultDisplay();
        width = display.getWidth() / 3;
        height = width;
        /*
         * Google admod
         */
        //ad = (AdView) findViewById(R.id.adView);
        SharedPreferences setting = getSharedPreferences(PREFS_NAME, 0);
        FEEDS_GOOGLE_ADMOB = setting.getBoolean("Google Admob", true);
        File file = getBaseContext().getFileStreamPath("google_admob.txt");
        if (file.exists()) {
            try {
                FileInputStream Rfile = openFileInput("google_admob.txt");

                InputStreamReader einputreader = new InputStreamReader(Rfile);
                BufferedReader ebuffreader = new BufferedReader(einputreader);
                Boolean tmp = Boolean.valueOf(ebuffreader.readLine());
                PhimpMe.FEEDS_GOOGLE_ADMOB = tmp;
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        Log.i("PhimpMe", "feed_google_admob : " + FEEDS_GOOGLE_ADMOB);
//        AdView adView = (AdView) this.findViewById(R.id.adView);
//
//        AdRequest request = new AdRequest.Builder()       // All emulators
//                .addTestDevice("AC98C820A50B4AD8A2106EDE96FB87D4")  // An example device ID
//                .build();
//        adView.loadAd(request);
//        if (FEEDS_GOOGLE_ADMOB == false) {
//            adView.setVisibility(ViewGroup.GONE);
//            //adView.destroy();
//        }

    	        /*
    	         * user config
    	         */

        File file0 = getBaseContext().getFileStreamPath("local_gallery.txt");
        if (file0.exists()) {
public static void hideTabs() {
//        mBottomNav.setVisibility(ViewGroup.GONE);
    }

//    public static void ShowAd() {
//        ad.setVisibility(ViewGroup.VISIBLE);
//    }

    public static void hideAd() {
        ad.setVisibility(ViewGroup.GONE);
    }

    @Override
    protected void onPause() {
public void onResume() {
        super.onResume();
        PhimpMe.showTabs();

        if (PhimpMe.FEEDS_GOOGLE_ADMOB == true) {
            //PhimpMe.ShowAd();
        }
        if (PhimpMe.add_account_upload) {
            reloadAccountsList();
            PhimpMe.add_account_upload = false;
public void onResume()
        }
        else {
          PhimpMe.showTabs();	
		
          if (PhimpMe.FEEDS_GOOGLE_ADMOB == true){
            //PhimpMe.ShowAd();
          }
		
          if (PhimpMe.IdList.size() == 5) {
            PhimpMe.IdList.clear();
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:ads="http://schemas.android.com/apk/lib/com.google.ads"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent">
    <TabHost xmlns:android="http://schemas.android.com/apk/res/android"
        android:id="@android:id/tabhost"
        android:layout_above="@+id/adView"
        android:layout_width="fill_parent"
        android:layout_height="fill_parent">
        <LinearLayout android:orientation="vertical"
        </LinearLayout>
    </TabHost>

    <com.google.ads.AdView
        android:id="@+id/adView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:layout_centerHorizontal="true"
        ads:adSize="SMART_BANNER"
        ads:adUnitId="@string/admob_id"
        ads:loadAdOnCreate="true"
        ads:testDevices="TEST_EMULATOR" />

</RelativeLayout>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:ads="http://schemas.android.com/apk/lib/com.google.ads"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent">
    <TabHost xmlns:android="http://schemas.android.com/apk/res/android"
        android:id="@android:id/tabhost"
        android:layout_above="@+id/adView"
        android:layout_width="fill_parent"
        android:layout_height="fill_parent">

        </LinearLayout>

    </TabHost>
    <com.google.ads.AdView
        android:id="@+id/adView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:layout_centerHorizontal="true"
        ads:adSize="SMART_BANNER"
        ads:adUnitId="@string/admob_id"
        ads:loadAdOnCreate="true"
        ads:testDevices="TEST_EMULATOR" />

</RelativeLayout>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:ads="http://schemas.android.com/apk/lib/com.google.ads"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent">
    <TabHost xmlns:android="http://schemas.android.com/apk/res/android"
        android:id="@android:id/tabhost"
        android:layout_above="@+id/adView"
        android:layout_width="fill_parent"
        android:layout_height="fill_parent">

        </LinearLayout>

    </TabHost>
    <com.google.ads.AdView
        android:id="@+id/adView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:layout_centerHorizontal="true"
        ads:adSize="SMART_BANNER"
        ads:adUnitId="@string/admob_id"
        ads:loadAdOnCreate="true"
        ads:testDevices="TEST_EMULATOR" />

</RelativeLayout>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:ads="http://schemas.android.com/apk/lib/com.google.ads"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent">
    <TabHost xmlns:android="http://schemas.android.com/apk/res/android"
        android:id="@android:id/tabhost"
        android:layout_above="@+id/adView"
        android:layout_width="fill_parent"
        android:layout_height="fill_parent">

        </LinearLayout>

    </TabHost>
    <com.google.ads.AdView
        android:id="@+id/adView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:layout_centerHorizontal="true"
        ads:adSize="SMART_BANNER"
        ads:adUnitId="@string/admob_id"
        ads:loadAdOnCreate="true"
        ads:testDevices="TEST_EMULATOR" />

</RelativeLayout>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:ads="http://schemas.android.com/apk/lib/com.google.ads"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:orientation="vertical"
    android:layout_width="fill_parent"

</RelativeLayout>


    <!--<com.google.ads.AdView-->
    <!--android:id="@+id/adView"-->
    <!--android:layout_width="wrap_content"-->
    <!--android:layout_height="wrap_content"-->
    <!--android:layout_alignParentBottom="true"-->
    <!--android:layout_centerHorizontal="true"-->
    <!--ads:adSize="SMART_BANNER"-->
    <!--ads:adUnitId="@string/admob_id"-->
    <!--ads:loadAdOnCreate="true"-->
    <!--ads:testDevices="TEST_EMULATOR" />-->
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void setPlaceGuess(String placeGuess) {
        if ((placeGuess != null) && (placeGuess.length() > 0)) {
            mLocationGuess.setText(placeGuess);
            mLocationGuess.setTextColor(Color.parseColor("#000000"));
            if (mObservation.geoprivacy.equals("private") || mObservation.geoprivacy.equals("obscured")) {
                mObservation.private_place_guess = placeGuess;
                mObservation.place_guess = null;
            } else {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void onReceive(Context context, Intent intent) {
                resultsJSON = (SerializableJSONArray) intent.getSerializableExtra(INaturalistService.RESULTS);
            }

            JSONArray results = resultsJSON.getJSONArray();
            ArrayList<JSONObject> resultsArray = new ArrayList<JSONObject>();

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void auditProcedureRecord(AuditLogger auditLogger, SpoolFileReader reade
    void spoolProvideAndRegister(ExportContext ctx) {
        LinkedHashSet<Object> obj = new LinkedHashSet<>();
        Attributes xdsiManifest = ctx.getXDSiManifest();
        URI dest = ctx.getExporter().getExporterDescriptor().getExportURI();
        String schemeSpecificPart = dest.getSchemeSpecificPart();
        String calledHost = schemeSpecificPart.substring(schemeSpecificPart.indexOf("://")+3, schemeSpecificPart.lastIndexOf(":"));
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.util.HashMap;
import java.util.List;
import java.util.Random;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.md_5.bungee.api.chat.BaseComponent;
public void performActions( ChatEvent event, ProxiedPlayer player ) {
                Matcher m = getMatcher( message );
                StringBuilder sb = new StringBuilder();
                int last = 0;
                while ( m.find() ) {
                        int n = rand.nextInt( ((String[]) actions.get( action )).length );
                        sb.append( message.substring( last, m.start() ) );
                        sb.append( util.ParseVariables(((String[]) actions.get( action ))[n], event) );
                        last = m.end();
                }
                sb.append( message.substring( last ) );
                message = sb.toString();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void buildEnrichmentMap() {
				new EMCreationParameters(prefix, pvalue, qvalue, NESFilter.ALL, Optional.empty(), 
						metric, similaritycutoff, propertyManager.getDefaultCombinedConstant());
		
		
		CreateEnrichmentMapTaskFactory taskFactory = taskFactoryFactory.create(creationParams, dataSets);
		insertTasksAfterCurrentTask(taskFactory.createTaskIterator());
public boolean initializeSets(TaskMonitor tm) {
					updateRankAtMax((GSEAResult)result, ranks);
				}
				
				GeneSet geneset = genesets.get(genesetName);
				if(geneset != null) {
					// while we are checking, update the size of the genesets based on post filtered data
					result.setGsSize(geneset.getGenes().size());
					
					if(result.geneSetOfInterest(map.getParams())) {
						if(occurrences != null) {
							occurrences.merge(genesetName, 1, (v,d) -> v + 1);
						}
						genesetsOfInterest.put(genesetName, geneset);
					}
				}
				else if(throwIfMissing) { // TEMPORARY
					throw new IllegalThreadStateException("The Geneset: " + genesetName + " is not found in the GMT file.");
				}
			}
		}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
package org.jboss.reddeer.eclipse.ui.problems;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

import org.jboss.reddeer.common.wait.TimePeriod;
import org.jboss.reddeer.common.wait.WaitUntil;
import org.jboss.reddeer.common.wait.WaitWhile;
import org.jboss.reddeer.core.condition.ShellWithTextIsAvailable;
import org.jboss.reddeer.eclipse.condition.AbstractExtendedMarkersViewIsUpdating;
import org.jboss.reddeer.eclipse.exception.EclipseLayerException;
import org.jboss.reddeer.eclipse.ui.problems.matcher.AbstractProblemMatcher;
public ProblemsView() {
	 */
	private List<TreeItem> filterProblemType(List<TreeItem> list, ProblemType problemType){
		for (TreeItem problemSeverityTreeItem : list) {
			if (problemSeverityTreeItem.getText().matches("^Errors \\(\\d+ item.*\\)") 
					&& problemType == ProblemType.ERROR) {
				return problemSeverityTreeItem.getItems();
			} 
			if (problemSeverityTreeItem.getText().matches("^Warnings \\(\\d+ item.*\\)")
					&& problemType == ProblemType.WARNING) {
				return problemSeverityTreeItem.getItems();
			}
		}
		return new LinkedList<TreeItem>();
public ProblemsView() {
			boolean itemFitsMatchers = true;
			if(matchers != null){
				for (AbstractProblemMatcher matcher: matchers) {
					if (!matcher.matches(item.getCell(getIndexOfColumn(matcher.getColumn())))) {
						itemFitsMatchers = false;
						break;
					}
				}
			}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Add this to your module's `build.gradle` file:
```gradle
dependencies {
    // ... other dependencies
    compile 'com.afollestad:aesthetic:0.4.0'
}
```

ext.versions = [
        minSdk            : 16,
        compileSdk        : 25,
        buildTools        : '25.0.3',
        publishVersion    : '0.4.1',
        publishVersionCode: 13,
        gradlePlugin      : '2.3.2',

        supportLib        : '25.3.1',
public static void pause(@NonNull AppCompatActivity activity) {
    if (instance.backgroundSubscriptions != null) {
      instance.backgroundSubscriptions.clear();
    }
    if (instance.context != null
        && instance.context.getClass().getName().equals(activity.getClass().getName())) {
      instance.context = null;
    }
    if (activity.isFinishing()) {
      instance.backgroundSubscriberViews.remove(activity);
    }
  }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        </apply-to-dependencies>
        <dependencies>
            <module name="javax.api"/>
            <module name="javax.xml.ws.api"/>
            <module name="org.slf4j"/>
        </dependencies>
  </resources>
  <dependencies>
    <module name="javax.api" />
    <module name="javax.xml.ws.api" />
    <module name="org.slf4j" />
    <module name="javax.xml.bind.api" />
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void renamePet(final UltraPlayer ultraPlayer) {
                if (event.getName() == null) {
                    return;
                }
                if (SettingsManager.getConfig().getBoolean("Pets-Rename.Requires-Money.Enabled") && UltraCosmeticsData.get().getPlugin().isVaultLoaded()) {
                    event.setWillClose(false);
                    event.setWillDestroy(false);
                    buyRenamePet(ultraPlayer, event.getName());
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
In the java `Calendar` class months use 0 based indexing: January is month 0, De

### How do I use my custom logic to enable/disable dates?
`DatePickerDialog` exposes some utility methods to enable / disable dates for common scenario's. If your needs are not covered by these, you can supply a custom implementation of the `DateRangeLimiter` interface.

```java
class MyDateRangeLimiter implements DateRangeLimiter {
  @Override
  public int getMinYear() {
    return 1900;
class MyDateRangeLimiter implements DateRangeLimiter {
  public Calendar setToNearestDate(Calendar day) {
      return day;
  }
}
```

    private static final String KEY_VERSION = "version";
    private static final String KEY_TIMEZONE = "timezone";
    private static final String KEY_DATERANGELIMITER = "daterangelimiter";
    private static final String KEY_DEFAULTDATERANGELIMITER = "defaultdaterangelimiter";

    private static final int ANIMATION_DURATION = 300;
    private static final int ANIMATION_DELAY = 500;
    private int mCancelColor = -1;
    private Version mVersion;
    private TimeZone mTimezone;
    private DefaultDateRangeLimiter mDefaultLimiter = new DefaultDateRangeLimiter(this);
    private DateRangeLimiter mDateRangeLimiter = mDefaultLimiter;

    private HapticFeedbackController mHapticFeedbackController;
public void onSaveInstanceState(@NonNull Bundle outState) {
        outState.putInt(KEY_CANCEL_COLOR, mCancelColor);
        outState.putSerializable(KEY_VERSION, mVersion);
        outState.putSerializable(KEY_TIMEZONE, mTimezone);
        outState.putSerializable(KEY_DATERANGELIMITER, mDateRangeLimiter);
        outState.putSerializable(KEY_DEFAULTDATERANGELIMITER, mDefaultLimiter);
    }

    @Override
public View onCreateView(LayoutInflater inflater, ViewGroup container,
            mCancelColor = savedInstanceState.getInt(KEY_CANCEL_COLOR);
            mVersion = (Version) savedInstanceState.getSerializable(KEY_VERSION);
            mTimezone = (TimeZone) savedInstanceState.getSerializable(KEY_TIMEZONE);
            mDateRangeLimiter = (DateRangeLimiter) savedInstanceState.getSerializable(KEY_DATERANGELIMITER);
            mDefaultLimiter = (DefaultDateRangeLimiter) savedInstanceState.getSerializable(KEY_DEFAULTDATERANGELIMITER);
        }

        int viewRes = mVersion == Version.VERSION_1 ? R.layout.mdtp_date_picker_dialog : R.layout.mdtp_date_picker_dialog_v2;
        View view = inflater.inflate(viewRes, container, false);
        // All options have been set at this point: round the initial selection if necessary

package com.wdullaer.materialdatetimepicker.date;

import java.io.Serializable;
import java.util.Calendar;

@SuppressWarnings("WeakerAccess")
public interface DateRangeLimiter extends Serializable {
    int getMinYear();

    int getMaxYear();

package com.wdullaer.materialdatetimepicker.date;

import android.support.annotation.NonNull;
import android.support.annotation.Nullable;

import java.util.Arrays;
import java.util.Calendar;
import java.util.HashSet;
import java.util.TreeSet;

class DefaultDateRangeLimiter implements DateRangeLimiter {
    private static final int DEFAULT_START_YEAR = 1900;
    private static final int DEFAULT_END_YEAR = 2100;

    private DatePickerController mController;
    private int mMinYear = DEFAULT_START_YEAR;
    private int mMaxYear = DEFAULT_END_YEAR;
    private Calendar mMinDate;
    private Calendar mMaxDate;
    private TreeSet<Calendar> selectableDays = new TreeSet<>();
    private HashSet<Calendar> disabledDays = new HashSet<>();

    DefaultDateRangeLimiter(@NonNull DatePickerController controller) {
        mController = controller;
    }

    void setSelectableDays(@NonNull Calendar[] days) {
        for (Calendar selectableDay : days) Utils.trimToMidnight(selectableDay);
        this.selectableDays.addAll(Arrays.asList(days));
void setMaxDate(@NonNull Calendar calendar) {
        mMaxDate = Utils.trimToMidnight((Calendar) calendar.clone());
    }

    void setYearRange(int startYear, int endYear) {
        if (endYear < startYear) {
            throw new IllegalArgumentException("Year end must be larger than or equal to year start");
public int getMaxYear() {
    public @NonNull Calendar getStartDate() {
        if (!selectableDays.isEmpty()) return (Calendar) selectableDays.first().clone();
        if (mMinDate != null) return (Calendar) mMinDate.clone();
        Calendar output = Calendar.getInstance(mController.getTimeZone());
        output.set(Calendar.YEAR, mMinYear);
        output.set(Calendar.DAY_OF_MONTH, 1);
        output.set(Calendar.MONTH, Calendar.JANUARY);
public int getMaxYear() {
    public @NonNull Calendar getEndDate() {
        if (!selectableDays.isEmpty()) return (Calendar) selectableDays.last().clone();
        if (mMaxDate != null) return (Calendar) mMaxDate.clone();
        Calendar output = Calendar.getInstance(mController.getTimeZone());
        output.set(Calendar.YEAR, mMaxYear);
        output.set(Calendar.DAY_OF_MONTH, 31);
        output.set(Calendar.MONTH, Calendar.DECEMBER);
private boolean isAfterMax(@NonNull Calendar calendar) {

            if (newCalendar != null || higher == null) {
                newCalendar = newCalendar == null ? calendar : newCalendar;
                newCalendar.setTimeZone(mController.getTimeZone());
                return (Calendar) newCalendar.clone();
            }

public void setToNearestShouldBeInSelectableDays(
            @InRange(min = "01/01/1800", max = "12/31/2099", format = "MM/dd/yyyy") Date date,
            @InRange(min = "01/01/1800", max = "12/31/2099", format = "MM/dd/yyyy") Date[] dates
    ) {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);

        Calendar day = Calendar.getInstance();
        day.setTime(date);
public void setToNearestShouldNeverBeInDisabledDays(
            @InRange(min = "01/01/1800", max = "12/31/2099", format = "MM/dd/yyyy") Date date,
            @InRange(min = "01/01/1800", max = "12/31/2099", format = "MM/dd/yyyy") Date[] dates
    ) {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);

        Calendar day = Calendar.getInstance();
        day.setTime(date);
public void setToNearestShouldNeverBeBelowMinDate(
            @InRange(min = "01/01/1800", max = "12/31/2099", format = "MM/dd/yyyy") Date date,
            @InRange(min = "01/01/1800", max = "12/31/2099", format = "MM/dd/yyyy") Date minDate
    ) {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);

        Calendar day = Calendar.getInstance();
        day.setTime(date);
public void setToNearestShouldNeverBeAboveMaxDate(
            @InRange(min = "01/01/1800", max = "12/31/2099", format = "MM/dd/yyyy") Date date,
            @InRange(min = "01/01/1800", max = "12/31/2099", format = "MM/dd/yyyy") Date maxDate
    ) {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);

        Calendar day = Calendar.getInstance();
        day.setTime(date);
public TimeZone getTimeZone() {
    // getters
    @Test
    public void getSelectableDaysShouldHaveDatesTrimmedToMidnight() {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);
        Calendar[] days = new Calendar[3];
        for (int i = 0;i < days.length; i++) {
            Calendar day = Calendar.getInstance();
public void getSelectableDaysShouldHaveDatesTrimmedToMidnight() {

    @Test
    public void getDisabledDaysShouldHaveDatesTrimmedToMidnight() {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);
        Calendar[] days = new Calendar[3];
        for (int i = 0;i < days.length; i++) {
            Calendar day = Calendar.getInstance();
public void getDisabledDaysShouldHaveDatesTrimmedToMidnight() {

    @Test
    public void getMinDateShouldHaveDateTrimmedToMidnight() {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);
        Calendar day = Calendar.getInstance();
        day.set(Calendar.YEAR, 1999);
        day.set(Calendar.HOUR_OF_DAY, 2);
public void getMinDateShouldHaveDateTrimmedToMidnight() {

    @Test
    public void getMaxDateShouldHaveDateTrimmedToMidnight() {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);
        Calendar day = Calendar.getInstance();
        day.set(Calendar.YEAR, 1999);
        day.set(Calendar.HOUR_OF_DAY, 2);
public void getMaxDateShouldHaveDateTrimmedToMidnight() {
    // getStartDate()
    @Test
    public void getStartDateShouldReturnFirstSelectableDay() {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);
        Calendar[] days = new Calendar[3];
        for (int i = 0; i < days.length; i++) {
            days[i] = Calendar.getInstance();
public void getStartDateShouldReturnFirstSelectableDay() {

    @Test
    public void getStartDateShouldReturnMinDate() {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);
        Calendar minDate = Calendar.getInstance();

        limiter.setMinDate(minDate);
public void getStartDateShouldReturnMinDate() {

    @Test
    public void getStartDateShouldPreferSelectableOverMinDate() {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);
        Calendar[] days = new Calendar[3];
        for (int i = 0; i < days.length; i++) {
            days[i] = Calendar.getInstance();
public void getStartDateShouldPreferSelectableOverMinDate() {
    // getEndDate()
    @Test
    public void getEndDateShouldReturnLastSelectableDay() {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);
        Calendar[] days = new Calendar[3];
        for (int i = 0; i < days.length; i++) {
            days[i] = Calendar.getInstance();
public void getEndDateShouldReturnLastSelectableDay() {

    @Test
    public void getEndDateShouldReturnMaxDate() {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);
        Calendar maxDate = Calendar.getInstance();

        limiter.setMaxDate(maxDate);
public void getEndDateShouldReturnMaxDate() {

    @Test
    public void getEndDateShouldPreferSelectableOverMaxDate() {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);
        Calendar[] days = new Calendar[3];
        for (int i = 0; i < days.length; i++) {
            days[i] = Calendar.getInstance();
public void getEndDateShouldPreferSelectableOverMaxDate() {
    // isOutOfRange()
    @Test
    public void isOutOfRangeShouldReturnTrueForDisabledDates() {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);
        Calendar[] days = new Calendar[1];
        Calendar day = Calendar.getInstance();
        day.set(Calendar.YEAR, 1999);
public void isOutOfRangeShouldReturnTrueForDisabledDates() {

    @Test
    public void isOutOfRangeShouldReturnFalseForEnabledDates() {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);
        Calendar[] days = new Calendar[1];
        Calendar day = Calendar.getInstance();
        day.set(Calendar.YEAR, 1999);
public void isOutOfRangeShouldReturnFalseForEnabledDates() {

    @Test
    public void isOutOfRangeShouldReturnTrueIfDateIsBeforeMin() {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);
        Calendar day = Calendar.getInstance();
        day.set(Calendar.YEAR, 1999);

public void isOutOfRangeShouldReturnTrueIfDateIsBeforeMin() {

    @Test
    public void isOutOfRangeShouldReturnTrueIfDateIsBeforeMinYear() {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);
        int minYear = 1999;

        limiter.setYearRange(minYear, minYear + 1);
public void isOutOfRangeShouldReturnTrueIfDateIsBeforeMinYear() {

    @Test
    public void isOutOfRangeShouldReturnTrueIfDateIsAfterMax() {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);
        Calendar day = Calendar.getInstance();
        day.set(Calendar.YEAR, 1999);

public void isOutOfRangeShouldReturnTrueIfDateIsAfterMax() {

    @Test
    public void isOutOfRangeShouldReturnTrueIfDateIsAfterMaxYear() {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);
        int maxYear = 1999;

        limiter.setYearRange(maxYear - 1, maxYear);
public void isOutOfRangeShouldReturnTrueIfDateIsAfterMaxYear() {

    @Test
    public void isOutOfRangeShouldPreferDisabledOverEnabled() {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);
        Calendar[] days = new Calendar[1];
        Calendar day = Calendar.getInstance();
        day.set(Calendar.YEAR, 1999);
public void isOutOfRangeShouldPreferDisabledOverEnabled() {
    // setToNearestDate()
    @Test
    public void setToNearestShouldReturnTheInputWhenValid() {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);
        Calendar day = Calendar.getInstance();
        Calendar expected = (Calendar) day.clone();

public void setToNearestShouldReturnTheInputWhenValid() {

    @Test
    public void setToNearestShouldRoundDisabledDates() {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);
        Calendar[] days = new Calendar[3];
        for (int i = 0;i < days.length; i++) {
            Calendar day = Calendar.getInstance();
public void setToNearestShouldRoundDisabledDates() {

    @Test
    public void setToNearestShouldRoundToMinDate() {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);
        Calendar minDate = Calendar.getInstance();
        minDate.set(Calendar.YEAR, 1999);

public void setToNearestShouldRoundToMinDate() {

    @Test
    public void setToNearestShouldRoundToMaxDate() {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);
        Calendar maxDate = Calendar.getInstance();
        maxDate.set(Calendar.YEAR, 1999);

public void setToNearestShouldRoundToMaxDate() {

    @Test
    public void setToNearestShouldRoundToASelectableDay() {
        DefaultDateRangeLimiter limiter = new DefaultDateRangeLimiter(controller);
        Calendar[] days = new Calendar[3];
        for (int i = 0;i < days.length; i++) {
            Calendar day = Calendar.getInstance();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public static Drawable getDrawable(Context context, @Nullable Feed feed) {
            drawable = faviconCache.get(feed.getId());

            if(drawable == null) {
                drawable = new TextDrawable.Builder(feed.getName().substring(0, 1), getFeedColor(context, feed))
                        .textColor(ContextCompat.getColor(context, R.color.textdrawable_text))
                        .build();
                faviconCache.put(feed.getId(), drawable);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.text.SimpleDateFormat;
import java.util.Iterator;


public class GpsStatusFragment extends Fragment implements GpsTestListener {

    private boolean mUseLegacyGnssApi = false;

    public void onLocationChanged(Location location) {
        if (!mGotFix) {
            mTTFFView.setText(GpsTestActivity.getInstance().mTtff);
            mGotFix = true;
        }
        mLatitudeView.setText(getString(R.string.gps_latitude_value, location.getLatitude()));
        mLongitudeView.setText(getString(R.string.gps_longitude_value, location.getLongitude()));
        mFixTime = location.getTime();
        if (location.hasAltitude()) {
            mAltitudeView.setText(getString(R.string.gps_altitude_value, location.getAltitude()));
        } else {
            mAltitudeView.setText("");
        }
        if (location.hasAccuracy()) {
            mAccuracyView.setText(getString(R.string.gps_accuracy_value, location.getAccuracy()));
        } else {
            mAccuracyView.setText("");
        }
        if (location.hasSpeed()) {
            mSpeedView.setText(getString(R.string.gps_speed_value, location.getSpeed()));
        } else {
            mSpeedView.setText("");
        }
        if (location.hasBearing()) {
            mBearingView.setText(getString(R.string.gps_bearing_value, location.getBearing()));
        } else {
            mBearingView.setText("");
        }
private void setStarted(boolean navigating) {
    }

    private void updateFixTime() {
        if (mFixTime == 0 || !GpsTestActivity.getInstance().mStarted) {
            mFixTimeView.setText("");
        } else {
            mFixTimeView.setText(mDateFormat.format(mFixTime));
public void onNmeaMessage(String message, long timestamp) {
        if (message.startsWith("$GPGGA") || message.startsWith("$GNGNS")) {
            Double altitudeMsl = GpsTestUtil.getAltitudeMeanSeaLevel(message);
            if (altitudeMsl != null && mNavigating) {
                mAltitudeMslView.setText(getString(R.string.gps_altitude_msl_value, altitudeMsl));
            }
        }
        if (message.startsWith("$GNGSA") || message.startsWith("$GPGSA")) {
public void onNmeaMessage(String message, long timestamp) {
                showDopViews();
                mPdopView.setText(String.valueOf(dop.getPositionDop()));
                mHvdopView.setText(
                        getString(R.string.hvdop_value, dop.getHorizontalDop(),
                                dop.getVerticalDop()));
            }
        }
private void updateGnssStatus(GnssStatus status) {
        setStarted(true);
        updateFixTime();

        mSnrCn0Title = mRes.getString(R.string.gps_cn0_column_label);

        if (mPrns == null) {
private void updateGnssStatus(GnssStatus status) {
            mSvCount++;
        }

        mNumSats.setText(getString(R.string.gps_num_sats_value, mUsedInFixCount, mSvCount));

        mAdapter.notifyDataSetChanged();
    }
private void updateLegacyStatus(GpsStatus status) {
        setStarted(true);
        updateFixTime();

        mSnrCn0Title = mRes.getString(R.string.gps_snr_column_label);

        Iterator<GpsSatellite> satellites = status.getSatellites().iterator();
private void updateLegacyStatus(GpsStatus status) {
            mSvCount++;
        }

        mNumSats.setText(getString(R.string.gps_num_sats_value, mUsedInFixCount, mSvCount));

        mAdapter.notifyDataSetChanged();
    }
public View getView(int position, View convertView, ViewGroup parent) {
                        break;
                    case ELEVATION_COLUMN:
                        if (mSvElevations[row] != 0.0f) {
                            text = getString(R.string.gps_elevation_column_value,
                                    Float.toString(mSvElevations[row]));
                        } else {
                            text = "";
                        }
                        break;
                    case AZIMUTH_COLUMN:
                        if (mSvAzimuths[row] != 0.0f) {
                            text = getString(R.string.gps_azimuth_column_value,
                                    Float.toString(mSvAzimuths[row]));
                        } else {
                            text = "";
import android.location.GnssStatus;
import android.os.Build;
import android.support.annotation.RequiresApi;
import android.text.TextUtils;
import android.util.Log;

public static boolean canManageDialog(Activity activity) {
    }

    /**
     * Outputs the provided nmea message and timestamp to log
     *
     * @param timestamp timestamp to write to the log, or Long.MIN_VALUE to not write a timestamp
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
3.0.0-RC1
o Add verifyConnection configuration property for bolt and http driver
o Support Neo4j version 3.3.0-alpha3 in 3.3 profile
void preSave(Object object) {
        } else {
            preSaveCheck(object);
        }
    }

    void postSave() {
private void preSaveCheck(Object object) {
            logger.debug("already visited: {}", object);
        }

        // now fire events for any objects whose relationships have been deleted from reachable ones
        // and which therefore have been possibly rendered unreachable from the object graph traversal
        for (Object other : unreachable()) {
            if (visit(other) && !preSaveFired(other)) { // only if not yet visited and not yet fired
                firePreSave(other);
            }
        }

        // fire events for existing nodes that are not dirty, but which have had an edge added:
        for (Object other : touched()) {
            if (!preSaveFired(other)) { // only if not yet already fired
                firePreSave(other);
            }
        }
    }

    private void firePreSave(Object object) {
private boolean preSaveFired(Object object) {
        Set<Object> unreachable = new HashSet<>();

        for (MappedRelationship mappedRelationship : deletedRelationships) {
            unreachable.add(session.context().getNodeEntity(mappedRelationship.getStartNodeId()));
            unreachable.add(session.context().getNodeEntity(mappedRelationship.getEndNodeId()));
        }

        return unreachable;
    }

    // registers this object as visited and returns true if it was not previously visited, false otherwise
    private boolean visit(Object object) {
        return this.visited.add(EntityUtils.identity(object, this.session.metaData()));
import static org.junit.Assert.*;
import static org.neo4j.ogm.testutil.GraphTestUtils.*;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import org.neo4j.ogm.domain.social.*;
import org.neo4j.ogm.session.Session;
import org.neo4j.ogm.session.SessionFactory;
import org.neo4j.ogm.testutil.MultiDriverTestClass;

/**
public void removeUndirectedRelationship() {
        session.save(userA);
        assertSameGraph(getGraphDatabaseService(), "CREATE (a:User {name:'A'}) CREATE (b:User {name:'B'})");
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
repositories {
        name = "CoFH Maven"
        url = "http://maven.covers1624.net"
    }
	maven {
        url = "http://chickenbones.net/maven"
    }
}

dependencies {
processResources
    }
}

sourceSets {
    main {
		java {
            exclude '**/me/jacky1356400/exchangers/item/powered/*'
		}
	}
}
org.gradle.jvmargs=-Xmx4G
mc_version=1.12
forge_version=14.21.1.2396
mod_version=2.1
@Mod(modid = Data.MODID, version = Data.VERSION, name = Data.MODNAME, dependencies = Exchangers.DEPENDS, useMetadata = true)
public class Exchangers {

	public static final String DEPENDS = "after:redstoneflux;after:enderio;after:thermalfoundation;after:thermalexpansion;after:mekanism;";

	public static Logger logger = LogManager.getLogger("Exchangers");


import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.common.capabilities.CapabilityInject;
import net.minecraftforge.energy.IEnergyStorage;

public class EnergyHelper {

    @CapabilityInject (IEnergyStorage.class)

    public static ItemStack setDefaultEnergyTag(ItemStack container, int energy) {

        if (!container.hasTagCompound()) {
public void onItemRegistry(RegistryEvent.Register<Item> e) {

	@SubscribeEvent
	public void onRecipeRegistry(RegistryEvent.Register<IRecipe> e) {
		initRecipes();
		e.getRegistry().registerAll(Data.RECIPES.toArray(new IRecipe[0]));
	}
public void preInit(FMLPreInitializationEvent e) {
		File configDir = e.getModConfigurationDirectory();
		config = new Configuration(new File(configDir.getPath(), "exchangers.cfg"));
		Config.readConfig();
		/*
		if ((Config.enderIOModule = true) && (Loader.isModLoaded(Data.EIO))) {
			EnderIOIntegration.init();
		}
		*/
		if ((Config.thermalExpansionModule = true) && (Loader.isModLoaded(Data.THERMAL))) {
			ThermalExpansionIntegration.init();
		}
		/*
		if ((Config.mekanismModule = true) && (Loader.isModLoaded(Data.MEK))) {
			MekanismIntegration.init();
		}
		*/
		MinecraftForge.EVENT_BUS.register(new ModRegistry());
		PacketHandler.registerMessages(Data.MODID);
	}
	public static final String EIO = "enderio";
	public static final String MEK = "mekanism";
	public static final String THERMAL = "thermalexpansion";
	public static final String VERSION = "1.12-2.1";
	public static final String MODID = "exchangers";
	public static final String MODNAME = "Exchangers";
	public static final CreativeTabs TAB = new CreativeTabs(MODID) {
  "modid": "exchangers",
  "name": "Exchangers",
  "description": "Block Exchangers.",
  "version": "1.12-2.1",
  "mcversion": "1.12",
  "url": "https://github.com/Jacky1356400/Exchangers",
  "updateUrl": "",
  "authorList": ["Jacky1356400", "Shadows_of_Fire", "Turkey2349"],
  "credits": "ThatGamerBlue, ColossalPercy, JCOnline_ and many other people that helped the development of this mod!",
  "logoFile": "assets/exchangers/logo.png",
  "screenshots": [],
  "dependencies": []
}
]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
https://github.com/randomizedtesting/randomizedtesting/blob/master/CHANGES

======================= randomizedtesting 2.5.2-SNAPSHOT ====================

======================= randomizedtesting 2.5.1 ====================

Changes in Backwards Compatibility
public Charset getCharset() {
   * System properties on the slave.
   */
  public Map<String,String> getSystemProperties() {
    return bootstrapEvent.getSystemProperties();
  }

public Charset getCharset() {
   * (Java 8 will have real PID support, supposedly).
   */
  public String getPidString() {
    return bootstrapEvent.getPidString();
  }

  /**
      SlaveMain.class.getName() + ".fireRunnerFailure";

  /**
   * Event sink.
   */
  private final Serializer serializer;
public static void main(String[] allArgs) {
      if (eventsFile == null) {
        throw new IOException("You must specify communication channel for events.");
      }
      // Send bootstrap package.
      serializer = new Serializer(new EventsOutputStream(eventsFile))
        .serialize(new BootstrapEvent())
public void testHeartbeat() {
    executeTarget("testHeartbeat");
    assertLogContains("HEARTBEAT J0");
    assertLogContains("at: HeartbeatSlow.method1");
  }
}
                <include name="**/HeartbeatSlow.class" />
            </fileset>

            <listeners>
                <junit4:report-text />
            </listeners>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private static void init(Class<?> cls,
                cls = cls.getSuperclass();
            }
            separator = declaredSeparator != null ? declaredSeparator : separator;
        }

        /**
private void processPositionalParameters0(boolean validateOnly, Stack<String> ar
                    }
                }
                Collections.reverse(argsCopy);
                for (int i = 0; i < indexRange.min; i++) { argsCopy.pop(); }
                Arity arity = Arity.forParameters(positionalParam);
                assertNoMissingParameters(positionalParam, arity.min, argsCopy);
                if (!validateOnly) {
private String unquote(String value) {
                        : value;
        }
    }

    /**
     * Inner class to group the built-in {@link ITypeConverter} implementations.
     */
public void testNonVarargArrayParametersWithArity2() {
        }
    }

    class VariousPrefixCharacters {
        @Option(names = {"-d", "--dash"}) int dash;
        @Option(names = {"/S"}) int slashS;
public void testPositionalParamWithAbsoluteIndex() {
            CommandLine.parse(new App(), "000");
            fail("Should fail with missingParamException");
        } catch (MissingParameterException ex) {
            assertEquals("Missing required parameters: file1, file2, all", ex.getMessage());
        }
    }

public void testPositionalParamWithFixedIndexRange() {
            CommandLine.parse(new App());
            fail("Should fail with missingParamException");
        } catch (MissingParameterException ex) {
            assertEquals("Missing required parameters: file0_1, fileList1_2, fileArray0_3, all", ex.getMessage());
        }
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public static String processNameTemplate(final String template, final Map<String
        while (matcher.find()) {
            final String pattern = matcher.group(1);
            final String replacement = processPattern(pattern, params).orElseGet(matcher::group);
            matcher.appendReplacement(sb, replacement);
        }
        matcher.appendTail(sb);
        return sb.toString();
public void shouldTransformPlaceholdersToPropertyValues() {
                        + " \"1111222233334444\", \"{missing}\", true");
    }

    @Step("\"{user.emails.address}\", \"{user.emails}\", \"{user.emails.attachments}\", \"{user.password}\", \"{}\"," +
            " \"{user.card.number}\", \"{missing}\", {staySignedIn}")
    private void loginWith(final DummyUser user, final boolean staySignedIn) {
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import com.alpha.pineapple.docker.model.ContainerInfo;
import com.alpha.pineapple.docker.model.ContainerInfoImpl;
import com.alpha.pineapple.docker.model.ImageInfo;
import com.alpha.pineapple.docker.model.jaxb.ContainerConfigurationExposedPortsMap;
import com.alpha.pineapple.docker.model.jaxb.ContainerConfigurationHostConfigPortBindingsMap;
import com.alpha.pineapple.docker.model.jaxb.ContainerConfigurationLabelsMap;
import com.alpha.pineapple.docker.model.jaxb.ContainerConfigurationVolumesMap;
import com.alpha.pineapple.docker.model.rest.ContainerConfigurationHostConfig;
import com.alpha.pineapple.docker.model.rest.ContainerConfigurationVolumeNullValue;
import com.alpha.testutils.ObjectMotherContent;
@ContextConfiguration(locations = { "/com.alpha.pineapple.plugin.docker-config.xml" })
public class MapperImplIntegrationTest {

    /**
     * Object under test.
     */
    @Resource
    Mapper mapper;

    /**
     * Object mother for the docker model.
     */
    ObjectMotherContent contentMother;

    /**
     * Container configurations.
     */
    Map<String, ContainerConfiguration> containerConfigs;

    /**
     * Random value.
     */
    String randomRepo;

    /**
     * Random value.
     */
    String randomTag;

    /**
     * Random value.
     */
    String randomRepo2;

    /**
     * Random value.
     */
    String randomTag2;

    /**
     * Random value.
     */
    String randomId;

    /**
     * Random value.
     */
    String randomMountpoint;

    /**
     * Random value.
     */
    String randomMountpoint2;

    /**
     * Random name.
     */
    String randomName;

    /**
     * Random value.
     */
    String randomValue;

    /**
     * Random name.
     */
    String randomName2;

    /**
     * Random value.
     */
    String randomValue2;

    /**
     * Random
     */
    Random random;

    @Before
    public void setUp() throws Exception {
	random = new Random();
	randomRepo = RandomStringUtils.randomAlphanumeric(10);
	randomTag = RandomStringUtils.randomAlphanumeric(10);
	randomRepo2 = RandomStringUtils.randomAlphanumeric(10);
	randomTag2 = RandomStringUtils.randomAlphanumeric(10);
	randomId = RandomStringUtils.randomAlphanumeric(10);
	randomMountpoint = RandomStringUtils.randomAlphanumeric(10);
	randomMountpoint2 = RandomStringUtils.randomAlphanumeric(10);
	randomName = RandomStringUtils.randomAlphanumeric(10);
	randomValue = RandomStringUtils.randomAlphanumeric(10);
	randomName2 = RandomStringUtils.randomAlphanumeric(10);
	randomValue2 = RandomStringUtils.randomAlphanumeric(10);

	// create content mother
	contentMother = new ObjectMotherContent();

	// create container configs
	containerConfigs = new HashMap<String, ContainerConfiguration>();
    }

    @After
    public void tearDown() throws Exception {
    }

    /**
     * Assert container configuration has default value as set by
     * {@linkplain ContainerInfoImpl} during creation of the target container
     * configuration.
     * 
     * @param containerConfig
     *            container configuration to test.
     */
    void assertDefaultProperties(com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig) {
	// test default properties
	assertEquals(true, containerConfig.isAttachStderr());
	assertEquals(true, containerConfig.isAttachStdin());
	assertEquals(true, containerConfig.isAttachStdout());
	assertEquals("", containerConfig.getDomainname());
	assertEquals("", containerConfig.getHostname());
	assertEquals(null, containerConfig.getImage()); // !!!!!!!!!!!!!!!
	assertEquals(null, containerConfig.getMacAddress());
	assertEquals(false, containerConfig.isNetworkDisabled());
	assertEquals(true, containerConfig.isOpenStdin());
	assertEquals(false, containerConfig.isStdinOnce());
	assertEquals(true, containerConfig.isTty());
	assertEquals("", containerConfig.getUser());
	assertEquals("", containerConfig.getWorkingDir());

	// test default host-config properties
	ContainerConfigurationHostConfig hostConfig = containerConfig.getHostConfig();
	assertNotNull(hostConfig);
	assertEquals(Long.valueOf(0), hostConfig.getCpuShares());
	assertEquals(Long.valueOf(0), hostConfig.getCpuPeriod());
	assertEquals("", hostConfig.getCpusetCpus());
	assertEquals("", hostConfig.getCpusetMems());
	assertEquals(Long.valueOf(0), hostConfig.getMemory());
	assertEquals(Long.valueOf(0), hostConfig.getMemorySwap());
    }

    /**
     * Set random properties for source container configuration.
     * 
     * @param containerConfig
     *            source container configuration.
     */
    void setRandomProperties(AbstractContainerConfiguration containerConfig) {
	containerConfig.setAttachStderr(RandomUtils.nextBoolean());
	containerConfig.setAttachStdin(RandomUtils.nextBoolean());
	containerConfig.setAttachStdout(RandomUtils.nextBoolean());
	containerConfig.setDomainname(RandomStringUtils.randomAlphanumeric(10));
	containerConfig.setHostname(RandomStringUtils.randomAlphanumeric(10));
	containerConfig.setMacAddress(RandomStringUtils.randomAlphanumeric(10));
	containerConfig.setNetworkDisabled(RandomUtils.nextBoolean());
	containerConfig.setOpenStdin(RandomUtils.nextBoolean());
	containerConfig.setStdinOnce(RandomUtils.nextBoolean());
	containerConfig.setTty(RandomUtils.nextBoolean());
	containerConfig.setUser(RandomStringUtils.randomAlphanumeric(10));
	containerConfig.setWorkingDir(RandomStringUtils.randomAlphanumeric(10));

	// set host-config properties
	com.alpha.pineapple.plugin.docker.model.ContainerConfigurationHostConfig hostConfig;
	hostConfig = containerConfig.getHostConfig();
	assertNotNull(hostConfig);
	hostConfig.setCpuShares(RandomUtils.nextLong());
	hostConfig.setCpuPeriod(RandomUtils.nextLong());
	hostConfig.setCpusetCpus(RandomStringUtils.randomAlphanumeric(10));
	hostConfig.setCpusetMems(RandomStringUtils.randomAlphanumeric(10));
	hostConfig.setMemory(RandomUtils.nextLong());
	hostConfig.setMemorySwap(RandomUtils.nextLong());

    }

    /**
     * Assert that properties defined on the source configuration is set on the
     * target configuration.
     * 
     * @param srcContainerConfig
     *            source container configuration.
     * @param targetContainerConfig
     *            target container configuration.
     */
    void assertProperties(AbstractContainerConfiguration srcContainerConfig,
	    com.alpha.pineapple.docker.model.rest.ContainerConfiguration targetContainerConfig) {

	assertEquals(srcContainerConfig.isAttachStderr(), targetContainerConfig.isAttachStderr());
	assertEquals(srcContainerConfig.isAttachStdin(), targetContainerConfig.isAttachStdin());
	assertEquals(srcContainerConfig.isAttachStdout(), targetContainerConfig.isAttachStdout());
	assertEquals(srcContainerConfig.getDomainname(), targetContainerConfig.getDomainname());
	assertEquals(srcContainerConfig.getHostname(), targetContainerConfig.getHostname());
	assertEquals(srcContainerConfig.getMacAddress(), targetContainerConfig.getMacAddress());
	assertEquals(srcContainerConfig.isNetworkDisabled(), targetContainerConfig.isNetworkDisabled());
	assertEquals(srcContainerConfig.isOpenStdin(), targetContainerConfig.isOpenStdin());
	assertEquals(srcContainerConfig.isStdinOnce(), targetContainerConfig.isStdinOnce());
	assertEquals(srcContainerConfig.isTty(), targetContainerConfig.isTty());
	assertEquals(srcContainerConfig.getUser(), targetContainerConfig.getUser());
	assertEquals(srcContainerConfig.getWorkingDir(), targetContainerConfig.getWorkingDir());

	// test default host-config properties
	com.alpha.pineapple.plugin.docker.model.ContainerConfigurationHostConfig srcHostConfig;
	srcHostConfig = srcContainerConfig.getHostConfig();
	assertNotNull(srcHostConfig);
	ContainerConfigurationHostConfig targetHostConfig = targetContainerConfig.getHostConfig();
	assertNotNull(targetHostConfig);

	assertEquals(srcHostConfig.getCpuShares(), targetHostConfig.getCpuShares());
	assertEquals(srcHostConfig.getCpuPeriod(), targetHostConfig.getCpuPeriod());
	assertEquals(srcHostConfig.getCpusetCpus(), targetHostConfig.getCpusetCpus());
	assertEquals(srcHostConfig.getCpusetMems(), targetHostConfig.getCpusetMems());
	assertEquals(srcHostConfig.getMemory(), targetHostConfig.getMemory());
	assertEquals(srcHostConfig.getMemorySwap(), targetHostConfig.getMemorySwap());
    }

    /**
     * Assert container configuration has default object as set by
     * {@linkplain ContainerInfoImpl} during creation of the target container
     * configuration.
     * 
     * @param containerConfig
     *            container configuration to test.
     */
    void assertDefaultObjects(com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig) {
	assertNotNull(containerConfig.getCmd());
	assertEquals(1, containerConfig.getCmd().size());
	assertNotNull(containerConfig.getEnv());
	assertTrue(containerConfig.getEnv().isEmpty());
	assertNotNull(containerConfig.getEntrypoint());
	assertEquals(0, containerConfig.getEntrypoint().size());
	assertNotNull(containerConfig.getExposedPorts());
	assertEquals(0, containerConfig.getExposedPorts().size());
	assertNotNull(containerConfig.getLabels());
	assertEquals(0, containerConfig.getLabels().size());
	assertNotNull(containerConfig.getOnBuild());
	assertEquals(0, containerConfig.getOnBuild().size());
	assertNotNull(containerConfig.getVolumes());
	assertEquals(0, containerConfig.getVolumes().size());
    }

    /**
     * Assert that container reference is defined on container configuration.
     * 
     * @param containerCmd
     *            container definition.
     */
    void assertReferenceIsDefined(Container containerCmd) {
	// test container configuration reference is defined
	EmbeddedContainerConfiguration sourceContainerConfig = containerCmd.getConfiguration();
	assertNotNull(sourceContainerConfig);
	assertEquals(randomId, sourceContainerConfig.getRef());
    }

    /**
     * Test that mapper can be looked up from the context.
     */
    @Test
    public void testCanGetInstanceFromContext() {
	assertNotNull(mapper);
    }

    /**
     * Test image can be mapped for creation.
     */
    @Test
    public void testMapImageForCreation() throws Exception {

	// create content
	Image command = contentMother.createImageCommand(randomRepo, randomTag);

	// map
	ImageInfo info = mapper.mapImageForCreation(command);

	// test
	assertEquals(randomRepo, info.getRepository());
	assertEquals(randomTag, info.getTag());
    }

    /**
     * Test tagged source image can be mapped for creation.
     */
    @Test
    public void testMapTaggedSourceImageForCreation() throws Exception {

	// create content
	TaggedImage command = contentMother.createTaggedImageCommand(randomRepo, randomTag, randomRepo2, randomTag2);

	// map
	ImageInfo info = mapper.mapTaggedSourceImageForCreation(command);

	// test
	assertEquals(randomRepo, info.getRepository());
	assertEquals(randomTag, info.getTag());
    }

    /**
     * Test tagged target image can be mapped for creation.
     */
    @Test
    public void testMapTaggedTargetImageForCreation() throws Exception {

	// create content
	TaggedImage command = contentMother.createTaggedImageCommand(randomRepo, randomTag, randomRepo2, randomTag2);

	// map
	ImageInfo info = mapper.mapTaggedTargetImageImageForCreation(command);

	// test
	assertEquals(randomRepo2, info.getRepository());
	assertEquals(randomTag2, info.getTag());
    }

    /**
     * Test image can be mapped for deletion.
     */
    @Test
    public void testMapImageForDeletion() throws Exception {

	// create content
	Image command = contentMother.createImageCommand(randomRepo, randomTag);

	// map
	ImageInfo info = mapper.mapImageForDeletion(command);

	// test
	assertEquals(randomRepo, info.getRepository());
	assertEquals(randomTag, info.getTag());
    }

    /**
     * Test tagged image can be mapped for creation.
     */
    @Test
    public void testMapTaggedImageForDeletion() throws Exception {

	// create content
	TaggedImage command = contentMother.createTaggedImageCommand(randomRepo, randomTag, randomRepo2, randomTag2);

	// map
	ImageInfo info = mapper.mapTaggedImageForDeletion(command);

	// test
	assertEquals(randomRepo2, info.getRepository());
	assertEquals(randomTag2, info.getTag());
    }

    /**
     * Test image created from Docker file can be mapped for creation.
     */
    @Test
    public void testmapImageFromDockerfileForCreation() throws Exception {

	// create content
	ImageFromDockerfile command = contentMother.createImageFromDockerfileCommand(randomRepo, randomTag, randomName,
		false);

	// map
	ImageInfo info = mapper.mapImageFromDockerfileForCreation(command);

	// test
	assertEquals(randomRepo, info.getRepository());
	assertEquals(randomTag, info.getTag());
    }

    /**
     * Test image created from Docker file can be mapped for deletion.
     */
    @Test
    public void testmapImageFromDockerfileForDeletion() throws Exception {

	// create content
	ImageFromDockerfile command = contentMother.createImageFromDockerfileCommand(randomRepo, randomTag, randomName,
		false);

	// map
	ImageInfo info = mapper.mapImageFromDockerfileForDeletion(command);

	// test
	assertEquals(randomRepo, info.getRepository());
	assertEquals(randomTag, info.getTag());
    }

    /**
     * Test container can be mapped for creation.
     */
    @Test
    public void testMapContainerForCreation() throws Exception {

	// create content
	Container command = contentMother.createContainerCommand(randomId, randomRepo, randomTag);

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	ImageInfo imageInfo = info.getImageInfo();
	assertNotNull(imageInfo);
	assertEquals(randomRepo, imageInfo.getRepository());
	assertEquals(randomTag, imageInfo.getTag());
    }

    /**
     * Test container can be mapped for creation with undefined container
     * configuration, i.e. the source container configuration is undefined.
     * 
     * The values in the mapped container configuration are set by the
     * {@linkplain ContainerInfoImpl} during creation of the target container
     * configuration.
     * 
     * A target configuration is created and mapped with default values.
     */
    @Test
    public void testMapContainerForCreationWithUndefinedContainerConfig() throws Exception {

	// create content
	Container command = contentMother.createContainerCommand(randomId, randomRepo, randomTag);

	// test source container configuration is defined
	assertNull(command.getConfiguration());

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);
	assertDefaultObjects(containerConfig);
	assertDefaultProperties(containerConfig);
    }

    /**
     * Test container can be mapped for creation with empty container
     * configuration, i.e. the source container configuration is defined but
     * contains no values
     * 
     * The values in the mapped container configuration are set by the
     * {@linkplain ContainerInfoImpl} during creation of the target container
     * configuration.
     * 
     * A target configuration is created and mapped with default values.
     */
    @Test
    public void testMapContainerForCreationWithEmptyContainerConfig() throws Exception {

	// create content
	Container command = contentMother.createContainerCommandWithContainerConfig(randomId, randomRepo, randomTag);

	// test source container configuration is defined
	assertNotNull(command.getConfiguration());

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);
	assertDefaultObjects(containerConfig);
	assertDefaultProperties(containerConfig);
    }

    /**
     * Test container can be mapped for creation with container configuration,
     * i.e. the source container configuration is defined and contains some
     * custom values.
     * 
     * A target configuration is created and mapped with the custom property
     * values.
     */
    @Test
    public void testMapContainerForCreationWithCustomPropertyValues() throws Exception {

	// create content
	Container command = contentMother.createContainerCommandWithContainerConfig(randomId, randomRepo, randomTag);

	// create source container configuration
	EmbeddedContainerConfiguration srcContainerConfig = command.getConfiguration();
	assertNotNull(srcContainerConfig);
	setRandomProperties(srcContainerConfig);

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);
	assertDefaultObjects(containerConfig);
	assertProperties(srcContainerConfig, containerConfig);
    }

    /**
     * Test container can be mapped for creation with container configuration,
     * i.e. the source container configuration is defined and contains only
     * defined commands.
     * 
     * A target configuration is created and mapped with defined commands.
     */
    @Test
    public void testMapContainerForCreationWith_ZeroCmds() throws Exception {

	// create content
	Container command = contentMother.createContainerCommandWithContainerConfig(randomId, randomRepo, randomTag);

	// create source container configuration
	EmbeddedContainerConfiguration srcContainerConfig = command.getConfiguration();
	assertNotNull(srcContainerConfig);

	// NO-OP: define command list with zero entries

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);

	// test that command list is mapped to one default command
	List<String> actualCmds = containerConfig.getCmd();
	assertNotNull(actualCmds);
	assertEquals(1, containerConfig.getCmd().size());
    }

    /**
     * Test container can be mapped for creation with container configuration,
     * i.e. the source container configuration is defined and contains only
     * defined commands.
     * 
     * A target configuration is created and mapped with defined commands.
     */
    @Test
    public void testMapContainerForCreationWith_OneCmd() throws Exception {

	// create content
	Container command = contentMother.createContainerCommandWithContainerConfig(randomId, randomRepo, randomTag);

	// create source container configuration
	EmbeddedContainerConfiguration srcContainerConfig = command.getConfiguration();
	assertNotNull(srcContainerConfig);

	// define command list with one entry
	List<String> cmds = srcContainerConfig.getCmd();
	cmds.add(RandomStringUtils.randomAlphanumeric(10));

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);

	// test that command list is mapped to one command
	List<String> actualCmds = containerConfig.getCmd();
	assertNotNull(actualCmds);
	assertEquals(1, containerConfig.getCmd().size());
	assertEquals(actualCmds.get(0), containerConfig.getCmd().get(0));
    }

    /**
     * Test container can be mapped for creation with container configuration,
     * i.e. the source container configuration is defined and contains only
     * defined commands.
     * 
     * A target configuration is created and mapped with defined commands.
     */
    @Test
    public void testMapContainerForCreationWith_TwoCmds() throws Exception {

	// create content
	Container command = contentMother.createContainerCommandWithContainerConfig(randomId, randomRepo, randomTag);

	// create source container configuration
	EmbeddedContainerConfiguration srcContainerConfig = command.getConfiguration();
	assertNotNull(srcContainerConfig);

	// define command list with two entries
	List<String> cmds = srcContainerConfig.getCmd();
	cmds.add(RandomStringUtils.randomAlphanumeric(10));
	cmds.add(RandomStringUtils.randomAlphanumeric(10));

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);

	// test that command list is mapped to two commands
	List<String> actualCmds = containerConfig.getCmd();
	assertNotNull(actualCmds);
	assertEquals(2, containerConfig.getCmd().size());
	assertEquals(actualCmds.get(0), containerConfig.getCmd().get(0));
	assertEquals(actualCmds.get(1), containerConfig.getCmd().get(1));
    }

    /**
     * Test container can be mapped for creation with container configuration,
     * i.e. the source container configuration is defined and contains only
     * defined environments.
     * 
     * A target configuration is created and mapped with defined environments.
     */
    @Test
    public void testMapContainerForCreationWith_ZeroEnvs() throws Exception {

	// create content
	Container command = contentMother.createContainerCommandWithContainerConfig(randomId, randomRepo, randomTag);

	// create source container configuration
	EmbeddedContainerConfiguration srcContainerConfig = command.getConfiguration();
	assertNotNull(srcContainerConfig);

	// NO-OP: define env list with zero entries

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);

	// test
	List<String> actualEnvs = containerConfig.getEnv();
	assertNotNull(actualEnvs);
	assertEquals(0, containerConfig.getEnv().size());
    }

    /**
     * Test container can be mapped for creation with container configuration,
     * i.e. the source container configuration is defined and contains only
     * defined environments.
     * 
     * A target configuration is created and mapped with defined environments.
     */
    @Test
    public void testMapContainerForCreationWith_OneEnv() throws Exception {

	// create content
	Container command = contentMother.createContainerCommandWithContainerConfig(randomId, randomRepo, randomTag);

	// create source container configuration
	EmbeddedContainerConfiguration srcContainerConfig = command.getConfiguration();
	assertNotNull(srcContainerConfig);

	// define env list with one entry
	contentMother.addEnvironmentVariable(command, randomName, randomValue);

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);

	// test that envs list is mapped to one env
	List<String> actualEnvs = containerConfig.getEnv();
	assertNotNull(actualEnvs);
	assertEquals(1, containerConfig.getCmd().size());
	assertEquals(actualEnvs.get(0), containerConfig.getEnv().get(0));
    }

    /**
     * Test container can be mapped for creation with container configuration,
     * i.e. the source container configuration is defined and contains only
     * defined environments.
     * 
     * A target configuration is created and mapped with defined environments.
     */
    @Test
    public void testMapContainerForCreationWith_TwoEnvs() throws Exception {

	// create content
	Container command = contentMother.createContainerCommandWithContainerConfig(randomId, randomRepo, randomTag);

	// create source container configuration
	EmbeddedContainerConfiguration srcContainerConfig = command.getConfiguration();
	assertNotNull(srcContainerConfig);

	// define env list with two entries
	contentMother.addEnvironmentVariable(command, randomName, randomValue);
	contentMother.addEnvironmentVariable(command, randomName2, randomValue);

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);

	// test that envs list is mapped to two envs
	List<String> actualEnvs = containerConfig.getEnv();
	assertNotNull(actualEnvs);
	assertEquals(2, containerConfig.getEnv().size());
	assertEquals(actualEnvs.get(0), containerConfig.getEnv().get(0));
	assertEquals(actualEnvs.get(1), containerConfig.getEnv().get(1));
    }

    /**
     * Test container can be mapped for creation with container configuration,
     * i.e. the source container configuration is defined and contains only
     * defined environments.
     * 
     * A target configuration is created and mapped with defined environments.
     */
    @Test
    public void testMapContainerForCreationWith_ZeroExposedPorts() throws Exception {

	// create content
	Container command = contentMother.createContainerCommandWithContainerConfig(randomId, randomRepo, randomTag);

	// create source container configuration
	EmbeddedContainerConfiguration srcContainerConfig = command.getConfiguration();
	assertNotNull(srcContainerConfig);

	// NO-OP: define exposed ports list with zero entries

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);

	// test
	ContainerConfigurationExposedPortsMap actualPorts = containerConfig.getExposedPorts();
	assertNotNull(actualPorts);
	assertEquals(0, actualPorts.size());
    }

    /**
     * Test container can be mapped for creation with container configuration,
     * i.e. the source container configuration is defined and contains only
     * defined environments.
     * 
     * A target configuration is created and mapped with defined environments.
     */
    @Test
    public void testMapContainerForCreationWith_OneExposedPort() throws Exception {

	// create content
	Container command = contentMother.createContainerCommandWithContainerConfig(randomId, randomRepo, randomTag);

	// create source container configuration
	EmbeddedContainerConfiguration srcContainerConfig = command.getConfiguration();
	assertNotNull(srcContainerConfig);

	// define port list with one entry
	contentMother.addExposedPort(command, random);

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);

	// test
	ContainerConfigurationExposedPortsMap actualPorts = containerConfig.getExposedPorts();
	assertNotNull(actualPorts);
	assertEquals(1, actualPorts.size());
    }

    /**
     * Test container can be mapped for creation with container configuration,
     * i.e. the source container configuration is defined and contains only
     * defined environments.
     * 
     * A target configuration is created and mapped with defined environments.
     */
    @Test
    public void testMapContainerForCreationWith_TwoExposedPorts() throws Exception {

	// create content
	Container command = contentMother.createContainerCommandWithContainerConfig(randomId, randomRepo, randomTag);

	// create source container configuration
	EmbeddedContainerConfiguration srcContainerConfig = command.getConfiguration();
	assertNotNull(srcContainerConfig);

	// define port list with one entry
	contentMother.addExposedPort(command, random);
	contentMother.addExposedPort(command, random);

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);

	// test
	ContainerConfigurationExposedPortsMap actualPorts = containerConfig.getExposedPorts();
	assertNotNull(actualPorts);
	assertEquals(2, actualPorts.size());
    }

    /**
     * Test container can be mapped for creation with container configuration,
     * i.e. the source container configuration is defined and contains only
     * defined environments.
     * 
     * A target configuration is created and mapped with defined environments.
     */
    @Test
    public void testMapContainerForCreationWith_TwoIdenticalExposedPortsAreOnlyAddedOnce() throws Exception {

	// create content
	Container command = contentMother.createContainerCommandWithContainerConfig(randomId, randomRepo, randomTag);

	// create source container configuration
	EmbeddedContainerConfiguration srcContainerConfig = command.getConfiguration();
	assertNotNull(srcContainerConfig);

	// define port list with one entry
	int portNumber = NetworkUtils.getRandomPort(random);
	contentMother.addExposedPort(command, portNumber);
	contentMother.addExposedPort(command, portNumber);

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);

	// test
	ContainerConfigurationExposedPortsMap actualPorts = containerConfig.getExposedPorts();
	assertNotNull(actualPorts);
	assertEquals(1, actualPorts.size());
    }

    /**
     * Test container can be mapped for creation with referenced container
     * configuration, i.e. the source container configuration is undefined but a
     * referenced container configuration is defined and the values are set from
     * the referenced configuration.
     * 
     * A target configuration is created and mapped with values from the
     * referenced container configuration.
     */
    @Test
    public void testMapContainerForCreationWithReferencedPropertyValues() throws Exception {

	// create and add referenced container configuration
	ContainerConfiguration refContainerConfig;
	refContainerConfig = contentMother.ReferencedContainerConfiguration(randomId);
	containerConfigs.put(randomId, refContainerConfig);

	// create container with reference
	Container command = contentMother.createContainerCommandWithReferencedContainerConfig(randomId, randomRepo,
		randomTag, randomId);
	assertReferenceIsDefined(command);

	// set custom property values in referenced container configuration
	setRandomProperties(refContainerConfig);

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);
	assertDefaultObjects(containerConfig);
	assertProperties(refContainerConfig, containerConfig);
    }

    /**
     * Test container can be mapped for creation with referenced container
     * configuration, i.e. the source container configuration is undefined but a
     * referenced container configuration is defined but contains no values.
     * 
     * A target configuration is created and mapped with default values from the
     * referenced container configuration.
     */
    @Test
    public void testMapContainerForCreationWithReferencedConfigurationWithUndefinedValues() throws Exception {

	// create and add referenced container configuration
	ContainerConfiguration refContainerConfig;
	refContainerConfig = contentMother.ReferencedContainerConfiguration(randomId);
	containerConfigs.put(randomId, refContainerConfig);

	// create container with reference
	Container command = contentMother.createContainerCommandWithReferencedContainerConfig(randomId, randomRepo,
		randomTag, randomId);
	assertReferenceIsDefined(command);

	// NO property values is set in referenced container configuration

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);
	assertDefaultObjects(containerConfig);
	assertDefaultProperties(containerConfig);
    }

    /**
     * Test container can be mapped for creation with source and referenced
     * container configuration, i.e. the source container configuration is
     * defined and a referenced container configuration is defined and the
     * values are set from the source configuration.
     * 
     * A target configuration is created and mapped with values from the source
     * container configuration.
     */
    @Test
    public void testMapContainerForCreationWithSourceAndReferencedPropertyValues() throws Exception {

	// create and add referenced container configuration
	ContainerConfiguration refContainerConfig;
	refContainerConfig = contentMother.ReferencedContainerConfiguration(randomId);
	containerConfigs.put(randomId, refContainerConfig);

	// create container with reference
	Container command = contentMother.createContainerCommandWithReferencedContainerConfig(randomId, randomRepo,
		randomTag, randomId);
	assertReferenceIsDefined(command);

	// create source container configuration
	EmbeddedContainerConfiguration srcContainerConfig = command.getConfiguration();
	assertNotNull(srcContainerConfig);
	setRandomProperties(srcContainerConfig);

	// set custom property values in referenced container configuration
	setRandomProperties(refContainerConfig);

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);
	assertDefaultObjects(containerConfig);

	// test that container configuration contains values from the source
	// configuration.
	assertProperties(srcContainerConfig, containerConfig);
    }

    /**
     * Test container can be mapped for creation with container configuration,
     * i.e. the source container configuration is defined and contains only
     * defined volumes.
     * 
     * A target configuration is created and mapped with defined volumes.
     */
    @Test
    public void testMapContainerForCreationWith_ZeroVolumes() throws Exception {

	// create content
	Container command = contentMother.createContainerCommandWithContainerConfig(randomId, randomRepo, randomTag);

	// create source container configuration
	EmbeddedContainerConfiguration srcContainerConfig = command.getConfiguration();
	assertNotNull(srcContainerConfig);

	// NO-OP: define zero volumes

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);

	// test
	ContainerConfigurationVolumesMap actualVolumes = containerConfig.getVolumes();
	assertNotNull(actualVolumes);
	assertEquals(0, actualVolumes.size());
    }

    /**
     * Test container can be mapped for creation with container configuration,
     * i.e. the source container configuration is defined and contains only
     * defined environments.
     * 
     * A target configuration is created and mapped with defined volumes.
     */
    @Test
    public void testMapContainerForCreationWith_OneVolume() throws Exception {

	// create content
	Container command = contentMother.createContainerCommandWithContainerConfig(randomId, randomRepo, randomTag);

	// create source container configuration
	EmbeddedContainerConfiguration srcContainerConfig = command.getConfiguration();
	assertNotNull(srcContainerConfig);

	// define one volume
	contentMother.addVolume(command, randomMountpoint);

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);

	// test
	ContainerConfigurationVolumesMap actualVolumes = containerConfig.getVolumes();
	assertNotNull(actualVolumes);
	assertEquals(1, actualVolumes.size());
	assertTrue(actualVolumes.containsKey(randomMountpoint));
	assertTrue(actualVolumes.get(randomMountpoint) instanceof ContainerConfigurationVolumeNullValue);
    }

    /**
     * Test container can be mapped for creation with container configuration,
     * i.e. the source container configuration is defined and contains only
     * defined environments.
     * 
     * A target configuration is created and mapped with defined volumes.
     */
    @Test
    public void testMapContainerForCreationWith_TwoVolumes() throws Exception {

	// create content
	Container command = contentMother.createContainerCommandWithContainerConfig(randomId, randomRepo, randomTag);

	// create source container configuration
	EmbeddedContainerConfiguration srcContainerConfig = command.getConfiguration();
	assertNotNull(srcContainerConfig);

	// define one volume
	contentMother.addVolume(command, randomMountpoint);
	contentMother.addVolume(command, randomMountpoint2);

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);

	// test
	ContainerConfigurationVolumesMap actualVolumes = containerConfig.getVolumes();
	assertNotNull(actualVolumes);
	assertEquals(2, actualVolumes.size());
	assertTrue(actualVolumes.containsKey(randomMountpoint));
	assertTrue(actualVolumes.containsKey(randomMountpoint2));
	assertTrue(actualVolumes.get(randomMountpoint) instanceof ContainerConfigurationVolumeNullValue);
	assertTrue(actualVolumes.get(randomMountpoint2) instanceof ContainerConfigurationVolumeNullValue);
    }

    /**
     * Test container can be mapped for creation with container configuration,
     * i.e. the source container configuration is defined and contains only
     * defined environments.
     * 
     * A target configuration is created and mapped with defined volumes.
     */
    @Test
    public void testMapContainerForCreationWith_TwoIdenticalVolumesAreOnlyAddedOnce() throws Exception {

	// create content
	Container command = contentMother.createContainerCommandWithContainerConfig(randomId, randomRepo, randomTag);

	// create source container configuration
	EmbeddedContainerConfiguration srcContainerConfig = command.getConfiguration();
	assertNotNull(srcContainerConfig);

	// define one volume
	contentMother.addVolume(command, randomMountpoint);
	contentMother.addVolume(command, randomMountpoint);

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);

	// test
	ContainerConfigurationVolumesMap actualVolumes = containerConfig.getVolumes();
	assertNotNull(actualVolumes);
	assertEquals(1, actualVolumes.size());
	assertTrue(actualVolumes.containsKey(randomMountpoint));
	assertTrue(actualVolumes.get(randomMountpoint) instanceof ContainerConfigurationVolumeNullValue);
    }

    /**
     * Test container can be mapped for creation with container configuration,
     * i.e. the source container configuration is defined and contains only
     * defined labels.
     * 
     * A target configuration is created and mapped with defined labels.
     */
    @Test
    public void testMapContainerForCreationWith_ZeroLabels() throws Exception {

	// create content
	Container command = contentMother.createContainerCommandWithContainerConfig(randomId, randomRepo, randomTag);

	// create source container configuration
	EmbeddedContainerConfiguration srcContainerConfig = command.getConfiguration();
	assertNotNull(srcContainerConfig);

	// NO-OP: define zero labels

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);

	// test
	ContainerConfigurationLabelsMap actualLabels = containerConfig.getLabels();
	assertNotNull(actualLabels);
	assertEquals(0, actualLabels.size());
    }

    /**
     * Test container can be mapped for creation with container configuration,
     * i.e. the source container configuration is defined and contains only
     * defined labels.
     * 
     * A target configuration is created and mapped with defined labels.
     */
    @Test
    public void testMapContainerForCreationWith_OneLabel() throws Exception {

	// create content
	Container command = contentMother.createContainerCommandWithContainerConfig(randomId, randomRepo, randomTag);

	// create source container configuration
	EmbeddedContainerConfiguration srcContainerConfig = command.getConfiguration();
	assertNotNull(srcContainerConfig);

	// define one label
	contentMother.addLabel(command, randomName, randomValue);

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);

	// test
	ContainerConfigurationLabelsMap actualLabels = containerConfig.getLabels();
	assertNotNull(actualLabels);
	assertEquals(1, actualLabels.size());
	assertTrue(actualLabels.containsKey(randomName));
	assertEquals(randomValue, actualLabels.get(randomName));
	assertEquals(randomValue, actualLabels.get(randomName));
    }

    /**
     * Test container can be mapped for creation with container configuration,
     * i.e. the source container configuration is defined and contains only
     * defined labels.
     * 
     * A target configuration is created and mapped with defined labels.
     */
    @Test
    public void testMapContainerForCreationWith_TwoLabel() throws Exception {

	// create content
	Container command = contentMother.createContainerCommandWithContainerConfig(randomId, randomRepo, randomTag);

	// create source container configuration
	EmbeddedContainerConfiguration srcContainerConfig = command.getConfiguration();
	assertNotNull(srcContainerConfig);

	// define two labels
	contentMother.addLabel(command, randomName, randomValue);
	contentMother.addLabel(command, randomName2, randomValue2);

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);

	// test
	ContainerConfigurationLabelsMap actualLabels = containerConfig.getLabels();
	assertNotNull(actualLabels);
	assertEquals(2, actualLabels.size());
	assertTrue(actualLabels.containsKey(randomName));
	assertEquals(randomValue, actualLabels.get(randomName));
	assertTrue(actualLabels.containsKey(randomName2));
	assertEquals(randomValue2, actualLabels.get(randomName2));
    }

    /**
     * Test container can be mapped for creation with container configuration,
     * i.e. the source container configuration is defined and contains only
     * defined labels.
     * 
     * A target configuration is created and mapped with defined labels.
     */
    @Test
    public void testMapContainerForCreationWith_TwoIdenticalLabelsAreOnlyAddedOnce() throws Exception {

	// create content
	Container command = contentMother.createContainerCommandWithContainerConfig(randomId, randomRepo, randomTag);

	// create source container configuration
	EmbeddedContainerConfiguration srcContainerConfig = command.getConfiguration();
	assertNotNull(srcContainerConfig);

	// define two labels
	contentMother.addLabel(command, randomName, randomValue);
	contentMother.addLabel(command, randomName, randomValue);

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);

	// test
	ContainerConfigurationLabelsMap actualLabels = containerConfig.getLabels();
	assertNotNull(actualLabels);
	assertEquals(1, actualLabels.size());
	assertTrue(actualLabels.containsKey(randomName));
	assertEquals(randomValue, actualLabels.get(randomName));
    }

    /**
     * Test container can be mapped for creation with container configuration,
     * i.e. the source container configuration is defined and contains only
     * defined environments.
     * 
     * A target configuration is created and mapped with defined environments.
     */
    @Test
    public void testMapContainerForCreationWith_OnePortBinding() throws Exception {

	// create content
	Container command = contentMother.createContainerCommandWithContainerConfig(randomId, randomRepo, randomTag);

	// create source container configuration
	EmbeddedContainerConfiguration srcContainerConfig = command.getConfiguration();
	assertNotNull(srcContainerConfig);

	// define port binding
	contentMother.addTcpPortBinding(command, random);

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);

	// test
	ContainerConfigurationHostConfig hostConfig = containerConfig.getHostConfig();
	assertNotNull(hostConfig);
	ContainerConfigurationHostConfigPortBindingsMap bindings = hostConfig.getPortBindings();
	assertEquals(1, bindings.size());
    }

    /**
     * Test container can be mapped for creation with container configuration,
     * i.e. the source container configuration is defined and contains only
     * defined environments.
     * 
     * A target configuration is created and mapped with defined environments.
     */
    @Test
    public void testMapContainerForCreationWith_TwoPortBindings() throws Exception {

	// create content
	Container command = contentMother.createContainerCommandWithContainerConfig(randomId, randomRepo, randomTag);

	// create source container configuration
	EmbeddedContainerConfiguration srcContainerConfig = command.getConfiguration();
	assertNotNull(srcContainerConfig);

	// define port binding
	contentMother.addTcpPortBinding(command, random);
	contentMother.addTcpPortBinding(command, random);

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);

	// test
	ContainerConfigurationHostConfig hostConfig = containerConfig.getHostConfig();
	assertNotNull(hostConfig);
	ContainerConfigurationHostConfigPortBindingsMap bindings = hostConfig.getPortBindings();
	assertEquals(2, bindings.size());
    }

    /**
     * Test container can be mapped for creation with container configuration,
     * i.e. the source container configuration is defined and contains only
     * defined environments.
     * 
     * A target configuration is created and mapped with defined environments.
     */
    @Test
    public void testMapContainerForCreationWith_TwoIdenticalPortBindingsAreOnlyAddedOnce() throws Exception {

	// create content
	Container command = contentMother.createContainerCommandWithContainerConfig(randomId, randomRepo, randomTag);

	// create source container configuration
	EmbeddedContainerConfiguration srcContainerConfig = command.getConfiguration();
	assertNotNull(srcContainerConfig);

	// define port binding
	int portNumber = NetworkUtils.getRandomPort(random);
	contentMother.addTcpPortBinding(command, portNumber, portNumber);
	contentMother.addTcpPortBinding(command, portNumber, portNumber);

	// map
	ContainerInfo info = mapper.mapContainerForCreation(command, containerConfigs);

	// test
	com.alpha.pineapple.docker.model.rest.ContainerConfiguration containerConfig = info.getContainerConfiguration();
	assertNotNull(containerConfig);

	// test
	ContainerConfigurationHostConfig hostConfig = containerConfig.getHostConfig();
	assertNotNull(hostConfig);
	ContainerConfigurationHostConfigPortBindingsMap bindings = hostConfig.getPortBindings();
	assertEquals(1, bindings.size());
    }

}
package com.alpha.pineapple.docker.model;

import com.alpha.pineapple.docker.model.rest.ContainerConfiguration;
import com.alpha.pineapple.docker.model.rest.ContainerConfigurationExposedPortNullValue;
import com.alpha.pineapple.docker.model.rest.ContainerConfigurationHostConfig;
import com.alpha.pineapple.docker.model.rest.ContainerConfigurationVolumeNullValue;

 */
public interface ContainerInfo {

    /**
     * Return image info.
     * 
     * @return image info.
     */
    ImageInfo getImageInfo();

    /**
     * Return container name.
     * 
     * @return container name.
     */
    String getName();

    /**
     * Get container configuration.
     * 
     * @return container configuration.
     */
    ContainerConfiguration getContainerConfiguration();

    /**
     * Add exposed TCP port to container configuration.
     * 
     * The port is added with the expected Docker format &lt;port&gt;/tcp and a
     * null value object {@linkplain ContainerConfigurationExposedPortNullValue}
     * .
     * 
     * @param port
     *            number. Must be a value between 0 and 65535.
     */
    void addExposedTcpPort(int portNumber);

    /**
     * Add exposed UDP port to container configuration.
     * 
     * The port is added with the expected Docker format &lt;port&gt;/tcp and a
     * null value object {@linkplain ContainerConfigurationExposedPortNullValue}
     * .
     * 
     * @param port
     *            number. Must be a value between 0 and 65535.
     */
    void addExposedUdpPort(int portNumber);

    /**
     * Create port string according to the Docker format:
     * &lt;port&gt;/&lt;tcp|udp&gt;
     * 
     * @param portNumber
     *            IP port number.
     * @param portType
     *            port type. Should either be "udp" or "tcp".
     * 
     * @return port string.
     */
    String createPortString(int portNumber, String portType);

    /**
     * Add volume to container configuration.
     * 
     * The volume is added with a null value object
     * {@linkplain ContainerConfigurationVolumeNullValue}.
     * 
     * @param volume.
     */
    void addVolume(String volume);

    /**
     * Add environment variable.
     * 
     * @param name
     *            variable name.
     * @param value
     *            variable value.
     */
    void addEnvironmentVariable(String name, String value);

    /**
     * Add label.
     * 
     * @param key
     *            label key.
     * @param value
     *            label value.
     */
    void addLabel(String key, String value);

    /**
     * Add bound TCP port to host configuration. Container port is bound to host
     * port.
     * 
     * @param containerPortNumber
     *            Container host IP port number.
     * @param hostPortNumber
     *            host host IP port number.
     */
    void addTcpPortBinding(int containerPortNumber, int hostPortNumber);

    /**
     * Add bound UDP port to host configuration. Container port is bound to host
     * port.
     * 
     * @param containerPortNumber
     *            Container host IP port number.
     * @param hostPortNumber
     *            host host IP port number.
     */
    void addUdpPortBinding(int containerPortNumber, int hostPortNumber);
    
    /**
     * Create container host configuration object.
     * 
     * @return container host configuration object.
     */
    public ContainerConfigurationHostConfig createHostConfiguration();
    
}
import org.apache.commons.lang.Validate;

import com.alpha.javautils.NetworkUtils;
import com.alpha.pineapple.docker.model.jaxb.ContainerConfigurationExposedPortsMap;
import com.alpha.pineapple.docker.model.jaxb.ContainerConfigurationHostConfigPortBindingsMap;
import com.alpha.pineapple.docker.model.jaxb.ContainerConfigurationLabelsMap;
import com.alpha.pineapple.docker.model.jaxb.ContainerConfigurationVolumesMap;
import com.alpha.pineapple.docker.model.rest.ContainerConfiguration;
import com.alpha.pineapple.docker.model.rest.ContainerConfigurationHostConfig;
import com.alpha.pineapple.docker.model.rest.ContainerConfigurationHostConfigPortBindingValue;
import com.alpha.pineapple.docker.model.rest.ObjectFactory;

/**
 * Implementation of the {@linkplain ContainerInfo} interface.
 */
public class ContainerInfoImpl implements ContainerInfo {

    /**
     * Error message for port number validation.
     */
    static final String ILLEGAL_PORT_TEXT = "portNumber is illegal port number. Legal values are between 1 to 65535";

    /**
     * Image info.
     */
    ImageInfo info;

    /**
     * Container name.
     */
    String name;

    /**
     * Configuration which is passed to Docker upon creation.
     */
    ContainerConfiguration configuration;

    /**
     * Docker object factory.
     */
    static final ObjectFactory dockerModelObjectFactory = new ObjectFactory();

    /**
     * ContainerInfoImpl constructor.
     * 
     * @param id
     *            Container ID.
     * @param info
     *            image info.
     */
    ContainerInfoImpl(String id, ImageInfo info) {
	this.name = id;
	this.info = info;	
	configuration = dockerModelObjectFactory.createContainerConfiguration();
    }

    @Override
    public ImageInfo getImageInfo() {
	return info;
    }

    @Override
    public String getName() {
	return name;
    }

    @Override
    public ContainerConfiguration getContainerConfiguration() {
	return configuration;
    }

    @Override
    public void addExposedTcpPort(int portNumber) {
	addPort(portNumber, "tcp");
    }

    @Override
    public void addExposedUdpPort(int portNumber) {
	addPort(portNumber, "udp");
    }

    @Override
    public String createPortString(int portNumber, String portType) {
	String portKey = new StringBuilder().append(portNumber).append("/").append(portType.toLowerCase()).toString();
	return portKey;
    }

    /**
     * Add port.
     * 
     * If exposed ports map isn't defined in configuration then it is created.
     * 
     * @param portNumber
     *            IP port number.
     * @param portType
     *            port type.
     * 
     * @throws IllegalArgumentException
     *             if port number is invalid.
     */
    void addPort(int portNumber, String portType) {
	NetworkUtils.validatePort(portNumber);
	Validate.notNull(portType, "portType is undefined");
	Validate.notEmpty(portType, "portType is empty");

	String portKey = createPortString(portNumber, portType);
	if(configuration.getExposedPorts() == null) configuration.setExposedPorts(new ContainerConfigurationExposedPortsMap());
	ContainerConfigurationExposedPortsMap exposedPorts = configuration.getExposedPorts();	
	exposedPorts.put(portKey, dockerModelObjectFactory.createContainerConfigurationExposedPortNullValue());
    }

    @Override
    public void addVolume(String volume) {
	Validate.notNull(volume, "volume is undefined.");
	Validate.notEmpty(volume, "volume is empty.");

	// get volumes map 
	if(configuration.getVolumes() == null) configuration.setVolumes(new ContainerConfigurationVolumesMap());
	ContainerConfigurationVolumesMap volumes = configuration.getVolumes();
	
	// add volume
	volumes.put(volume, dockerModelObjectFactory.createContainerConfigurationVolumeNullValue());
    }

    @Override
    public void addEnvironmentVariable(String name, String value) {
	Validate.notNull(name, "name is undefined.");
	Validate.notEmpty(name, "name is empty.");
	Validate.notNull(value, "value is undefined.");
	Validate.notEmpty(value, "value is empty.");

	List<String> envs = configuration.getEnv();
	String env = new StringBuilder().append(name).append("=").append(value).toString();
	envs.add(env);
    }

    @Override
    public void addLabel(String key, String value) {
	Validate.notNull(key, "key is undefined.");
	Validate.notEmpty(key, "key is empty.");
	Validate.notNull(value, "value is undefined.");
	Validate.notEmpty(value, "value is empty.");

	// get labels map
	if(configuration.getLabels() == null) configuration.setLabels(new ContainerConfigurationLabelsMap());
	ContainerConfigurationLabelsMap labels = configuration.getLabels();
	
	// add label
	labels.put(key, value);
    }

    @Override
    public void addTcpPortBinding(int containerPortNumber, int hostPortNumber) {
	addPortBinding(containerPortNumber, "tcp", hostPortNumber);
    }

    @Override
    public void addUdpPortBinding(int containerPortNumber, int hostPortNumber) {
	addPortBinding(containerPortNumber, "udp", hostPortNumber);
    }

    /**
     * Add port binding.
     * 
     * @param containerPortNumber
     *            container port number.
     * @param containerPortType
     *            container port type.
     * @param hostPortNumber
     *            host port number.
     * 
     * @throws IllegalArgumentException
     *             if port number is invalid.
     */
    void addPortBinding(int containerPortNumber, String containerPortType, int hostPortNumber) {
	NetworkUtils.validatePort(containerPortNumber);
	Validate.notNull(containerPortType, "containerPortType is undefined.");
	Validate.notEmpty(containerPortType, "containerPortType is empty.");
	NetworkUtils.validatePort(hostPortNumber);

	// get host config
	if(configuration.getHostConfig() == null ) configuration.setHostConfig(dockerModelObjectFactory.createContainerConfigurationHostConfig());
	ContainerConfigurationHostConfig hostConfig = configuration.getHostConfig();

	// get binding map
	if(hostConfig.getPortBindings() == null) hostConfig.setPortBindings(new ContainerConfigurationHostConfigPortBindingsMap());		
	ContainerConfigurationHostConfigPortBindingsMap bindings = hostConfig.getPortBindings();
	
	// add binding
	String portKey = createPortString(containerPortNumber, containerPortType);
	ContainerConfigurationHostConfigPortBindingValue bindingValue;
	bindingValue = dockerModelObjectFactory.createContainerConfigurationHostConfigPortBindingValue();
	ContainerConfigurationHostConfigPortBindingValue[] valueArray = new ContainerConfigurationHostConfigPortBindingValue[] {
		bindingValue };
	bindingValue.setHostPort(Integer.toString(hostPortNumber));
	bindingValue.setHostIp(PORTBINDING_NULL_HOST_IP);
	bindings.put(portKey, valueArray);
    }

    @Override
    public ContainerConfigurationHostConfig createHostConfiguration() {
	if(configuration.getHostConfig()== null) 
	    configuration.setHostConfig(dockerModelObjectFactory.createContainerConfigurationHostConfig());
	return configuration.getHostConfig();
    }
    
    
}
/*
 *    Pineapple - a tool to install, configure and test Java web applications 
 *    and infrastructure. 
 *
 *    Copyright (C) 2007-2015 Allan Thrane Andersen..
 *
 *    This file is part of Pineapple.
 *
 *    Pineapple is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    Pineapple is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with Pineapple. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package com.alpha.pineapple.docker.model.jaxb;

import java.util.Map.Entry;
import java.util.Set;

import javax.xml.bind.annotation.adapters.XmlAdapter;

import com.alpha.pineapple.docker.model.rest.ContainerConfigurationExposedPort;
import com.alpha.pineapple.docker.model.rest.ContainerConfigurationExposedPorts;
import com.alpha.pineapple.docker.model.rest.ObjectFactory;

/**
 * {@linkplain XmlAdapter} sub class to support customized binding to a map for
 * the {@linkplain ContainerConfigurationExposedPorts} JAXB generated type.
 */
public class ContainerConfigurationExposedPortsMapAdapter
	extends XmlAdapter<ContainerConfigurationExposedPorts, ContainerConfigurationExposedPortsMap> {

    /**
     * Object factory.
     */
    ObjectFactory objectFactory = new ObjectFactory();

    @Override
    public ContainerConfigurationExposedPorts marshal(ContainerConfigurationExposedPortsMap map) throws Exception {
	ContainerConfigurationExposedPorts ports = objectFactory.createContainerConfigurationExposedPorts();
	Set<Entry<String, Object>> entries = map.entrySet();
	for (Entry<String, Object> entry : entries) {
	    ContainerConfigurationExposedPort port = objectFactory.createContainerConfigurationExposedPort();
	    port.setPort(entry.getKey());
	    port.setNullValue(objectFactory.createContainerConfigurationExposedPortNullValue());
	    ports.getPort().add(port);
	}
	return ports;
    }

    @Override
    public ContainerConfigurationExposedPortsMap unmarshal(ContainerConfigurationExposedPorts value) throws Exception {
	ContainerConfigurationExposedPortsMap map = new ContainerConfigurationExposedPortsMap();
	for (ContainerConfigurationExposedPort port : value.getPort()) {
	    map.put(port.getPort(), port.getNullValue());
	}
	return map;
    }

}
/*
 *    Pineapple - a tool to install, configure and test Java web applications 
 *    and infrastructure. 
 *
 *    Copyright (C) 2007-2015 Allan Thrane Andersen..
 *
 *    This file is part of Pineapple.
 *
 *    Pineapple is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    Pineapple is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with Pineapple. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package com.alpha.pineapple.docker.model.jaxb;

import java.util.List;
import java.util.Map.Entry;
import java.util.Set;

import javax.xml.bind.annotation.adapters.XmlAdapter;

import com.alpha.pineapple.docker.model.rest.ContainerConfigurationHostConfigPortBinding;
import com.alpha.pineapple.docker.model.rest.ContainerConfigurationHostConfigPortBindingValue;
import com.alpha.pineapple.docker.model.rest.ContainerConfigurationHostConfigPortBindings;
import com.alpha.pineapple.docker.model.rest.ObjectFactory;

/**
 * {@linkplain XmlAdapter} sub class to support customized binding to a map for
 * the {@linkplain ContainerConfigurationHostConfigPortBindings} JAXB generated
 * type.
 */
public class ContainerConfigurationHostConfigPortBindingsMapAdapter extends
	XmlAdapter<ContainerConfigurationHostConfigPortBindings, ContainerConfigurationHostConfigPortBindingsMap> {

    /**
     * Object factory.
     */
    ObjectFactory objectFactory = new ObjectFactory();

    @Override
    public ContainerConfigurationHostConfigPortBindings marshal(ContainerConfigurationHostConfigPortBindingsMap map)
	    throws Exception {
	ContainerConfigurationHostConfigPortBindings bindings = objectFactory
		.createContainerConfigurationHostConfigPortBindings();
	Set<Entry<String, ContainerConfigurationHostConfigPortBindingValue[]>> entries = map.entrySet();
	for (Entry<String, ContainerConfigurationHostConfigPortBindingValue[]> entry : entries) {

	    ContainerConfigurationHostConfigPortBinding binding = objectFactory
		    .createContainerConfigurationHostConfigPortBinding();
	    binding.setContainerPort(entry.getKey());
	    List<ContainerConfigurationHostConfigPortBindingValue> bindingValueList = binding.getValue();

	    // add values in array
	    for (ContainerConfigurationHostConfigPortBindingValue bindingValue : entry.getValue()) {
		bindingValueList.add(bindingValue);
	    }
	}
	return bindings;
    }

    @Override
    public ContainerConfigurationHostConfigPortBindingsMap unmarshal(ContainerConfigurationHostConfigPortBindings value)
	    throws Exception {
	ContainerConfigurationHostConfigPortBindingsMap map = new ContainerConfigurationHostConfigPortBindingsMap();
	for (ContainerConfigurationHostConfigPortBinding binding : value.getBinding()) {

	    List<ContainerConfigurationHostConfigPortBindingValue> valueList = binding.getValue();
	    ContainerConfigurationHostConfigPortBindingValue[] valueArray = new ContainerConfigurationHostConfigPortBindingValue[valueList
		    .size()];
	    valueArray = valueList.toArray(valueArray);
	    map.put(binding.getContainerPort(), valueArray);
	}
	return map;
    }

}

import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;

@SuppressWarnings("serial")
@XmlJavaTypeAdapter(ContainerConfigurationExposedPortsMapAdapter.class)
public class ContainerConfigurationExposedPortsMap extends HashMap<String, Object> {
}

import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;

import com.alpha.pineapple.docker.model.rest.ContainerConfigurationHostConfigPortBindingValue;

@SuppressWarnings("serial")
@XmlJavaTypeAdapter(ContainerConfigurationHostConfigPortBindingsMapAdapter.class)
public class ContainerConfigurationHostConfigPortBindingsMap
	extends HashMap<String, ContainerConfigurationHostConfigPortBindingValue[]> {
}
		</jaxb:bindings>		 
	</jaxb:bindings>

	<!-- Image definitions -->

	<jaxb:bindings schemaLocation="docker_1_0.xsd" >
	</jaxb:bindings>

	<jaxb:bindings schemaLocation="docker_1_0.xsd" >
		<jaxb:bindings node="//xs:complexType[@name='containerConfigurationExposedPortsType']" >
			<jaxb:class name="ContainerConfigurationExposedPorts" />				
		</jaxb:bindings>		 
	</jaxb:bindings>

	<jaxb:bindings schemaLocation="docker_1_0.xsd" >
		<jaxb:bindings node="//xs:complexType[@name='containerConfigurationExposedPortType']" >
			<jaxb:class name="ContainerConfigurationExposedPort" />				
		</jaxb:bindings>		 
	</jaxb:bindings>

	<jaxb:bindings schemaLocation="docker_1_0.xsd" >
		<jaxb:bindings node="//xs:complexType[@name='containerConfigurationExposedPortNullValueType']" >
			<jaxb:class name="ContainerConfigurationExposedPortNullValue" />				
		</jaxb:bindings>		 
	</jaxb:bindings>

	<jaxb:bindings schemaLocation="docker_1_0.xsd" >
		<jaxb:bindings node="//xs:complexType[@name='containerConfigurationVolumesType']" >
			<jaxb:class name="ContainerConfigurationVolumes" />				
		</jaxb:bindings>		 
		</jaxb:bindings>		 
	</jaxb:bindings>

	<jaxb:bindings schemaLocation="docker_1_0.xsd" > 
		<jaxb:bindings node="//xs:complexType[@name='containerConfigurationHostConfigPortBindingsType']" >
			<jaxb:class name="ContainerConfigurationHostConfigPortBindings" />				
		</jaxb:bindings>		 
	</jaxb:bindings>

	<jaxb:bindings schemaLocation="docker_1_0.xsd" >
		<jaxb:bindings node="//xs:complexType[@name='containerConfigurationHostConfigPortBindingType']" >
			<jaxb:class name="ContainerConfigurationHostConfigPortBinding" />				
		</jaxb:bindings>		 
	</jaxb:bindings>

	<jaxb:bindings schemaLocation="docker_1_0.xsd" >
		<jaxb:bindings node="//xs:complexType[@name='containerConfigurationHostConfigPortBindingValueType']" >
			<jaxb:class name="ContainerConfigurationHostConfigPortBindingValue" />				
		</jaxb:bindings>		 
	</jaxb:bindings>

	<jaxb:bindings schemaLocation="docker_1_0.xsd" >
		<jaxb:bindings node="//xs:complexType[@name='containerConfigurationHostConfigRestartPolicyType']" >
			<jaxb:class name="ContainerConfigurationHostConfigRestartPolicy" />				
	<jaxb:bindings schemaLocation="docker_1_0.xsd" >
		<jaxb:bindings node="//xs:complexType[@name='containerConfigurationType']//xs:element[@name='exposedPorts']">
			<jaxb:property>
				<jaxb:baseType name="com.alpha.pineapple.docker.model.jaxb.ContainerConfigurationExposedPortsMap" />
			</jaxb:property>
		</jaxb:bindings>
	</jaxb:bindings>
	<jaxb:bindings schemaLocation="docker_1_0.xsd" >
		<jaxb:bindings node="//xs:complexType[@name='containerConfigurationHostConfigType']//xs:element[@name='portBindings']">
			<jaxb:property>
				<jaxb:baseType name="com.alpha.pineapple.docker.model.jaxb.ContainerConfigurationHostConfigPortBindingsMap" />
			</jaxb:property>
		</jaxb:bindings>
	</jaxb:bindings>
		</jaxb:bindings>
	</jaxb:bindings>

	<!-- Map definitions for generic types -->

	<jaxb:bindings schemaLocation="docker_1_0.xsd" >

	<!-- 
		Corresponds to /pkg/jsonmessage/JSONProgress
		https://github.com/moby/moby/blob/eb8abc95985bf3882a4a177c409a96e36e25f5b7/pkg/jsonmessage/jsonmessage.go#L33
	-->
	<xs:complexType name="jsonProgressType" >
		<xs:annotation>

	<!-- 
		Corresponds to /pkg/jsonmessage/JSONError
		https://github.com/moby/moby/blob/eb8abc95985bf3882a4a177c409a96e36e25f5b7/pkg/jsonmessage/jsonmessage.go#L20
	-->
	<xs:complexType name="jsonErrorType" >
		<xs:annotation>
		<xs:attribute name="message" type="xs:string" use="optional"/> 			
	</xs:complexType>


	<!-- Image definitions -->


	<!-- 
		Corresponds to ImageInspect
		https://github.com/moby/moby/blob/04295d26df3034a9a92da8400418f843d7c48780/api/types/types.go	
	 -->
	<xs:complexType name="imageInspectType" >
		<xs:annotation>

	<!-- 
		Corresponds to Config    
		https://github.com/moby/moby/blob/04295d26df3034a9a92da8400418f843d7c48780/api/types/container/config.go
	 -->
	<xs:complexType name="containerConfigurationType" >
		<xs:annotation>
			<xs:element name="cmd" type="stringList" minOccurs="0" maxOccurs="1" />
			<xs:element name="entrypoint" type="stringList" minOccurs="0" maxOccurs="1" />
			<xs:element name="env" type="stringList" minOccurs="0" maxOccurs="1" />			
			<xs:element name="exposedPorts" type="containerConfigurationExposedPortsType" minOccurs="0" maxOccurs="1" />		
			<xs:element name="healthcheck" type="HealthConfigType" minOccurs="0" maxOccurs="1" />				
			<xs:element name="hostConfig" type="containerConfigurationHostConfigType" minOccurs="0" maxOccurs="1" />			
			<xs:element name="labels" type="containerConfigurationLabelsType" minOccurs="0" maxOccurs="1" />			
		</xs:sequence>
	</xs:complexType>

	<xs:complexType name="containerConfigurationExposedPortsType">
		<xs:annotation>
			<xs:documentation>Info about exposed ports in a container configuration and inspected container.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="port" type="containerConfigurationExposedPortType" minOccurs="0" maxOccurs="unbounded" />
		</xs:sequence>
	</xs:complexType>

	<xs:complexType name="containerConfigurationExposedPortType">
		<xs:annotation>
			<xs:documentation>
				Exposed port in container configuration and inspected container.
				The value isn't used by Docker, but a null value (an object) must be defined.
			</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="port" type="xs:string" />
			<xs:element name="nullValue" type="containerConfigurationExposedPortNullValueType" />
		</xs:sequence>
	</xs:complexType>

	<xs:complexType name="containerConfigurationExposedPortNullValueType">
		<xs:annotation>
			<xs:documentation>Null value for exposed port in container configuration and inspected container.</xs:documentation>
		</xs:annotation>
	</xs:complexType>

	<xs:complexType name="containerConfigurationVolumesType">
		<xs:annotation>
			<xs:documentation>Info about volumes in a container configuration.</xs:documentation>

	<!-- 
		Corresponds to HostConfig   
		https://github.com/moby/moby/blob/04295d26df3034a9a92da8400418f843d7c48780/api/types/container/host_config.go		

		Please notice:
		
			<xs:element name="links" type="stringList" minOccurs="0" maxOccurs="1" />				
			<xs:element name="restartPolicy" type="containerConfigurationHostConfigRestartPolicyType" minOccurs="0" maxOccurs="1" />
			<xs:element name="logConfig" type="containerConfigurationHostConfigLogConfigType" minOccurs="0" maxOccurs="1" />
			<xs:element name="portBindings" type="containerConfigurationHostConfigPortBindingsType" minOccurs="0" maxOccurs="1" />
			<xs:element name="blkioWeightDevice" type="weightDevicesType" minOccurs="0" maxOccurs="1" />
			<xs:element name="blkioDeviceReadBps" type="throttleDevicesType" minOccurs="0" maxOccurs="1" />
			<xs:element name="blkioDeviceWriteBps" type="throttleDevicesType" minOccurs="0" maxOccurs="1" />
		<xs:attribute name="volumeDriver" type="xs:string" use="optional"/> 											
	</xs:complexType>

	<xs:complexType name="containerConfigurationHostConfigPortBindingsType" >
		<xs:annotation>
			<xs:documentation>Port bindings configuration in container host configuration and container inspection.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="binding" type="containerConfigurationHostConfigPortBindingType" minOccurs="0" maxOccurs="unbounded" />
 		</xs:sequence>		
	</xs:complexType>

	<xs:complexType name="containerConfigurationHostConfigPortBindingType">
		<xs:annotation>
			<xs:documentation>Port binding configuration in container host configuration and container inspection.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="containerPort" type="xs:string" minOccurs="0" maxOccurs="1" />
			<xs:element name="value" type="containerConfigurationHostConfigPortBindingValueType" minOccurs="0" maxOccurs="unbounded" />						
		</xs:sequence>
	</xs:complexType>

	<xs:complexType name="containerConfigurationHostConfigPortBindingValueType">
		<xs:annotation>
			<xs:documentation>Port binding value in container host configuration and container inspection.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="hostPort" type="xs:string" />
			<xs:element name="hostIp" type="xs:string" /> <!-- hostIP is only used for container inspection -->
		</xs:sequence>
	</xs:complexType>

	<xs:complexType name="containerConfigurationHostConfigLogConfigType" >
		<xs:annotation>
			<xs:documentation>

	<!-- 
		Corresponds to ContainerJSON   
		https://github.com/moby/moby/blob/04295d26df3034a9a92da8400418f843d7c48780/api/types/types.go	 
	-->
	<xs:complexType name="containerJsonType" >
		<xs:annotation>
		<xs:attribute name="status" type="xs:string" use="optional"/>			
	</xs:complexType>

	<xs:complexType name="inspectedContainerNetworkSettingsType" >
		<xs:annotation>
			<xs:documentation>Info about the network configuration of a Docker container (Partial output from inspecting a container).</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="ports" type="containerConfigurationExposedPortsType" minOccurs="0" maxOccurs="1" />
			<xs:element name="networks" type="inspectedContainerNetworkSettingsNetworksType" minOccurs="0" maxOccurs="1" />			
 		</xs:sequence>
		<xs:attribute name="bridge" type="xs:string" use="optional"/>		
Development documentation
	The project uses JABX through the Maven 2 plugin <<<maven-jaxb2-plugin>>> 
	to generate classes from XML schemas.		
	 	
** Customized package names
	 	
	The generated classes are mapping into the package 
	<<<com.alpha.pineapple.docker.model.rest>>> using the JAXB bindings file at:
	<<<src/main/resources/bindings.xjb>>>.

** Customized type names
	
	The JAXB bindings file also defines mappings of Schema type into
	Java types. The applied rule is to remove the postfixed <<<Type>>>
Development documentation
	
	Partial output from the {{{https://docs.docker.com/engine/api/v1.28/#operation/ContainerInspect}Inspect a container (v1.28)}} operation.	
	
	Defined Docker type: {{{https://github.com/moby/moby/blob/04295d26df3034a9a92da8400418f843d7c48780/api/types/blkiodev/blkio.go}WeightDevice}}

*** weightDevicesType	

Development documentation

	Partial output from the {{{https://docs.docker.com/engine/api/v1.28/#operation/ContainerInspect}Inspect a container (v1.28)}} operation.	
	
	Defined Docker type: {{{https://github.com/moby/moby/blob/04295d26df3034a9a92da8400418f843d7c48780/api/types/blkiodev/blkio.go}WeightDevice}}
	
*** throttleDevicesType	

Development documentation

	Partial output from the {{{https://docs.docker.com/engine/api/v1.28/#operation/ContainerInspect}Inspect a container (v1.28)}} operation.	
	
	Defined Docker type: {{{https://github.com/moby/moby/blob/04295d26df3034a9a92da8400418f843d7c48780/api/types/blkiodev/blkio.go}ThrottleDevice}}

*** MountType	
	
	Partial output from the {{{https://docs.docker.com/engine/api/v1.28/#operation/ContainerInspect}Inspect a container (v1.28)}} operation.	
	
	Defined Docker type: {{{https://github.com/moby/moby/blob/04295d26df3034a9a92da8400418f843d7c48780/api/types/blkiodev/blkio.go}Mount}}

** Schema types for images

*** jsonProgressType 

Development documentation
	
	Used by the schema type <<<jsonMessageType>>>.
	
	Defined Docker type: {{{https://github.com/moby/moby/blob/eb8abc95985bf3882a4a177c409a96e36e25f5b7/pkg/jsonmessage/jsonmessage.go}JSONProgress}}

*** jsonErrorType 

	JSONError wraps a concrete Code and Message, Code is is an integer error code, Message is the error message
		
	Used by the schema type <<<jsonMessageType>>>.
	
	Defined Docker type: {{{https://github.com/moby/moby/blob/eb8abc95985bf3882a4a177c409a96e36e25f5b7/pkg/jsonmessage/jsonmessage.go}JSONError}}

*** listedImageType

Development documentation
		
	Output from the {{{https://docs.docker.com/engine/api/v1.28/#operation/ImageInspect}Inspect an image (v1.28)}} operation.	
	
	Defined Docker type: {{{https://github.com/docker/docker/blob/04295d26df3034a9a92da8400418f843d7c48780/api/types/types.go}ImageInspect}}
	
*** jsonMessageType	
	
	Info about Docker image creation progress.
	
	Defined Docker type: {{{https://github.com/moby/moby/blob/eb8abc95985bf3882a4a177c409a96e36e25f5b7/pkg/jsonmessage/jsonmessage.go}JSONMessage}}	
	
*** imageDeletionType

Development documentation
	
	[]

	Defined Docker type: {{{https://github.com/docker/docker/blob/04295d26df3034a9a92da8400418f843d7c48780/api/types/container/config.go}container.Config}}


*** containerJson

	Info about an inspected Docker container. 

	Partial output from the {{{https://docs.docker.com/engine/api/v1.28/#operation/ContainerInspect}Inspect a container (v1.28)}} operation.	
	
	Defined Docker type: {{{https://github.com/moby/moby/blob/04295d26df3034a9a92da8400418f843d7c48780/api/types/types.go}ContainerJSON}}

*** containerConfigurationType

Development documentation
	Partial output from the {{{https://docs.docker.com/engine/api/v1.28/#operation/ContainerInspect}Inspect a container (v1.28)}} and 
	{{{https://docs.docker.com/engine/api/v1.28/#operation/ImageInspect}Inspect an image (v1.28)}} operations.	

	Defined Docker type: {{{https://github.com/moby/moby/blob/04295d26df3034a9a92da8400418f843d7c48780/api/types/types.go}HostConfig}}
	
	Used by these schema types:
	
Development documentation
	
	Partial output from the {{{https://docs.docker.com/engine/api/v1.28/#operation/ContainerInspect}Inspect a container (v1.28)}} operation.	

	Defined Docker type: {{{https://github.com/moby/moby/blob/04295d26df3034a9a92da8400418f843d7c48780/api/types/types.go}HostConfig}}
	
	Used by these schema types:
	
Development documentation
	
	Partial output from the {{{https://docs.docker.com/engine/api/v1.28/#operation/ContainerInspect}Inspect a container (v1.28)}} operation.	

	Defined Docker type: {{{https://github.com/moby/moby/blob/04295d26df3034a9a92da8400418f843d7c48780/api/types/types.go}HostConfig}}
	
	Used by these schema types:
	
Development documentation

	The schema contains these types for handling container:
	

	* <<<containerConfigurationExposedPortType>>> - Docker container configuration of a single exposed port 
	(Input to container creation and output from container inspection).
	The JSON marshalled from this type when the Docker REST API is invoked
	requires a map with values with the format: <<<\{ "\<port\>/\<tcp|udp\>: \{\}" \}>>>.
	To support this requirement the exposed port type defines a port (the port/protocol part)
	and a null value (the \{\} part). To generate the null object for the value the 
	<<<containerConfigurationExposedPortNullValueType>>> is used.

	* <<<containerConfigurationExposedPortNullValueType>>> - Null value for
	export port (Input to container creation and output from container inspection).

	* <<<containerConfigurationExposedPortsType>>> - Docker container configuration of a map of 
	exposed ports (Input to container creation and output from container inspection). 
	Each port is defined using the <<<containerConfigurationExposedPortType>>>.
	During marshalling the type is bound to the map 
	<<<ContainerConfigurationExposedPortsMap>>> using the 
	<<<ContainerConfigurationExposedPortsMapAdapter>>>.

	* <<<containerConfigurationLabelType>>> - Docker container configuration of a label
	(Input to container creation, output from container inspection and listing of containers).
	The JSON marshalled from this type when the Docker REST API is invoked
Development documentation
	<<<ContainerConfigurationVolumesMap>>> using the 
	<<<ContainerConfigurationVolumesMapAdapter>>>.

	* <<<containerConfigurationHostConfigPortBindingValueType>>> - Value for port binding

	* <<<containerConfigurationHostConfigPortBindingType>>> - Docker container configuration of a port binding
	(Input to container creation and output from container inspection).
	The JSON marshalled from this type when the Docker REST API is invoked
	requires a map with values with the format: <<<\{ "22/tcp": [\{ "HostPort": "11022" \}] \} >>>.
	To support this requirement the binding type defines a key (element named containerPort) and value (element named value).
	The value is of the type <<<containerConfigurationHostConfigPortBindingValueType>>>.

	* <<<containerConfigurationHostConfigPortBindingsType>>> - Docker container configuration of a map of 
	port bindings (Input to container creation and output from container inspection). 
	Each label is defined using the <<<containerConfigurationHostConfigPortBindingType>>>.
	During marshalling the type is bound to the map 
	<<<ContainerConfigurationHostConfigPortBindingsMap>>> using the 
	<<<ContainerConfigurationHostConfigPortBindingsMapAdapter>>>.

	* <<<createdContainerType>>> - Info about created Docker container 
	(Output from container creation).

Development documentation
*** Exposed ports

	To support binding of schema element <<<containerConfigurationType.exposedPorts>>> to a map, 
	the binding is customized to bind to the custom map <<<ContainerConfigurationExposedPortsMap>>> 
	using the custom JABX adaptor <<<ContainerConfigurationExposedPortsMapAdapter>>>.

*** Labels

	To support binding of schema element <<<containerConfigurationType.labels>>> to a map, 
	the binding is customized to bind to the custom map <<<ContainerConfigurationLabelsMap>>> 
	using the custom JABX adaptor <<<ContainerConfigurationLabelsMapAdapter>>>.
	The map and JAXB adaptor is shared with the other bindings in the section.

	To support binding of schema element <<<listedContainerType.labels>>> to a map, 
	the binding is customized to bind to the custom map <<<ContainerConfigurationLabelsMap>>> 
	using the custom JABX adaptor <<<ContainerConfigurationLabelsMapAdapter>>>.
	The map and JAXB adaptor is shared with the other bindings in the section.
	
	To support binding of schema element <<<inspectedImageContainerType.labels>>> to a map, 
	the binding is customized to bind to the custom map <<<ContainerConfigurationLabelsMap>>> 
	using the custom JABX adaptor <<<ContainerConfigurationLabelsMapAdapter>>>.
	The map and JAXB adaptor is shared with the other bindings in the section.

	To support binding of schema element <<<listedImageType.labels>>> to a map, 
	the binding is customized to bind to the custom map <<<ContainerConfigurationLabelsMap>>> 
	using the custom JABX adaptor <<<ContainerConfigurationLabelsMapAdapter>>>.
	The map and JAXB adaptor is shared with the other bindings in the section.

*** Port binding

	To support binding of schema element <<<containerConfigurationHostConfigType.portBindings>>> to a map, 
	the binding is customized to bind to the custom map <<<ContainerConfigurationHostConfigPortBindingsMap>>> 
	using the custom JABX adaptor <<<ContainerConfigurationHostConfigPortBindingsMapAdapter>>>.

*** Restart policy

	TODO:..

*** Volumes

	To support binding of <<<containerConfigurationType.volumes>>> to a map, the binding is customized
	to bind to the custom map <<<ContainerConfigurationVolumesMap>> using the custom JABX adaptor
	<<<ContainerConfigurationVolumesMapAdapter>>>.

*** Network

	To support binding of schema element <<<inspectedContainerNetworkSettingsType.networks>>> to a map, 
	the binding is customized to bind to the custom map <<<InspectedContainerNetworkSettingsNetworksMap>>> 
	using the custom JABX adaptor <<<InspectedContainerNetworkSettingsNetworksMapAdapter>>>.
	
*** GraphDriver Data

	To support binding of schema element <<<inspectedImageGraphDriverType.data>>> to a map, 
	the binding is customized to bind to the custom map <<<GraphDriverDataMap>>> 
	using the custom JABX adaptor <<<GraphDriverDataMapAdapter>>>.
	The map and JAXB adaptor is shared with the other bindings in the section.
	
Development documentation
	error handling from for RestTemlpate: 
	
	* <<<RestResponseErrorHandler>>> which implements the <<<ResponseErrorHandler>>> interface 
	to provide a customized error handler for exceptions returned by RestTemplate. The error handle 
	captures the exception from	RestTemplate and information from the HTTP response. The handler 
	then throws a <<<RestResponseException>>> with all the collected data.

Development documentation
	The package <<<com.alpha.pineapple.docker.utils>>> also contains helper classes used during marshalling JSON to objects:

	* <<<UpperCaseStyleStrategy>>> implements the Jackson <<<PropertyNamingStrategy>>> interface 
	to provide a customized property naming strategy during marshalling. The strategy generates
	upper case target attribute names in objects for for JSON attribute to be mapped to. Special cases:
	
		* If the target object attribute is <<<ListedImage.id>>> then the received JSON property <<<Id>>> is
Development documentation
		
	[]

** Support for customized JAXB bindings 

	The package <<<com.alpha.pineapple.docker.model.jaxb>>> contains objects 
	for implementation of customized JAXB bindings:

	* <<<ContainerConfigurationExposedPortsMap>>> custom map implementation. 
	Used bind to the schema generated type <<<ContainerConfigurationExposedPorts>>> into a map.

	* <<<ContainerConfigurationExposedPortsMapAdapter>>> JAXB binding adapter. 
	Implements binding of schema generated type <<<ContainerConfigurationExposedPorts>>>
	to <<<ContainerConfigurationExposedPortsMap>>> and back.

	* <<<ContainerConfigurationLabelsMap>>> custom map implementation. 
	Used bind to the schema generated type <<<ContainerConfigurationLabels>>>,
Development documentation
	Implements binding of schema generated type <<<ContainerConfigurationVolumes>>>
	to <<<ContainerConfigurationVolumesMap>>> and back.

	* <<<ContainerConfigurationHostConfigPortBindingsMap>>> custom map implementation. 
	Used bind to the schema generated type <<<ContainerConfigurationHostConfigPortBinding>>> into a map.

	* <<<ContainerConfigurationHostConfigPortBindingsMapAdapter>>> JAXB binding adapter. 
	Implements binding of schema generated type <<<ContainerConfigurationHostConfigPortBinding>>>
	to <<<ContainerConfigurationHostConfigPortBindingsMap>>> and back.

	[]
			
** General test utilities 
import com.alpha.pineapple.docker.model.ContainerInstanceInfo;
import com.alpha.pineapple.docker.model.ImageInfo;
import com.alpha.pineapple.docker.model.InfoBuilder;
import com.alpha.pineapple.docker.model.jaxb.ContainerConfigurationExposedPortsMap;
import com.alpha.pineapple.docker.model.jaxb.ContainerConfigurationHostConfigPortBindingsMap;
import com.alpha.pineapple.docker.model.jaxb.ContainerConfigurationLabelsMap;
import com.alpha.pineapple.docker.model.jaxb.ContainerConfigurationVolumesMap;
import com.alpha.pineapple.docker.model.rest.ContainerConfiguration;
import com.alpha.pineapple.docker.model.rest.ContainerConfigurationHostConfig;
import com.alpha.pineapple.docker.model.rest.ContainerConfigurationHostConfigPortBindingValue;
import com.alpha.pineapple.docker.model.rest.ContainerJson;
import com.alpha.pineapple.docker.model.rest.ObjectFactory;
import com.alpha.pineapple.docker.session.DockerSession;
import com.alpha.pineapple.docker.utils.RestResponseException;
import com.alpha.pineapple.execution.ExecutionResult;
public void testCommandCanCreateContainerWithOneExposedTcpPort() throws Exceptio
		assertNotNull(inspectedContainer);
		ContainerConfiguration actualConfiguration = inspectedContainer.getConfig();
		assertNotNull(actualConfiguration);
		ContainerConfigurationExposedPortsMap exposedPorts = actualConfiguration.getExposedPorts();
		assertNotNull(exposedPorts);
		assertEquals(1, exposedPorts.size());
		assertTrue(exposedPorts.containsKey(containerInfo.createPortString(PORT_NUMBER, "tcp")));
public void testCommandCanCreateContainerWithOneExposedUdpPort() throws Exceptio
		assertNotNull(inspectedContainer);
		ContainerConfiguration actualConfiguration = inspectedContainer.getConfig();
		assertNotNull(actualConfiguration);
		ContainerConfigurationExposedPortsMap exposedPorts = actualConfiguration.getExposedPorts();
		assertNotNull(exposedPorts);
		assertEquals(1, exposedPorts.size());
		assertTrue(exposedPorts.containsKey(containerInfo.createPortString(PORT_NUMBER, "udp")));
public void testCommandCanCreateContainerWithTwoExposedTcpPort() throws Exceptio
		assertNotNull(inspectedContainer);
		ContainerConfiguration actualConfiguration = inspectedContainer.getConfig();
		assertNotNull(actualConfiguration);
		ContainerConfigurationExposedPortsMap exposedPorts = actualConfiguration.getExposedPorts();
		assertNotNull(exposedPorts);
		assertEquals(2, exposedPorts.size());
		assertTrue(exposedPorts.containsKey(containerInfo.createPortString(PORT_NUMBER, "tcp")));
public void testCommandCanCreateContainerWithOneTcpPortBinding() throws Exceptio
		assertTrue(dockerClient.containerExists(session, containerInstanceInfo.getContainerInfo()));
		ContainerJson inspectedContainer = dockerHelper.inspectContainer(session, containerInfo);
		assertNotNull(inspectedContainer);
		ContainerConfigurationHostConfigPortBindingsMap portBindings = inspectedContainer.getHostConfig()
				.getPortBindings();
		assertNotNull(portBindings);
		assertEquals(1, portBindings.size());
		String bindingKey = containerInfo.createPortString(randomPort, "tcp");
		assertTrue(portBindings.containsKey(bindingKey));
		ContainerConfigurationHostConfigPortBindingValue[] bindingArray = portBindings.get(bindingKey);
		assertEquals(1, bindingArray.length);
		assertEquals("", bindingArray[FIRST_INDEX].getHostIp());
		assertEquals(Integer.toString(randomPort), bindingArray[FIRST_INDEX].getHostPort());
public void testCommandCanCreateContainerWithOneUdpPortBinding() throws Exceptio
		assertTrue(dockerClient.containerExists(session, containerInstanceInfo.getContainerInfo()));
		ContainerJson inspectedContainer = dockerHelper.inspectContainer(session, containerInfo);
		assertNotNull(inspectedContainer);
		ContainerConfigurationHostConfigPortBindingsMap portBindings = inspectedContainer.getHostConfig()
				.getPortBindings();
		assertNotNull(portBindings);
		assertEquals(1, portBindings.size());
		String bindingKey = containerInfo.createPortString(randomPort, "udp");
		assertTrue(portBindings.containsKey(bindingKey));
		ContainerConfigurationHostConfigPortBindingValue[] bindingArray = portBindings.get(bindingKey);
		assertEquals(1, bindingArray.length);
		assertEquals("", bindingArray[FIRST_INDEX].getHostIp());
		assertEquals(Integer.toString(randomPort), bindingArray[FIRST_INDEX].getHostPort());
public void testCommandCanCreateContainerWithTwoTcpPortBindings() throws Excepti
		assertTrue(dockerClient.containerExists(session, containerInstanceInfo.getContainerInfo()));
		ContainerJson inspectedContainer = dockerHelper.inspectContainer(session, containerInfo);
		assertNotNull(inspectedContainer);
		ContainerConfigurationHostConfigPortBindingsMap portBindings = inspectedContainer.getHostConfig()
				.getPortBindings();
		assertNotNull(portBindings);
		assertEquals(2, portBindings.size());
		String bindingKey = containerInfo.createPortString(randomPort, "tcp");
		assertTrue(portBindings.containsKey(bindingKey));
		ContainerConfigurationHostConfigPortBindingValue[] bindingArray = portBindings.get(bindingKey);
		assertEquals(1, bindingArray.length);
		assertEquals("", bindingArray[FIRST_INDEX].getHostIp());
		assertEquals(Integer.toString(randomPort), bindingArray[FIRST_INDEX].getHostPort());
		String bindingKey2 = containerInfo.createPortString(randomPort2, "tcp");
		assertTrue(portBindings.containsKey(bindingKey2));
		ContainerConfigurationHostConfigPortBindingValue[] bindingArray2 = portBindings.get(bindingKey2);
		assertEquals(1, bindingArray2.length);
		assertEquals("", bindingArray2[FIRST_INDEX].getHostIp());
		assertEquals(Integer.toString(randomPort2), bindingArray2[FIRST_INDEX].getHostPort());
public void testCommandCanCreateContainerWithOneUdpPortBindingWithDifferentHostA
		assertTrue(dockerClient.containerExists(session, containerInstanceInfo.getContainerInfo()));
		ContainerJson inspectedContainer = dockerHelper.inspectContainer(session, containerInfo);
		assertNotNull(inspectedContainer);
		ContainerConfigurationHostConfigPortBindingsMap portBindings = inspectedContainer.getHostConfig()
				.getPortBindings();
		assertNotNull(portBindings);
		assertEquals(1, portBindings.size());
		String bindingKey = containerInfo.createPortString(randomPort, "udp");
		assertTrue(portBindings.containsKey(bindingKey));
		ContainerConfigurationHostConfigPortBindingValue[] bindingArray = portBindings.get(bindingKey);
		assertEquals(1, bindingArray.length);
		assertEquals("", bindingArray[FIRST_INDEX].getHostIp());
		assertEquals(Integer.toString(randomPort2), bindingArray[FIRST_INDEX].getHostPort());
public void testCommandCanCreateContainerWithTwoIdenticalUdpPortBindings() throw
		assertTrue(dockerClient.containerExists(session, containerInstanceInfo.getContainerInfo()));
		ContainerJson inspectedContainer = dockerHelper.inspectContainer(session, containerInfo);
		assertNotNull(inspectedContainer);
		ContainerConfigurationHostConfigPortBindingsMap portBindings = inspectedContainer.getHostConfig()
				.getPortBindings();
		assertNotNull(portBindings);
		assertEquals(1, portBindings.size());
		String bindingKey = containerInfo.createPortString(randomPort, "udp");
		assertTrue(portBindings.containsKey(bindingKey));
		ContainerConfigurationHostConfigPortBindingValue[] bindingArray = portBindings.get(bindingKey);
		assertEquals(1, bindingArray.length);
		assertEquals("", bindingArray[FIRST_INDEX].getHostIp());
		assertEquals(Integer.toString(randomPort), bindingArray[FIRST_INDEX].getHostPort());
import org.junit.Test;
import org.springframework.test.util.ReflectionTestUtils;

import com.alpha.pineapple.docker.model.jaxb.ContainerConfigurationExposedPortsMap;
import com.alpha.pineapple.docker.model.jaxb.ContainerConfigurationHostConfigPortBindingsMap;
import com.alpha.pineapple.docker.model.jaxb.ContainerConfigurationLabelsMap;
import com.alpha.pineapple.docker.model.jaxb.ContainerConfigurationVolumesMap;
import com.alpha.pineapple.docker.model.rest.ContainerConfiguration;
import com.alpha.pineapple.docker.model.rest.ContainerConfigurationExposedPortNullValue;
import com.alpha.pineapple.docker.model.rest.ContainerConfigurationHostConfig;
import com.alpha.pineapple.docker.model.rest.ContainerConfigurationHostConfigPortBindingValue;
import com.alpha.pineapple.docker.model.rest.ContainerConfigurationVolumeNullValue;

/**
 * Unit test of the class {@linkplain ContainerInfoImpl}.
 *
 */
public class ContainerInfoImplTest {

    /**
     * First array index.
     */
    static final int FIRST_INDEX = 0;

    /**
     * Image info.
     */
    ImageInfo imageInfo;

    /**
     * Subject under test.
     */
    ContainerInfo containerInfo;

    /**
     * Random value.
     */
    String randomValue;

    /**
     * Random value.
     */
    String randomValue2;

    /**
     * Info builder.
     */
    InfoBuilderImpl infobuilder;

    @Before
    public void setUp() throws Exception {
	randomValue = RandomStringUtils.randomAlphabetic(10);
	randomValue2 = RandomStringUtils.randomAlphabetic(10);
	infobuilder = new InfoBuilderImpl();
    }

    @After
    public void tearDown() throws Exception {
	imageInfo = null;
    }

    /**
     * Test that instance is created with expected name.
     */
    @Test
    public void testHasExpectedName() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);

	// test
	assertEquals(randomValue, containerInfo.getName());
    }

    /**
     * Test that instance is created with expected image info.
     */
    @Test
    public void testHasExpectedImageInfo() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);

	// test
	assertEquals(imageInfo, containerInfo.getImageInfo());
    }

    /**
     * Test that instance is created with defined container configuration..
     */
    @Test
    public void testHasDefinedContainerConfiguration() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);

	// test
	assertNotNull(containerInfo.getContainerConfiguration());
    }
    
    /**
     * Test that container configuration returns defined environment variables list when queried.
     */
    @Test
    public void testContainerConfigurationInitiallyReturnsEnvironmentVariablesListWhenQueried() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	assertNotNull(containeConfig);
	assertNotNull(containeConfig.getEnv());
    }

    /**
     * Test that using internal inspection of container configuration reveals initial undefined environment variables list.
     */
    @Test
    public void testInternalInspectionOfContainerConfigurationReturnsUndefinedEnvironmentVariablesList() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	assertNotNull(containeConfig);	
	assertNull(ReflectionTestUtils.getField(containeConfig, "env"));
    }

    /**
     * Test that container configuration returns defined command list when queried.
     */
    @Test
    public void testContainerConfigurationInitiallyReturnsCommandListWhenQueried() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	assertNotNull(containeConfig);
	assertNotNull(containeConfig.getCmd());
    }

    /**
     * Test that using internal inspection of container configuration reveals initial undefined command list.
     */
    @Test
    public void testInternalInspectionOfContainerConfigurationReturnsUndefinedCommandList() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	assertNotNull(containeConfig);	
	assertNull(ReflectionTestUtils.getField(containeConfig, "cmd"));
    }
    
    /**
     * Test that container configuration returns defined entrypoint list when queried.
     */
    @Test
    public void testContainerConfigurationInitiallyReturnsEntryppointListWhenQueried() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	assertNotNull(containeConfig);
	assertNotNull(containeConfig.getEntrypoint());
    }

    /**
     * Test that using internal inspection of container configuration reveals initial undefined entrypoint list.
     */
    @Test
    public void testInternalInspectionOfContainerConfigurationReturnsUndefinedEntrypointList() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	assertNotNull(containeConfig);	
	assertNull(ReflectionTestUtils.getField(containeConfig, "entrypoint"));
    }
    
    /**
     * Test that container configuration returns defined onbuild list when queried.
     */
    @Test
    public void testContainerConfigurationInitiallyReturnsOnbuildListWhenQueried() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	assertNotNull(containeConfig);
	assertNotNull(containeConfig.getOnBuild());
    }
    
    /**
     * Test that using internal inspection of container configuration reveals initial undefined onbuild list.
     */
    @Test
    public void testInternalInspectionOfContainerConfigurationReturnsUndefinedOnbuildList() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	assertNotNull(containeConfig);	
	assertNull(ReflectionTestUtils.getField(containeConfig, "onBuild"));
    }
    
    /**
     * Test that container configuration returns initially undefined environment variables map.
     */
    @Test
    public void testContainerConfigurationHasInitiallyUndefinedLabelsMap() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	assertNotNull(containeConfig);
	ContainerConfigurationLabelsMap labels = containeConfig.getLabels();
	assertNull(labels);
    }

    /**
     * Test that container configuration returns initially undefined exposed ports map.
     */
    @Test
    public void testContainerConfigurationHasInitiallyUndefinedExposedPortsMap() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	assertNotNull(containeConfig);
	ContainerConfigurationExposedPortsMap exposedPorts = containeConfig.getExposedPorts();
	assertNull(exposedPorts);
    }

    /**
     * Test that container configuration return initially undefined volumes map.
     */
    @Test
    public void testContainerConfigurationHasInitiallyUndefinedVolumesMap() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	assertNotNull(containeConfig);
	assertNull(containeConfig.getVolumes());
    }

    /**
     * Test that container configuration has initially undefined host configuration, e.g null.
     */
    @Test
    public void testContainerConfigurationHasInitiallyUndefinedHostConfig() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	assertNotNull(containeConfig);
	assertNull(containeConfig.getHostConfig());
    }

    /**
     * Test that a legal TCP port can be added to the exposed ports.
     */
    @Test
    public void testLegalTcpPortCanBeAddedToExposedPorts() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addExposedTcpPort(1024);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	ContainerConfigurationExposedPortsMap exposedPorts = containeConfig.getExposedPorts();
	assertEquals(1, exposedPorts.size());
	assertTrue(exposedPorts.containsKey("1024/tcp"));
	Object port = exposedPorts.get("1024/tcp");
	assertTrue(port instanceof ContainerConfigurationExposedPortNullValue);
    }

    /**
     * Test that a legal UDP port can be added to the exposed ports.
     */
    @Test
    public void testLegalUdpPortCanBeAddedToExposedPorts() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addExposedUdpPort(1024);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	ContainerConfigurationExposedPortsMap exposedPorts = containeConfig.getExposedPorts();
	assertEquals(1, exposedPorts.size());
	assertTrue(exposedPorts.containsKey("1024/udp"));
	Object port = exposedPorts.get("1024/udp");
	assertTrue(port instanceof ContainerConfigurationExposedPortNullValue);
    }

    /**
     * Test that a adding an illegal UDP port fails.
     */
    @Test(expected = IllegalArgumentException.class)
    public void testFailsToAddZeroUdpPortToExposedPorts() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addExposedUdpPort(0);
    }

    /**
     * Test that a adding an illegal UDP port fails.
     */
    @Test(expected = IllegalArgumentException.class)
    public void testFailsToAddNegativeUdpPortToExposedPorts() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addExposedUdpPort(-1);
    }

    /**
     * Test that a adding an illegal UDP port fails.
     */
    @Test(expected = IllegalArgumentException.class)
    public void testFailsToAddOutOfBoundUdpPortToExposedPorts() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addExposedUdpPort(70000);
    }

    /**
     * Test that adding the same TCP twice, then the second insert attempt is
     * ignored.
     */
    @Test
    public void testCanAddTheSamePortTwiceToExposedPorts() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addExposedTcpPort(1024);
	containerInfo.addExposedTcpPort(1024);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	ContainerConfigurationExposedPortsMap exposedPorts = containeConfig.getExposedPorts();
	assertEquals(1, exposedPorts.size());
	assertTrue(exposedPorts.containsKey("1024/tcp"));
	Object port = exposedPorts.get("1024/tcp");
	assertTrue(port instanceof ContainerConfigurationExposedPortNullValue);
    }

    /**
     * Test that a TCP and UDP port with the same value can be added.
     */
    @Test
    public void testCanAddTcpAndUdpPortWithTheSameValueToExposedPorts() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addExposedTcpPort(1024);
	containerInfo.addExposedUdpPort(1024);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	ContainerConfigurationExposedPortsMap exposedPorts = containeConfig.getExposedPorts();
	assertEquals(2, exposedPorts.size());
	assertTrue(exposedPorts.containsKey("1024/tcp"));
	assertTrue(exposedPorts.containsKey("1024/udp"));
	Object port = exposedPorts.get("1024/tcp");
	assertTrue(port instanceof ContainerConfigurationExposedPortNullValue);
	port = exposedPorts.get("1024/udp");
	assertTrue(port instanceof ContainerConfigurationExposedPortNullValue);
    }

    /**
     * Test that two TCP ports can be added.
     */
    @Test
    public void testCanAddTwoTcpPortsToExposedPorts() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addExposedTcpPort(1024);
	containerInfo.addExposedTcpPort(1025);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	ContainerConfigurationExposedPortsMap exposedPorts = containeConfig.getExposedPorts();
	assertEquals(2, exposedPorts.size());
	assertTrue(exposedPorts.containsKey("1024/tcp"));
	assertTrue(exposedPorts.containsKey("1025/tcp"));
	Object port = exposedPorts.get("1024/tcp");
	assertTrue(port instanceof ContainerConfigurationExposedPortNullValue);
	port = exposedPorts.get("1025/tcp");
	assertTrue(port instanceof ContainerConfigurationExposedPortNullValue);
    }

    /**
     * Test that a volume can be added.
     */
    @Test
    public void testVolumeCanBeAdded() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addVolume(randomValue2);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	ContainerConfigurationVolumesMap volumes = containeConfig.getVolumes();
	assertEquals(1, volumes.size());
	assertTrue(volumes.containsKey(randomValue2));
	Object port = volumes.get(randomValue2);
	assertTrue(port instanceof ContainerConfigurationVolumeNullValue);
    }

    /**
     * Test that adding an illegal volume fails.
     */
    @Test(expected = IllegalArgumentException.class)
    public void testFailsAddToUndefinedVolume() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addVolume(null);
    }

    /**
     * Test that adding an illegal volume fails.
     */
    @Test(expected = IllegalArgumentException.class)
    public void testFailsToAddEmptyVolume() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addVolume("");
    }

    /**
     * Test that adding the same volume, then the second insert attempt is
     * ignored.
     */
    @Test
    public void testCanAddTheSameVolumeTwice() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addVolume(randomValue2);
	containerInfo.addVolume(randomValue2);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	ContainerConfigurationVolumesMap volumes = containeConfig.getVolumes();
	assertEquals(1, volumes.size());
	assertTrue(volumes.containsKey(randomValue2));
	Object volume = volumes.get(randomValue2);
	assertTrue(volume instanceof ContainerConfigurationVolumeNullValue);
    }

    /**
     * Test that two volumes can be added.
     */
    @Test
    public void testCanAddTwoVolumes() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addVolume(randomValue);
	containerInfo.addVolume(randomValue2);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	ContainerConfigurationVolumesMap volumes = containeConfig.getVolumes();
	assertEquals(2, volumes.size());
	assertTrue(volumes.containsKey(randomValue));
	Object volume = volumes.get(randomValue);
	assertTrue(volume instanceof ContainerConfigurationVolumeNullValue);
	assertTrue(volumes.containsKey(randomValue2));
	volume = volumes.get(randomValue2);
	assertTrue(volume instanceof ContainerConfigurationVolumeNullValue);
    }

    /**
     * Test that container configuration has no environment variables defined,
     * i.e. the container is empty.
     */
    @Test
    public void testContainerConfigurationHasNoEnvironmentVariablesDefined() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	List<String> envs = containeConfig.getEnv();
	assertTrue(envs.isEmpty());
    }

    /**
     * Test that an environment variable can be added.
     */
    @Test
    public void testEnvironmentVariableCanBeAdded() {
	String name = "K" + randomValue;
	String value = "V" + randomValue;

	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addEnvironmentVariable(name, value);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	List<String> envs = containeConfig.getEnv();
	assertEquals(1, envs.size());
	assertEquals(name + "=" + value, envs.get(0));
    }

    /**
     * Test that two environment variables can be added.
     */
    @Test
    public void testTwoEnvironmentVariableCanBeAdded() {
	String name = "K" + randomValue;
	String value = "V" + randomValue;
	String name2 = "K" + randomValue2;
	String value2 = "V" + randomValue2;

	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addEnvironmentVariable(name, value);
	containerInfo.addEnvironmentVariable(name2, value2);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	List<String> envs = containeConfig.getEnv();
	assertEquals(2, envs.size());
	assertEquals(name + "=" + value, envs.get(0));
	assertEquals(name2 + "=" + value2, envs.get(1));
    }

    /**
     * Test that adding an illegal environment variable name fails
     */
    @Test(expected = IllegalArgumentException.class)
    public void testFailsToAddUndefinedEnvironmentVariableName() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addEnvironmentVariable(null, randomValue);
    }

    /**
     * Test that adding an illegal environment variable name fails.
     */
    @Test(expected = IllegalArgumentException.class)
    public void testFailsToAddEmptyEnvironmentVariableName() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addEnvironmentVariable("", randomValue);
    }

    /**
     * Test that adding an illegal environment variable value fails
     */
    @Test(expected = IllegalArgumentException.class)
    public void testFailsToAddUndefinedEnvironmentVariableValue() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addEnvironmentVariable(randomValue, null);
    }

    /**
     * Test that adding an illegal environment variable value fails.
     */
    @Test(expected = IllegalArgumentException.class)
    public void testFailsToAddEmptyEnvironmentVariableValue() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addEnvironmentVariable(randomValue, "");
    }

    /**
     * Test that a label can be added.
     */
    @Test
    public void testLabelCanBeAdded() {
	String key = "K" + randomValue;
	String value = "V" + randomValue;

	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addLabel(key, value);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	ContainerConfigurationLabelsMap labels = containeConfig.getLabels();
	assertEquals(1, labels.size());
	assertTrue(labels.containsKey(key));
	assertEquals(value, labels.get(key));
    }

    /**
     * Test that two labels can be added.
     */
    @Test
    public void testTwoLabelsCanBeAdded() {
	String key = "K" + randomValue;
	String value = "V" + randomValue;
	String key2 = "K" + randomValue2;
	String value2 = "V" + randomValue2;

	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addLabel(key, value);
	containerInfo.addLabel(key2, value2);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	ContainerConfigurationLabelsMap labels = containeConfig.getLabels();
	assertEquals(2, labels.size());
	assertTrue(labels.containsKey(key));
	assertEquals(value, labels.get(key));
	assertTrue(labels.containsKey(key2));
	assertEquals(value2, labels.get(key2));
    }

    /**
     * Test that adding an illegal label key fails
     */
    @Test(expected = IllegalArgumentException.class)
    public void testFailsToAddUndefinedLabelKey() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addLabel(null, randomValue);
    }

    /**
     * Test that adding an illegal label key fails.
     */
    @Test(expected = IllegalArgumentException.class)
    public void testFailsToAddEmptyKeyName() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addLabel("", randomValue);
    }

    /**
     * Test that adding an illegal label value fails
     */
    @Test(expected = IllegalArgumentException.class)
    public void testFailsToAddUndefinedLabelValue() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addLabel(randomValue, null);

    }

    /**
     * Test that adding an illegal label value fails.
     */
    @Test(expected = IllegalArgumentException.class)
    public void testFailsToAddEmptyLabelValue() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addLabel(randomValue, "");
    }

    /**
     * Test that a legal TCP port can be added to port bindings.
     */
    @Test
    public void testLegalTcpPortCanBeAddedToPortBindings() {
	int containerPortNumber = 10;
	int hostPortNumber = 20020;

	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	String portKey = containerInfo.createPortString(containerPortNumber, "tcp");
	containerInfo.addTcpPortBinding(containerPortNumber, hostPortNumber);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	ContainerConfigurationHostConfigPortBindingsMap portBindings = containeConfig.getHostConfig().getPortBindings();
	assertEquals(1, portBindings.size());
	assertTrue(portBindings.containsKey(portKey));
	ContainerConfigurationHostConfigPortBindingValue[] valueArray = portBindings.get(portKey);
	assertEquals(1, valueArray.length);
	assertNotNull(valueArray[FIRST_INDEX]);
	assertNull(valueArray[FIRST_INDEX].getHostIp());
	assertEquals(Integer.toString(hostPortNumber), valueArray[FIRST_INDEX].getHostPort());
    }

    /**
     * Test that a legal UDP port can be added to port bindings.
     */
    @Test
    public void testLegalUdpPortCanBeAddedToPortBindings() {
	int containerPortNumber = 10;
	int hostPortNumber = 20020;

	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	String portKey = containerInfo.createPortString(containerPortNumber, "udp");
	containerInfo.addUdpPortBinding(containerPortNumber, hostPortNumber);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	ContainerConfigurationHostConfigPortBindingsMap portBindings = containeConfig.getHostConfig().getPortBindings();
	assertEquals(1, portBindings.size());
	assertTrue(portBindings.containsKey(portKey));
	ContainerConfigurationHostConfigPortBindingValue[] valueArray = portBindings.get(portKey);
	assertEquals(1, valueArray.length);
	assertNotNull(valueArray[FIRST_INDEX]);
	assertNull(valueArray[FIRST_INDEX].getHostIp());
	assertEquals(Integer.toString(hostPortNumber), valueArray[FIRST_INDEX].getHostPort());
    }

    /**
     * Test that a adding an illegal UDP port fails.
     */
    @Test(expected = IllegalArgumentException.class)
    public void testFailsToAddZeroContainerUdpPortToPortbindings() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addUdpPortBinding(0, 10);
    }

    /**
     * Test that a adding an illegal UDP port fails.
     */
    @Test(expected = IllegalArgumentException.class)
    public void testFailsToAddNegativeContainerUdpPortToPortBindings() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addUdpPortBinding(-1, 10);
    }

    /**
     * Test that a adding an illegal UDP port fails.
     */
    @Test(expected = IllegalArgumentException.class)
    public void testFailsToAddOutOfBoundContainerUdpPortToPortBindings() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addUdpPortBinding(70000, 10);
    }

    /**
     * Test that a adding an illegal UDP port fails.
     */
    @Test(expected = IllegalArgumentException.class)
    public void testFailsToAddZeroHostUdpPortToPortbindings() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addUdpPortBinding(10, 0);
    }

    /**
     * Test that a adding an illegal UDP port fails.
     */
    @Test(expected = IllegalArgumentException.class)
    public void testFailsToAddNegativeHostUdpPortToPortBindings() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addUdpPortBinding(10, -1);
    }

    /**
     * Test that a adding an illegal UDP port fails.
     */
    @Test(expected = IllegalArgumentException.class)
    public void testFailsToAddOutOfBoundHostUdpPortToPortBindings() {
	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	containerInfo.addUdpPortBinding(10, 70000);
    }

    /**
     * Test that adding the same TCP twice, then the second insert attempt is
     * ignored.
     */
    @Test
    public void testCanAddTheSamePortTwiceToPortBindings() {
	int containerPortNumber = 10;
	int hostPortNumber = 20020;

	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	String tcpPortKey = containerInfo.createPortString(containerPortNumber, "tcp");
	containerInfo.addTcpPortBinding(containerPortNumber, hostPortNumber);
	containerInfo.addTcpPortBinding(containerPortNumber, hostPortNumber);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	ContainerConfigurationHostConfigPortBindingsMap portBindings = containeConfig.getHostConfig().getPortBindings();
	assertEquals(1, portBindings.size());

	assertTrue(portBindings.containsKey(tcpPortKey));
	ContainerConfigurationHostConfigPortBindingValue[] valueArray = portBindings.get(tcpPortKey);
	assertEquals(1, valueArray.length);
	assertNotNull(valueArray[FIRST_INDEX]);
	assertNull(valueArray[FIRST_INDEX].getHostIp());
	assertEquals(Integer.toString(hostPortNumber), valueArray[FIRST_INDEX].getHostPort());
    }

    /**
     * Test that a TCP and UDP port with the same value can be added.
     */
    @Test
    public void testCanAddTcpAndUdpPortWithTheSameValueToPortbindings() {
	int containerPortNumber = 10;
	int hostPortNumber = 20020;

	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	String udpPortKey = containerInfo.createPortString(containerPortNumber, "udp");
	String tcpPortKey = containerInfo.createPortString(containerPortNumber, "tcp");
	containerInfo.addUdpPortBinding(containerPortNumber, hostPortNumber);
	containerInfo.addTcpPortBinding(containerPortNumber, hostPortNumber);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	ContainerConfigurationHostConfigPortBindingsMap portBindings = containeConfig.getHostConfig().getPortBindings();
	assertEquals(2, portBindings.size());
	assertTrue(portBindings.containsKey(udpPortKey));
	ContainerConfigurationHostConfigPortBindingValue[] valueArray = portBindings.get(udpPortKey);
	assertEquals(1, valueArray.length);
	assertNotNull(valueArray[FIRST_INDEX]);
	assertNull(valueArray[FIRST_INDEX].getHostIp());
	assertEquals(Integer.toString(hostPortNumber), valueArray[FIRST_INDEX].getHostPort());

	assertTrue(portBindings.containsKey(tcpPortKey));
	valueArray = portBindings.get(tcpPortKey);
	assertEquals(1, valueArray.length);
	assertNotNull(valueArray[FIRST_INDEX]);
	assertNull(valueArray[FIRST_INDEX].getHostIp());
	assertEquals(Integer.toString(hostPortNumber), valueArray[FIRST_INDEX].getHostPort());
    }

    /**
     * Test that two TCP ports can be added.
     */
    @Test
    public void testCanAddTwoTcpPortsToPortBindings() {
	int containerPortNumber = 10;
	int containerPortNumber2 = 11;
	int hostPortNumber = 20020;
	int hostPortNumber2 = 20021;

	imageInfo = infobuilder.buildImageInfo(randomValue, "");
	containerInfo = new ContainerInfoImpl(randomValue, imageInfo);
	String tcpPortKey = containerInfo.createPortString(containerPortNumber, "tcp");
	String tcpPortKey2 = containerInfo.createPortString(containerPortNumber2, "tcp");
	containerInfo.addTcpPortBinding(containerPortNumber, hostPortNumber);
	containerInfo.addTcpPortBinding(containerPortNumber2, hostPortNumber2);

	// test
	ContainerConfiguration containeConfig = containerInfo.getContainerConfiguration();
	ContainerConfigurationHostConfigPortBindingsMap portBindings = containeConfig.getHostConfig().getPortBindings();
	assertEquals(2, portBindings.size());
	assertTrue(portBindings.containsKey(tcpPortKey));
	ContainerConfigurationHostConfigPortBindingValue[] valueArray = portBindings.get(tcpPortKey);
	assertEquals(1, valueArray.length);
	assertNotNull(valueArray[FIRST_INDEX]);
	assertNull(valueArray[FIRST_INDEX].getHostIp());
	assertEquals(Integer.toString(hostPortNumber), valueArray[FIRST_INDEX].getHostPort());

	assertTrue(portBindings.containsKey(tcpPortKey2));
	valueArray = portBindings.get(tcpPortKey2);
	assertEquals(1, valueArray.length);
	assertNotNull(valueArray[FIRST_INDEX]);
	assertNull(valueArray[FIRST_INDEX].getHostIp());
	assertEquals(Integer.toString(hostPortNumber2), valueArray[FIRST_INDEX].getHostPort());
    }

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            </plugins>
        </build>
      </profile>

      <profile>
        <id>Release</id>
        <activation>
          <property>
            <name>releasetag</name>
          </property>
        </activation>
        <repositories>
          <repository>
	          <id>jitpack.io</id>
            <url>https://jitpack.io</url>
          </repository>
        </repositories>

        <properties>
            <endorsed.dir>${project.build.directory}/endorsed</endorsed.dir>
            <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        </properties>

        <dependencies>
            <dependency>
                <groupId>com.github.SemanticWebBuilder</groupId>
                <artifactId>SWBNLP</artifactId>
                <version>${releasetag}</version>
            </dependency>
            <dependency>
                <groupId>com.github.SemanticWebBuilder</groupId>
                <artifactId>SWBAdmin</artifactId>
                <version>${releasetag}</version>
            </dependency>
            <dependency>
                <groupId>com.github.SemanticWebBuilder</groupId>
                <artifactId>SWBTripleStoreLevelDB</artifactId>
                <version>${releasetag}</version>
            </dependency>
            <dependency>
                <groupId>com.github.SemanticWebBuilder</groupId>
                <artifactId>SWBTripleStoreMongoDB</artifactId>
                <version>${releasetag}</version>
            </dependency>
            <dependency>
                <groupId>hsqldb</groupId>
                <artifactId>hsqldb</artifactId>
                <version>1.8.0.10</version>
            </dependency>
            <dependency>
                <groupId>com.github.SemanticWebBuilder</groupId>
                <artifactId>SWBOffice</artifactId>
                <version>${releasetag}</version>
            </dependency>
            <dependency>
                <groupId>com.github.SemanticWebBuilder</groupId>
                <artifactId>SWB3Resources</artifactId>
                <version>${releasetag}</version>
            </dependency>
            <dependency>
                <groupId>javax</groupId>
                <artifactId>javaee-web-api</artifactId>
                <version>7.0</version>
                <scope>provided</scope>
            </dependency>
        </dependencies>

        <build>
            <plugins>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <version>3.1</version>
                    <configuration>
                        <source>1.7</source>
                        <target>1.7</target>
                        <compilerArguments>
                            <endorseddirs>${endorsed.dir}</endorseddirs>
                        </compilerArguments>
                    </configuration>
                </plugin>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-war-plugin</artifactId>
                    <version>2.3</version>
                    <configuration>
                        <outputFileNameMapping>@{artifactId}@.@{extension}@</outputFileNameMapping>
                        <failOnMissingWebXml>false</failOnMissingWebXml>
                    </configuration>
                </plugin>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-dependency-plugin</artifactId>
                    <version>2.6</version>
                    <executions>
                        <execution>
                            <phase>validate</phase>
                            <goals>
                                <goal>copy</goal>
                            </goals>
                            <configuration>
                                <outputDirectory>${endorsed.dir}</outputDirectory>
                                <silent>true</silent>
                                <artifactItems>
                                    <artifactItem>
                                        <groupId>javax</groupId>
                                        <artifactId>javaee-endorsed-api</artifactId>
                                        <version>7.0</version>
                                        <type>jar</type>
                                    </artifactItem>
                                </artifactItems>
                            </configuration>
                        </execution>
                    </executions>
                </plugin>
            </plugins>
        </build>
      </profile>

      <profile>
        <id>Release</id>
        <activation>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
- Added CTM integration for Disk Manipulator (raoulvdberge)
- Fixed possible rare dupe bug with Importer (raoulvdberge)
- Fixed Shulker Box dupe bug with Destructor (raoulvdberge)

### 1.5.14
- Updated Forge to 2426 (raoulvdberge)
import com.raoulvdberge.refinedstorage.gui.GuiBase;
import com.raoulvdberge.refinedstorage.gui.Scrollbar;
import com.raoulvdberge.refinedstorage.gui.grid.filtering.GridFilterParser;
import com.raoulvdberge.refinedstorage.gui.grid.sorting.GridSorting;
import com.raoulvdberge.refinedstorage.gui.grid.sorting.GridSortingID;
import com.raoulvdberge.refinedstorage.gui.grid.sorting.GridSortingInventoryTweaks;
import com.raoulvdberge.refinedstorage.gui.grid.sorting.GridSortingName;
import com.raoulvdberge.refinedstorage.gui.grid.sorting.GridSortingQuantity;
import com.raoulvdberge.refinedstorage.gui.grid.stack.GridStackFluid;
import com.raoulvdberge.refinedstorage.gui.grid.stack.GridStackItem;
import com.raoulvdberge.refinedstorage.gui.grid.stack.IGridStack;
protected void keyTyped(char character, int keyCode) throws IOException {
    }

    private void updateSearchHistory(int delta) {
        if (searchHistory == -1) {
            searchHistory = SEARCH_HISTORY.size();
        }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private float pxFromDp(float dp) {
    }

    void restartPreview(int isFront) {
        if (inPreview) {
            camera.stopPreview();
        }
        camera.release();
        camera = Camera.open(isFront);
        initPreview(preview.getHeight());
        startPreview();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void onCreateNavigationView() {
            public void onDataChange(DataSnapshot dataSnapshot) {
                Usuario user = dataSnapshot.getValue(Usuario.class);

                for (String pId : user.getProjetos()) {
                    FirebaseDatabase database = FirebaseDatabase.getInstance();
                    DatabaseReference myRef = database.getReference("projects/" + pId );
                    final String projectId = pId;
                    myRef.addListenerForSingleValueEvent(
                            new ValueEventListener() {
                                @Override
                                public void onDataChange(DataSnapshot dataSnapshot) {
                                    // Get user value
                                    Projeto projeto = dataSnapshot.getValue(Projeto.class);
                                    addProjectMenu(projeto.getNomeProjeto(), projectId);

                                }

                                @Override
                                public void onCancelled(DatabaseError databaseError) {
                                    Log.w("Firebase", "getUser:onCancelled", databaseError.toException());
                                    // ...
                                }
                            });

                }
            }

            @Override
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import java.io.FileInputStream;
import java.io.IOException;
import java.lang.reflect.Method;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.FileChannel.MapMode;
 */
public final class LineParser {

  private final int maxMapSize;

  public LineParser() {
public LineParser() {
   * @param cs the character set to use
   * @param lineCallback callback executed for every line
   * @throws IOException if an exception happens when reading
   */
  public void forEach(Path path, Charset cs, Consumer<Line> lineCallback) throws IOException {
    try (FileInputStream stream = new FileInputStream(path.toFile());
            FileChannel channel = stream.getChannel()) {
      long fileSize = channel.size();
      LineReader reader = LineReader.forCharset(cs);
      byte[] cr = "\r".getBytes(cs);
private static void readLine(int lineStart, long mapStart, int mapIndex,

  }

  private static void unmap(MappedByteBuffer buffer) {
    try {
      Method cleanerMethod = buffer.getClass().getMethod("cleaner");
      if (!cleanerMethod.isAccessible()) {
        cleanerMethod.setAccessible(true);
      }
      Object cleaner = cleanerMethod.invoke(buffer);
      if (cleaner instanceof Runnable) {
        // Java 9 branch
        // jdk.internal.ref.Cleaner cleaner = ((java.nio.DirectByteBufferR) buffer).cleaner();
        // cleaner.run();
        ((Runnable) cleaner).run();
      } else {
        // Java 8 branch
        // sun.misc.Cleaner cleaner = ((sun.nio.ch.DirectBuffer) buffer).cleaner();
        // cleaner.clean();
        Method cleanMethod = cleaner.getClass().getMethod("clean");
        if (!cleanMethod.isAccessible()) {
          cleanMethod.setAccessible(true);
        }
        cleanMethod.invoke(cleaner);
      }
    } catch (ReflectiveOperationException e) {
      throw new RuntimeException("could not unmap buffer", e);
    }
  }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void clearCanvas(){
    }

    @Override
    protected void onLayout(boolean changed, int left, int top, int right,
                            int bottom) {
        super.onLayout(changed, left, top, right, bottom);
        layoutLeft = left;
        layoutTop = top;
protected void onLayout(boolean changed, int left, int top, int right,
    private void newBitmapCanvas(int left, int top, int right, int bottom) {
        bmp = null;
        canvasBmp = null;
        bmp = Bitmap.createBitmap(right - left, bottom - top, Bitmap.Config.ARGB_8888);
        canvasBmp = new Canvas(bmp);
        canvasBmp.drawColor(backgroundColor);
    }

    @Override
private float getPt( float n1 , float n2 , float perc){

    private void draw(Point p0, Point p1, Point p2, float lastWidth,
                      float currentWidth, float velocity){

        float xa, xb, ya, yb, x, y;
        float increment;
        if(velocity>MIN_VELOCITY_BOUND && velocity< MAX_VELOCITY_BOUND){
            increment = DRAWING_CONSTANT - (velocity * INCREMENT_CONSTANT);
        }else{
            increment = MIN_INCREMENT;
        }

        for(float i = 0f; i < 1f; i += increment){
                xa = getPt( p0.x , p1.x , i );
                ya = getPt( p0.y , p1.y , i );
                xb = getPt( p1.x , p2.x , i );
private void draw(Point p0, Point p1, Point p2, float lastWidth,
                x = getPt( xa , xb , i );
                y = getPt( ya , yb , i );

            float strokeVal = lastWidth + (currentWidth - lastWidth) * (i);
            paint.setStrokeWidth(strokeVal < MIN_PEN_SIZE ? MIN_PEN_SIZE : strokeVal);
            canvasBmp.drawPoint(x, y, paint);
        }
    }

private Point midPoint(Point p1, Point p2){
     * @return Bitmap
     */
    public Bitmap getSignatureBitmap(){
        return Bitmap.createScaledBitmap(bmp, bmp.getWidth(), bmp.getHeight(), true);
    }

    private Bitmap getSignatureBitmap(Bitmap bitmap){
private Bitmap getSignatureBitmap(Bitmap bitmap){
     *
     * @param   bitmap Bitmap
     */
    public void setBitmap(Bitmap bitmap)
    {
        bmp=bitmap;
        canvasBmp = new Canvas(bitmap);
        postInvalidate();
    }
    
    /**
     * Check is signature bitmap empty
     *
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void blockUser() {
            .negativeText(android.R.string.cancel)
            .onPositive(new MaterialDialog.SingleButtonCallback() {
                @Override
                public void onClick(@NonNull MaterialDialog materialDialog, @NonNull DialogAction dialogAction) {
                    setPrivacy(PRIVACY_BLOCK);
                }
            })
            .show();
private void unblockUser() {
            .negativeText(android.R.string.cancel)
            .onPositive(new MaterialDialog.SingleButtonCallback() {
                @Override
                public void onClick(@NonNull MaterialDialog materialDialog, @NonNull DialogAction dialogAction) {
                    setPrivacy(PRIVACY_UNBLOCK);
                }
            })
            .show();
public void onClick(View v) {
                        else
                            action = PRIVACY_REJECT;

                        setPrivacy(action);
                    }
                };

public void onClick(View v) {
            mInvitationBar.setVisibility(visible ? View.VISIBLE : View.GONE);
    }

    void setPrivacy(int action) {
        int status;

        switch (action) {
void setPrivacy(int action) {
                return;
        }

        Context ctx = getActivity();

        // temporarly disable peer observer because the next call will write to the threads table
        unregisterPeerObserver();

public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which)
                        switch (which) {
                            case POSITIVE:
                                // trust new key
                                trustKeyChange(null);
                                break;
                            case NEGATIVE:
                                // block user immediately
                                setPrivacy(PRIVACY_BLOCK);
                                break;
                        }
                    }
public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which)
        builder.show();
    }

    void trustKeyChange(String fingerprint) {
        // mark current key as trusted
        if (fingerprint == null)
            fingerprint = getContact().getFingerprint();
        Kontalk.getMessagesController(getContext())
            .setTrustLevelAndRetryMessages(getContext(), mUserJID, fingerprint, MyUsers.Keys.TRUST_VERIFIED);
        // reload contact
        invalidateContact();
    }
public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which)
                                        // hide warning bar
                                        hideWarning();
                                        // trust new key
                                        trustKeyChange((String) data[0]);
                                        break;
                                    case NEUTRAL:
                                        showIdentityDialog(false, dialogTitleId);
public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which)
                                        // hide warning bar
                                        hideWarning();
                                        // block user immediately
                                        setPrivacy(PRIVACY_BLOCK);
                                        break;
                                }
                            }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void onBindViewHolder(final ViewHolder holder, int position) {
                buttonControlMain1.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        Double data = Double.valueOf(editTextControlMain.getText().toString());
                        Double dataDecrement = data - 0.0025;
                        if (dataDecrement < -5.0)
                            dataDecrement = -5.0;
                        else if (dataDecrement > 5.0)
                            dataDecrement = 5.0;
                        seekBarControlMain.setProgress((int)((dataDecrement+5)*10));
                        DecimalFormat df = new DecimalFormat("#.####");
                        editTextControlMain.setText(df.format(dataDecrement));
                    }
                });

                buttonControlMain2.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        Double data1 = Double.valueOf(editTextControlMain.getText().toString());
                        Double dataIncrement = data1 + 0.0025;
                        if (dataIncrement < -5.0)
                            dataIncrement = -5.0;
                        else if (dataIncrement > 5.0)
                            dataIncrement = 5.0;
                        seekBarControlMain.setProgress((int)((dataIncrement+5)*10));
                        DecimalFormat df = new DecimalFormat("#.####");
                        editTextControlMain.setText(df.format(dataIncrement));
                    }
                });

                buttonControlMain3.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        Float value = Float.parseFloat(editTextControlMain.getText().toString());
                        if (value > 5)
                            value = 5f;
                        else if (value < -5)
                            value = -5f;
                        editTextControlMain.setText(String.valueOf(value));
                        //seekBarControlMain.setProgress((int) ((value + 5) * 10));

                        if (scienceLab.isConnected())
                            scienceLab.setPV1(value);
                    }
                });

public void onStopTrackingTouch(SeekBar seekBar) {
                buttonControlMain1.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        Double data = Double.valueOf(editTextControlMain.getText().toString());
                        Double dataDecrement = data - 0.0025;
                        if (dataDecrement < -3.3)
                            dataDecrement = -3.3;
                        else if (dataDecrement > 3.3)
                            dataDecrement = 3.3;
                        seekBarControlMain.setProgress((int)((dataDecrement+3.3)*15.15));
                        DecimalFormat df = new DecimalFormat("#.####");
                        editTextControlMain.setText(df.format(dataDecrement));
                    }
                });

                buttonControlMain2.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        Double data1 = Double.valueOf(editTextControlMain.getText().toString());
                        Double dataIncrement = data1 + 0.0025;
                        if (dataIncrement < -3.3)
                            dataIncrement = -3.3;
                        else if (dataIncrement > 3.3)
                            dataIncrement = 3.3;
                        seekBarControlMain.setProgress((int)((dataIncrement+3.3)*15.15));
                        DecimalFormat df = new DecimalFormat("#.####");
                        editTextControlMain.setText(df.format(dataIncrement));
                    }
                });

                buttonControlMain3.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        Float value = Float.parseFloat(editTextControlMain.getText().toString());
                        if (value > 3.3)
                            value = 3.3f;
                        else if (value < -3.3)
                            value = -3.3f;
                        editTextControlMain.setText(String.valueOf(value));
                        seekBarControlMain.setProgress((int) ((value + 3.3) * 15.15));

                        if (scienceLab.isConnected())
                            scienceLab.setPV2(value);
                    }
                });

public void onStopTrackingTouch(SeekBar seekBar) {
                buttonControlMain1.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        Double data = Double.valueOf(editTextControlMain.getText().toString());
                        Double dataDecrement = data - 0.0025;
                        if (dataDecrement < 0.0)
                            dataDecrement = 0.0;
                        else if (dataDecrement > 3.3)
                            dataDecrement = 3.3;
                        seekBarControlMain.setProgress((int)(dataDecrement*30.30));
                        DecimalFormat df = new DecimalFormat("#.####");
                        editTextControlMain.setText(df.format(dataDecrement));
                    }
                });

                buttonControlMain2.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        Double data1 = Double.valueOf(editTextControlMain.getText().toString());
                        Double dataIncrement = data1 + 0.0025;
                        if (dataIncrement < 0.0)
                            dataIncrement = 0.0;
                        else if (dataIncrement > 3.3)
                            dataIncrement = 3.3;
                        seekBarControlMain.setProgress((int)(dataIncrement*30.30));
                        DecimalFormat df = new DecimalFormat("#.####");
                        editTextControlMain.setText(df.format(dataIncrement));
                    }
                });

                buttonControlMain3.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        Float value = Float.parseFloat(editTextControlMain.getText().toString());
                        if (value > 3.3)
                            value = 3.3f;
                        else if (value < 0)
                            value = 0f;
                        editTextControlMain.setText(String.valueOf(value));
                        //seekBarControlMain.setProgress((int) (value * 30.30));

                        if (scienceLab.isConnected())
                            scienceLab.setPV3(value);
                    }
                });

public void onStopTrackingTouch(SeekBar seekBar) {
                buttonControlMain1.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        Double data = Double.valueOf(editTextControlMain.getText().toString());
                        Double dataDecrement = data - 0.0025;
                        if (dataDecrement < 0.0)
                            dataDecrement = 0.0;
                        else if (dataDecrement > 3.3)
                            dataDecrement = 3.3;
                        DecimalFormat df = new DecimalFormat("#.####");
                        editTextControlMain.setText(df.format(dataDecrement));
                    }
                });

                buttonControlMain2.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        Double data1 = Double.valueOf(editTextControlMain.getText().toString());
                        Double dataIncrement = data1 + 0.0025;
                        if (dataIncrement < 0.0)
                            dataIncrement = 0.0;
                        else if (dataIncrement > 3.3)
                            dataIncrement = 3.3;
                        DecimalFormat df = new DecimalFormat("#.####");
                        editTextControlMain.setText(df.format(dataIncrement));
                    }
                });

                buttonControlMain3.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        Float value = Float.parseFloat(editTextControlMain.getText().toString());
                        if (value > 3.3)
                            value = 3.3f;
                        else if (value < 0)
                            value = 0f;
                        editTextControlMain.setText(String.valueOf(value));
                        //seekBarControlMain.setProgress((int) (value * 30.30));

                        if (scienceLab.isConnected())
                            scienceLab.setPCS(value);

                    }
                });

public void onStopTrackingTouch(SeekBar seekBar) {
                buttonControlMain1.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        int data = Integer.valueOf(editTextControlMain.getText().toString());
                        int dataDecrement = data - 1;
                        if (dataDecrement < 10)
                            dataDecrement = 10;
                        else if (dataDecrement > 5000)
                            dataDecrement = 5000;

                        seekBarControlMain.setProgress((int)((dataDecrement-10)/49.9));
                        DecimalFormat df = new DecimalFormat("####");
                        editTextControlMain.setText(df.format(dataDecrement));
                    }
                });

                buttonControlMain2.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        int data1 = Integer.valueOf(editTextControlMain.getText().toString());
                        int dataIncrement = data1 + 1;
                        if (dataIncrement < 10)
                            dataIncrement = 10;
                        else if (dataIncrement > 5000)
                            dataIncrement = 5000;
                        seekBarControlMain.setProgress((int)((dataIncrement-10)/49.9));
                        DecimalFormat df = new DecimalFormat("####");
                        editTextControlMain.setText(df.format(dataIncrement));
                    }
                });

                buttonControlMain3.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        Float value = Float.parseFloat(editTextControlMain.getText().toString());
                        if (value < 10)
                            value = 10f;
                        else if (value > 5000)
                            value = 5000f;
                        editTextControlMain.setText(String.valueOf(value));
                        //seekBarControlMain.setProgress((int) ((value - 10) / 49.9));

                        // call to scienceLab for setting
                    }
                });

public void onStopTrackingTouch(SeekBar seekBar) {
                buttonControlMain1.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        int data = Integer.valueOf(editTextControlMain.getText().toString());
                        int dataDecrement = data - 1;
                        if (dataDecrement < 10)
                            dataDecrement = 10;
                        else if (dataDecrement > 5000)
                            dataDecrement = 5000;
                        seekBarControlMain.setProgress((int)((dataDecrement-10)/49.9));
                        DecimalFormat df = new DecimalFormat("####");
                        editTextControlMain.setText(df.format(dataDecrement));
                    }
                });

                buttonControlMain2.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        int data1 = Integer.valueOf(editTextControlMain.getText().toString());
                        int dataIncrement = data1 + 1;
                        if (dataIncrement < 10)
                            dataIncrement = 10;
                        else if (dataIncrement > 5000)
                            dataIncrement = 5000;
                        seekBarControlMain.setProgress((int)((dataIncrement-10)/49.9));
                        DecimalFormat df = new DecimalFormat("####");
                        editTextControlMain.setText(df.format(dataIncrement));
                    }
                });

                buttonControlMain3.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        Float value = Float.parseFloat(editTextControlMain.getText().toString());
                        if (value < 10)
                            value = 10f;
                        else if (value > 5000)
                            value = 5000f;
                        editTextControlMain.setText(String.valueOf(value));
                        seekBarControlMain.setProgress((int) ((value - 10) / 49.9));

                        // call to scienceLab for setting
                    }
                });
                seekBarControlMain.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
public void onStopTrackingTouch(SeekBar seekBar) {
                buttonControlMain1.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        int data = Integer.valueOf(editTextControlMain.getText().toString());
                        int dataDecrement = data - 1;
                        if (dataDecrement < 10)
                            dataDecrement = 10;
                        else if (dataDecrement > 5000)
                            dataDecrement = 5000;
                        seekBarControlMain.setProgress((int)((dataDecrement-10)/49.9));
                        DecimalFormat df = new DecimalFormat("####");
                        editTextControlMain.setText(df.format(dataDecrement));
                    }
                });

                buttonControlMain2.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        int data1 = Integer.valueOf(editTextControlMain.getText().toString());
                        int dataIncrement = data1 + 1;
                        if (dataIncrement < 10)
                            dataIncrement = 10;
                        else if (dataIncrement > 5000)
                            dataIncrement = 5000;
                        seekBarControlMain.setProgress((int)((dataIncrement-10)/49.9));
                        DecimalFormat df = new DecimalFormat("####");
                        editTextControlMain.setText(df.format(dataIncrement));
                    }
                });

                buttonControlMain3.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        Float value = Float.parseFloat(editTextControlMain.getText().toString());
                        if (value < 10)
                            value = 10f;
                        else if (value > 5000)
                            value = 5000f;
                        editTextControlMain.setText(String.valueOf(value));
                        seekBarControlMain.setProgress((int) ((value - 10) / 49.9));

                        // call to scienceLab for setting
                    }
                });
                seekBarControlMain.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        </activity>

        <activity
            android:name=".activities.ShortcutActivity"
            android:label="@string/manual_connection_shortcut"
            android:theme="@style/AppBaseTheme.Dialog">
    <string name="pref_timeout">Таймаут соединения</string>
    <string name="pref_timeout_summary">Количество миллисекунд, в течение которого приложение ожидает ответа от сервера. Если установлен 0, приложеие будет ждать до тех пор пока не будет поймана одна из ошибок (по умолчанию: 0).</string>
    <string name="toast_unsupported_function">Похоже эта функция не поддерживается вашим устройством :(</string>
</resources>
    <string name="pref_timeout">Connection timeout</string>
    <string name="pref_timeout_summary">Number of milliseconds to wait for server answer. If 0 is set, application will wait until connection error is caught (default: 0).</string>
    <string name="toast_unsupported_function">This function seems to be unsupported on your device. Sorry :(</string>
</resources>
        android:title="@string/developer_github_repo"
        android:summary="@string/developer_github_repo_summary">

        <intent
            android:action="android.intent.action.VIEW"
            android:data="@string/developer_github_repo_link" />

    </PreferenceScreen>

    <PreferenceScreen
        android:title="@string/developer_vkontakte"
        android:summary="@string/developer_vkontakte_summary">

        <intent
            android:action="android.intent.action.VIEW"
            android:data="@string/developer_vkontakte_link" />

    </PreferenceScreen>

    <PreferenceScreen
        android:title="@string/developer_site"
        android:summary="@string/developer_site_link">

        <intent
            android:action="android.intent.action.VIEW"
            android:data="@string/developer_site_link" />

    </PreferenceScreen>

    <PreferenceScreen
        android:title="@string/developer_google_play">

        <intent
            android:action="android.intent.action.VIEW"
            android:data="@string/developer_google_play_link" />

    </PreferenceScreen>

            android:title="@string/contirutor_revertron"
            android:summary="@string/contributor_revertron_summary">

            <intent
                android:action="android.intent.action.VIEW"
                android:data="@string/contributor_revertron_link" />

        </PreferenceScreen>

        <PreferenceScreen
            android:title="@string/contributor_Mikhail_Kuropatkin"
            android:summary="@string/contrinutor_Mikhail_Kuropatkin_summary">

            <intent
                android:action="android.intent.action.VIEW"
                android:data="@string/contributor_Mikhail_Kuropatkin_link" />

        </PreferenceScreen>

        <PreferenceScreen
            android:title="@string/contributor_Alexander_Krotov"
            android:summary="@string/contributor_Alexander_Krotov_summary">

            <intent
                android:action="android.intent.action.VIEW"
                android:data="@string/contributor_Alexander_Krotov_link" />

        </PreferenceScreen>
    </PreferenceCategory>
import android.content.DialogInterface;
import android.content.Intent;
import android.content.SharedPreferences;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.preference.CheckBoxPreference;
private void donate_dialog() {
            public void onClick(DialogInterface dialogInterface, int i) {
                switch (i) {
                    case 0: // Yandex.Money
                        Intent yandex = new Intent(Intent.ACTION_VIEW);
                        yandex.setData(Uri.parse(getString(R.string.donate_yandex_data)));
                        startActivity(yandex);
                        break;

                    case 1: // WebMoney
public void onClick(DialogInterface dialogInterface, int i) {
                        break;

                    case 2: // GitHub
                        Intent github = new Intent(Intent.ACTION_VIEW);
                        github.setData(Uri.parse(getString(R.string.developer_github_repo_link)));
                        startActivity(github);
                        break;

                    case 3: // VK
                        Intent vk = new Intent(Intent.ACTION_VIEW);
                        vk.setData(Uri.parse(getString(R.string.developer_vkontakte_link)));
                        startActivity(vk);
                        break;

                    case 4: // Google Play
                        Intent google = new Intent(Intent.ACTION_VIEW);
                        google.setData(Uri.parse(getString(R.string.developer_google_play_link)));
                        startActivity(google);
                        break;
                }
            }
import android.app.PendingIntent;
import android.content.Intent;
import android.content.SharedPreferences;
import android.net.Uri;
import android.os.SystemClock;
import android.preference.PreferenceManager;


import pw.thedrhax.mosmetro.R;
import pw.thedrhax.mosmetro.activities.DebugActivity;
import pw.thedrhax.mosmetro.authenticator.Provider;
import pw.thedrhax.mosmetro.authenticator.Task;
import pw.thedrhax.util.Logger;
private void notify (Provider.RESULT result) {
                            .text(getString(R.string.notification_not_registered_register))
                            .icon(R.drawable.ic_notification_register)
                            .onClick(PendingIntent.getActivity(this, 0,
                                    new Intent(Intent.ACTION_VIEW)
                                            .setData(Uri.parse("http://wi-fi.ru")),
                                    PendingIntent.FLAG_UPDATE_CURRENT
                            ))
                            .id(2).show().id(1);
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.net.Uri;
import android.preference.PreferenceManager;
import android.support.annotation.NonNull;


import pw.thedrhax.mosmetro.BuildConfig;
import pw.thedrhax.mosmetro.R;
import pw.thedrhax.mosmetro.httpclient.CachedRetriever;
import pw.thedrhax.util.Notify;
import pw.thedrhax.util.Version;
public void check() {
        }

        long id, max_version;
        String title, message;
        Uri url;
        try {
            id = Integer.parseInt((String)data.get("id"));
            max_version = Integer.parseInt((String)data.get("max_version"));
            title = (String)data.get("title");
            message = (String)data.get("message");
            url = Uri.parse((String)data.get("url"));
        } catch (Exception ex) {
            return;
        }
public void check() {
        new Notify(context).id(255)
                .icon(R.drawable.ic_notification_message)
                .onClick(PendingIntent.getActivity(context, 255,
                        new Intent(Intent.ACTION_VIEW).setData(url),
                        PendingIntent.FLAG_UPDATE_CURRENT
                ))
                .title(title)
import android.content.DialogInterface;
import android.content.Intent;
import android.content.SharedPreferences;
import android.net.Uri;
import android.os.AsyncTask;
import android.preference.PreferenceManager;


import pw.thedrhax.mosmetro.BuildConfig;
import pw.thedrhax.mosmetro.R;
import pw.thedrhax.mosmetro.httpclient.CachedRetriever;
import pw.thedrhax.util.Version;

public void download() {
                    .putInt("pref_updater_build", version)
                    .apply();

            context.startActivity(new Intent(Intent.ACTION_VIEW).setData(Uri.parse(url)));
        }
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
          <property key="DynamicImport-Package" value="netscape.javascript" />
          <property key="Import-Package" value="javax.xml.namespace, *;resolution:=optional" />
          <property key="Bundle-Name" value="cy3sbml" />
          <property key="Bundle-ClassPath" value=".,noggit-0.6.jar,jersey-common-2.17.jar,jackson-annotations-2.8.0.jar,netty-3.4.0.Final.jar,biomodels-wslib-1.21.jar,spring-context-support-3.2.9.RELEASE.jar,json-simple-1.1.1.jar,axis2-1.6.2.jar,httpcore-4.4.4.jar,hibernate-validator-5.0.1.Final.jar,javax.inject-2.4.0-b10.jar,antlr4-annotations-4.3.jar,axis-wsdl4j-1.5.1.jar,commons-lang3-3.4.jar,log4j-api-2.3.jar,BFLog-1.3.3.jar,jsbml-groups-1.2-20160818.131451-5.jar,commons-net-3.1.jar,jdom2-2.0.5.jar,spring-beans-3.2.9.RELEASE.jar,aopalliance-repackaged-2.4.0-b10.jar,snappy-java-1.0.5.jar,collection-0.6.jar,jsbml-dyn-1.2-20160818.131320-5.jar,osgi-resource-locator-1.0.1.jar,junit-4.12.jar,ols-client-2.5-20160617.102510-1.jar,woodstox-core-5.0.1.jar,biojava-ontology-4.0.0.jar,jackson-core-asl-1.9.13.jar,log4j-1.2.15.jar,jcommander-1.32.jar,spring-core-3.2.9.RELEASE.jar,velocity-1.7.jar,jersey-client-2.17.jar,woodstox-core-asl-4.4.1.jar,javassist-3.18.1-GA.jar,hk2-locator-2.4.0-b10.jar,libthrift-0.9.2.jar,jsbml-multi-1.2-20160818.131626-5.jar,jsbml-spatial-1.2-20160818.131930-5.jar,commons-io-2.5.jar,commons-collections-3.2.1.jar,spring-aop-3.2.9.RELEASE.jar,jena-arq-3.1.0.jar,servlet-api-2.5-20081211.jar,jackson-core-2.8.1.jar,log4j-1.2-api-2.3.jar,hamcrest-core-1.3.jar,antlr-runtime-3.5.jar,httpclient-4.5.2.jar,guava-17.0.jar,spring-expression-3.2.9.RELEASE.jar,jena-iri-3.1.0.jar,jsbml-comp-1.2-20160818.131010-5.jar,jsbml-1.2-20160818.132014-5.jar,jetty-6.1.26.jar,jena-shaded-guava-3.1.0.jar,jcl-over-slf4j-1.7.21.jar,joda-time-2.1.jar,commons-cli-1.3.jar,jsbml-layout-1.2-20160818.131540-5.jar,guice-4.0.jar,validation-api-1.1.0.Final.jar,jaxb-osgi-2.2.11.jar,xmlpull-1.1.3.1.jar,jena-base-3.1.0.jar,jsbml-distrib-1.2-20160818.131236-5.jar,activation-1.1.jar,mail-1.4.jar,registry-lib-1.1.1.jar,jersey-guava-2.17.jar,avro-1.7.6.jar,classmate-0.8.0.jar,miriam-lib-1.1.6.jar,paranamer-2.3.jar,hamcrest-all-1.3.jar,axis-1.4.jar,jsonld-java-0.8.3.jar,jmxtools-1.2.1.jar,slf4j-api-1.7.21.jar,staxmate-2.3.0.jar,commons-configuration-1.9.jar,axis-jaxrpc-1.4.jar,jena-core-3.1.0.jar,xz-1.0.jar,jetty-util-6.1.26.jar,spi-0.2.4.jar,httpclient-osgi-4.5.2.jar,jms-1.1.jar,jsr305-2.0.3.jar,httpcore-osgi-4.4.4.jar,commons-lang-2.6.jar,jaxb2-basics-runtime-0.11.0.jar,xpp3_min-1.1.4c.jar,jsbml-fbc-1.2-20160818.131406-5.jar,jigsaw-2.2.6.jar,logback-classic-1.1.7.jar,solr-solrj-5.2.1.jar,ST4-4.0.8.jar,httpclient-cache-4.5.2.jar,hk2-api-2.4.0-b10.jar,japi-1.0.7.jar,guice-multibindings-4.0.jar,jmxri-1.2.1.jar,jsbml-render-1.2-20160818.131759-5.jar,jsbml-tidy-1.2-20160818.131153-5.jar,httpcore-nio-4.4.4.jar,ehcache-2.10.2.2.21.jar,commons-compress-1.4.1.jar,jersey-media-jaxb-2.17.jar,jsbml-req-1.2-20160818.131843-5.jar,antlr4-runtime-4.3.jar,jboss-logging-3.1.1.GA.jar,taverna-robundle-0.15.1-incubating.jar,fluent-hc-4.5.2.jar,jsbml-core-1.2-20160818.130905-5.jar,jackson-databind-2.8.1.jar,stax2-api-3.1.4.jar,jsbml-arrays-1.2-20160818.131054-5.jar,logback-core-1.1.7.jar,LibFX-0.3.0.jar,zookeeper-3.4.6.jar,jsbml-qual-1.2-20160818.131710-5.jar,axis-saaj-1.4.jar,commons-codec-1.9.jar,javax.inject-1.jar,httpmime-4.4.1.jar,xstream-1.3.1.jar,spring-web-3.2.9.RELEASE.jar,jena-tdb-3.1.0.jar,javax.annotation-api-1.2.jar,org.abego.treelayout.core-1.0.1.jar,javax.ws.rs-api-2.0.1.jar,CombineArchive-1.1.1.jar,avro-ipc-1.7.6.jar,commons-logging-1.2.jar,jackson-mapper-asl-1.9.13.jar,commons-csv-1.0.jar,joda-convert-1.3.1.jar,jtidy-r938.jar,antlr4-4.3.jar,commons-discovery-0.2.jar,aopalliance-1.0.jar,spring-context-3.2.9.RELEASE.jar,hk2-utils-2.4.0-b10.jar" />
          <property key="Include-Resource" value="noggit-0.6.jar=$MAVEN_REPOSITORY$/org/noggit/noggit/0.6/noggit-0.6.jar,jersey-common-2.17.jar=$MAVEN_REPOSITORY$/org/glassfish/jersey/core/jersey-common/2.17/jersey-common-2.17.jar,jackson-annotations-2.8.0.jar=$MAVEN_REPOSITORY$/com/fasterxml/jackson/core/jackson-annotations/2.8.0/jackson-annotations-2.8.0.jar,netty-3.4.0.Final.jar=$MAVEN_REPOSITORY$/io/netty/netty/3.4.0.Final/netty-3.4.0.Final.jar,biomodels-wslib-1.21.jar=$MAVEN_REPOSITORY$/uk/ac/ebi/biomodels/biomodels-wslib/1.21/biomodels-wslib-1.21.jar,spring-context-support-3.2.9.RELEASE.jar=$MAVEN_REPOSITORY$/org/springframework/spring-context-support/3.2.9.RELEASE/spring-context-support-3.2.9.RELEASE.jar,json-simple-1.1.1.jar=$MAVEN_REPOSITORY$/com/googlecode/json-simple/json-simple/1.1.1/json-simple-1.1.1.jar,axis2-1.6.2.jar=$MAVEN_REPOSITORY$/org/apache/axis2/axis2/1.6.2/axis2-1.6.2.jar,httpcore-4.4.4.jar=$MAVEN_REPOSITORY$/org/apache/httpcomponents/httpcore/4.4.4/httpcore-4.4.4.jar,hibernate-validator-5.0.1.Final.jar=$MAVEN_REPOSITORY$/org/hibernate/hibernate-validator/5.0.1.Final/hibernate-validator-5.0.1.Final.jar,javax.inject-2.4.0-b10.jar=$MAVEN_REPOSITORY$/org/glassfish/hk2/external/javax.inject/2.4.0-b10/javax.inject-2.4.0-b10.jar,antlr4-annotations-4.3.jar=$MAVEN_REPOSITORY$/org/antlr/antlr4-annotations/4.3/antlr4-annotations-4.3.jar,axis-wsdl4j-1.5.1.jar=$MAVEN_REPOSITORY$/axis/axis-wsdl4j/1.5.1/axis-wsdl4j-1.5.1.jar,commons-lang3-3.4.jar=$MAVEN_REPOSITORY$/org/apache/commons/commons-lang3/3.4/commons-lang3-3.4.jar,log4j-api-2.3.jar=$MAVEN_REPOSITORY$/org/apache/logging/log4j/log4j-api/2.3/log4j-api-2.3.jar,BFLog-1.3.3.jar=$MAVEN_REPOSITORY$/de/binfalse/BFLog/1.3.3/BFLog-1.3.3.jar,jsbml-groups-1.2-20160818.131451-5.jar=$MAVEN_REPOSITORY$/org/sbml/jsbml/ext/jsbml-groups/1.2-SNAPSHOT/jsbml-groups-1.2-SNAPSHOT.jar,commons-net-3.1.jar=$MAVEN_REPOSITORY$/commons-net/commons-net/3.1/commons-net-3.1.jar,jdom2-2.0.5.jar=$MAVEN_REPOSITORY$/org/jdom/jdom2/2.0.5/jdom2-2.0.5.jar,spring-beans-3.2.9.RELEASE.jar=$MAVEN_REPOSITORY$/org/springframework/spring-beans/3.2.9.RELEASE/spring-beans-3.2.9.RELEASE.jar,aopalliance-repackaged-2.4.0-b10.jar=$MAVEN_REPOSITORY$/org/glassfish/hk2/external/aopalliance-repackaged/2.4.0-b10/aopalliance-repackaged-2.4.0-b10.jar,snappy-java-1.0.5.jar=$MAVEN_REPOSITORY$/org/xerial/snappy/snappy-java/1.0.5/snappy-java-1.0.5.jar,collection-0.6.jar=$MAVEN_REPOSITORY$/com/github/andrewoma/dexx/collection/0.6/collection-0.6.jar,jsbml-dyn-1.2-20160818.131320-5.jar=$MAVEN_REPOSITORY$/org/sbml/jsbml/ext/jsbml-dyn/1.2-SNAPSHOT/jsbml-dyn-1.2-SNAPSHOT.jar,osgi-resource-locator-1.0.1.jar=$MAVEN_REPOSITORY$/org/glassfish/hk2/osgi-resource-locator/1.0.1/osgi-resource-locator-1.0.1.jar,junit-4.12.jar=$MAVEN_REPOSITORY$/junit/junit/4.12/junit-4.12.jar,ols-client-2.5-20160617.102510-1.jar=$MAVEN_REPOSITORY$/uk/ac/ebi/pride/utilities/ols-client/2.5-SNAPSHOT/ols-client-2.5-SNAPSHOT.jar,woodstox-core-5.0.1.jar=$MAVEN_REPOSITORY$/com/fasterxml/woodstox/woodstox-core/5.0.1/woodstox-core-5.0.1.jar,biojava-ontology-4.0.0.jar=$MAVEN_REPOSITORY$/org/biojava/biojava-ontology/4.0.0/biojava-ontology-4.0.0.jar,jackson-core-asl-1.9.13.jar=$MAVEN_REPOSITORY$/org/codehaus/jackson/jackson-core-asl/1.9.13/jackson-core-asl-1.9.13.jar,log4j-1.2.15.jar=$MAVEN_REPOSITORY$/log4j/log4j/1.2.15/log4j-1.2.15.jar,jcommander-1.32.jar=$MAVEN_REPOSITORY$/com/beust/jcommander/1.32/jcommander-1.32.jar,spring-core-3.2.9.RELEASE.jar=$MAVEN_REPOSITORY$/org/springframework/spring-core/3.2.9.RELEASE/spring-core-3.2.9.RELEASE.jar,velocity-1.7.jar=$MAVEN_REPOSITORY$/org/apache/velocity/velocity/1.7/velocity-1.7.jar,jersey-client-2.17.jar=$MAVEN_REPOSITORY$/org/glassfish/jersey/core/jersey-client/2.17/jersey-client-2.17.jar,woodstox-core-asl-4.4.1.jar=$MAVEN_REPOSITORY$/org/codehaus/woodstox/woodstox-core-asl/4.4.1/woodstox-core-asl-4.4.1.jar,javassist-3.18.1-GA.jar=$MAVEN_REPOSITORY$/org/javassist/javassist/3.18.1-GA/javassist-3.18.1-GA.jar,hk2-locator-2.4.0-b10.jar=$MAVEN_REPOSITORY$/org/glassfish/hk2/hk2-locator/2.4.0-b10/hk2-locator-2.4.0-b10.jar,libthrift-0.9.2.jar=$MAVEN_REPOSITORY$/org/apache/thrift/libthrift/0.9.2/libthrift-0.9.2.jar,jsbml-multi-1.2-20160818.131626-5.jar=$MAVEN_REPOSITORY$/org/sbml/jsbml/ext/jsbml-multi/1.2-SNAPSHOT/jsbml-multi-1.2-SNAPSHOT.jar,jsbml-spatial-1.2-20160818.131930-5.jar=$MAVEN_REPOSITORY$/org/sbml/jsbml/ext/jsbml-spatial/1.2-SNAPSHOT/jsbml-spatial-1.2-SNAPSHOT.jar,commons-io-2.5.jar=$MAVEN_REPOSITORY$/commons-io/commons-io/2.5/commons-io-2.5.jar,commons-collections-3.2.1.jar=$MAVEN_REPOSITORY$/commons-collections/commons-collections/3.2.1/commons-collections-3.2.1.jar,spring-aop-3.2.9.RELEASE.jar=$MAVEN_REPOSITORY$/org/springframework/spring-aop/3.2.9.RELEASE/spring-aop-3.2.9.RELEASE.jar,jena-arq-3.1.0.jar=$MAVEN_REPOSITORY$/org/apache/jena/jena-arq/3.1.0/jena-arq-3.1.0.jar,servlet-api-2.5-20081211.jar=$MAVEN_REPOSITORY$/org/mortbay/jetty/servlet-api/2.5-20081211/servlet-api-2.5-20081211.jar,jackson-core-2.8.1.jar=$MAVEN_REPOSITORY$/com/fasterxml/jackson/core/jackson-core/2.8.1/jackson-core-2.8.1.jar,log4j-1.2-api-2.3.jar=$MAVEN_REPOSITORY$/org/apache/logging/log4j/log4j-1.2-api/2.3/log4j-1.2-api-2.3.jar,hamcrest-core-1.3.jar=$MAVEN_REPOSITORY$/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar,antlr-runtime-3.5.jar=$MAVEN_REPOSITORY$/org/antlr/antlr-runtime/3.5/antlr-runtime-3.5.jar,httpclient-4.5.2.jar=$MAVEN_REPOSITORY$/org/apache/httpcomponents/httpclient/4.5.2/httpclient-4.5.2.jar,guava-17.0.jar=$MAVEN_REPOSITORY$/com/google/guava/guava/17.0/guava-17.0.jar,spring-expression-3.2.9.RELEASE.jar=$MAVEN_REPOSITORY$/org/springframework/spring-expression/3.2.9.RELEASE/spring-expression-3.2.9.RELEASE.jar,jena-iri-3.1.0.jar=$MAVEN_REPOSITORY$/org/apache/jena/jena-iri/3.1.0/jena-iri-3.1.0.jar,jsbml-comp-1.2-20160818.131010-5.jar=$MAVEN_REPOSITORY$/org/sbml/jsbml/ext/jsbml-comp/1.2-SNAPSHOT/jsbml-comp-1.2-SNAPSHOT.jar,jsbml-1.2-20160818.132014-5.jar=$MAVEN_REPOSITORY$/org/sbml/jsbml/jsbml/1.2-SNAPSHOT/jsbml-1.2-SNAPSHOT.jar,jetty-6.1.26.jar=$MAVEN_REPOSITORY$/org/mortbay/jetty/jetty/6.1.26/jetty-6.1.26.jar,jena-shaded-guava-3.1.0.jar=$MAVEN_REPOSITORY$/org/apache/jena/jena-shaded-guava/3.1.0/jena-shaded-guava-3.1.0.jar,jcl-over-slf4j-1.7.21.jar=$MAVEN_REPOSITORY$/org/slf4j/jcl-over-slf4j/1.7.21/jcl-over-slf4j-1.7.21.jar,joda-time-2.1.jar=$MAVEN_REPOSITORY$/joda-time/joda-time/2.1/joda-time-2.1.jar,commons-cli-1.3.jar=$MAVEN_REPOSITORY$/commons-cli/commons-cli/1.3/commons-cli-1.3.jar,jsbml-layout-1.2-20160818.131540-5.jar=$MAVEN_REPOSITORY$/org/sbml/jsbml/ext/jsbml-layout/1.2-SNAPSHOT/jsbml-layout-1.2-SNAPSHOT.jar,guice-4.0.jar=$MAVEN_REPOSITORY$/com/google/inject/guice/4.0/guice-4.0.jar,validation-api-1.1.0.Final.jar=$MAVEN_REPOSITORY$/javax/validation/validation-api/1.1.0.Final/validation-api-1.1.0.Final.jar,jaxb-osgi-2.2.11.jar=$MAVEN_REPOSITORY$/com/sun/xml/bind/jaxb-osgi/2.2.11/jaxb-osgi-2.2.11.jar,xmlpull-1.1.3.1.jar=$MAVEN_REPOSITORY$/xmlpull/xmlpull/1.1.3.1/xmlpull-1.1.3.1.jar,jena-base-3.1.0.jar=$MAVEN_REPOSITORY$/org/apache/jena/jena-base/3.1.0/jena-base-3.1.0.jar,jsbml-distrib-1.2-20160818.131236-5.jar=$MAVEN_REPOSITORY$/org/sbml/jsbml/ext/jsbml-distrib/1.2-SNAPSHOT/jsbml-distrib-1.2-SNAPSHOT.jar,activation-1.1.jar=$MAVEN_REPOSITORY$/javax/activation/activation/1.1/activation-1.1.jar,mail-1.4.jar=$MAVEN_REPOSITORY$/javax/mail/mail/1.4/mail-1.4.jar,registry-lib-1.1.1.jar=$MAVEN_REPOSITORY$/org/identifiers/registry-lib/1.1.1/registry-lib-1.1.1.jar,jersey-guava-2.17.jar=$MAVEN_REPOSITORY$/org/glassfish/jersey/bundles/repackaged/jersey-guava/2.17/jersey-guava-2.17.jar,avro-1.7.6.jar=$MAVEN_REPOSITORY$/org/apache/avro/avro/1.7.6/avro-1.7.6.jar,classmate-0.8.0.jar=$MAVEN_REPOSITORY$/com/fasterxml/classmate/0.8.0/classmate-0.8.0.jar,miriam-lib-1.1.6.jar=$MAVEN_REPOSITORY$/uk/ac/ebi/miriam/miriam-lib/1.1.6/miriam-lib-1.1.6.jar,paranamer-2.3.jar=$MAVEN_REPOSITORY$/com/thoughtworks/paranamer/paranamer/2.3/paranamer-2.3.jar,hamcrest-all-1.3.jar=$MAVEN_REPOSITORY$/org/hamcrest/hamcrest-all/1.3/hamcrest-all-1.3.jar,axis-1.4.jar=$MAVEN_REPOSITORY$/axis/axis/1.4/axis-1.4.jar,jsonld-java-0.8.3.jar=$MAVEN_REPOSITORY$/com/github/jsonld-java/jsonld-java/0.8.3/jsonld-java-0.8.3.jar,jmxtools-1.2.1.jar=$MAVEN_REPOSITORY$/com/sun/jdmk/jmxtools/1.2.1/jmxtools-1.2.1.jar,slf4j-api-1.7.21.jar=$MAVEN_REPOSITORY$/org/slf4j/slf4j-api/1.7.21/slf4j-api-1.7.21.jar,staxmate-2.3.0.jar=$MAVEN_REPOSITORY$/com/fasterxml/staxmate/staxmate/2.3.0/staxmate-2.3.0.jar,commons-configuration-1.9.jar=$MAVEN_REPOSITORY$/commons-configuration/commons-configuration/1.9/commons-configuration-1.9.jar,axis-jaxrpc-1.4.jar=$MAVEN_REPOSITORY$/org/apache/axis/axis-jaxrpc/1.4/axis-jaxrpc-1.4.jar,jena-core-3.1.0.jar=$MAVEN_REPOSITORY$/org/apache/jena/jena-core/3.1.0/jena-core-3.1.0.jar,xz-1.0.jar=$MAVEN_REPOSITORY$/org/tukaani/xz/1.0/xz-1.0.jar,jetty-util-6.1.26.jar=$MAVEN_REPOSITORY$/org/mortbay/jetty/jetty-util/6.1.26/jetty-util-6.1.26.jar,spi-0.2.4.jar=$MAVEN_REPOSITORY$/org/mangosdk/spi/spi/0.2.4/spi-0.2.4.jar,httpclient-osgi-4.5.2.jar=$MAVEN_REPOSITORY$/org/apache/httpcomponents/httpclient-osgi/4.5.2/httpclient-osgi-4.5.2.jar,jms-1.1.jar=$MAVEN_REPOSITORY$/javax/jms/jms/1.1/jms-1.1.jar,jsr305-2.0.3.jar=$MAVEN_REPOSITORY$/com/google/code/findbugs/jsr305/2.0.3/jsr305-2.0.3.jar,httpcore-osgi-4.4.4.jar=$MAVEN_REPOSITORY$/org/apache/httpcomponents/httpcore-osgi/4.4.4/httpcore-osgi-4.4.4.jar,commons-lang-2.6.jar=$MAVEN_REPOSITORY$/commons-lang/commons-lang/2.6/commons-lang-2.6.jar,jaxb2-basics-runtime-0.11.0.jar=$MAVEN_REPOSITORY$/org/jvnet/jaxb2_commons/jaxb2-basics-runtime/0.11.0/jaxb2-basics-runtime-0.11.0.jar,xpp3_min-1.1.4c.jar=$MAVEN_REPOSITORY$/xpp3/xpp3_min/1.1.4c/xpp3_min-1.1.4c.jar,jsbml-fbc-1.2-20160818.131406-5.jar=$MAVEN_REPOSITORY$/org/sbml/jsbml/ext/jsbml-fbc/1.2-SNAPSHOT/jsbml-fbc-1.2-SNAPSHOT.jar,jigsaw-2.2.6.jar=$MAVEN_REPOSITORY$/org/w3c/jigsaw/jigsaw/2.2.6/jigsaw-2.2.6.jar,logback-classic-1.1.7.jar=$MAVEN_REPOSITORY$/ch/qos/logback/logback-classic/1.1.7/logback-classic-1.1.7.jar,solr-solrj-5.2.1.jar=$MAVEN_REPOSITORY$/org/apache/solr/solr-solrj/5.2.1/solr-solrj-5.2.1.jar,ST4-4.0.8.jar=$MAVEN_REPOSITORY$/org/antlr/ST4/4.0.8/ST4-4.0.8.jar,httpclient-cache-4.5.2.jar=$MAVEN_REPOSITORY$/org/apache/httpcomponents/httpclient-cache/4.5.2/httpclient-cache-4.5.2.jar,hk2-api-2.4.0-b10.jar=$MAVEN_REPOSITORY$/org/glassfish/hk2/hk2-api/2.4.0-b10/hk2-api-2.4.0-b10.jar,japi-1.0.7.jar=$MAVEN_REPOSITORY$/uk/ac/ebi/uniprot/japi/1.0.7/japi-1.0.7.jar,guice-multibindings-4.0.jar=$MAVEN_REPOSITORY$/com/google/inject/extensions/guice-multibindings/4.0/guice-multibindings-4.0.jar,jmxri-1.2.1.jar=$MAVEN_REPOSITORY$/com/sun/jmx/jmxri/1.2.1/jmxri-1.2.1.jar,jsbml-render-1.2-20160818.131759-5.jar=$MAVEN_REPOSITORY$/org/sbml/jsbml/ext/jsbml-render/1.2-SNAPSHOT/jsbml-render-1.2-SNAPSHOT.jar,jsbml-tidy-1.2-20160818.131153-5.jar=$MAVEN_REPOSITORY$/org/sbml/jsbml/modules/jsbml-tidy/1.2-SNAPSHOT/jsbml-tidy-1.2-SNAPSHOT.jar,httpcore-nio-4.4.4.jar=$MAVEN_REPOSITORY$/org/apache/httpcomponents/httpcore-nio/4.4.4/httpcore-nio-4.4.4.jar,ehcache-2.10.2.2.21.jar=$MAVEN_REPOSITORY$/net/sf/ehcache/ehcache/2.10.2.2.21/ehcache-2.10.2.2.21.jar,commons-compress-1.4.1.jar=$MAVEN_REPOSITORY$/org/apache/commons/commons-compress/1.4.1/commons-compress-1.4.1.jar,jersey-media-jaxb-2.17.jar=$MAVEN_REPOSITORY$/org/glassfish/jersey/media/jersey-media-jaxb/2.17/jersey-media-jaxb-2.17.jar,jsbml-req-1.2-20160818.131843-5.jar=$MAVEN_REPOSITORY$/org/sbml/jsbml/ext/jsbml-req/1.2-SNAPSHOT/jsbml-req-1.2-SNAPSHOT.jar,antlr4-runtime-4.3.jar=$MAVEN_REPOSITORY$/org/antlr/antlr4-runtime/4.3/antlr4-runtime-4.3.jar,jboss-logging-3.1.1.GA.jar=$MAVEN_REPOSITORY$/org/jboss/logging/jboss-logging/3.1.1.GA/jboss-logging-3.1.1.GA.jar,taverna-robundle-0.15.1-incubating.jar=$MAVEN_REPOSITORY$/org/apache/taverna/language/taverna-robundle/0.15.1-incubating/taverna-robundle-0.15.1-incubating.jar,fluent-hc-4.5.2.jar=$MAVEN_REPOSITORY$/org/apache/httpcomponents/fluent-hc/4.5.2/fluent-hc-4.5.2.jar,jsbml-core-1.2-20160818.130905-5.jar=$MAVEN_REPOSITORY$/org/sbml/jsbml/jsbml-core/1.2-SNAPSHOT/jsbml-core-1.2-SNAPSHOT.jar,jackson-databind-2.8.1.jar=$MAVEN_REPOSITORY$/com/fasterxml/jackson/core/jackson-databind/2.8.1/jackson-databind-2.8.1.jar,stax2-api-3.1.4.jar=$MAVEN_REPOSITORY$/org/codehaus/woodstox/stax2-api/3.1.4/stax2-api-3.1.4.jar,jsbml-arrays-1.2-20160818.131054-5.jar=$MAVEN_REPOSITORY$/org/sbml/jsbml/ext/jsbml-arrays/1.2-SNAPSHOT/jsbml-arrays-1.2-SNAPSHOT.jar,logback-core-1.1.7.jar=$MAVEN_REPOSITORY$/ch/qos/logback/logback-core/1.1.7/logback-core-1.1.7.jar,LibFX-0.3.0.jar=$MAVEN_REPOSITORY$/org/codefx/libfx/LibFX/0.3.0/LibFX-0.3.0.jar,zookeeper-3.4.6.jar=$MAVEN_REPOSITORY$/org/apache/zookeeper/zookeeper/3.4.6/zookeeper-3.4.6.jar,jsbml-qual-1.2-20160818.131710-5.jar=$MAVEN_REPOSITORY$/org/sbml/jsbml/ext/jsbml-qual/1.2-SNAPSHOT/jsbml-qual-1.2-SNAPSHOT.jar,axis-saaj-1.4.jar=$MAVEN_REPOSITORY$/org/apache/axis/axis-saaj/1.4/axis-saaj-1.4.jar,commons-codec-1.9.jar=$MAVEN_REPOSITORY$/commons-codec/commons-codec/1.9/commons-codec-1.9.jar,javax.inject-1.jar=$MAVEN_REPOSITORY$/javax/inject/javax.inject/1/javax.inject-1.jar,httpmime-4.4.1.jar=$MAVEN_REPOSITORY$/org/apache/httpcomponents/httpmime/4.4.1/httpmime-4.4.1.jar,xstream-1.3.1.jar=$MAVEN_REPOSITORY$/com/thoughtworks/xstream/xstream/1.3.1/xstream-1.3.1.jar,spring-web-3.2.9.RELEASE.jar=$MAVEN_REPOSITORY$/org/springframework/spring-web/3.2.9.RELEASE/spring-web-3.2.9.RELEASE.jar,jena-tdb-3.1.0.jar=$MAVEN_REPOSITORY$/org/apache/jena/jena-tdb/3.1.0/jena-tdb-3.1.0.jar,javax.annotation-api-1.2.jar=$MAVEN_REPOSITORY$/javax/annotation/javax.annotation-api/1.2/javax.annotation-api-1.2.jar,org.abego.treelayout.core-1.0.1.jar=$MAVEN_REPOSITORY$/org/abego/treelayout/org.abego.treelayout.core/1.0.1/org.abego.treelayout.core-1.0.1.jar,javax.ws.rs-api-2.0.1.jar=$MAVEN_REPOSITORY$/javax/ws/rs/javax.ws.rs-api/2.0.1/javax.ws.rs-api-2.0.1.jar,CombineArchive-1.1.1.jar=$MAVEN_REPOSITORY$/de/unirostock/sems/CombineArchive/1.1.1/CombineArchive-1.1.1.jar,avro-ipc-1.7.6.jar=$MAVEN_REPOSITORY$/org/apache/avro/avro-ipc/1.7.6/avro-ipc-1.7.6.jar,commons-logging-1.2.jar=$MAVEN_REPOSITORY$/commons-logging/commons-logging/1.2/commons-logging-1.2.jar,jackson-mapper-asl-1.9.13.jar=$MAVEN_REPOSITORY$/org/codehaus/jackson/jackson-mapper-asl/1.9.13/jackson-mapper-asl-1.9.13.jar,commons-csv-1.0.jar=$MAVEN_REPOSITORY$/org/apache/commons/commons-csv/1.0/commons-csv-1.0.jar,joda-convert-1.3.1.jar=$MAVEN_REPOSITORY$/org/joda/joda-convert/1.3.1/joda-convert-1.3.1.jar,jtidy-r938.jar=$MAVEN_REPOSITORY$/net/sf/jtidy/jtidy/r938/jtidy-r938.jar,antlr4-4.3.jar=$MAVEN_REPOSITORY$/org/antlr/antlr4/4.3/antlr4-4.3.jar,commons-discovery-0.2.jar=$MAVEN_REPOSITORY$/commons-discovery/commons-discovery/0.2/commons-discovery-0.2.jar,aopalliance-1.0.jar=$MAVEN_REPOSITORY$/aopalliance/aopalliance/1.0/aopalliance-1.0.jar,spring-context-3.2.9.RELEASE.jar=$MAVEN_REPOSITORY$/org/springframework/spring-context/3.2.9.RELEASE/spring-context-3.2.9.RELEASE.jar,hk2-utils-2.4.0-b10.jar=$MAVEN_REPOSITORY$/org/glassfish/hk2/hk2-utils/2.4.0-b10/hk2-utils-2.4.0-b10.jar" />
          <property key="Embedded-Artifacts" value="noggit-0.6.jar;g=&quot;org.noggit&quot;;a=&quot;noggit&quot;;v=&quot;0.6&quot;,jersey-common-2.17.jar;g=&quot;org.glassfish.jersey.core&quot;;a=&quot;jersey-common&quot;;v=&quot;2.17&quot;,jackson-annotations-2.8.0.jar;g=&quot;com.fasterxml.jackson.core&quot;;a=&quot;jackson-annotations&quot;;v=&quot;2.8.0&quot;,netty-3.4.0.Final.jar;g=&quot;io.netty&quot;;a=&quot;netty&quot;;v=&quot;3.4.0.Final&quot;,biomodels-wslib-1.21.jar;g=&quot;uk.ac.ebi.biomodels&quot;;a=&quot;biomodels-wslib&quot;;v=&quot;1.21&quot;,spring-context-support-3.2.9.RELEASE.jar;g=&quot;org.springframework&quot;;a=&quot;spring-context-support&quot;;v=&quot;3.2.9.RELEASE&quot;,json-simple-1.1.1.jar;g=&quot;com.googlecode.json-simple&quot;;a=&quot;json-simple&quot;;v=&quot;1.1.1&quot;,axis2-1.6.2.jar;g=&quot;org.apache.axis2&quot;;a=&quot;axis2&quot;;v=&quot;1.6.2&quot;,httpcore-4.4.4.jar;g=&quot;org.apache.httpcomponents&quot;;a=&quot;httpcore&quot;;v=&quot;4.4.4&quot;,hibernate-validator-5.0.1.Final.jar;g=&quot;org.hibernate&quot;;a=&quot;hibernate-validator&quot;;v=&quot;5.0.1.Final&quot;,javax.inject-2.4.0-b10.jar;g=&quot;org.glassfish.hk2.external&quot;;a=&quot;javax.inject&quot;;v=&quot;2.4.0-b10&quot;,antlr4-annotations-4.3.jar;g=&quot;org.antlr&quot;;a=&quot;antlr4-annotations&quot;;v=&quot;4.3&quot;,axis-wsdl4j-1.5.1.jar;g=&quot;axis&quot;;a=&quot;axis-wsdl4j&quot;;v=&quot;1.5.1&quot;,commons-lang3-3.4.jar;g=&quot;org.apache.commons&quot;;a=&quot;commons-lang3&quot;;v=&quot;3.4&quot;,log4j-api-2.3.jar;g=&quot;org.apache.logging.log4j&quot;;a=&quot;log4j-api&quot;;v=&quot;2.3&quot;,BFLog-1.3.3.jar;g=&quot;de.binfalse&quot;;a=&quot;BFLog&quot;;v=&quot;1.3.3&quot;,jsbml-groups-1.2-20160818.131451-5.jar;g=&quot;org.sbml.jsbml.ext&quot;;a=&quot;jsbml-groups&quot;;v=&quot;1.2-20160818.131451-5&quot;,commons-net-3.1.jar;g=&quot;commons-net&quot;;a=&quot;commons-net&quot;;v=&quot;3.1&quot;,jdom2-2.0.5.jar;g=&quot;org.jdom&quot;;a=&quot;jdom2&quot;;v=&quot;2.0.5&quot;,spring-beans-3.2.9.RELEASE.jar;g=&quot;org.springframework&quot;;a=&quot;spring-beans&quot;;v=&quot;3.2.9.RELEASE&quot;,aopalliance-repackaged-2.4.0-b10.jar;g=&quot;org.glassfish.hk2.external&quot;;a=&quot;aopalliance-repackaged&quot;;v=&quot;2.4.0-b10&quot;,snappy-java-1.0.5.jar;g=&quot;org.xerial.snappy&quot;;a=&quot;snappy-java&quot;;v=&quot;1.0.5&quot;,collection-0.6.jar;g=&quot;com.github.andrewoma.dexx&quot;;a=&quot;collection&quot;;v=&quot;0.6&quot;,jsbml-dyn-1.2-20160818.131320-5.jar;g=&quot;org.sbml.jsbml.ext&quot;;a=&quot;jsbml-dyn&quot;;v=&quot;1.2-20160818.131320-5&quot;,osgi-resource-locator-1.0.1.jar;g=&quot;org.glassfish.hk2&quot;;a=&quot;osgi-resource-locator&quot;;v=&quot;1.0.1&quot;,junit-4.12.jar;g=&quot;junit&quot;;a=&quot;junit&quot;;v=&quot;4.12&quot;,ols-client-2.5-20160617.102510-1.jar;g=&quot;uk.ac.ebi.pride.utilities&quot;;a=&quot;ols-client&quot;;v=&quot;2.5-20160617.102510-1&quot;,woodstox-core-5.0.1.jar;g=&quot;com.fasterxml.woodstox&quot;;a=&quot;woodstox-core&quot;;v=&quot;5.0.1&quot;,biojava-ontology-4.0.0.jar;g=&quot;org.biojava&quot;;a=&quot;biojava-ontology&quot;;v=&quot;4.0.0&quot;,jackson-core-asl-1.9.13.jar;g=&quot;org.codehaus.jackson&quot;;a=&quot;jackson-core-asl&quot;;v=&quot;1.9.13&quot;,log4j-1.2.15.jar;g=&quot;log4j&quot;;a=&quot;log4j&quot;;v=&quot;1.2.15&quot;,jcommander-1.32.jar;g=&quot;com.beust&quot;;a=&quot;jcommander&quot;;v=&quot;1.32&quot;,spring-core-3.2.9.RELEASE.jar;g=&quot;org.springframework&quot;;a=&quot;spring-core&quot;;v=&quot;3.2.9.RELEASE&quot;,velocity-1.7.jar;g=&quot;org.apache.velocity&quot;;a=&quot;velocity&quot;;v=&quot;1.7&quot;,jersey-client-2.17.jar;g=&quot;org.glassfish.jersey.core&quot;;a=&quot;jersey-client&quot;;v=&quot;2.17&quot;,woodstox-core-asl-4.4.1.jar;g=&quot;org.codehaus.woodstox&quot;;a=&quot;woodstox-core-asl&quot;;v=&quot;4.4.1&quot;,javassist-3.18.1-GA.jar;g=&quot;org.javassist&quot;;a=&quot;javassist&quot;;v=&quot;3.18.1-GA&quot;,hk2-locator-2.4.0-b10.jar;g=&quot;org.glassfish.hk2&quot;;a=&quot;hk2-locator&quot;;v=&quot;2.4.0-b10&quot;,libthrift-0.9.2.jar;g=&quot;org.apache.thrift&quot;;a=&quot;libthrift&quot;;v=&quot;0.9.2&quot;,jsbml-multi-1.2-20160818.131626-5.jar;g=&quot;org.sbml.jsbml.ext&quot;;a=&quot;jsbml-multi&quot;;v=&quot;1.2-20160818.131626-5&quot;,jsbml-spatial-1.2-20160818.131930-5.jar;g=&quot;org.sbml.jsbml.ext&quot;;a=&quot;jsbml-spatial&quot;;v=&quot;1.2-20160818.131930-5&quot;,commons-io-2.5.jar;g=&quot;commons-io&quot;;a=&quot;commons-io&quot;;v=&quot;2.5&quot;,commons-collections-3.2.1.jar;g=&quot;commons-collections&quot;;a=&quot;commons-collections&quot;;v=&quot;3.2.1&quot;,spring-aop-3.2.9.RELEASE.jar;g=&quot;org.springframework&quot;;a=&quot;spring-aop&quot;;v=&quot;3.2.9.RELEASE&quot;,jena-arq-3.1.0.jar;g=&quot;org.apache.jena&quot;;a=&quot;jena-arq&quot;;v=&quot;3.1.0&quot;,servlet-api-2.5-20081211.jar;g=&quot;org.mortbay.jetty&quot;;a=&quot;servlet-api&quot;;v=&quot;2.5-20081211&quot;,jackson-core-2.8.1.jar;g=&quot;com.fasterxml.jackson.core&quot;;a=&quot;jackson-core&quot;;v=&quot;2.8.1&quot;,log4j-1.2-api-2.3.jar;g=&quot;org.apache.logging.log4j&quot;;a=&quot;log4j-1.2-api&quot;;v=&quot;2.3&quot;,hamcrest-core-1.3.jar;g=&quot;org.hamcrest&quot;;a=&quot;hamcrest-core&quot;;v=&quot;1.3&quot;,antlr-runtime-3.5.jar;g=&quot;org.antlr&quot;;a=&quot;antlr-runtime&quot;;v=&quot;3.5&quot;,httpclient-4.5.2.jar;g=&quot;org.apache.httpcomponents&quot;;a=&quot;httpclient&quot;;v=&quot;4.5.2&quot;,guava-17.0.jar;g=&quot;com.google.guava&quot;;a=&quot;guava&quot;;v=&quot;17.0&quot;,spring-expression-3.2.9.RELEASE.jar;g=&quot;org.springframework&quot;;a=&quot;spring-expression&quot;;v=&quot;3.2.9.RELEASE&quot;,jena-iri-3.1.0.jar;g=&quot;org.apache.jena&quot;;a=&quot;jena-iri&quot;;v=&quot;3.1.0&quot;,jsbml-comp-1.2-20160818.131010-5.jar;g=&quot;org.sbml.jsbml.ext&quot;;a=&quot;jsbml-comp&quot;;v=&quot;1.2-20160818.131010-5&quot;,jsbml-1.2-20160818.132014-5.jar;g=&quot;org.sbml.jsbml&quot;;a=&quot;jsbml&quot;;v=&quot;1.2-20160818.132014-5&quot;,jetty-6.1.26.jar;g=&quot;org.mortbay.jetty&quot;;a=&quot;jetty&quot;;v=&quot;6.1.26&quot;,jena-shaded-guava-3.1.0.jar;g=&quot;org.apache.jena&quot;;a=&quot;jena-shaded-guava&quot;;v=&quot;3.1.0&quot;,jcl-over-slf4j-1.7.21.jar;g=&quot;org.slf4j&quot;;a=&quot;jcl-over-slf4j&quot;;v=&quot;1.7.21&quot;,joda-time-2.1.jar;g=&quot;joda-time&quot;;a=&quot;joda-time&quot;;v=&quot;2.1&quot;,commons-cli-1.3.jar;g=&quot;commons-cli&quot;;a=&quot;commons-cli&quot;;v=&quot;1.3&quot;,jsbml-layout-1.2-20160818.131540-5.jar;g=&quot;org.sbml.jsbml.ext&quot;;a=&quot;jsbml-layout&quot;;v=&quot;1.2-20160818.131540-5&quot;,guice-4.0.jar;g=&quot;com.google.inject&quot;;a=&quot;guice&quot;;v=&quot;4.0&quot;,validation-api-1.1.0.Final.jar;g=&quot;javax.validation&quot;;a=&quot;validation-api&quot;;v=&quot;1.1.0.Final&quot;,jaxb-osgi-2.2.11.jar;g=&quot;com.sun.xml.bind&quot;;a=&quot;jaxb-osgi&quot;;v=&quot;2.2.11&quot;,xmlpull-1.1.3.1.jar;g=&quot;xmlpull&quot;;a=&quot;xmlpull&quot;;v=&quot;1.1.3.1&quot;,jena-base-3.1.0.jar;g=&quot;org.apache.jena&quot;;a=&quot;jena-base&quot;;v=&quot;3.1.0&quot;,jsbml-distrib-1.2-20160818.131236-5.jar;g=&quot;org.sbml.jsbml.ext&quot;;a=&quot;jsbml-distrib&quot;;v=&quot;1.2-20160818.131236-5&quot;,activation-1.1.jar;g=&quot;javax.activation&quot;;a=&quot;activation&quot;;v=&quot;1.1&quot;,mail-1.4.jar;g=&quot;javax.mail&quot;;a=&quot;mail&quot;;v=&quot;1.4&quot;,registry-lib-1.1.1.jar;g=&quot;org.identifiers&quot;;a=&quot;registry-lib&quot;;v=&quot;1.1.1&quot;,jersey-guava-2.17.jar;g=&quot;org.glassfish.jersey.bundles.repackaged&quot;;a=&quot;jersey-guava&quot;;v=&quot;2.17&quot;,avro-1.7.6.jar;g=&quot;org.apache.avro&quot;;a=&quot;avro&quot;;v=&quot;1.7.6&quot;,classmate-0.8.0.jar;g=&quot;com.fasterxml&quot;;a=&quot;classmate&quot;;v=&quot;0.8.0&quot;,miriam-lib-1.1.6.jar;g=&quot;uk.ac.ebi.miriam&quot;;a=&quot;miriam-lib&quot;;v=&quot;1.1.6&quot;,paranamer-2.3.jar;g=&quot;com.thoughtworks.paranamer&quot;;a=&quot;paranamer&quot;;v=&quot;2.3&quot;,hamcrest-all-1.3.jar;g=&quot;org.hamcrest&quot;;a=&quot;hamcrest-all&quot;;v=&quot;1.3&quot;,axis-1.4.jar;g=&quot;axis&quot;;a=&quot;axis&quot;;v=&quot;1.4&quot;,jsonld-java-0.8.3.jar;g=&quot;com.github.jsonld-java&quot;;a=&quot;jsonld-java&quot;;v=&quot;0.8.3&quot;,jmxtools-1.2.1.jar;g=&quot;com.sun.jdmk&quot;;a=&quot;jmxtools&quot;;v=&quot;1.2.1&quot;,slf4j-api-1.7.21.jar;g=&quot;org.slf4j&quot;;a=&quot;slf4j-api&quot;;v=&quot;1.7.21&quot;,staxmate-2.3.0.jar;g=&quot;com.fasterxml.staxmate&quot;;a=&quot;staxmate&quot;;v=&quot;2.3.0&quot;,commons-configuration-1.9.jar;g=&quot;commons-configuration&quot;;a=&quot;commons-configuration&quot;;v=&quot;1.9&quot;,axis-jaxrpc-1.4.jar;g=&quot;org.apache.axis&quot;;a=&quot;axis-jaxrpc&quot;;v=&quot;1.4&quot;,jena-core-3.1.0.jar;g=&quot;org.apache.jena&quot;;a=&quot;jena-core&quot;;v=&quot;3.1.0&quot;,xz-1.0.jar;g=&quot;org.tukaani&quot;;a=&quot;xz&quot;;v=&quot;1.0&quot;,jetty-util-6.1.26.jar;g=&quot;org.mortbay.jetty&quot;;a=&quot;jetty-util&quot;;v=&quot;6.1.26&quot;,spi-0.2.4.jar;g=&quot;org.mangosdk.spi&quot;;a=&quot;spi&quot;;v=&quot;0.2.4&quot;,httpclient-osgi-4.5.2.jar;g=&quot;org.apache.httpcomponents&quot;;a=&quot;httpclient-osgi&quot;;v=&quot;4.5.2&quot;,jms-1.1.jar;g=&quot;javax.jms&quot;;a=&quot;jms&quot;;v=&quot;1.1&quot;,jsr305-2.0.3.jar;g=&quot;com.google.code.findbugs&quot;;a=&quot;jsr305&quot;;v=&quot;2.0.3&quot;,httpcore-osgi-4.4.4.jar;g=&quot;org.apache.httpcomponents&quot;;a=&quot;httpcore-osgi&quot;;v=&quot;4.4.4&quot;,commons-lang-2.6.jar;g=&quot;commons-lang&quot;;a=&quot;commons-lang&quot;;v=&quot;2.6&quot;,jaxb2-basics-runtime-0.11.0.jar;g=&quot;org.jvnet.jaxb2_commons&quot;;a=&quot;jaxb2-basics-runtime&quot;;v=&quot;0.11.0&quot;,xpp3_min-1.1.4c.jar;g=&quot;xpp3&quot;;a=&quot;xpp3_min&quot;;v=&quot;1.1.4c&quot;,jsbml-fbc-1.2-20160818.131406-5.jar;g=&quot;org.sbml.jsbml.ext&quot;;a=&quot;jsbml-fbc&quot;;v=&quot;1.2-20160818.131406-5&quot;,jigsaw-2.2.6.jar;g=&quot;org.w3c.jigsaw&quot;;a=&quot;jigsaw&quot;;v=&quot;2.2.6&quot;,logback-classic-1.1.7.jar;g=&quot;ch.qos.logback&quot;;a=&quot;logback-classic&quot;;v=&quot;1.1.7&quot;,solr-solrj-5.2.1.jar;g=&quot;org.apache.solr&quot;;a=&quot;solr-solrj&quot;;v=&quot;5.2.1&quot;,ST4-4.0.8.jar;g=&quot;org.antlr&quot;;a=&quot;ST4&quot;;v=&quot;4.0.8&quot;,httpclient-cache-4.5.2.jar;g=&quot;org.apache.httpcomponents&quot;;a=&quot;httpclient-cache&quot;;v=&quot;4.5.2&quot;,hk2-api-2.4.0-b10.jar;g=&quot;org.glassfish.hk2&quot;;a=&quot;hk2-api&quot;;v=&quot;2.4.0-b10&quot;,japi-1.0.7.jar;g=&quot;uk.ac.ebi.uniprot&quot;;a=&quot;japi&quot;;v=&quot;1.0.7&quot;,guice-multibindings-4.0.jar;g=&quot;com.google.inject.extensions&quot;;a=&quot;guice-multibindings&quot;;v=&quot;4.0&quot;,jmxri-1.2.1.jar;g=&quot;com.sun.jmx&quot;;a=&quot;jmxri&quot;;v=&quot;1.2.1&quot;,jsbml-render-1.2-20160818.131759-5.jar;g=&quot;org.sbml.jsbml.ext&quot;;a=&quot;jsbml-render&quot;;v=&quot;1.2-20160818.131759-5&quot;,jsbml-tidy-1.2-20160818.131153-5.jar;g=&quot;org.sbml.jsbml.modules&quot;;a=&quot;jsbml-tidy&quot;;v=&quot;1.2-20160818.131153-5&quot;,httpcore-nio-4.4.4.jar;g=&quot;org.apache.httpcomponents&quot;;a=&quot;httpcore-nio&quot;;v=&quot;4.4.4&quot;,ehcache-2.10.2.2.21.jar;g=&quot;net.sf.ehcache&quot;;a=&quot;ehcache&quot;;v=&quot;2.10.2.2.21&quot;,commons-compress-1.4.1.jar;g=&quot;org.apache.commons&quot;;a=&quot;commons-compress&quot;;v=&quot;1.4.1&quot;,jersey-media-jaxb-2.17.jar;g=&quot;org.glassfish.jersey.media&quot;;a=&quot;jersey-media-jaxb&quot;;v=&quot;2.17&quot;,jsbml-req-1.2-20160818.131843-5.jar;g=&quot;org.sbml.jsbml.ext&quot;;a=&quot;jsbml-req&quot;;v=&quot;1.2-20160818.131843-5&quot;,antlr4-runtime-4.3.jar;g=&quot;org.antlr&quot;;a=&quot;antlr4-runtime&quot;;v=&quot;4.3&quot;,jboss-logging-3.1.1.GA.jar;g=&quot;org.jboss.logging&quot;;a=&quot;jboss-logging&quot;;v=&quot;3.1.1.GA&quot;,taverna-robundle-0.15.1-incubating.jar;g=&quot;org.apache.taverna.language&quot;;a=&quot;taverna-robundle&quot;;v=&quot;0.15.1-incubating&quot;,fluent-hc-4.5.2.jar;g=&quot;org.apache.httpcomponents&quot;;a=&quot;fluent-hc&quot;;v=&quot;4.5.2&quot;,jsbml-core-1.2-20160818.130905-5.jar;g=&quot;org.sbml.jsbml&quot;;a=&quot;jsbml-core&quot;;v=&quot;1.2-20160818.130905-5&quot;,jackson-databind-2.8.1.jar;g=&quot;com.fasterxml.jackson.core&quot;;a=&quot;jackson-databind&quot;;v=&quot;2.8.1&quot;,stax2-api-3.1.4.jar;g=&quot;org.codehaus.woodstox&quot;;a=&quot;stax2-api&quot;;v=&quot;3.1.4&quot;,jsbml-arrays-1.2-20160818.131054-5.jar;g=&quot;org.sbml.jsbml.ext&quot;;a=&quot;jsbml-arrays&quot;;v=&quot;1.2-20160818.131054-5&quot;,logback-core-1.1.7.jar;g=&quot;ch.qos.logback&quot;;a=&quot;logback-core&quot;;v=&quot;1.1.7&quot;,LibFX-0.3.0.jar;g=&quot;org.codefx.libfx&quot;;a=&quot;LibFX&quot;;v=&quot;0.3.0&quot;,zookeeper-3.4.6.jar;g=&quot;org.apache.zookeeper&quot;;a=&quot;zookeeper&quot;;v=&quot;3.4.6&quot;,jsbml-qual-1.2-20160818.131710-5.jar;g=&quot;org.sbml.jsbml.ext&quot;;a=&quot;jsbml-qual&quot;;v=&quot;1.2-20160818.131710-5&quot;,axis-saaj-1.4.jar;g=&quot;org.apache.axis&quot;;a=&quot;axis-saaj&quot;;v=&quot;1.4&quot;,commons-codec-1.9.jar;g=&quot;commons-codec&quot;;a=&quot;commons-codec&quot;;v=&quot;1.9&quot;,javax.inject-1.jar;g=&quot;javax.inject&quot;;a=&quot;javax.inject&quot;;v=&quot;1&quot;,httpmime-4.4.1.jar;g=&quot;org.apache.httpcomponents&quot;;a=&quot;httpmime&quot;;v=&quot;4.4.1&quot;,xstream-1.3.1.jar;g=&quot;com.thoughtworks.xstream&quot;;a=&quot;xstream&quot;;v=&quot;1.3.1&quot;,spring-web-3.2.9.RELEASE.jar;g=&quot;org.springframework&quot;;a=&quot;spring-web&quot;;v=&quot;3.2.9.RELEASE&quot;,jena-tdb-3.1.0.jar;g=&quot;org.apache.jena&quot;;a=&quot;jena-tdb&quot;;v=&quot;3.1.0&quot;,javax.annotation-api-1.2.jar;g=&quot;javax.annotation&quot;;a=&quot;javax.annotation-api&quot;;v=&quot;1.2&quot;,org.abego.treelayout.core-1.0.1.jar;g=&quot;org.abego.treelayout&quot;;a=&quot;org.abego.treelayout.core&quot;;v=&quot;1.0.1&quot;,javax.ws.rs-api-2.0.1.jar;g=&quot;javax.ws.rs&quot;;a=&quot;javax.ws.rs-api&quot;;v=&quot;2.0.1&quot;,CombineArchive-1.1.1.jar;g=&quot;de.unirostock.sems&quot;;a=&quot;CombineArchive&quot;;v=&quot;1.1.1&quot;,avro-ipc-1.7.6.jar;g=&quot;org.apache.avro&quot;;a=&quot;avro-ipc&quot;;v=&quot;1.7.6&quot;,commons-logging-1.2.jar;g=&quot;commons-logging&quot;;a=&quot;commons-logging&quot;;v=&quot;1.2&quot;,jackson-mapper-asl-1.9.13.jar;g=&quot;org.codehaus.jackson&quot;;a=&quot;jackson-mapper-asl&quot;;v=&quot;1.9.13&quot;,commons-csv-1.0.jar;g=&quot;org.apache.commons&quot;;a=&quot;commons-csv&quot;;v=&quot;1.0&quot;,joda-convert-1.3.1.jar;g=&quot;org.joda&quot;;a=&quot;joda-convert&quot;;v=&quot;1.3.1&quot;,jtidy-r938.jar;g=&quot;net.sf.jtidy&quot;;a=&quot;jtidy&quot;;v=&quot;r938&quot;,antlr4-4.3.jar;g=&quot;org.antlr&quot;;a=&quot;antlr4&quot;;v=&quot;4.3&quot;,commons-discovery-0.2.jar;g=&quot;commons-discovery&quot;;a=&quot;commons-discovery&quot;;v=&quot;0.2&quot;,aopalliance-1.0.jar;g=&quot;aopalliance&quot;;a=&quot;aopalliance&quot;;v=&quot;1.0&quot;,spring-context-3.2.9.RELEASE.jar;g=&quot;org.springframework&quot;;a=&quot;spring-context&quot;;v=&quot;3.2.9.RELEASE&quot;,hk2-utils-2.4.0-b10.jar;g=&quot;org.glassfish.hk2&quot;;a=&quot;hk2-utils&quot;;v=&quot;2.4.0-b10&quot;" />
        </additionalProperties>
        <additionalJARContents />
      </configuration>
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: org.cytoscape:event-api:3.4.0" level="project" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: org.cytoscape:swing-util-api:3.4.0" level="project" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: org.cytoscape:viewmodel-api:3.4.0" level="project" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: org.cytoscape:filter-api:3.4.0" level="project" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: org.cytoscape:work-swing-api:3.4.0" level="project" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: org.cytoscape:service-api:3.4.0" level="project" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: org.cytoscape:session-api:3.4.0" level="project" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: org.cytoscape:core-task-api:3.4.0" level="project" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: org.cytoscape:layout-api:3.4.0" level="project" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: org.cytoscape:property-api:3.4.0" level="project" />
    <orderEntry type="library" name="Maven: de.unirostock.sems:CombineArchive:1.1.1" level="project" />
    <orderEntry type="library" name="Maven: de.binfalse:BFLog:1.3.3" level="project" />
    <orderEntry type="library" name="Maven: org.jdom:jdom2:2.0.5" level="project" />
    <orderEntry type="library" name="Maven: org.slf4j:jcl-over-slf4j:1.7.21" level="project" />
    <orderEntry type="library" scope="TEST" name="Maven: org.cytoscape:event-api:test-jar:tests:3.4.0" level="project" />
    <orderEntry type="library" scope="TEST" name="Maven: org.cytoscape:model-impl:test-jar:tests:3.4.0" level="project" />
    <orderEntry type="library" scope="TEST" name="Maven: org.cytoscape:equations-api:3.4.0" level="project" />
    <orderEntry type="library" scope="TEST" name="Maven: org.cytoscape:equations-impl:3.4.0" level="project" />
    <orderEntry type="library" scope="TEST" name="Maven: org.cytoscape:model-impl:3.4.0" level="project" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: org.cytoscape:model-api:3.4.0" level="project" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: org.cytoscape:event-api:3.4.0" level="project" />
    <orderEntry type="library" scope="PROVIDED" name="Maven: org.cytoscape:swing-application-api:3.4.0" level="project" />
    <orderEntry type="library" name="Maven: org.apache.httpcomponents:httpcore-osgi:4.4.4" level="project" />
    <orderEntry type="library" name="Maven: org.apache.httpcomponents:httpcore-nio:4.4.4" level="project" />
    <orderEntry type="library" name="Maven: org.slf4j:jcl-over-slf4j:1.7.21" level="project" />
    <orderEntry type="library" name="Maven: uk.ac.ebi.uniprot:japi:1.0.7" level="project" />
    <orderEntry type="library" name="Maven: aopalliance:aopalliance:1.0" level="project" />
    <orderEntry type="library" name="Maven: com.beust:jcommander:1.32" level="project" />
    <orderEntry type="library" name="Maven: com.fasterxml:classmate:0.8.0" level="project" />
    <orderEntry type="library" name="Maven: org.apache.axis2:axis2:1.6.2" level="project" />
    <orderEntry type="library" name="Maven: org.apache.commons:commons-compress:1.4.1" level="project" />
    <orderEntry type="library" name="Maven: org.apache.httpcomponents:httpmime:4.4.1" level="project" />
    <orderEntry type="library" name="Maven: org.apache.solr:solr-solrj:5.2.1" level="project" />
    <orderEntry type="library" name="Maven: org.apache.velocity:velocity:1.7" level="project" />
    <orderEntry type="library" name="Maven: org.apache.zookeeper:zookeeper:3.4.6" level="project" />
    <orderEntry type="library" name="Maven: org.codehaus.jackson:jackson-core-asl:1.9.13" level="project" />
        <dependency>
            <groupId>uk.ac.ebi.uniprot</groupId>
            <artifactId>japi</artifactId>
            <version>1.0.7</version>
            <exclusions>
                <exclusion>
                    <groupId>ch.qos.logback</groupId>
 * Helper functions to test SBML models.
 */
public class TestUtils {
	public static String BIOMODELS_RESOURCE_PATH = "/models/BioModels-r30_curated";
	public static String BIGGMODELS_RESOURCE_PATH = "/models/bigg_models-v1.2";
	public static String SBMLTESTCASES_RESOURCE_PATH = "/models/sbml-test-suite-3.2.0";
    public static String UNITTESTS_RESOURCE_PATH = "/models/unittests";

	private static final Logger logger = LoggerFactory.getLogger(TestUtils.class);
	
	/** Reads the system proxy variables and sets the 
	 * java system variables so that the tests use these.
	 */
	public static void setSystemProxyForTests(){
		Map<String, String> env = System.getenv();
		String key = "HTTP_PROXY";
		if (env.containsKey(key)){
			String value = env.get(key);
			if (value.startsWith("http://")){
				value = value.substring(7, value.length());
			}
			String[] tokens = value.split(":");
			// we found the proxy settings
			if (tokens.length == 2){
				String host = tokens[0];
				String port = tokens[1];
				logger.info(String.format("Set test proxy: %!s(MISSING):%!s(MISSING)", host, port));
				System.setProperty("http.proxyHost", host);
		        System.setProperty("http.proxyPort", port);		
			}
		}	
	}
	
	/**
	 * Get an iteratable over the resources in the resourcePath.
	 *
	 * Resources in the skip set are skipped.
	 * If a filter string is given only the resources matching the filter are returned.
	 */
	public static Iterable<Object[]> findResources(String resourcePath, String extension, String filter, HashSet<String> skip){
		
		File currentDir = new File(System.getProperty("user.dir"));
		// String rootPath = new File(currentDir, resourcePath).getPath();
		String rootPath = currentDir.getAbsolutePath() + "/src/test/resources" + resourcePath;
		
		System.out.println("curDir:" + currentDir);
		System.out.println("rootPath:" + rootPath);
		
		// Get SBML files for passed tests
		LinkedList<String> sbmlPaths = TestUtils.findFiles(rootPath, extension, filter, skip);
		Collections.sort(sbmlPaths);
		
		int N = sbmlPaths.size();
		System.out.println("Number of resources: " + N);
		Object[][] resources = new String[N][1];
		for (int k=0; k<N; k++){
			String path = sbmlPaths.get(k);
			// create the resource
			String[] items = path.split("/");
			int mindex = -1;
			for (int i=0; i<items.length; i++){
				if (items[i].equals("models")){
					mindex = i;
					break;
				}
			}
			String resource = StringUtils.join(ArrayUtils.subarray(items, mindex, items.length), "/");
			resources[k][0] = "/" + resource;
		}
		return Arrays.asList(resources);
	}
	
	
	/**
	 * Search recursively for all SBML files in given path.
	 * SBML files have to end in ".xml" and pass the filter expression
	 * and is not in the skip set.
	 */
	public static LinkedList<String> findFiles(String path, String extension, String filter, HashSet<String> skip){
		LinkedList<String> fileList = new LinkedList<>();
		
        File root = new File(path);
        File[] list = root.listFiles();
        
        if (list == null){
        	return fileList;
        }
        if (skip == null){
        	skip = new HashSet<>();
        }

        for (File f : list) {
        	String fpath = f.getAbsolutePath();
        	// recursively search directories
            if (f.isDirectory()) {
                fileList.addAll(findFiles(fpath, extension, filter, skip));
            }
            else {
            	String fname = f.getName();
                if (fname.endsWith(extension) && !skip.contains(fname)){
                	// no filter add
                	if (filter == null){
                		fileList.add(fpath);
                	} else {
                		// filter matches add
                        Pattern pattern = Pattern.compile(filter);
                        Matcher m = pattern.matcher(fname);
                		if (m.find()){
                			fileList.add(fpath);	 
                   	 	}
                	}
                }
            }
        }
        return fileList;
    }
	
	public static LinkedList<String> findFiles(String path, String extension){
		return findFiles(path, extension, null, null);
	}

	/**
	 * Read the CyNetworks from given SBML file resource.
     */
	public CyNetwork[] readNetwork(String resource) throws Exception {

        MockitoAnnotations.initMocks(this);
        final CyNetworkFactory networkFactory = new NetworkTestSupport().getNetworkFactory();
        final CyNetworkViewFactory networkViewFactory = new NetworkViewTestSupport().getNetworkViewFactory();
        final CyGroupFactory groupFactory = new GroupTestSupport().getGroupFactory();
		
		// read SBML	
		InputStream instream = TestUtils.class.getResourceAsStream(resource);
		String[] tokens = resource.split("/");
		String fileName = tokens[tokens.length-1];
		CyNetwork[] networks;
		try {
			// Reader can be tested without service adapter, 
			SBMLReaderTask readerTask = new SBMLReaderTask(instream, fileName, networkFactory, groupFactory);

			readerTask.run(null);
			networks = readerTask.getNetworks();
		} catch (Throwable t){
			networks = null;
		}
		return networks;
	}


	public static CyNode findNodeById(String sbmlId, CyNetwork network) {
		for (CyNode node : network.getNodeList()) {
			CyRow attributes = network.getRow(node);
			String id = attributes.get(SBML.ATTR_ID, String.class);
			if (id != null && id.equals(sbmlId)) {
				return node;
			}
		}
		return null;
	}

    /**
     * Perform the network test for a given SBML resource.
     *
     * There is a memory leak in the network creation, probably the following issue
     * 	http://code.cytoscape.org/redmine/issues/3507
     *
     * See also:
     * This aborts the travis build.
     */
    public static void testNetwork(TaskMonitor taskMonitor, String testType, String resource){
        logger.info("--------------------------------------------------------");
        logger.info(String.format("%!s(MISSING) : %!s(MISSING)", testType, resource));

public static void testNetwork(TaskMonitor taskMonitor, String testType, String
            networks = readerTask.getNetworks();
            assertFalse(readerTask.getError());

            for (CyNetwork network: networks){
                network.dispose();
            }

        } catch (Throwable t){
            networks = null;
            t.printStackTrace();
        }
        try {
            instream.close();
        } catch (IOException e){
            e.printStackTrace();
        }

        // Networks could be read
        assertNotNull(networks);
        assertTrue(networks.length >= 1);
    }

    /**
     * Perform the network test for a given SBML resource.
     *
     * There is a memory leak in the network creation, probably the following issue
     * 	http://code.cytoscape.org/redmine/issues/3507
     *
     * See also:
     * This aborts the travis build.
     */
public static void testNetworkSerialization(String testType, String resource) th
        // Deserialize
        InputStream inputStream = new FileInputStream(tempFile.getAbsolutePath());
        InputStream buffer = new BufferedInputStream(inputStream);
        ObjectInput input = new ObjectInputStream (buffer);

        SBMLDocument docSerialized = (SBMLDocument)input.readObject();
        assertNotNull(docSerialized);
    }
}
private void readNetwork(String resource) throws Exception {
        // run the reader
        SBMLReaderTask readerTask = new SBMLReaderTask(instream, fileName, networkFactory, groupFactory);
        readerTask.run(null);
        
    }

    /**
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
package net.techcable.sonarpet;

import java.util.Arrays;
import java.util.EnumMap;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Maps;

import org.bukkit.Sound;

    DONKEY_AMBIENT("ENTITY_DONKEY_AMBIENT", "DONKEY_IDLE"),
    DONKEY_ANGRY("ENTITY_DONKEY_ANGRY", "DONKEY_ANGRY"),
    DONKEY_DEATH("ENTITY_DONKEY_DEATH", "DONKEY_DEATH"),
    ENDERMITE_STEP("ENTITY_ENDERMITE_STEP", "SILVERFISH_WALK"), // SILVERFISH_WALK is the cloest we have on 1.8.8 :(
    GHAST_AMBIENT("ENTITY_GHAST_AMBIENT", "GHAST_MOAN"),
    GHAST_DEATH("ENTITY_GHAST_DEATH", "GHAST_DEATH"),
    HORSE_AMBIENT("ENTITY_HORSE_AMBIENT", "HORSE_IDLE"),
                } else {
                    sound = Sound.valueOf(name);
                }
            } catch (IllegalArgumentException ignroed) {}
        }
        if (sound == null) throw new IllegalArgumentException("No sounds named " + Arrays.toString(names) + " are found!");
        this.sound = sound;
    public Sound getBukkitSound() {
        return sound;
    }
}

import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.entity.Entity;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.LivingEntity;
static INMS getInstance() {
    boolean isLiquid(Material block);

    EntityRegistry getEntityRegistry();
}

/**
package net.techcable.sonarpet.nms;

import org.bukkit.Sound;
import org.bukkit.entity.Entity;
import org.bukkit.entity.LivingEntity;

    void clearGoals();

    Sound getDeathSound();

    Navigation getNavigation();

    double distanceTo(Entity other);

    default void playSound(SafeSound sound, float volume, float pitch) {
        playSound(sound.getBukkitSound(), volume, pitch);
    }

    void playSound(Sound bukkitSound, float volume, float pitch);

    boolean isInvisible();

import net.techcable.sonarpet.nms.NMSEntity;
import net.techcable.sonarpet.nms.NMSInsentientEntity;
import net.techcable.sonarpet.nms.NMSPlayer;
import net.techcable.sonarpet.nms.entity.goals.PetGoalFloat;
import net.techcable.sonarpet.nms.entity.goals.PetGoalFollowOwner;
import net.techcable.sonarpet.nms.entity.goals.PetGoalLookAtPlayer;
public void remove(boolean makeSound) {
        if (this.getEntity() != null) {
            getBukkitEntity().remove();
        }
        if (makeSound) {
            getEntity().playSound(getEntity().getDeathSound(), 1.0F, 1.0F);
        }
    }

import net.techcable.pineapple.reflection.PineappleField;
import net.techcable.pineapple.reflection.Reflection;
import net.techcable.sonarpet.nms.NMSInsentientEntity;

import org.bukkit.Sound;
import org.bukkit.craftbukkit.v1_10_R1.entity.CraftEntity;
public EntityInsentient getHandle() {

    @Override
    @SneakyThrows
    public Sound getDeathSound() {
        SoundEffect soundEffect = (SoundEffect) GET_DEATH_SOUND_METHOD_HANDLE.invoke(getHandle());
        return NMSImpl.toBukkitSound(soundEffect);
    }

    public NMSEntityInsentientImpl(EntityInsentient handle) {
import net.techcable.sonarpet.nms.BlockSoundData;
import net.techcable.sonarpet.nms.NMSEntity;
import net.techcable.sonarpet.nms.NMSInsentientEntity;
import net.techcable.sonarpet.nms.versions.v1_10_R1.data.NMSSpawnEggItemData;

import org.bukkit.Location;
public EntityRegistry getEntityRegistry() {
        return new NMSEntityRegistry();
    }

    //
    // Utility methods
    //
    private static final ImmutableMap<SoundEffect, Sound> BUKKIT_SOUNDS;
    static {
        ImmutableMap.Builder<SoundEffect, Sound> soundsBuilder = ImmutableMap.builder();
        for (Sound bukkitSound : Sound.values()) {
            SoundEffect mojangSound = CraftSound.getSoundEffect(CraftSound.getSound(bukkitSound));
            soundsBuilder.put(mojangSound, bukkitSound);
        }
        BUKKIT_SOUNDS = soundsBuilder.build();
    }
    public static Sound toBukkitSound(SoundEffect mojangEffect) {
        Sound bukkitEffect = BUKKIT_SOUNDS.get(mojangEffect);
        if (bukkitEffect == null) throw new AssertionError("No bukkit sound effect for mojang effect: " + mojangEffect);
        return bukkitEffect;
    }
}
import net.techcable.pineapple.reflection.PineappleField;
import net.techcable.sonarpet.nms.DataWatcher;
import net.techcable.sonarpet.nms.NMSLivingEntity;

import org.bukkit.Sound;
import org.bukkit.craftbukkit.v1_10_R1.CraftSound;
public void setStepHeight(float stepHeight) {
    //

    @Override
    public void playSound(Sound bukkitSound, float volume, float pitch) {
        SoundEffect sound = CraftSound.getSoundEffect(CraftSound.getSound(bukkitSound));
        getHandle().a(sound, volume, pitch);
    }

    @Override
import net.techcable.pineapple.reflection.PineappleField;
import net.techcable.pineapple.reflection.Reflection;
import net.techcable.sonarpet.nms.NMSInsentientEntity;

import org.bukkit.Sound;
import org.bukkit.craftbukkit.v1_11_R1.entity.CraftEntity;
public EntityInsentient getHandle() {

    @Override
    @SneakyThrows
    public Sound getDeathSound() {
        SoundEffect soundEffect = (SoundEffect) GET_DEATH_SOUND_METHOD_HANDLE.invoke(getHandle());
        return NMSImpl.toBukkitSound(soundEffect);
    }

    public NMSEntityInsentientImpl(EntityInsentient handle) {
import net.techcable.sonarpet.nms.INMS;
import net.techcable.sonarpet.nms.NMSEntity;
import net.techcable.sonarpet.nms.NMSInsentientEntity;
import net.techcable.sonarpet.nms.versions.v1_11_R1.data.NMSSpawnEggItemData;

import org.bukkit.Location;
public EntityRegistry getEntityRegistry() {
        return new NMSEntityRegistry();
    }

    //
    // Utility methods
    //
    private static final ImmutableMap<SoundEffect, Sound> BUKKIT_SOUNDS;
    static {
        ImmutableMap.Builder<SoundEffect, Sound> soundsBuilder = ImmutableMap.builder();
        for (Sound bukkitSound : Sound.values()) {
            SoundEffect mojangSound = CraftSound.getSoundEffect(CraftSound.getSound(bukkitSound));
            soundsBuilder.put(mojangSound, bukkitSound);
        }
        BUKKIT_SOUNDS = soundsBuilder.build();
    }
    public static Sound toBukkitSound(SoundEffect mojangEffect) {
        Sound bukkitEffect = BUKKIT_SOUNDS.get(mojangEffect);
        if (bukkitEffect == null) throw new AssertionError("No bukkit sound effect for mojang effect: " + mojangEffect);
        return bukkitEffect;
    }
}
import net.techcable.pineapple.reflection.PineappleField;
import net.techcable.sonarpet.nms.DataWatcher;
import net.techcable.sonarpet.nms.NMSLivingEntity;

import org.bukkit.Sound;
import org.bukkit.craftbukkit.v1_11_R1.CraftSound;
public void setStepHeight(float stepHeight) {
    //

    @Override
    public void playSound(Sound bukkitSound, float volume, float pitch) {
        SoundEffect sound = CraftSound.getSoundEffect(CraftSound.getSound(bukkitSound));
        getHandle().a(sound, volume, pitch);
    }

    @Override
import net.techcable.pineapple.reflection.PineappleField;
import net.techcable.pineapple.reflection.Reflection;
import net.techcable.sonarpet.nms.NMSInsentientEntity;

import org.bukkit.Sound;
import org.bukkit.craftbukkit.v1_8_R3.entity.CraftEntity;
import org.bukkit.craftbukkit.v1_8_R3.entity.CraftLivingEntity;
import org.bukkit.entity.Entity;
public EntityInsentient getHandle() {

    @Override
    @SneakyThrows
    public Sound getDeathSound() {
        String soundEffect = (String) GET_DEATH_SOUND_METHOD_HANDLE.invoke(getHandle());
        return NMSImpl.toBukkitSound(soundEffect);
    }

    public NMSEntityInsentientImpl(EntityInsentient handle) {
package net.techcable.sonarpet.nms.versions.v1_8_R3;

import net.minecraft.server.v1_8_R3.EntityHorse;
import net.minecraft.server.v1_8_R3.EntityInsentient;
import net.minecraft.server.v1_8_R3.EntityPlayer;
import net.techcable.sonarpet.nms.BlockSoundData;
import net.techcable.sonarpet.nms.NMSEntity;
import net.techcable.sonarpet.nms.NMSInsentientEntity;

import org.bukkit.Location;
import org.bukkit.Material;
public EntityRegistry getEntityRegistry() {
        return new NMSEntityRegistry();
    }

    //
    // Utility methods
    //
    private static final ImmutableMap<String, Sound> BUKKIT_SOUNDS;
    static {
        ImmutableMap.Builder<String, Sound> soundsBuilder = ImmutableMap.builder();
        for (Sound bukkitSound : Sound.values()) {
            soundsBuilder.put(CraftSound.getSound(bukkitSound), bukkitSound);
        }
        BUKKIT_SOUNDS = soundsBuilder.build();
    }
    public static Sound toBukkitSound(String mojangSoundName) {
        Sound bukkitEffect = BUKKIT_SOUNDS.get(mojangSoundName);
        if (bukkitEffect == null) throw new AssertionError("No bukkit sound effect for mojang sound: " + mojangSoundName);
        return bukkitEffect;
    }
}
import net.techcable.pineapple.reflection.PineappleField;
import net.techcable.sonarpet.nms.DataWatcher;
import net.techcable.sonarpet.nms.NMSLivingEntity;

import org.bukkit.Sound;
import org.bukkit.craftbukkit.v1_8_R3.CraftSound;
public double distanceTo(Entity other) {
    //

    @Override
    public void playSound(Sound bukkitSound, float volume, float pitch) {
        String sound = CraftSound.getSound(bukkitSound);
        getHandle().makeSound(sound, volume, pitch);
    }

    @Override
import net.techcable.pineapple.reflection.PineappleField;
import net.techcable.pineapple.reflection.Reflection;
import net.techcable.sonarpet.nms.NMSInsentientEntity;

import org.bukkit.Sound;
import org.bukkit.craftbukkit.v1_9_R1.entity.CraftEntity;
import org.bukkit.craftbukkit.v1_9_R1.entity.CraftLivingEntity;
import org.bukkit.entity.Entity;
public EntityInsentient getHandle() {

    @Override
    @SneakyThrows
    public Sound getDeathSound() {
        SoundEffect soundEffect = (SoundEffect) GET_DEATH_SOUND_METHOD_HANDLE.invoke(getHandle());
        return NMSImpl.toBukkitSound(soundEffect);
    }

    public NMSEntityInsentientImpl(EntityInsentient handle) {
import net.techcable.sonarpet.nms.BlockSoundData;
import net.techcable.sonarpet.nms.NMSEntity;
import net.techcable.sonarpet.nms.NMSInsentientEntity;
import net.techcable.sonarpet.nms.versions.v1_9_R1.data.NMSSpawnEggItemData;

import org.bukkit.Location;
public EntityRegistry getEntityRegistry() {
        return new NMSEntityRegistry();
    }

    //
    // Utility methods
    //
    private static final ImmutableMap<SoundEffect, Sound> BUKKIT_SOUNDS;
    static {
        ImmutableMap.Builder<SoundEffect, Sound> soundsBuilder = ImmutableMap.builder();
        for (Sound bukkitSound : Sound.values()) {
            SoundEffect mojangSound = CraftSound.getSoundEffect(CraftSound.getSound(bukkitSound));
            soundsBuilder.put(mojangSound, bukkitSound);
        }
        BUKKIT_SOUNDS = soundsBuilder.build();
    }
    public static Sound toBukkitSound(SoundEffect mojangEffect) {
        Sound bukkitEffect = BUKKIT_SOUNDS.get(mojangEffect);
        if (bukkitEffect == null) throw new AssertionError("No bukkit sound effect for mojang effect: " + mojangEffect);
        return bukkitEffect;
    }
}
import net.techcable.pineapple.reflection.PineappleField;
import net.techcable.sonarpet.nms.DataWatcher;
import net.techcable.sonarpet.nms.NMSLivingEntity;

import org.bukkit.Sound;
import org.bukkit.craftbukkit.v1_9_R1.CraftSound;
public void setStepHeight(float stepHeight) {
    //

    @Override
    public void playSound(Sound bukkitSound, float volume, float pitch) {
        SoundEffect sound = CraftSound.getSoundEffect(CraftSound.getSound(bukkitSound));
        getHandle().a(sound, volume, pitch);
    }

    @Override
import net.techcable.pineapple.reflection.PineappleField;
import net.techcable.pineapple.reflection.Reflection;
import net.techcable.sonarpet.nms.NMSInsentientEntity;

import org.bukkit.Sound;
import org.bukkit.craftbukkit.v1_9_R2.entity.CraftEntity;
import org.bukkit.craftbukkit.v1_9_R2.entity.CraftLivingEntity;
import org.bukkit.entity.Entity;
public EntityInsentient getHandle() {

    @Override
    @SneakyThrows
    public Sound getDeathSound() {
        SoundEffect soundEffect = (SoundEffect) GET_DEATH_SOUND_METHOD_HANDLE.invoke(getHandle());
        return NMSImpl.toBukkitSound(soundEffect);
    }

    public NMSEntityInsentientImpl(EntityInsentient handle) {
import net.techcable.sonarpet.nms.BlockSoundData;
import net.techcable.sonarpet.nms.NMSEntity;
import net.techcable.sonarpet.nms.NMSInsentientEntity;
import net.techcable.sonarpet.nms.versions.v1_9_R2.data.NMSSpawnEggItemData;

import org.bukkit.Location;
public EntityRegistry getEntityRegistry() {
        return new NMSEntityRegistry();
    }

    //
    // Utility methods
    //
    private static final ImmutableMap<SoundEffect, Sound> BUKKIT_SOUNDS;
    static {
        ImmutableMap.Builder<SoundEffect, Sound> soundsBuilder = ImmutableMap.builder();
        for (Sound bukkitSound : Sound.values()) {
            SoundEffect mojangSound = CraftSound.getSoundEffect(CraftSound.getSound(bukkitSound));
            soundsBuilder.put(mojangSound, bukkitSound);
        }
        BUKKIT_SOUNDS = soundsBuilder.build();
    }
    public static Sound toBukkitSound(SoundEffect mojangEffect) {
        Sound bukkitEffect = BUKKIT_SOUNDS.get(mojangEffect);
        if (bukkitEffect == null) throw new AssertionError("No bukkit sound effect for mojang effect: " + mojangEffect);
        return bukkitEffect;
    }
}
import net.techcable.pineapple.reflection.PineappleField;
import net.techcable.sonarpet.nms.DataWatcher;
import net.techcable.sonarpet.nms.NMSLivingEntity;

import org.bukkit.Sound;
import org.bukkit.craftbukkit.v1_9_R2.CraftSound;
public void setStepHeight(float stepHeight) {
    //

    @Override
    public void playSound(Sound bukkitSound, float volume, float pitch) {
        SoundEffect sound = CraftSound.getSoundEffect(CraftSound.getSound(bukkitSound));
        getHandle().a(sound, volume, pitch);
    }

    @Override
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Dv6
            <option value="$PROJECT_DIR$/app" />
          </set>
        </option>
        <option name="myModules">
          <set>
            <option value="$PROJECT_DIR$" />
            <option value="$PROJECT_DIR$/app" />
          </set>
        </option>
      </GradleProjectSettings>
    </option>
  </component>
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="NullableNotNullManager">
    <option name="myDefaultNullable" value="android.support.annotation.Nullable" />
    <option name="myDefaultNotNull" value="android.support.annotation.NonNull" />
    <ConfirmationsSetting value="0" id="Add" />
    <ConfirmationsSetting value="0" id="Remove" />
  </component>
  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_7" default="true" assert-keyword="true" jdk-15="true" project-jdk-name="1.8" project-jdk-type="JavaSDK">
    <output url="file://$PROJECT_DIR$/build/classes" />
  </component>
  <component name="ProjectType">
<project version="4">
  <component name="ProjectModuleManager">
    <modules>
      <module fileurl="file://$PROJECT_DIR$/Dv6.iml" filepath="$PROJECT_DIR$/Dv6.iml" />
      <module fileurl="file://$PROJECT_DIR$/app/app.iml" filepath="$PROJECT_DIR$/app/app.iml" />
    </modules>
  </component>
<?xml version="1.0" encoding="UTF-8"?>
<module external.linked.project.id="Dv6" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
  <component name="FacetManager">
    <facet type="java-gradle" name="Java-Gradle">
      <configuration>
    <content url="file://$MODULE_DIR$">
      <excludeFolder url="file://$MODULE_DIR$/.gradle" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>
    <facet type="android" name="Android">
      <configuration>
        <option name="SELECTED_BUILD_VARIANT" value="debug" />
        <option name="SELECTED_TEST_ARTIFACT" value="_android_test_" />
        <option name="ASSEMBLE_TASK_NAME" value="assembleDebug" />
        <option name="COMPILE_JAVA_TASK_NAME" value="compileDebugSources" />
        <afterSyncTasks>
      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/debug" isTestSource="false" generated="true" />
      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/debug" isTestSource="false" generated="true" />
      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/debug" isTestSource="false" generated="true" />
      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/debug" type="java-resource" />
      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/resValues/debug" type="java-resource" />
      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/androidTest/debug" isTestSource="true" generated="true" />
      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/androidTest/debug" isTestSource="true" generated="true" />
      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/androidTest/debug" isTestSource="true" generated="true" />
      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/androidTest/debug" isTestSource="true" generated="true" />
      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/androidTest/debug" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/resValues/androidTest/debug" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/debug/res" type="java-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/debug/resources" type="java-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/debug/assets" type="java-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/debug/aidl" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/debug/java" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/debug/jni" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/debug/rs" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/debug/shaders" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/testDebug/res" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/testDebug/resources" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/testDebug/assets" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/testDebug/aidl" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/testDebug/java" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/testDebug/jni" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/testDebug/rs" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/testDebug/shaders" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/res" type="java-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/assets" type="java-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/aidl" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/jni" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/rs" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/shaders" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/res" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/resources" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/assets" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/aidl" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/java" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/jni" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/rs" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/shaders" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/res" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/resources" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/assets" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/aidl" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/java" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/jni" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/rs" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/shaders" isTestSource="true" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/assets" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/blame" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/bundles" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/classes" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/dependency-cache" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.android.support/appcompat-v7/23.0.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.android.support/design/23.0.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/com.android.support/support-v4/23.0.0/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/exploded-aar/eu.chainfire/libsuperuser/1.0.0.201602271131/jars" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/incremental" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/incremental-classes" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/incremental-runtime-classes" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/incremental-safeguard" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/incremental-verifier" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/instant-run-support" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/jniLibs" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/manifests" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/restart-dex" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/rs" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/shaders" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/symbols" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/transforms" />
      <excludeFolder url="file://$MODULE_DIR$/build/outputs" />
    <orderEntry type="jdk" jdkName="Android API 23 Platform" jdkType="Android SDK" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" exported="" name="appcompat-v7-23.0.0" level="project" />
    <orderEntry type="library" exported="" name="libsuperuser-1.0.0.201602271131" level="project" />
    <orderEntry type="library" exported="" name="systembartint-1.0.4" level="project" />
    <orderEntry type="library" exported="" name="support-v4-23.0.0" level="project" />
    <orderEntry type="library" exported="" name="design-23.0.0" level="project" />
    <orderEntry type="library" exported="" name="support-annotations-23.0.0" level="project" />
apply plugin: 'com.android.application'

android {
    compileSdkVersion 23
    buildToolsVersion "23.0.0"

    defaultConfig {
        applicationId "org.daduke.realmar.dhcpv6client"
 * Created by Anastassios Martakos on 8/24/15.
 */
public class MainFragment extends Fragment {
    private Button refresh_button;
    private BroadcastReceiver resultReceiver;

    @Override
public void onCreate(Bundle savedInstanceState) {
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        // Inflate the layout for this fragment
        return inflater.inflate(R.layout.main_fragment, container, false);
    }

    @Override
    public void onStart() {
        super.onStart();

        refresh_button = (Button) getView().findViewById(R.id.button_refresh);

        refresh_button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
public void onClick(View view) {
        });

        get_ip_addresses();
    }

    @Override
private BroadcastReceiver createBroadcastReceiver() {
        return new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                if(intent.getStringExtra("refresh_ips") == "refresh_ips") {
                    get_ip_addresses();
                }
            }
public void onReceive(Context context, Intent intent) {
    public void get_ip_addresses() {
        ArrayList[] ips = Misc.get_ips();

        final ListView list_view = (ListView) getView().findViewById(R.id.ip_addresses);

        ArrayList<Object> ip_collection = new ArrayList<>();

            android:layout_height="match_parent">

            <Button
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/button_refresh"
                android:id="@+id/button_refresh"
                android:layout_centerHorizontal="true" />

        </RelativeLayout>

buildscript {
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:2.1.0'

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
#Tue May 17 12:38:59 CEST 2016
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
               logger.info("Aparapi JNI loaded successfully.");
               openCLAvailable = true;
            }
            catch (final IOException e) {
               logger.log(Level.SEVERE, "Check your environment. Failed to load codegen native library "
                     + " or possibly failed to locate opencl native library (opencl.dll/opencl.so)."
                     + " Ensure that OpenCL is in your PATH (windows) or in LD_LIBRARY_PATH (linux).");
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	</jaxb:bindings>

	<jaxb:bindings schemaLocation="docker_1_0.xsd" >
		<jaxb:bindings node="//xs:complexType[@name='inspectedImageConfigurationType']" >
			<jaxb:class name="InspectedImageConfiguration" />				
		</jaxb:bindings>		 
	</jaxb:bindings>

	<jaxb:bindings schemaLocation="docker_1_0.xsd" >
		<jaxb:bindings node="//xs:complexType[@name='imageCreationType']" >
			<jaxb:class name="ImageCreation" />				
		</jaxb:bindings>		 
		</jaxb:bindings>
	</jaxb:bindings>

	<jaxb:bindings schemaLocation="docker_1_0.xsd" >
		<jaxb:bindings node="//xs:complexType[@name='inspectedImageConfigurationType']//xs:element[@name='exposedPorts']">
			<jaxb:property>
				<jaxb:baseType name="com.alpha.pineapple.docker.model.jaxb.ContainerConfigurationExposedPortsMap" />
			</jaxb:property>
		</jaxb:bindings>
	</jaxb:bindings>

	<jaxb:bindings schemaLocation="docker_1_0.xsd" >
		<jaxb:bindings node="//xs:complexType[@name='inspectedImageConfigurationType']//xs:element[@name='labels']">
			<jaxb:property>
				<jaxb:baseType name="com.alpha.pineapple.docker.model.jaxb.ContainerConfigurationLabelsMap" />
			</jaxb:property>
		</jaxb:bindings>
	</jaxb:bindings>

	<jaxb:bindings schemaLocation="docker_1_0.xsd" >
		<jaxb:bindings node="//xs:complexType[@name='inspectedImageConfigurationType']//xs:element[@name='portSpecs']">
			<jaxb:property>
				<jaxb:baseType name="com.alpha.pineapple.docker.model.jaxb.ContainerConfigurationHostConfigPortBindingsMap" />
			</jaxb:property>
		</jaxb:bindings>
	</jaxb:bindings>

	<jaxb:bindings schemaLocation="docker_1_0.xsd" >
		<jaxb:bindings node="//xs:complexType[@name='inspectedImageConfigurationType']//xs:element[@name='volumes']">
			<jaxb:property>
				<jaxb:baseType name="com.alpha.pineapple.docker.model.jaxb.ContainerConfigurationVolumesMap" />
			</jaxb:property>
		</jaxb:bindings>
	</jaxb:bindings>

	<!-- Map definitions for containers -->

	<jaxb:bindings schemaLocation="docker_1_0.xsd" >
		</xs:annotation>
		<xs:sequence>
			<xs:element name="containerConfig" type="containerConfigurationType" minOccurs="0" maxOccurs="1" />
			<xs:element name="config" type="inspectedImageConfigurationType" minOccurs="0" maxOccurs="1" />
			<xs:element name="graphDriver" type="graphDriverType" minOccurs="0" maxOccurs="1" />			
			<xs:element name="repoDigests" type="stringList" minOccurs="0" maxOccurs="1" />						
			<xs:element name="repoTags" type="stringList" minOccurs="0" maxOccurs="1" />								
		<xs:attribute name="virtualSize" type="xs:long" use="optional"/>	
	</xs:complexType>

	<xs:complexType name="inspectedImageConfigurationType" >
		<xs:annotation>
			<xs:documentation>Docker image configuration (Output from inspecting an image).</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="cmd" type="stringList" minOccurs="0" maxOccurs="1" />
			<xs:element name="entrypoint" type="stringList" minOccurs="0" maxOccurs="1" />
			<xs:element name="env" type="stringList" minOccurs="0" maxOccurs="1" />
			<xs:element name="exposedPorts" type="containerConfigurationExposedPortsType" minOccurs="0" maxOccurs="1" />			
			<xs:element name="labels" type="containerConfigurationLabelsType" minOccurs="0" maxOccurs="1" />
			<xs:element name="onBuild" type="stringList" minOccurs="0" maxOccurs="1" />
			<xs:element name="portSpecs" type="containerConfigurationHostConfigPortBindingsType" minOccurs="0" maxOccurs="1" />									
			<xs:element name="volumes" type="containerConfigurationVolumesType" minOccurs="0" maxOccurs="1" />						
		</xs:sequence>
		<xs:attribute name="attachStderr" type="xs:boolean" use="optional"/>		
		<xs:attribute name="attachStdin" type="xs:boolean" use="optional"/>		
		<xs:attribute name="attachStdout" type="xs:boolean" use="optional"/>		
		<xs:attribute name="domainname" type="xs:string" use="optional"/>		
		<xs:attribute name="hostname" type="xs:string" use="optional"/>		
		<xs:attribute name="image" type="xs:string" use="optional"/>				
		<xs:attribute name="init" type="xs:string" use="optional"/>				
		<xs:attribute name="macAddress" type="xs:string" use="optional"/>				
		<xs:attribute name="networkDisabled" type="xs:boolean" use="optional"/>				
		<xs:attribute name="openStdin" type="xs:boolean" use="optional"/>			
		<xs:attribute name="stdinOnce" type="xs:boolean" use="optional"/>		
		<xs:attribute name="tty" type="xs:boolean" use="optional"/>				
		<xs:attribute name="user" type="xs:string" use="optional"/>		
		<xs:attribute name="volumeDriver" type="xs:string" use="optional"/>		
		<xs:attribute name="workingDir" type="xs:string" use="optional"/>		
	</xs:complexType>

	<xs:complexType name="imageCreationType" >
		<xs:annotation>
			<xs:documentation>Info about Docker image creation progress.</xs:documentation>
			<xs:element name="onBuild" type="stringList" minOccurs="0" maxOccurs="1" />
			<xs:element name="volumes" type="containerConfigurationVolumesType" minOccurs="0" maxOccurs="1" />						
		</xs:sequence>
		<xs:attribute name="attachStderr" type="xs:boolean" use="optional"/>		
		<xs:attribute name="attachStdin" type="xs:boolean" use="optional"/>		
		<xs:attribute name="attachStdout" type="xs:boolean" use="optional"/>		
Development documentation
	Output from the {{{https://docs.docker.com/engine/api/v1.28/#operation/ImageInspect}Inspect an image (v1.28)}} operation.	
	
	Defined Docker type: {{{https://github.com/docker/docker/blob/04295d26df3034a9a92da8400418f843d7c48780/api/types/types.go}ImageInspect}}

*** inspectedImageConfigurationType

	Docker image configuration.	
	
	Output from the {{{https://docs.docker.com/engine/api/v1.28/#operation/ImageInspect}Inspect an image (v1.28)}} operation.	
	
*** imageCreationType	
	
Development documentation
	
	Defined Docker type: {{{https://github.com/moby/moby/blob/04295d26df3034a9a92da8400418f843d7c48780/api/types/types.go}ContainerJSONBase}}

*** containerConfigurationHostConfigType 

	Info about the host configuration of a Docker container.
Development documentation
	To support binding of schema element <<<containerConfigurationHostConfigType.portBindings>>> to a map, 
	the binding is customized to bind to the custom map <<<ContainerConfigurationHostConfigPortBindingsMap>>> 
	using the custom JABX adaptor <<<ContainerConfigurationHostConfigPortBindingsMapAdapter>>>.
	The map and JAXB adaptor is shared with two other bindings in this section.

	To support binding of schema element <<<inspectedContainerConfigurationType.portSpecs>>> to a map, 
	the binding is customized to bind to the custom map <<<ContainerConfigurationHostConfigPortBindingsMap>>> 
	using the custom JABX adaptor <<<ContainerConfigurationHostConfigPortBindingsMapAdapter>>>.
	The map and JAXB adaptor is shared with two other bindings in this section.

	To support binding of schema element <<<inspectedImageConfigurationType.portSpecs>>> to a map, 
	the binding is customized to bind to the custom map <<<ContainerConfigurationHostConfigPortBindingsMap>>> 
	using the custom JABX adaptor <<<ContainerConfigurationHostConfigPortBindingsMapAdapter>>>.
	The map and JAXB adaptor is shared with two other bindings in this section.

*** Restart policy

Development documentation
	using the custom JABX adaptor <<<ContainerConfigurationVolumesMapAdapter>>>.
	The map and JAXB adaptor is shared with binding of <<<containerConfigurationType.volumes>>>.

	To support binding of schema element <<<inspectedImageConfigurationType.volumes>>> to a map, 
	the binding is customized to bind to the custom map <<<ContainerConfigurationVolumesMap>>> 
	using the custom JABX adaptor <<<ContainerConfigurationVolumesMapAdapter>>>.
	The map and JAXB adaptor is shared with binding of <<<containerConfigurationType.volumes>>>
	and <<<inspectedContainerConfigurationType.volumes>>>.

	To support binding of schema element <<<containerJsonBaseType.volumes>>> to a map, 
	the binding is customized to bind to the custom map <<<InspectedContainerVolumesMap>>> 
	using the custom JABX adaptor <<<InspectedContainerVolumesMapAdapter>>>.
public void testCanGetInstance() throws Exception {
    }

    /**
     * Test that command can report on containers.
     */
    @SuppressWarnings("unchecked")
    @Test
    public void testCommandCanReportOnContainers() throws Exception {
	// setup context
	context.put(ReportOnImagesCommand.EXECUTIONRESULT_KEY, executionResult);
	context.put(ReportOnImagesCommand.SESSION_KEY, session);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void initCertPath(String certPath) throws IOException {
            // Try default locations as last resort
            if (this.certPath == null) {
                File dockerHome = new File(System.getProperty("user.home") + "/.docker");
                if (dockerHome.isDirectory() && dockerHome.list(SuffixFileFilter.PEM_FILTER).length > 0) {
                    this.certPath = dockerHome.getAbsolutePath();
                }
            }
        }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public LocationHandler start() {
    public LocationHandler stop() {
        if (mGoogleApiClient != null) {
            LocationServices.FusedLocationApi.removeLocationUpdates(mGoogleApiClient, this);
            mGoogleApiClient.disconnect();
        }
        return this;
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    <properties>
        <!-- This is the path to the root [dspace-src] directory. -->
        <root.basedir>${basedir}/..</root.basedir>
        <jersey.version>2.21</jersey.version>
    </properties>
    <build>
        <plugins>
                    <groupId>org.springframework</groupId>
                    <artifactId>spring-aop</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
     * 
     * <ol>
     * <li>如果对象实现了 {@link Comparable} 接口, 那么直接比较</li>
     * <li>如果对象没有实现 {@link Comparable} 接口, 那么依照扎金花比牌原则(相同大小的牌,比牌方输),谁(t1)比谁(t2),谁(t1)输,谁(t1)排后面</li>
     * </ol>
     * 
     * </li>
     * 
     *     //----------------------------------------------------------
     * 
     *     assertEquals(7, set.size());
     *     assertThat(set, allOf(contains(
     *                     nullPropertyValue, <span style="color:green">//如果对应的属性值是null,排在后面</span>
     *                     userSameHashCode_1_name1, <span style="color:green">//指定属性的属性值越小对应的对象排在前面,反之排在后面</span>
     * 
     *                     <span style="color:green">//如果两个值相等,那么比较对象本身</span>
     *                     <span style="color:green">//如果对象没有实现 Comparable 接口, 那么谁(t1)比谁(t2),谁(t1)输,谁(t1)排后面(扎金花原则)</span>
     *                     userSameHashCode_5_name5,
     *                     userSameHashCode_5_name6,
     *                     userSameHashCode_5_name1,
     *                     userSameHashCode_5_name2,
     * 
     *                     nullObject)<span style="color:green">//空元素排在后面</span>
     *     ));
public int compare(T t1,T t2){
            return -1;
        }

        //--------------------------------------------------------------------------------

        Comparable propertyValue1 = PropertyUtil.getProperty(t1, propertyName);
        Comparable propertyValue2 = PropertyUtil.getProperty(t2, propertyName);
public int compare(T t1,T t2){
            propertyValue1 = ConvertUtil.convert(propertyValue1, propertyValueConvertToClass);
            propertyValue2 = ConvertUtil.convert(propertyValue2, propertyValueConvertToClass);
        }
        return null != comparator ? comparator.compare(propertyValue1, propertyValue2) : compare(t1, t2, propertyValue1, propertyValue2);
    }

    /**
     * 先比较 propertyValue1以及propertyValue2,再比较 t1/t2 .
     * 
private int compare(T t1,T t2,Comparable propertyValue1,Comparable propertyValue
     * <blockquote>
     * <ol>
     * <li>如果对象实现了 {@link Comparable} 接口, 那么直接比较</li>
     * <li>如果对象没有实现 {@link Comparable} 接口, 那么依照<b>扎金花比牌原则</b>(相同大小的牌,比牌方输),谁(t1)比谁(t2),谁(t1)输,谁(t1)排后面</li>
     * </ol>
     * </blockquote>
     *
private int compare(T t1,T t2,Comparable propertyValue1,Comparable propertyValue
     * @param t2
     *            the t 2
     * @return 如果对象实现了 {@link Comparable} 接口, 那么直接强转比较<br>
     *         如果对象没有实现 {@link Comparable} 接口, 那么依照<b>扎金花比牌原则</b>(相同大小的牌,比牌方输),谁(t1)比谁(t2),谁(t1)输,谁(t1)排后面
     * @see <a href="https://github.com/venusdrogon/feilong-core/issues/631">PropertyComparator hash判断两个对象是否相等是否太草率？</a>
     * @since 1.10.3
     */
    @SuppressWarnings({ "rawtypes", "unchecked" })
    private int compareWithSameValue(T t1,T t2){
        //如果对象实现了 Comparable 接口, 那么直接强转比较
        return isInstance(t1, Comparable.class) ? ((Comparable) t1).compareTo(t2) : 1;
    }
}
private SortHelper(){
        throw new AssertionError("No " + getClass().getName() + " instances for you!");
    }

    //---------

    /**
     * 将 <code>propertyNameAndOrder</code>字符串转换成数组.
public void testPropertyComparatorWithTreeSet(){

        //----------------------------------------------------------

        assertEquals(7, set.size());
        assertThat(set, allOf(contains(
                        nullPropertyValue, //如果对应的属性值是null,排在最前面
                        userSameHashCode_1_name1, //指定属性的属性值越小对应的对象排在前面,反之排在后面

                        //如果两个值相等,那么比较对象本身
                        //如果对象没有实现 Comparable 接口, 那么谁(t1)比谁(t2),谁(t1)输,谁(t1)排后面(扎金花原则)
                        userSameHashCode_5_name5,
                        userSameHashCode_5_name6,
                        userSameHashCode_5_name1,
                        userSameHashCode_5_name2,

                        nullObject)//空元素排在后面
        ));
 */
package com.feilong.core.util.sortutiltest;

import static com.feilong.core.util.SortUtil.sortMapByValueDesc;
import static java.util.Collections.emptyMap;
import static org.hamcrest.Matchers.contains;

import java.util.LinkedHashMap;
import java.util.Map;

import org.junit.Test;

 */
public class SortMapByValueDescTest{

    /**
     * Test sort by value desc.
     */
public void testSortByValueDesc(){
    }

    @Test
    public void testSortByValueDescSameValue(){
        Map<String, Integer> map = new LinkedHashMap<>();
        map.put("a", 123);
public void testSortByValueDescSameValue(){
        map.put("g", 123);
        map.put("d", 123);

        assertThat(sortMapByValueDesc(map).keySet(), contains("c", "a", "g", "d", "b", "f"));
    }

    //---------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void onDc(FMLNetworkEvent.ClientDisconnectionFromServerEvent event) {
        ClientRenderEventHandler.resetPermChargeReveal();
        ClientRenderEventHandler.resetTempChargeReveal();
        AstralSorcery.proxy.scheduleClientside(TESRTranslucentBlock::cleanUp);
        PlayerChargeHandler.instance.setClientCharge(0F);
        CraftingAccessManager.clearModifications();
        CelestialGatewaySystem.instance.updateClientCache(new HashMap<>());
        ((DataLightConnections) SyncDataHolder.getDataClient(SyncDataHolder.DATA_LIGHT_CONNECTIONS)).clientClean();
public void onOverlay(RenderGameOverlayEvent.Post event) {
                GlStateManager.disableAlpha();
                Tuple<Double, Double> uvPos = ssr.getUVOffset(ClientScheduler.getClientTick());

                float percFilled = Minecraft.getMinecraft().player.isCreative() ? 1F : PlayerChargeHandler.instance.clientCharge;
                double uLength = ssr.getULength() * percFilled;

                GlStateManager.color(1F, 1F, 1F, visibilityTempCharge);
import hellfirepvp.astralsorcery.common.constellation.perk.ConstellationPerkLevelManager;
import hellfirepvp.astralsorcery.common.constellation.perk.ConstellationPerks;
import hellfirepvp.astralsorcery.common.constellation.perk.PlayerPerkHandler;
import hellfirepvp.astralsorcery.common.container.*;
import hellfirepvp.astralsorcery.common.crafting.ItemHandle;
import hellfirepvp.astralsorcery.common.crafting.helper.CraftingAccessManager;
import hellfirepvp.astralsorcery.common.integrations.ModIntegrationBloodMagic;
import hellfirepvp.astralsorcery.common.item.ItemCraftingComponent;
import hellfirepvp.astralsorcery.common.item.ItemJournal;
import hellfirepvp.astralsorcery.common.lib.BlocksAS;
import hellfirepvp.astralsorcery.common.migration.MappingMigrationHandler;
import hellfirepvp.astralsorcery.common.network.PacketChannel;
import hellfirepvp.astralsorcery.common.network.packet.server.PktLightningEffect;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.DamageSource;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;
import net.minecraft.world.WorldServer;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.common.util.FakePlayer;
import net.minecraftforge.common.util.FakePlayerFactory;
import net.minecraftforge.fml.common.network.IGuiHandler;
import net.minecraftforge.fml.common.network.NetworkRegistry;
import net.minecraftforge.fml.common.registry.GameRegistry;
import net.minecraftforge.oredict.OreDictionary;

import java.awt.*;
import java.util.UUID;

public void preInit() {
    }

    private void registerCapabilities() {
        //CapabilityManager.INSTANCE.register(IPlayerCapabilityPerks.class, new IPlayerCapabilityPerks.Storage(), IPlayerCapabilityPerks.Impl.class);
    }

    private void registerOreDictEntries() {
public void init() {
        //FIXME AFTER CT PORTED
        /*if (Mods.CRAFTTWEAKER.isPresent()) {
            AstralSorcery.log.info("Crafttweaker found! Adding recipe handlers...");
            ModIntegrationCrafttweaker.instance.load();
        } else {
            AstralSorcery.log.info("Crafttweaker not found!");
        }*/
protected void registerTickHandlers(TickManager manager) {
        manager.register(StarlightTransmissionHandler.getInstance());
        manager.register(StarlightUpdateHandler.getInstance());
        manager.register(WorldCacheManager.getInstance());
        manager.register(new LinkHandler()); //Only used as instance for tick handling
        manager.register(SyncDataHolder.getTickInstance());
        manager.register(new PlayerPerkHandler());
        manager.register(commonScheduler);
        manager.register(PlayerChargeHandler.instance);

        //TickTokenizedMaps
        manager.register(EventHandlerServer.spawnDenyRegions);
public boolean canPlaceBlockAt(World worldIn, BlockPos pos) {
    }

    @Override
    public ItemStack getPickBlock(IBlockState state, RayTraceResult target, World world, BlockPos pos, EntityPlayer player) {
        return super.getPickBlock(world.getBlockState(pos), target, world, pos, player); //Waila fix. wtf. why waila. why.
    }

package hellfirepvp.astralsorcery.common.constellation;

import hellfirepvp.astralsorcery.common.constellation.star.StarConnection;
import hellfirepvp.astralsorcery.common.constellation.star.StarLocation;
import hellfirepvp.astralsorcery.common.data.research.PlayerProgress;
default public Color getTierRenderColor() {
        return weak;
    }

    default public boolean canDiscover(PlayerProgress progress) {
        return true;
    }
 */
public class PlayerChargeHandler implements ITickHandler {

    public static PlayerChargeHandler instance = new PlayerChargeHandler();

    private Map<EntityPlayer, Float> chargeMap = new HashMap<>();
    public float clientCharge = 0F;
private void refreshRandom() {

    //Fired on client and serverside - client only if it's the world the client is in obviously.
    public void tick(World w) {
        if(initialValueMappings.isEmpty()) {
            setupInitialFunctions();
        }
public void onLogin(PlayerEvent.PlayerLoggedInEvent e) {
    public void onLogout(PlayerEvent.PlayerLoggedOutEvent e) {
        EntityPlayer player = e.player;

        PlayerChargeHandler.instance.informDisconnect(player);
        //ResearchManager.logoutResetClient(player);
    }

import hellfirepvp.astralsorcery.common.constellation.distribution.ConstellationSkyHandler;
import hellfirepvp.astralsorcery.common.constellation.perk.ConstellationPerk;
import hellfirepvp.astralsorcery.common.constellation.perk.ConstellationPerks;
import hellfirepvp.astralsorcery.common.data.config.Config;
import hellfirepvp.astralsorcery.common.data.research.PlayerProgress;
import hellfirepvp.astralsorcery.common.data.research.ResearchManager;
import net.minecraft.world.World;
import net.minecraft.world.WorldProviderEnd;
import net.minecraft.world.WorldProviderHell;
import net.minecraftforge.event.entity.living.LivingDeathEvent;
import net.minecraftforge.event.entity.living.LivingHurtEvent;
import net.minecraftforge.event.entity.living.LivingSetAttackTargetEvent;
public void onUnload(WorldEvent.Unload event) {
        }
    }

    @SideOnly(Side.CLIENT)
    private void clientUnload() {
        AstralSorcery.proxy.scheduleClientside(TESRTranslucentBlock::cleanUp);
    default public boolean drainTempCharge(EntityPlayer player, float charge, boolean simulate) {
        if(player.isCreative()) return true;

        if(!PlayerChargeHandler.instance.hasAtLeast(player, charge)) {
            return false;
        }
        if(!simulate) {
            PlayerChargeHandler.instance.drainCharge(player, charge);
        }
        return true;
    }
public void toBytes(ByteBuf buf) {

    @Override
    public IMessage onMessage(PktSyncCharge message, MessageContext ctx) {
        PlayerChargeHandler.instance.setClientCharge(message.charge);
        return null;
    }
}
public static void init() {

        registerConstellations();

        registerEffects();

        MinecraftForge.EVENT_BUS.post(new APIRegistryEvent.ConstellationRegister());
    }

    private static void registerEffects() {
        registerMapEffect(discidia,
                Arrays.asList(
                        new EnchantmentMapEffect(Enchantments.SHARPNESS, 3, 7),
private static void registerDispenseBehavior() {

    private static <T extends IForgeRegistryEntry> T registerItem(String modId, T item, String name) {
        try {
            LoadController modController = (LoadController) Loader.class.getField("modController").get(Loader.instance());
            Object oldMod = modController.getClass().getField("activeContainer").get(modController);
            modController.getClass().getField("activeContainer").set(modController, Loader.instance().getIndexedModList().get(modId));

            register(item, name);

import hellfirepvp.astralsorcery.common.CommonProxy;
import hellfirepvp.astralsorcery.common.potion.PotionBleed;
import hellfirepvp.astralsorcery.common.potion.PotionCheatDeath;
import net.minecraft.potion.Potion;

/**

    public static PotionCheatDeath potionCheatDeath;
    public static PotionBleed potionBleed;

    public static void init() {
        potionCheatDeath = registerPotion(new PotionCheatDeath());
        potionBleed = registerPotion(new PotionBleed());
    }

    private static <T extends Potion> T registerPotion(T potion) {
    public static CelestialGatewayRecipe rCelestialGateway;
    public static DrawingTableRecipe rDrawingTable;
    public static ConstellationRecipe rInfusedGlass;

    public static LensRecipe rLens;
    public static PrismLensRecipe rPrism;
private static void initAltarRecipes() {
        rCelestialGateway = registerAltarRecipe(new CelestialGatewayRecipe());
        rDrawingTable = registerAltarRecipe(new DrawingTableRecipe());

        NonNullList<ItemStack> applicable = NonNullList.create();
        for (ItemColoredLens.ColorType type : ItemColoredLens.ColorType.values()) {
            applicable.add(type.asStack());
private static void initAttunement() {
        resShiftStar.addPage(getTextPage("SHIFT_STAR.1"));
        resShiftStar.addPage(new JournalPageAttunementRecipe(RegistryRecipes.rShiftStar));

        registerItemLookup(new ItemStack(BlocksAS.lens, 1, OreDictionary.WILDCARD_VALUE),                 resLens,                 0, ResearchProgression.ATTUNEMENT);
        registerItemLookup(new ItemStack(ItemsAS.linkingTool, 1, OreDictionary.WILDCARD_VALUE),           resLinkTool,             0, ResearchProgression.ATTUNEMENT);
        registerItemLookup(BlockCustomOre.OreType.STARMETAL.asStack(),                                            resStarOre,              0, ResearchProgression.ATTUNEMENT);
private static void initAttunement() {
        registerItemLookup(new ItemStack(BlocksAS.celestialGateway, 1, OreDictionary.WILDCARD_VALUE),     resCelestialGateway,     1, ResearchProgression.ATTUNEMENT);
        registerItemLookup(new ItemStack(ItemsAS.shiftingStar, 1, OreDictionary.WILDCARD_VALUE),          resShiftStar,            0, ResearchProgression.ATTUNEMENT);
        registerItemLookup(new ItemStack(ItemsAS.grapplingWand, 1, OreDictionary.WILDCARD_VALUE),         resToolGrapple,          0, ResearchProgression.ATTUNEMENT);

        regAttunement.register(resLens);
        regAttunement.register(resLinkTool);
private static void initAttunement() {
        regAttunement.register(resCelestialGateway);
        regAttunement.register(resShiftStar);
        regAttunement.register(resToolGrapple);

        resStarOre.addSourceConnectionFrom(resLinkTool);
        resStarOre.addSourceConnectionFrom(resLens);

import hellfirepvp.astralsorcery.common.constellation.distribution.ConstellationSkyHandler;
import hellfirepvp.astralsorcery.common.constellation.distribution.WorldSkyHandler;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
public Vec3d getFogColor(float p_76562_1_, float p_76562_2_) {
    }

    @Override
    public Vec3d getSkyColor(Entity cameraEntity, float partialTicks) {
        return parentOvrProvider.getSkyColor(cameraEntity, partialTicks);
    }

public net.minecraft.client.renderer.EntityRenderer field_78499_K #smoothCamFilt
public net.minecraft.client.renderer.EntityRenderer field_78492_L #smoothCamPartialTicks
public net.minecraft.client.renderer.RenderGlobal func_180448_r()V #renderEndSky
public net.minecraft.client.renderer.RenderGlobal func_184382_g()I #getRenderedChunks
#public net.minecraft.world.WorldProvider func_76556_a()V #generateLightBrightnessTable
#public net.minecraft.world.WorldProvider func_76572_b()V #init
misc.sword.sharpened=Sharpened

effect.as.cheatdeath=Phoenix-Fire
effect.as.bleed=Bleeding

gui.journal.bm.knowledge.name=Knowledge
gui.journal.bm.constellations.name=Constellations
research.SPEC_RELAY.name=Spectral Relay
astralsorcery.journal.SPEC_RELAY.1.text=The starlight resonator can find fields of intense starlight which can be useful for harnessing the energy. The problem is moving infrastructure or traveling vast distances to harness the starlight can at times be impractical. As delving further into the secrets of the Ancients will undoubtedly require more and more starlight an alternative is in order.
astralsorcery.journal.SPEC_RELAY.4.text=A small setup, dedicated to collecting starlight for the altar near should help solve that problem. A clear view of the sky is most certainly a necessity and better results will most likely be achieved at night.<NL>When the relay has been placed high up but close to an altar, it will collect and focus starlight once a glass lens is placed inside it. The starlight is then redirected as small sparks to the closest nearby altar.<NL>However, placing too many relays close to each other will result in one cannibalizing the others' starlight and will most likely create  much more... §odisappointing§r results..

research.QUICK_CHARGE.name=Alignment Charge
astralsorcery.journal.QUICK_CHARGE.1.text=While learning more about the patterns and effects of starlight, the everpresent waves of starlight become more and more perceivable during the ebb and flow of day and night.<NL>While in its current form, the blue-white energy is potent enough to suffice for smaller rods and wands to tap into it to channel it, a bigger focus might be required to enhance the effects of single constellations while using the body or crystals to channel this energy.




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import android.widget.LinearLayout;
import android.widget.RatingBar;
import android.widget.TextView;

import org.secuso.privacyfriendlysudoku.controller.GameController;
import org.secuso.privacyfriendlysudoku.controller.GameStateManager;
import org.secuso.privacyfriendlysudoku.ui.view.SudokuSpecialButtonLayout;
import org.secuso.privacyfriendlysudoku.ui.view.WinDialog;

import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.RunnableFuture;
public void run() {
        }

        SharedPreferences sharedPref = PreferenceManager.getDefaultSharedPreferences(this);
        Symbol s = Symbol.valueOf(Symbol.class, sharedPref.getString("pref_symbols", "Default"));
        layout.setSymbols(s);
        keyboard.setSymbols(s);
    }
import java.util.LinkedList;
import java.util.List;

public class MainActivity extends BaseActivity implements NavigationView.OnNavigationItemSelectedListener{

    RatingBar difficultyBar;
private boolean goToNavigationItem(int id) {
                startActivity(intent);
                overridePendingTransition(0, 0);
                break;
            default:
        }
        return true;

public class TutorialActivity extends AppCompatActivity {

    private ViewPager viewPager;
    private MyViewPagerAdapter myViewPagerAdapter;
    private LinearLayout dotsLayout;
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Checking for first time launch - before calling setContentView()
        prefManager = new PrefManager(this);
        if (!prefManager.isFirstTimeLaunch()) {
            launchHomeScreen();
            finish();
        }

        // Making notification bar transparent
private int getItem(int i) {

    private void launchHomeScreen() {
        prefManager.setFirstTimeLaunch(false);
        startActivity(new Intent(TutorialActivity.this, MainActivity.class));
        finish();
    }

        android:title="@string/menu_reset" />

    <group android:id="@+id/group4">
        <item android:id="@+id/nav_newgame" android:icon="@android:drawable/ic_menu_today"
            android:title="@string/menu_main" />
        <item android:id="@+id/nav_highscore" android:icon="@android:drawable/ic_menu_myplaces"
            android:title="@string/menu_highscore" />
        android:checkableBehavior="all">
        <item android:id="@+id/menu_settings_main" android:icon="@drawable/ic_menu_settings"
            android:title="@string/menu_settings" />
        <item android:id="@+id/menu_help_main" android:icon="@drawable/ic_menu_help"
            android:title="@string/menu_help" />
        <item android:id="@+id/menu_about_main" android:icon="@drawable/ic_menu_about"

    <string name="next">Weiter</string>
    <string name="skip">Skip</string>

</resources>

    <string name="next">Next</string>
    <string name="skip">Skip</string>
</resources>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void afterPropertiesSet() throws Exception {
					credentialFactory.createFor(repo.getUri(), user, pass, passphrase));
			repo.afterPropertiesSet();
		}
		if (!getBasedir().getParentFile().canWrite()) {
			throw new IllegalStateException(
					"Cannot write parent of basedir (please configure a writable location): "

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import org.junit.Before;
import org.junit.Test;

import org.springframework.cloud.config.environment.Environment;
import org.springframework.cloud.config.server.environment.MultipleJGitEnvironmentRepository.PatternMatchingJGitEnvironmentRepository;
import org.springframework.cloud.config.server.test.ConfigServerTestUtils;
import org.springframework.core.env.StandardEnvironment;

import static org.hamcrest.CoreMatchers.containsString;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;

/**
 * @author Andy Chan (iceycake)
 */
public class MultipleJGitEnvironmentRepositoryTests {

	private StandardEnvironment environment = new StandardEnvironment();
	private MultipleJGitEnvironmentRepository repository = new MultipleJGitEnvironmentRepository(
			this.environment);

	@Before
	public void init() throws Exception {
		String defaultUri = ConfigServerTestUtils.prepareLocalRepo("config-repo");
		this.repository.setUri(defaultUri);
		this.repository.setRepos(createRepositories());
	}
public void defaultRepoBasedir() {
		repository.setBasedir(new File("target/testBase"));
		assertThat(repository.getBasedir().toString(), containsString("target/testBase"));
		assertThat(repository.getRepos().get("test1").getBasedir().toString(),
				containsString("tmp/test1"));
	}

	@Test
public void mappingRepoWithDefaultLabel() {
		assertVersion(environment);
	}

	private String getUri(String pattern) {
		String uri = null;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 * @see FlexibleAdapter
 * @see AnimatorAdapter
 * @since 03/05/2015 Created
 * <br/>27/01/2016 Improved Selection, SelectAll, FastScroller
 * <br/>29/05/2016 Use of TreeSet instead of ArrayList
 * <br/>04/04/2017 Use of FastScrollerDelegate
 */
@SuppressWarnings({"unused", "unchecked", "ConstantConditions", "WeakerAccess"})
public abstract class SelectableAdapter extends RecyclerView.Adapter
	public static boolean DEBUG = false;

	/**
	 * - MODE_IDLE: Adapter will not keep track of selections<br/>
	 * - MODE_SINGLE: Select only one per time<br/>
	 * - MODE_MULTI: Multi selection will be activated
	 */
	public static final int MODE_IDLE = 0, MODE_SINGLE = 1, MODE_MULTI = 2;
	public @interface Mode {
	}

	private Set<Integer> mSelectedPositions;
	private Set<FlexibleViewHolder> mBoundViewHolders;
	private int mMode;
	private IFlexibleLayoutManager mFlexibleLayoutManager;
	protected RecyclerView mRecyclerView;
public RecyclerView getRecyclerView() {
	 * Current instance of the wrapper class for LayoutManager suitable for FlexibleAdapter.
	 * LayoutManager must be already initialized in the RecyclerView.
	 *
	 * return wrapper class for any non-conventional LayoutManagers or {@code null} if not initialized.
	 * @since 5.0.0-rc2
	 */
	public IFlexibleLayoutManager getFlexibleLayoutManager() {
public void selectAll(Integer... viewTypes) {

	/**
	 * Clears the selection status for all items one by one and it doesn't stop animations in the items.
	 * <br/><br/>
	 * <b>Note 1:</b> Items are invalidated and rebound!<br/>
	 * <b>Note 2:</b> This method use java.util.Iterator to avoid java.util.ConcurrentModificationException.
	 *
	 * @since 1.0.0
	 */
	public void clearSelection() {
		if (DEBUG) Log.d(TAG, "clearSelection " + mSelectedPositions);
		Iterator<Integer> iterator = mSelectedPositions.iterator();
		int positionStart = 0, itemCount = 0;
		// The notification is done only on items that are currently selected.
		while (iterator.hasNext()) {
			int position = iterator.next();
			iterator.remove();
			// Optimization for ItemRangeChanged
			if (positionStart + itemCount == position) {
				itemCount++;
			} else {
				// Notify previous items in range
				notifySelectionChanged(positionStart, itemCount);
				positionStart = position;
				itemCount = 1;
			}
		}
		// Notify remaining items in range
		notifySelectionChanged(positionStart, itemCount);
	}

	private void notifySelectionChanged(int positionStart, int itemCount) {
public FastScroller getFastScroller() {
	 * <b>NOTE:</b> If the device has at least Lollipop, the Accent color is fetched, otherwise
	 * for previous version, the default value is used.
	 *
	 * @param fastScroller        instance of {@link FastScroller}
	 * @since 5.0.0-b6
	 */
	public void setFastScroller(@NonNull FastScroller fastScroller) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  <component name="EntryPointsManager">
    <entry_points version="2.0" />
  </component>
  <component name="ProjectLevelVcsManager" settingsEditedManually="false">
    <OptionsSetting value="true" id="Add" />
    <OptionsSetting value="true" id="Remove" />
    <OptionsSetting value="true" id="Checkout" />
    <OptionsSetting value="true" id="Update" />
    <OptionsSetting value="true" id="Status" />
    <OptionsSetting value="true" id="Edit" />
    <ConfirmationsSetting value="0" id="Add" />
    <ConfirmationsSetting value="0" id="Remove" />
  </component>
  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_8" default="true" assert-keyword="true" jdk-15="true" project-jdk-name="IntelliJ IDEA Community Edition IC-145.972.3" project-jdk-type="IDEA JDK">
    <output url="file://$PROJECT_DIR$/out" />
  </component>
</project>
Copyright © 2016, Mikko Ahlroth
All rights reserved.

Redistribution and use in source and binary forms, with or without
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/resources" type="java-resource" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>
<idea-plugin version="2">
  <id>net.codestats.plugin.atom.intellij</id>
  <name>Code::Stats</name>
  <version>1.0.4</version>
  <vendor email="mikko.ahlroth@gmail.com" url="https://codestats.net/">CodeStats</vendor>

  <description><![CDATA[
      Code::Stats plugin for the IntelliJ/JetBrains range of IDEs.
    ]]></description>

  <change-notes><![CDATA[
  <h1>1.0.4</h1>
  <p>Send local time offset with timestamp when coding. This will be used in graphs on the website later.</p>

  <h1>1.0.3</h1>
  <p>Make the last fix even better and add some nicer error output for user.</p>

  <h1>1.0.2 (unreleased)</h1>
  <p>Attempt to fix certificate errors caused by Java not having the Letsencrypt certificates in the trust store by default.</p>

  <h1>1.0.1</h1>
  <p>Fixed an issue where the plugin would crash when closing a project and opening a new one.</p>

  <h1>1.0</h1>
  <p>Initial version</p>
  ]]>
  </change-notes>

import com.intellij.openapi.editor.actionSystem.EditorActionManager;
import com.intellij.openapi.editor.actionSystem.TypedAction;
import com.intellij.openapi.editor.actionSystem.TypedActionHandler;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.project.ProjectManager;
import com.intellij.openapi.project.ProjectManagerListener;
import com.intellij.openapi.wm.IdeFrame;
import com.intellij.openapi.wm.StatusBar;
import com.intellij.openapi.wm.WindowManager;
import org.jetbrains.annotations.NotNull;

import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManagerFactory;
import java.io.BufferedInputStream;
    private String apiKey;

    private Integer statusBarUniqueID;
    private Hashtable<Project, StatusBarIcon> statusBarIcons;

    private SSLContext context;

public void initComponent() {
        executor = Executors.newScheduledThreadPool(1);
        xps = new Hashtable<>();

        // Add the status bar icon to the statusbar of all projects when they are loaded
        ProjectManager.getInstance().addProjectManagerListener(new ProjectManagerListener() {
            @Override
            public void projectOpened(Project project) {
                IdeFrame frame = WindowManager.getInstance().getIdeFrame(project);
                StatusBar statusBar = frame.getStatusBar();

                StatusBarIcon statusBarIcon = new StatusBarIcon(statusBarUniqueID.toString(), statusBar);

                statusBar.addWidget(statusBarIcon);
                statusBarIcons.put(project, statusBarIcon);
                statusBarUniqueID += 1;
            }

            @Override
            public boolean canCloseProject(Project project) {
                return true;
            }

            @Override
            public void projectClosed(Project project) {}

            @Override
            public void projectClosing(Project project) {
                IdeFrame frame = WindowManager.getInstance().getIdeFrame(project);
                frame.getStatusBar().removeWidget(statusBarIcons.get(project).ID());
                statusBarIcons.remove(project);
            }
        });

import com.intellij.openapi.wm.IdeFrame;
import com.intellij.openapi.wm.StatusBar;
import com.intellij.openapi.wm.StatusBarWidget;
import com.intellij.openapi.wm.WindowManager;
import com.intellij.util.Consumer;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.awt.event.MouseEvent;

/**
 * Created by nicd on 03/06/16.
 */
public class StatusBarIcon implements StatusBarWidget {
    public static final String STATUS_BAR_ID_PREFIX = "code-stats-intellij-status-bar-icon-";

import com.eclipsesource.json.Json;
import com.eclipsesource.json.JsonArray;
import com.eclipsesource.json.JsonObject;
import com.intellij.openapi.project.Project;

import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import java.io.OutputStreamWriter;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.time.Instant;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.Hashtable;
import java.util.Iterator;
    private Object xpsLock;
    private String apiURL;
    private String apiKey;
    private Hashtable<Project, StatusBarIcon> statusBarIcons;
    private SSLContext context;

    @Override
public void setConfig(final String apiURL, final String apiKey) {
        this.apiKey = apiKey;
    }

    public void setStatusBarIcons(Hashtable<Project, StatusBarIcon> statusBarIcons) {
        this.statusBarIcons = statusBarIcons;
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public Bitmap transform(Bitmap source) {
                source.recycle();
            }

            Bitmap bitmap = Bitmap.createBitmap(size, size, source.getConfig());

            Canvas canvas = new Canvas(bitmap);
            Paint paint = new Paint();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# Change Log
All notable changes to this project will be documented in this file.

## [1.0.12] - 2017/03/06
### Changed
- General: Added instructions for customizing the contents of the extension bundle.
private static void findExtensionClasses(final File srcDirectory,
          {
            extensionList.add((UnboundIDExtension) c.newInstance());
          }
          catch (final Exception e)
          {
            e.printStackTrace();
            // This shouldn't happen, but if it does, then there's not much that
            // can be done about it.
          }
        }
      }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/rs" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/main/shaders" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/res" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/resources" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/assets" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/aidl" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/java" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/rs" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/test/shaders" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/res" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/resources" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/assets" type="java-test-resource" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/aidl" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/java" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/rs" isTestSource="true" />
      <sourceFolder url="file://$MODULE_DIR$/src/androidTest/shaders" isTestSource="true" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/assets" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/blame" />
      <excludeFolder url="file://$MODULE_DIR$/build/intermediates/classes" />
    <orderEntry type="library" exported="" name="support-vector-drawable-25.1.1" level="project" />
    <orderEntry type="library" exported="" name="animated-vector-drawable-25.1.1" level="project" />
    <orderEntry type="module" module-name="restcomm.android.sdk" exported="" />
  </component>
</module>
public void onCallErrorEvent(String jobId, RCClient.ErrorCodes errorCode, String
   // don't need to disconnect media
   private void handleDisconnected(String jobId, boolean haveDisconnectedLocally)
   {
      // Device was already busy with another Connection, skip all handling here
      if (deviceAlreadyBusy) {
         return;
private void handleDisconnected(String jobId, boolean haveDisconnectedLocally)
   private void handleDisconnect(String reason)
   {
      RCLogger.i(TAG, "handleDisconnect(): reason: " + reason);

      audioManager.stop();

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /**
     * 画面端移動アニメーションの時間
     */
    private static final long MOVE_TO_EDGE_DURATION = 450L;

    /**
     * 画面端移動アニメーションの係数
public boolean onPreDraw() {
            moveToEdge(mInitX, mInitY, mAnimateInitialMove);
        }
        mIsDraggable = true;
        mWindowManager.updateViewLayout(this, mParams);
        return true;
    }

else if (mMoveDirection == FloatingViewManager.MOVE_DIRECTION_RIGHT) {
            // スクリーン位置の比率からY座標を設定(四捨五入)
            final int newY = (int) (mParams.y * mPositionLimitRect.height() / (float) oldPositionLimitHeight + 0.5f);
            mParams.y = Math.min(Math.max(mPositionLimitRect.top, newY), mPositionLimitRect.bottom);
            mWindowManager.updateViewLayout(this, mParams);
        }

    }
private void moveTo(int currentX, int currentY, int goalPositionX, int goalPosit
                    @Override
                    public void onAnimationUpdate(ValueAnimator animation) {
                        mParams.y = (Integer) animation.getAnimatedValue();
                        mWindowManager.updateViewLayout(FloatingView.this, mParams);
                    }
                });
            } else {
public void onAnimationUpdate(ValueAnimator animation) {
                    @Override
                    public void onAnimationUpdate(ValueAnimator animation) {
                        mParams.x = (Integer) animation.getAnimatedValue();
                        mWindowManager.updateViewLayout(FloatingView.this, mParams);
                    }
                });
            }
public void onAnimationUpdate(ValueAnimator animation) {
            if (mParams.x != goalPositionX || mParams.y != goalPositionY) {
                mParams.x = goalPositionX;
                mParams.y = goalPositionY;
                mWindowManager.updateViewLayout(FloatingView.this, mParams);
            }
        }
        // タッチ座標を初期化
public void onAnimationUpdate(ValueAnimator animation) {
    }

    /**
     * アニメーションをキャンセルします。
     */
    private void cancelAnimation() {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	public Group(Entity entity)
	{
		super(entity);
		setDefaultValues();
	}

	public Group(EntityType entityType)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void trustKeyChange(String fingerprint) {
    }

    private void showKeyWarning(int textId, final int dialogTitleId, final int dialogMessageId, final Object... data) {
        Activity context = getActivity();
        if (context != null) {
            showWarning(context.getText(textId), new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    new MaterialDialog.Builder(getActivity())
                        .title(dialogTitleId)
                        .content(dialogMessageId)
                        .positiveText(R.string.button_accept)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private ApiEvent(Builder builder) {
        if (null != builder.mRequestId) {
            setProperty(EventProperty.REQUEST_ID, builder.mRequestId);
        }
        setProperty(EventProperty.AUTHORITY_NAME, HttpEvent.sanitizeUrlForTelemetry(builder.mAuthority));
        setAuthorityType(builder.mAuthorityType);
        setProperty(EventProperty.UI_BEHAVIOR, builder.mUiBehavior);
        setProperty(EventProperty.API_ID, builder.mApiId);
private HttpEvent(Builder builder) {
        setProperty(EventProperty.HTTP_API_VERSION, builder.mApiVersion);
        setProperty(EventProperty.OAUTH_ERROR_CODE, builder.mOAuthErrorCode);
        setProperty(EventProperty.REQUEST_ID_HEADER, builder.mRequestIdHeader);
        setHttpPath(builder.mHttpPath);
        setProperty(EventProperty.HTTP_RESPONSE_CODE, String.valueOf(builder.mResponseCode));
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import net.minecraft.block.Block;
import net.minecraft.client.resources.I18n;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.EnumDyeColor;
import net.minecraft.item.ItemBlock;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.xalcon.torchmaster.TorchMasterMod;
import net.xalcon.torchmaster.common.ModBlocks;
import net.xalcon.torchmaster.common.blocks.BlockMegaTorch;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.SimpleTimeZone;

public class ItemBlockMegaTorch extends ItemBlock
{
public String getUnlocalizedName(ItemStack stack)
	}

	@Override
	public void addInformation(ItemStack stack, EntityPlayer playerIn, List<String> tooltip, boolean advanced)
	{
		super.addInformation(stack, playerIn, tooltip, advanced);
public void addInformation(ItemStack stack, EntityPlayer playerIn, List<String>

			int burnValueLeft = compound.getInteger("burnValueLeft");
			int burnRate = TorchMasterMod.ConfigHandler.getMegaTorchBurnoutRate();
			int ticksLeft = burnValueLeft / burnRate;

			int days = ticksLeft / DAY_TICKS;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public synchronized void setOutput(AudioOutput o) {
    
    private void ensureSourceDataLineIsReleased(){
	if(sourceDataLine!=null)
	    if(sourceDataLine.isOpen())
		sourceDataLine.close();
	sourceDataLine=null;
    }//end ensureSourceDataLineIsReleased()

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import org.jbehave.core.model.Story;
import org.jbehave.core.reporters.StoryReporterBuilder;
import org.jbehave.core.steps.CandidateSteps;
import org.junit.runner.Description;
import org.junit.runner.Runner;
import org.junit.runner.notification.RunNotifier;
public JUnitReportingRunner(Class<? extends ConfigurableEmbedder> testClass)
		}

		configuration = configuredEmbedder.configuration();
		candidateSteps = embedder.stepsFactory().createCandidateSteps();

		storyDescriptions = buildDescriptionFromStories();
		initRootDescription();
	}

public int testCount() {
	@Override
	public void run(RunNotifier notifier) {

		JUnitScenarioReporter reporter = new JUnitScenarioReporter(notifier,
				numberOfTestCases, rootDescription);
		reporter.usePendingStepStrategy(configuration.pendingStepStrategy());

		configuration.storyReporterBuilder().withFormats(
				new StoryReporterBuilder.ProvidedFormat(reporter));

		try {
			configuredEmbedder.runStoriesAsPaths(storyPaths);
public void beforeStory(Story story, boolean isGivenStory) {
					if (scenarioDescriptions.hasNext()) {
						currentScenario = scenarioDescriptions.next();
					}
				} else if (storyDescription.isTest()
						&& storyDescription.getMethodName().equals(
								story.getName())) {
					// Story BeforeStories or After Stories
					currentStoryDescription = storyDescription;
					notifier.fireTestStarted(currentStoryDescription);
				}
			}
		}
public void successful(String step) {
	}

	private void prepareNextStep() {
		if (stepDescriptions.hasNext()) {
			currentStep = stepDescriptions.next();
		}
		testCounter++;
package de.codecentric.jbehave.junit.monitoring;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.junit.Assert.assertThat;
import static org.mockito.Mockito.verify;

import java.util.Arrays;
import java.util.Collection;

import org.hamcrest.Matchers;
import org.jbehave.core.ConfigurableEmbedder;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.Description;
import org.junit.runner.RunWith;
import org.junit.runner.notification.RunNotifier;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameters;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

@RunWith(Parameterized.class)
public class JUnitReportingRunnerTest {

	@Mock
	private RunNotifier notifier;
	private JUnitReportingRunner runner;
	private String expectedDisplayName;
	private String expectedFirstStoryName;
	private Description description;

	@Before
	public void setUp() throws Throwable {
		MockitoAnnotations.initMocks(this);
	}

	@Parameters
	public static Collection<Object[]> data() {
		Object[][] params = {
				{ ExampleScenarioJUnitStories.class,
						ExampleScenarioJUnitStories.class.getName(),
						"Multiplication.story" },
				{ ExampleScenarioJUnitStory.class,
						ExampleScenarioJUnitStory.class.getName(),
						"example_scenario_j_unit_story.story" } };
		return Arrays.asList(params);
	}

	public JUnitReportingRunnerTest(Class<? extends ConfigurableEmbedder> cls,
			String expectedDisplayName, String expectedFirstStoryName)
			throws Throwable {
		runner = new JUnitReportingRunner(cls);
		this.expectedDisplayName = expectedDisplayName;
		this.expectedFirstStoryName = expectedFirstStoryName;
	}

	@Test
	public void runUpExampleScenarioAndCheckNotifications() {
		runner.run(notifier);
		verifyAllChildDescriptionsFired(runner.getDescription(), true);
	}

	private void verifyAllChildDescriptionsFired(Description description,
			boolean onlyChildren) {
		String displayName = description.getDisplayName();
		if (!onlyChildren && considerStepForVerification(description)) {
			verify(notifier).fireTestStarted(description);
			System.out.println("verified start " + displayName);
		}
		for (Description child : description.getChildren()) {
			verifyAllChildDescriptionsFired(child, false);
		}
		if (!onlyChildren && considerStepForVerification(description)) {
			verify(notifier).fireTestFinished(description);
			System.out.println("verified finish " + displayName);
		}
	}

	private boolean considerStepForVerification(Description d) {
		String displayName = d.getDisplayName();
		return Character.isDigit(displayName.charAt(displayName.length() - 1));
	}

	@Test
	public void topLevelDescriptionForExample() {
		assertThat(runner.getDescription().getDisplayName(),
				equalTo(expectedDisplayName));
	}

	@Test
	public void storyDescriptionsForExample() {
		assertThat(getFirstStory().getDisplayName(),
				equalTo(expectedFirstStoryName));
	}

	@Test
	public void scenarioDescriptionsForExample() {
		assertThat(getFirstScenario().getDisplayName(),
				equalTo("Scenario: 2 squared"));
	}

	@Test
	public void stepDescriptionsForExample() {
		assertThat(getFirstScenario().getChildren().get(0).getDisplayName(),
				Matchers.startsWith("Given a variable x with value 2"));
	}

	private Description getFirstStory() {
		return runner.getDescription().getChildren().get(1);
	}

	private Description getFirstScenario() {
		return getFirstStory().getChildren().get(0);
	}

}
package de.codecentric.jbehave.junit.monitoring;

import static org.mockito.Mockito.verify;

import org.jbehave.core.failures.FailingUponPendingStep;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;
import org.junit.runner.notification.RunNotifier;
import org.mockito.Matchers;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;

public class JUnitScenarioReporterTest {

	@Mock
	RunNotifier notifier;
	private Description rootDescription;
	private Description storyDescription;
	private Description scenarioDescription;
	private Story story;

	@Before
	public void setUp() {
		MockitoAnnotations.initMocks(this);
		rootDescription = Description.createTestDescription(this.getClass(),
				"root");
		storyDescription = Description.createTestDescription(this.getClass(),
				"story");
		rootDescription.addChild(storyDescription);
		scenarioDescription = Description.createTestDescription(
				this.getClass(), "scenario");
		storyDescription.addChild(scenarioDescription);

		story = new Story();
public void shouldCopeWithDescriptionNamesWhenSimilarButForExtraCharacters()
		Description child2 = addChildToScenario("child.");
		Description child3 = addChildToScenario("child..");

		JUnitScenarioReporter reporter = new JUnitScenarioReporter(notifier, 3,
				rootDescription);

		reportDefaultScenarioStart(reporter);
		reportStepSuccess(reporter);
public void shouldHandleFailedSteps() throws Exception {

		Description child1 = addChildToScenario("child");

		JUnitScenarioReporter reporter = new JUnitScenarioReporter(notifier, 1,
				rootDescription);

		reportDefaultScenarioStart(reporter);
		reportStepFailure(reporter);
public void shouldHandleFailedSteps() throws Exception {
	@Test
	public void shouldHandleIgnorableSteps() throws Exception {
		Description comment = addChildToScenario("!-- Comment");
		JUnitScenarioReporter reporter = new JUnitScenarioReporter(notifier, 1,
				rootDescription);

		reportDefaultScenarioStart(reporter);
		verifyStoryStarted();
public void shouldNotifyAboutBeforeStories() {
		rootDescription.addChild(beforeStories);
		rootDescription.addChild(storyDescription);

		JUnitScenarioReporter reporter = new JUnitScenarioReporter(notifier, 3,
				rootDescription);

		Story beforeStoriesStory = new Story();
		beforeStoriesStory.namedAs("BeforeStories");
public void shouldNotifyAboutAfterStories() {
				Object.class, "AfterStories");
		rootDescription.addChild(afterStories);

		JUnitScenarioReporter reporter = new JUnitScenarioReporter(notifier, 3,
				rootDescription);

		Story afterStoriesStory = new Story();
		afterStoriesStory.namedAs("AfterStories");
public void shouldNotifyGivenStory() {
		scenarioDescription.addChild(givenStoryDescription);
		Description child = addChildToScenario("child");

		JUnitScenarioReporter reporter = new JUnitScenarioReporter(notifier, 3,
				rootDescription);

		Story givenStory = new Story();
		givenStory.namedAs("aGivenStory");
public void shouldNotifyCompositeSteps() {
				"comp2");
		child.addChild(comp2);

		JUnitScenarioReporter reporter = new JUnitScenarioReporter(notifier, 4,
				rootDescription);

		reportDefaultScenarioStart(reporter);
		reportStepSuccess(reporter);
public void shouldPrepareExampleStepsBeforeScenario() {
		Description step = Description.createTestDescription(this.getClass(),
				"Step");
		example.addChild(step);
		JUnitScenarioReporter reporter = new JUnitScenarioReporter(notifier, 2,
				rootDescription);
		reportDefaultScenarioStart(reporter);
		reporter.example(null);
		reportStepSuccess(reporter);
public void shouldPrepareExampleStepsBeforeScenario() {
	public void shouldFailForPendingStepsIfConfigurationSaysSo() {
		Description child = addChildToScenario("child");

		JUnitScenarioReporter reporter = new JUnitScenarioReporter(notifier, 3,
				rootDescription);

		PendingStepStrategy strategy = new FailingUponPendingStep();
		reporter.usePendingStepStrategy(strategy);
public void shouldFailForPendingStepsIfConfigurationSaysSo() {
		verify(notifier).fireTestFailure(Mockito.<Failure> anyObject());
	}

	private void reportDefaultScenarioFinish(JUnitScenarioReporter reporter) {
		reporter.afterScenario();
		reporter.afterStory(false);
	}

	private void reportDefaultScenarioStart(JUnitScenarioReporter reporter) {
		reporter.beforeStory(story, false);
		reporter.beforeScenario("scenario");
	}

	private void verifyStandardFinish() {
package de.codecentric.jbehave.junit.monitoring.step;

import org.jbehave.core.annotations.AfterScenario;
import org.jbehave.core.annotations.AfterScenario.Outcome;
import org.jbehave.core.annotations.AfterStories;

public class InitSteps {
	@BeforeStories
	public void doSomethingBeforeStories() {
		System.out.println("InitSteps.doSomethingBeforeStories()");
	}

	@BeforeStory(uponGivenStory = true)
import org.jbehave.core.failures.FailingUponPendingStep;
import org.jbehave.core.io.LoadFromClasspath;
import org.jbehave.core.junit.JUnitStories;
import org.jbehave.core.reporters.Format;
import org.jbehave.core.reporters.StoryReporterBuilder;
import org.jbehave.core.steps.InjectableStepsFactory;
import org.jbehave.core.steps.InstanceStepsFactory;
import org.jbehave.core.steps.ParameterControls;
import org.junit.runner.RunWith;

import de.codecentric.jbehave.junit.monitoring.JUnitReportingRunner;
@RunWith(JUnitReportingRunner.class)
public class StoriesWithAllSortsOfBeforeAndAfter extends JUnitStories {

	public StoriesWithAllSortsOfBeforeAndAfter() {
		configuredEmbedder().embedderControls()
		// .doVerboseFailures(true)
				.useThreads(1);
	}

	@Override
	public Configuration configuration() {
		return new MostUsefulConfiguration()
				.usePendingStepStrategy(new FailingUponPendingStep())
				.useStoryReporterBuilder(
						new StoryReporterBuilder().withDefaultFormats()
								.withFailureTrace(true)
								.withFormats(Format.XML, Format.HTML))
				.useParameterControls(new ParameterControls("<", ">", true));
	}

	@Override
	public InjectableStepsFactory stepsFactory() {
		return new InstanceStepsFactory(configuration(), new ExampleSteps(),
				new InitSteps());
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void autoCorrectTextAt(Editable s, int cursor)
	{
		String textToCursor = s.subSequence(0, cursor).toString();
		String[] words = textToCursor.split("[ -]+");
		String lastWordBeforeCursor = words[words.length-1];

		boolean isFirstWord = words.length == 1;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void onSaveInstanceState(Bundle out) {
    protected abstract void handleActionView(Uri uri);

    /** Handles ACTION_VIEW_USERID intents: providing the user ID/JID. */
    protected abstract void handleActionViewConversation(Uri uri, Bundle args);

    private void processArguments(Bundle savedInstanceState) {
        Bundle args;
else if (ComposeMessage.ACTION_VIEW_CONVERSATION.equals(action)) {
            // view conversation - just userId provided
            else if (ComposeMessage.ACTION_VIEW_USERID.equals(action)) {
                Uri uri = args.getParcelable("data");
                handleActionViewConversation(uri, args);
            }
        }

else if (mUserJID == null) {
    }

    @Override
    protected void handleActionViewConversation(Uri uri, Bundle args) {
        mUserJID = uri.getPathSegments().get(1);
        mConversation = Conversation.loadFromUserId(getActivity(),
            mUserJID);
protected void handleActionViewConversation(Uri uri, Bundle args) {
            mUserName = mUserJID;
            mUserPhone = null;
        }
    }

    @Override
protected void handleActionView(Uri uri) {
     * Used only during activity restore.
     */
    @Override
    protected void handleActionViewConversation(Uri uri, Bundle args) {
        mGroupJID = uri.getPathSegments().get(1);
        mConversation = Conversation.loadFromUserId(getActivity(), mGroupJID);
        // unlikely, but better safe than sorry
        if (mConversation == null) {
            Log.i(TAG, "conversation for " + mGroupJID + " not found - exiting");
            getActivity().finish();
        }

        setThreadId(mConversation.getThreadId());
        mUserName = mGroupJID;
    }

    @Override
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
android:
  components:
    - tools
    - platform-tools
    - build-tools-25.0.3
    - android-25
    - extra-android-support
    - extra-android-m2repository
    - extra-google-m2repository
Add this to your module's `build.gradle` file:
```gradle
dependencies {
    // ... other dependencies
    compile 'com.afollestad:sectioned-recyclerview:0.4.4'
}
```

buildscript {

    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:' + versions.gradlePlugin
buildscript {
allprojects {
    repositories {
        jcenter()
    }
}

ext.versions = [
        minSdk: 14,
        compileSdk: 25,
        buildTools: '25.0.3',
        publishVersion: '0.4.4',
        publishVersionCode: 14,
        gradlePlugin: '2.3.2',
        supportLib: '25.3.1',
        truth: '0.31',
@SuppressWarnings("WeakerAccess")
public class ItemCoord {

  private int section;
  private int relativePos;

  ItemCoord(int section, int relativePos) {
    this.section = section;
  private final ArrayMap<Integer, Integer> headerLocationMap;
  private final ArrayMap<Integer, Boolean> collapsedSectionMap;
  private ItemProvider itemProvider;

  PositionManager() {
    this.headerLocationMap = new ArrayMap<>(0);
    this.collapsedSectionMap = new ArrayMap<>(0);
  }

  int invalidate(ItemProvider itemProvider) {
    this.itemProvider = itemProvider;
    int count = 0;
    headerLocationMap.clear();
void toggleSectionExpanded(int section) {
    }
  }

  boolean isSectionExpanded(int section) {
    if (section < 0 || section > itemProvider.getSectionCount() - 1) {
      throw new IllegalArgumentException("Section " + section + " is out of bounds.");

import java.util.List;

/**
 * @author Aidan Follestad (afollestad)
 */
@SuppressWarnings({"WeakerAccess", "unused"})
public abstract class SectionedRecyclerViewAdapter<VH extends SectionedViewHolder>
    extends RecyclerView.Adapter<VH> implements ItemProvider {

  private static final String TAG = "SectionedRVAdapter";

  protected static final int VIEW_TYPE_HEADER = -2;
  protected static final int VIEW_TYPE_ITEM = -1;

  private PositionManager positionManager;
  private GridLayoutManager layoutManager;
  private boolean showHeadersForEmptySections;

  public SectionedRecyclerViewAdapter() {
    positionManager = new PositionManager();
    positionManager.invalidate(this);
  }

  public void notifySectionChanged(@IntRange(from = 0, to = Integer.MAX_VALUE) int section) {
public void notifySectionChanged(@IntRange(from = 0, to = Integer.MAX_VALUE) int
      Log.d(TAG, "There are no items in section " + section + " to notify.");
      return;
    }
    Log.d(TAG, "Invalidating " + sectionItemCount + " items starting at index " + sectionHeaderIndex);
    notifyItemRangeChanged(sectionHeaderIndex, sectionItemCount);
  }

public void collapseSection(int section) {
  }

  public void expandAllSections() {
    for (int i = 0; i < getSectionCount(); i++) {
      positionManager.expandSection(i);
    }
    notifyDataSetChanged();
  }

  public void collapseAllSections() {
    for (int i = 0; i < getSectionCount(); i++) {
      positionManager.collapseSection(i);
    }
    notifyDataSetChanged();
  }

public void toggleSectionExpanded(int section) {
    notifyDataSetChanged();
  }


  public abstract int getSectionCount();

  public abstract int getItemCount(int section);
protected int getRowSpan(
    return 1;
  }

  /**
   * Converts an absolute position to a relative position and section.
   */
  public ItemCoord getRelativePosition(int absolutePosition) {
    return positionManager.relativePosition(absolutePosition);
  }
import android.support.v7.widget.RecyclerView;
import android.view.View;

public abstract class SectionedViewHolder extends RecyclerView.ViewHolder {

  interface PositionDelegate {
    ItemCoord relativePosition(int absolutePosition);

    boolean isHeader(int absolutePosition);
  }

  private PositionDelegate positionDelegate;

  public SectionedViewHolder(View itemView) {
protected ItemCoord getRelativePosition() {
  protected boolean isHeader() {
    return positionDelegate.isHeader(getAdapterPosition());
  }
}
  @Before
  public void before() {
    positionManager = new PositionManager();
    invalidate();
  }

public void test_collapse_section() {
  }

  @Test
  public void test_expand_section() {
    positionManager.collapseSection(1);
    assertThat(invalidate()).isEqualTo(7);
public void test_expand_section() {
  }

  @Test
  public void test_toggle_expanded() {
    positionManager.collapseSection(1);
    assertThat(invalidate()).isEqualTo(7);
public void test_toggle_expanded() {
  }

  @Test
  public void test_item_coord_toString() {
    assertThat(new ItemCoord(8, 16).toString()).isEqualTo("8:16");
  }
protected void onCreate(@Nullable Bundle savedInstanceState) {
        new GridLayoutManager(this, getResources().getInteger(R.integer.grid_span));
    list.setLayoutManager(manager);
    adapter.setLayoutManager(manager);
    adapter.shouldShowHeadersForEmptySections(false);
    adapter.collapseAllSections();
    list.setAdapter(adapter);
  }

  @Override
  public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.main, menu);
    return super.onCreateOptionsMenu(menu);
  }

public boolean onOptionsItemSelected(MenuItem item) {
      hideEmpty = !hideEmpty;
      adapter.shouldShowHeadersForEmptySections(hideEmpty);
      adapter.notifyDataSetChanged();
      item.setChecked(hideEmpty);
      return true;
    }
    return super.onOptionsItemSelected(item);
public MainVH onCreateViewHolder(ViewGroup parent, int viewType) {

    MainVH(View itemView, MainAdapter adapter) {
      super(itemView);
      this.title = (TextView) itemView.findViewById(R.id.title);
      this.caret = (ImageView) itemView.findViewById(R.id.caret);
      this.adapter = adapter;
      itemView.setOnClickListener(this);
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public int findLastSeenPosition(long lastSeen) {
    if (lastSeen <= 0)     return -1;
    if (!isActiveCursor()) return -1;

    int count = getItemCount();

    for (int i=0;i<count;i++) {
      MessageRecord messageRecord = getRecordForPositionOrThrow(i);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import android.animation.ObjectAnimator;
import android.content.Context;
import android.database.DataSetObserver;
import android.util.SparseArray;
import android.view.View;
import android.view.ViewGroup;
class WrapperAdapter implements WrapperListAdapter, ItemMainLayout.OnItemSlideListenerProxy, View.OnClickListener,
        AbsListView.OnScrollListener, ItemMainLayout.OnItemDeleteListenerProxy, Callback.OnDragDropListener,
        ItemMainLayout.OnItemScrollBackListenerProxy {
    private static final int TAG_LEFT = 3 << 24;
    private static final int TAG_RIGHT = 4 << 24;
    /* 上下文 */
    private Context mContext;
    /* 适配器 */
protected WrapperAdapter(Context context, SlideListView listView, ListAdapter ad
        mAdapter.registerDataSetObserver(mDataSetObserver);
        mListView.serAdapterDragDropListener(this);
        mItemIdTopMap = new HashMap<>();
    }

    @Override
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void takePictureInternal() {
            @Override
            public void onPictureTaken(byte[] data, Camera camera) {
                mCallback.onPictureTaken(data);
                camera.startPreview();
            }
        });
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Add this to your module's `build.gradle` file:
```gradle
dependencies {
    // ... other dependencies
    compile 'com.afollestad:aesthetic:0.4.3'
}
```

ext.versions = [
        minSdk            : 16,
        compileSdk        : 25,
        buildTools        : '25.0.3',
        publishVersion    : '0.4.3',
        publishVersionCode: 15,
        gradlePlugin      : '2.3.2',

        supportLib        : '25.3.1',

  public AestheticToolbar(Context context) {
    super(context);
    init();
  }

  public AestheticToolbar(Context context, @Nullable AttributeSet attrs) {
    super(context, attrs);
    init();
  }

  public AestheticToolbar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    init();
  }

  private void init() {
    onColorUpdated = PublishSubject.create();
  }

  private void invalidateColors(BgIconColorState state) {
public void setNavigationIcon(@Nullable Drawable icon, @ColorInt int color) {
  @Override
  protected void onAttachedToWindow() {
    super.onAttachedToWindow();
    subscription =
        Observable.combineLatest(
                Aesthetic.get().colorPrimary(),
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private static String read(Resource resource) throws IOException {
				builder.append(scanner.nextLine());

				if (scanner.hasNextLine()) {
					builder.append("\n");
				}
			}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import org.kontalk.provider.MyMessages.Messages;
import org.kontalk.provider.MyMessages.Messages.Fulltext;

import android.content.Context;
import android.database.Cursor;


/**
public static SearchItem fromCursor(Context context, Cursor cursor) {
    }

    public static Cursor query(Context context, String query) {
        // TODO enhanced queries?
        return context.getContentResolver().query(Fulltext.CONTENT_URI
                    .buildUpon().appendQueryParameter("pattern", query + "*").build(),
                SEARCH_PROJECTION, null, null, null);
    }
}
public void setQuery(String query) {
        Activity parent = getActivity();
        if (parent != null) {
            mCursor = SearchItem.query(parent, mQuery);
            getActivity().startManagingCursor(mCursor);

            mListAdapter = new SearchListAdapter(parent, mCursor);
            // TODO mListAdapter.setOnContentChangedListener(mContentChangedListener);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import enmasse.config.AddressConfigKeys;
import enmasse.config.LabelKeys;
import enmasse.controller.common.Kubernetes;
import enmasse.controller.model.Destination;
import enmasse.controller.model.InstanceId;
private void createOrReplace(Destination destination) {
        DoneableConfigMap builder = client.configMaps().inNamespace(instanceId.getNamespace()).withName(name).createOrReplaceWithNew()
                .withNewMetadata()
                .withName(name)
                .addToLabels(LabelKeys.GROUP_ID, Kubernetes.sanitizeName(destination.group()))
                .addToLabels(LabelKeys.TYPE, "address-config")
                .addToLabels(LabelKeys.INSTANCE, Kubernetes.sanitizeName(instanceId.getId()))
                .endMetadata();
        builder.addToData(AddressConfigKeys.ADDRESS, destination.address());
        builder.addToData(AddressConfigKeys.GROUP_ID, destination.group());
import io.fabric8.kubernetes.api.model.extensions.Deployment;
import io.fabric8.openshift.client.ParameterValue;

import java.util.List;
import java.util.Map;
import java.util.Set;
static String sanitizeName(String name) {
    static void addObjectLabel(KubernetesList items, String labelKey, String labelValue) {
        for (HasMetadata item : items.getItems()) {
            Map<String, String> labels = item.getMetadata().getLabels();
            labels.put(labelKey, labelValue);
            item.getMetadata().setLabels(labels);
        }
    }

    InstanceId getInstanceId();
    Kubernetes withInstance(InstanceId instance);


package enmasse.controller.common;

import enmasse.config.LabelKeys;
import enmasse.controller.address.DestinationCluster;
import enmasse.controller.model.InstanceId;
public KubernetesHelper(InstanceId instance, OpenShiftClient client, File templa
        objects.addAll(client.replicationControllers().inNamespace(instance.getNamespace()).list().getItems());

        for (HasMetadata config : objects) {
            Map<String, String> labels = config.getMetadata().getLabels();

            if (labels != null && labels.containsKey(LabelKeys.GROUP_ID)) {
                String groupId = labels.get(LabelKeys.GROUP_ID);

                if (!"address-config".equals(labels.get(LabelKeys.TYPE))) {
                    if (!resourceMap.containsKey(groupId)) {
                        resourceMap.put(groupId, new ArrayList<>());
                    }

package enmasse.controller.common;

import enmasse.config.LabelKeys;
import enmasse.controller.address.DestinationCluster;
import enmasse.controller.flavor.FlavorRepository;
private KubernetesList processTemplate(Destination first, Set<Destination> desti

        // If the flavor is shared, there is only one instance of it, so give it the name of the flavor
        paramMap.put(TemplateParameter.NAME, Kubernetes.sanitizeName(groupId));
        paramMap.put(TemplateParameter.INSTANCE, Kubernetes.sanitizeName(instance.id().getId()));
        paramMap.put(TemplateParameter.COLOCATED_ROUTER_SECRET, instance.certSecret());

        // If the name of the group matches that of the address, assume a scalable queue
private KubernetesList processTemplate(Destination first, Set<Destination> desti
        KubernetesList items = kubernetes.processTemplate(flavor.templateName(), parameters);

        // These are attributes that we need to identify components belonging to this address
        Kubernetes.addObjectLabel(items, LabelKeys.GROUP_ID, Kubernetes.sanitizeName(groupId));
        Kubernetes.addObjectLabel(items, LabelKeys.ADDRESS_CONFIG, Kubernetes.sanitizeName("address-config-" + groupId));
        first.uuid().ifPresent(uuid -> Kubernetes.addObjectLabel(items, LabelKeys.UUID, uuid));
        return items;
    }
    String NAME = "NAME";
    String ADDRESS = "ADDRESS";
    String INSTANCE = "INSTANCE";
    String MESSAGING_HOSTNAME = "MESSAGING_HOSTNAME";
    String MQTT_HOSTNAME = "MQTT_GATEWAY_HOSTNAME";
    String CONSOLE_HOSTNAME = "CONSOLE_HOSTNAME";
package enmasse.controller.instance;

import enmasse.config.LabelKeys;
import enmasse.controller.common.ConfigWatcher;
import enmasse.controller.instance.api.InstanceApi;
import enmasse.controller.instance.cert.CertManager;
import enmasse.controller.model.Instance;
import io.fabric8.kubernetes.api.model.extensions.Ingress;
import io.fabric8.kubernetes.api.model.extensions.IngressList;
import io.fabric8.openshift.api.model.Route;

import java.io.IOException;
import java.util.*;
import java.util.stream.Collectors;


/**
private void createInstances(Set<Instance> instances) {
    }

    private void updateRoutes(Instance.Builder instance) throws IOException {
        Map<String, String> labelMap = new HashMap<>();
        labelMap.put(LabelKeys.INSTANCE, instance.id().getId());

        /* Watch for routes and ingress */
        if (client.isAdaptable(OpenShiftClient.class)) {
            updateRoutes(instance, client.routes().inNamespace(instance.id().getNamespace()).withLabels(labelMap).list());
        } else {
            updateIngresses(instance, client.extensions().ingresses().inNamespace(instance.id().getNamespace()).withLabels(labelMap).list());
        }
    }

    private void updateIngresses(Instance.Builder instance, IngressList list) {
        for (Ingress ingress : list.getItems()) {
            updateRoute(instance, ingress.getMetadata().getName(), ingress.getSpec().getRules().get(0).getHost());
        }
    }

    private void updateRoutes(Instance.Builder instance, RouteList list) throws IOException {
        for (Route route : list.getItems()) {
            updateRoute(instance, route.getMetadata().getName(), route.getSpec().getHost());
        }
    }

    private void updateRoute(Instance.Builder builder, String name, String host) {
package enmasse.controller.instance;

import enmasse.config.LabelKeys;
import enmasse.controller.common.Kubernetes;
import enmasse.controller.common.KubernetesHelper;
public void create(Instance instance) {

    private KubernetesList createResourceList(Instance instance) {
        List<ParameterValue> parameterValues = new ArrayList<>();
        parameterValues.add(new ParameterValue(TemplateParameter.INSTANCE, Kubernetes.sanitizeName(instance.id().getId())));
        instance.messagingHost().ifPresent(h -> parameterValues.add(new ParameterValue(TemplateParameter.MESSAGING_HOSTNAME, h)));
        instance.mqttHost().ifPresent(h -> parameterValues.add(new ParameterValue(TemplateParameter.MQTT_HOSTNAME, h)));
        instance.consoleHost().ifPresent(h -> parameterValues.add(new ParameterValue(TemplateParameter.CONSOLE_HOSTNAME, h)));
public void retainInstances(Set<InstanceId> desiredInstances) {
                labels.put(LabelKeys.APP, "enmasse");
                labels.put(LabelKeys.TYPE, "instance");
                for (Namespace namespace : kubernetes.listNamespaces(labels)) {
                    String id = namespace.getMetadata().getLabels().get(LabelKeys.INSTANCE);
                    InstanceId instanceId = InstanceId.withIdAndNamespace(id, namespace.getMetadata().getName());
                    if (!desiredInstances.contains(instanceId)) {
                        delete(instanceId);

package enmasse.controller.common;

import enmasse.controller.flavor.FlavorManager;
import enmasse.controller.model.Destination;
import enmasse.controller.model.Flavor;
public void testStoreAndForward() {
        List<HasMetadata> resources = clusterList.getResources().getItems();
        assertThat(resources.size(), is(1));
        for (HasMetadata resource : resources) {
            Map<String, String> rlabel = resource.getMetadata().getLabels();
            assertNotNull(rlabel.get(LabelKeys.GROUP_ID));
            assertThat(rlabel.get(LabelKeys.GROUP_ID), is("foo-bar"));
        }
        List<ParameterValue> parameters = captor.getAllValues();
        assertThat(parameters.size(), is(4));
    }

    private DestinationCluster generateCluster(Destination destination, ArgumentCaptor<ParameterValue> captor) {
public interface LabelKeys {
    String TYPE = "type";

    String GROUP_ID = "group_id";
    String ADDRESS_CONFIG = "address_config";
    String INSTANCE = "instance";
    String UUID = "uuid";
    String ADDRESS = "address";
    String APP = "app";
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void updateCache(ClassLoader loader, Multimap<String, Location> newClass
                return ImmutableList.of();
            }
        }
        // special case for jboss/wildfly
        try {
            return Collections.list(loader.getResources("/"));
        } catch (IOException e) {
            logger.warn(e.getMessage(), e);
            return ImmutableList.of();
        }
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void cleanTaskActivities() {
		List<TrackedTask> resultList = createQuery.getResultList();
		for (TrackedTask trackedTask : resultList) {
			if (trackedTask.getCurrentActivity().isPresent()) {
				ITask task = getTask(trackedTask);
				// note that the ITask may not exist in this workspace
				if (task!=null && !task.isActive()) {
					// try to figure out when it was last active
					Activity activity = trackedTask.getCurrentActivity().get();
					ZonedDateTime start = activity.getStart().atZone(ZoneId.systemDefault());
public void migrate() {
	}

	/**
	 * Associates given Mylyn Task with this instance. If the Mylyn task already
	 * have a Timekeeper identifier attribute it will be used as an identifier
	 * for this instance, otherwise an indentifier string will be created.
	 * 
	 * @param task
	 *            the Mylyn task
public String getTaskId() {
	}

	/**
	 * Returns the {@link ITask} if available. If not, it can be obtained from
	 * {@link TimekeeperPlugin#getTask(TrackedTask)} which will look in the task
	 * repository.
	 * 
	 * @return the {@link ITask} or <code>null</code>
	 */
public Font getFont(Object element) {
		}
		if (element instanceof Activity) {
			TrackedTask trackedTask = ((Activity) element).getTrackedTask();
			ITask task = TimekeeperPlugin.getDefault().getTask(trackedTask);
			if (task != null && task.isActive()) {
				if (trackedTask.getCurrentActivity().isPresent()
						&& trackedTask.getCurrentActivity().get().equals(element)) {
protected void setValue(Object element, Object value) {
		if (element instanceof Activity) {
			if (value instanceof String) {
				TrackedTask trackedTask = ((Activity) element).getTrackedTask();
				ITask task = TimekeeperPlugin.getDefault().getTask(trackedTask);
				LocalDateTime start = ((Activity) element).getStart();
				// has time point or range been specified...
				Matcher range = Pattern.compile(TIME_RANGE).matcher((String) value);
protected void setValue(Object element, Object value) {
	}

	private void update(Object element, ITask task) {
		getViewer().update(element, null);
		getViewer().update(task, null);
		getViewer().update(Activator.getProjectName(task), null);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
buildscript {
	repositories {
	    jcenter()
	    maven { url = "http://files.minecraftforge.net/maven" }
	}
	dependencies {
		classpath 'net.minecraftforge.gradle:ForgeGradle:2.3-SNAPSHOT'
	}
}
apply plugin: 'net.minecraftforge.gradle.forge'
//Only edit below this line, the above code adds and enables the nessasary things for Forge to be setup.


version = "6.0.0.3"
group= "landmaster.plustic" // http://maven.apache.org/guides/mini/guide-naming-conventions.html
archivesBaseName = "plustic"

repositories {
		url 'http://dvs1.progwml6.com/files/maven'
	}
	maven {
        url = "http://maven.covers1624.net"
    }
}

sourceCompatibility = targetCompatibility = "1.8" // Need this here so eclipse task generates correctly.
dependencies {
	// or you may define them like so..
	//compile "some.group:artifact:version:classifier"
	//compile "some.group:artifact:version"
	  
	// real examples
	//compile 'com.mod-buildcraft:buildcraft:6.0.8:dev'  // adds buildcraft to the dev env
	//compile 'com.googlecode.efficient-java-matrix-library:ejml:0.24' // adds ejml to the dev env
dependencies {
	// http://www.gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html
	// http://www.gradle.org/docs/current/userguide/dependency_management.html
	
	deobfCompile "slimeknights.mantle:Mantle:1.12-1.3.0.15"
	deobfCompile "slimeknights:TConstruct:1.12-2.7.1.7"
	deobfCompile "cofh:RedstoneFlux:1.12-2.0.0.1:universal"
}

processResources {
	exclude '**/*.xcf'
	
processResources {
	
	// replace stuff in mcmod.info, nothing else
	from(sourceSets.main.resources.srcDirs) {
	    include 'mcmod.info'
	            
	    // replace version and mcversion
	    expand 'version':project.version, 'mcversion':project.minecraft.version
	}
	    
	// copy everything else, thats not the mcmod.info
	from(sourceSets.main.resources.srcDirs) {
	    exclude 'mcmod.info'
	}
}

jar {
	manifest {
	    attributes 'FMLAT': 'plustic_at.cfg'
	}
}
public void init(FMLInitializationEvent event) {
		
		IModule.modules.forEach(IModule::init2);
		
		integrate(materials, materialIntegrations);
	}
	
	@EventHandler
private static void preIntegrate(Map<String,Material> materials,
					} else {
						mi = new MaterialIntegration(v);
					}
					mi.preInit();
					materialIntegrations.put(k, mi);
				});
			}
		});
	}
	
	private static void integrate(Map<String,Material> materials,
			Map<String,MaterialIntegration> materialIntegrations) {
		materialIntegrations.forEach((k, mi) -> {
			mi.integrateRecipes();
		});
		
		Utils.displace(TinkerMaterials.wood.getIdentifier()); // so that natura woods are prioritized
	}
}

	public static final String MODID = "plustic";
	public static final String NAME = "PlusTiC";
	public static final String VERSION = "6.0.0.3";
	
	// TODO add dependencies when needed
	public static final String DEPENDS = "required-after:mantle;"
	+ "required-after:tconstruct@[1.12-2.7.1.7,);required-after:forge@[14.21.1.2387,);"
	+ "after:mekanism;after:biomesoplenty;"
	+ "after:botania;after:libvulpes;after:redstoneflux;"
	+ "after:armorplus;after:enderio;after:projectred-exploration;"
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public static void processMessageToMatchSession(HttpMessage message, List<HttpCo

		// Make a copy of the session tokens set, as they will be modified
		HttpSessionTokensSet tokensSet = session.getTokensNames();
		Set<String> unsetSiteTokens = new LinkedHashSet<>(tokensSet.getTokensSet());

		// Iterate through the cookies in the request
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void pause() {
        this.paused = true;

        if (singleFetchDataTask != null) singleFetchDataTask.pause();
        for (DownloadRunnable runnable : downloadRunnableList) {
            runnable.pause();
        }

        statusCallback.onPaused();
private void fetchWithMultipleConnection(final List<ConnectionModel> connectionM
                FileDownloadLog.d(this, "enable multiple connection: %!s(MISSING)", connectionModel);
            }

            downloadRunnableList.add(runnable);
        }

public boolean isRetry(Exception exception) {
    public void onError(Exception exception) {

        // discard all
        for (DownloadRunnable runnable : downloadRunnableList) {
            runnable.discard();
        }

        statusCallback.onError(exception);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import android.os.Environment;
import android.os.Handler;
import android.support.annotation.NonNull;
import android.support.v4.app.Fragment;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.LinearLayoutManager;
private void setAdapter() {
            public void run() {
                if (window.getView(R.id.layout_online_preset_store_recyclerview_loading, v).getVisibility() == View.VISIBLE) {
                    // loading for 10 seconds, prompt user to retry or not
                    new MaterialDialog.Builder(a)
                            .title(R.string.preset_store_connection_timeout_dialog_title)
                            .content(R.string.preset_store_connection_timeout_dialog_text)
                            .contentColorRes(R.color.dark_primary)
                            .positiveText(R.string.preset_store_connection_timeout_dialog_positive)
                            .negativeText(R.string.preset_store_connection_timeout_dialog_negative)
                            .onPositive(new MaterialDialog.SingleButtonCallback() {
                                @Override
                                public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
                                    setAdapter();
                                }
                            })
                            .onNegative(new MaterialDialog.SingleButtonCallback() {
                                @Override
                                public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
                                    setLoadingFailed();
                                }
                            })
                            .show();
                }
            }
        }, 10000);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
archivesBaseName = "BetterFps"
minecraft {
    version = "1.11.2"
    runDir = "run"
    tweakClass = "guichaguri.betterfps.tweaker.BetterFpsTweaker";
    mappings = "snapshot_20161220"

    at 'betterfps_at.cfg'
public static void loadConfig() {

    public static void saveConfig() {
        try {
            if(!CONFIG_FILE.exists()) CONFIG_FILE.createNewFile();
            FileUtils.writeStringToFile(CONFIG_FILE, new Gson().toJson(INSTANCE));
        } catch(Exception ex) {
            LOG.error("Could not save the config file", ex);
public BetterFpsResourcePack() {
    }

    private String getPath(ResourceLocation location) {
        return String.format("assets/%!s(MISSING)/%!s(MISSING)", location.getResourceDomain(), location.getResourcePath());
    }

    @Override
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import com.google.inject.Inject;
import com.intellij.lexer.Lexer;
import com.intellij.openapi.fileTypes.SyntaxHighlighter;
import com.intellij.openapi.fileTypes.SyntaxHighlighterFactory;
import com.intellij.openapi.project.Project;
import org.metaborg.intellij.idea.languages.IIdeaLanguageManager;
import org.metaborg.intellij.idea.languages.ILanguageBindingManager;
import org.metaborg.intellij.idea.languages.MetaborgIdeaLanguage;
import org.metaborg.intellij.idea.parsing.elements.SpoofaxTokenTypeManager;
import org.metaborg.intellij.resources.IIntelliJResourceService;

public SyntaxHighlighter getSyntaxHighlighter(
        @Nullable final FileObject file = this.resourceService.resolve(virtualFile);

        if (file != null) {
            implementation = this.identifierService.identify(file);
        }
        else if (virtualFile instanceof LightVirtualFile) {
            final com.intellij.lang.Language ideaLanguage = ((LightVirtualFile)virtualFile).getLanguage();
else if (virtualFile instanceof LightVirtualFile) {
        }

        if (implementation == null){
            // FIXME: What to do? Can I return null to get the default highlighting?
            return null;
        }

        @Nullable final IProject metaborgProject = null;  // FIXME: Get IProject from Project
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void applyChange( MavenProject project, SortedMap<String, Model> reactor
        final Map.Entry<String, Model> current = PomHelper.getModelEntry( reactor, groupId, artifactId );
        current.getValue().setVersion( newVersion );

        addFile( files, getProject(), current.getKey() );

        for ( Map.Entry<String, Model> sourceEntry : reactor.entrySet() )
        {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public static Boolean parseBoolean(Object obj) {
     * Sometimes search returns a count as a json number ("count":0), sometimes a string ("count":"1103").
     * Seems to be the same for result "ids" list (See Issue #1).  Handle either form and return as an int.
     */
    public static Integer parseInteger(Object o) {
        if (o instanceof Integer) {
            return (Integer)o;
        } else if (o instanceof String) {
public static Integer parseInteger(Object o) {
            }
        } else {
            Log.d(TAG, "unexpected type: "+o);
            return null;
        }
    }
}

    public Integer offset;

    public Integer visible;

    public final Integer searchLimit = 500;
    
private static HttpConnection conn() {
            return results; // search failed or server crashed

        Map<String, ?> response = (Map<String, ?>) resp;
        visible = Api.parseInteger(response.get("count"));

        // result_lol is a list of lists and looks like one of:
        //   [[32673,null,"0.0"],[886843,null,"0.0"]] // integer ids+?
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <activity android:name=".controller.IssueActivity" />
        <activity android:name=".controller.RepCallActivity" />
        <activity android:name=".controller.AboutActivity" />
        <activity android:name=".controller.TutorialActivity" />
        <activity android:name=".controller.SettingsActivity" />
        <activity android:name=".controller.LocationActivity"/>
        <activity android:name=".controller.StatsActivity"
            android:label="@string/stats_activity"/>
        <receiver
            android:name=".controller.NotifyBroadcastReceiver" />
        <receiver
protected void onCreate(@Nullable Bundle savedInstanceState) {
        setContentView(R.layout.activity_issue);
        ButterKnife.bind(this);

        getSupportActionBar().setDisplayHomeAsUpEnabled(true);
        getSupportActionBar().setTitle(mIssue.name);

        issueName.setText(mIssue.name);
        issueDescription.setText(mIssue.reason);
protected void onCreate(Bundle savedInstanceState) {
        Intent intent = getIntent();
        if (intent != null) {
            if (intent.getBooleanExtra(ALLOW_HOME_UP_KEY, false)) {
                getSupportActionBar().setDisplayHomeAsUpEnabled(true);
                allowsHomeUp = true;
            }
        }
private void returnToMain() {
        // If we came from MainActivity and return with another Intent, it will create a deep stack
        // of activities!
        if (allowsHomeUp) {
            onBackPressed();
        } else {
            Intent intent = new Intent(this, MainActivity.class);
            startActivity(intent);
private void returnToMain() {
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                onBackPressed();
                return true;
        }
        return super.onOptionsItemSelected(item);
protected void onCreate(Bundle savedInstanceState) {
        ButterKnife.bind(this);

        setSupportActionBar(actionBar);
        getSupportActionBar().setDisplayHomeAsUpEnabled(true);
        getSupportActionBar().setHomeAsUpIndicator(R.drawable.ic_menu_white_24dp);

        if (navigationView != null) {
            setupDrawerContent(navigationView);
package org.a5calls.android.a5calls.controller;

import android.content.DialogInterface;
import android.graphics.Bitmap;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.support.design.widget.Snackbar;
import android.support.v4.graphics.drawable.RoundedBitmapDrawable;
import android.support.v4.graphics.drawable.RoundedBitmapDrawableFactory;
import android.support.v7.app.AlertDialog;
protected void onCreate(@Nullable Bundle savedInstanceState) {
        setContentView(R.layout.activity_rep_call);
        ButterKnife.bind(this);

        getSupportActionBar().setDisplayHomeAsUpEnabled(true);
        getSupportActionBar().setTitle(mIssue.name);

        mStatusListener = new FiveCallsApi.CallRequestListener() {
            @Override
public void onCallCount(int count) {
            public void onCallReported() {
                // Note: Skips are not reported.
                Log.d(TAG, "call reported successfully!");
                onBackPressed();
            }
        };
        FiveCallsApi controller = AppSingleton.getInstance(getApplicationContext())
protected void onResume() {
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                onBackPressed();
                return true;
        }
        return super.onOptionsItemSelected(item);
public void onClick(View v) {
            public void onClick(View v) {
                reportEvent("skip");
                // Since this is the last contact, just go back to the main menu if they "skip"
                onBackPressed();
            }
        });
    }
private void reportEvent(String event) {
                    .build());
        }
    }
}
protected void onCreate(@Nullable Bundle savedInstanceState) {
        setContentView(R.layout.activity_stats);
        ButterKnife.bind(this);

        getSupportActionBar().setDisplayHomeAsUpEnabled(true);

        DatabaseHelper db = AppSingleton.getInstance(this).getDatabaseHelper();
        initializeUI(db);
    <string name="snooze">Recuérdeme más tarde</string>

    <!-- Button to load more and/or inactive issues [CHAR_LIMIT=50] -->
    <string name="load_more_btn">cargar más asuntos</string>

    <!-- Stats summary shown on the home page [CHAR_LIMIT=75] -->
    <string name="your_call_count_summary">Has hecho <xliff:g id="callCount">%!$(MISSING)d</xliff:g> llamadas</string>

    <!-- Navigation link to the FAQ page [CHAR_LIMIT=25] -->
    <string name="menu_faq">FAQ</string>

    <!-- Header for the representatives / contacts list [CHAR_LIMIT=100] -->
    <string name="rep_section_prompt">Contactos para llamar a este asunto:</string>

</resources>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

package com.cloudera.oryx.kafka.util;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Properties;
import java.util.concurrent.TimeUnit;

import kafka.admin.AdminUtils;
import kafka.admin.RackAwareMode;
import kafka.consumer.ConsumerConfig;
import kafka.javaapi.OffsetRequest;
import kafka.javaapi.OffsetResponse;
import kafka.javaapi.consumer.SimpleConsumer;
import kafka.utils.ZKGroupTopicDirs;
import kafka.utils.ZkUtils;
public static void fillInLatestOffsets(Map<Pair<String,Integer>,Long> offsets,
    kafkaParams.forEach(props::put);
    ConsumerConfig config = new ConsumerConfig(props);

    Map<TopicAndPartition,PartitionOffsetRequestInfo> latestRequests = new HashMap<>();
    Map<TopicAndPartition,PartitionOffsetRequestInfo> earliestRequests = new HashMap<>();
    offsets.keySet().forEach(topicPartition -> {
      TopicAndPartition tAndP = new TopicAndPartition(topicPartition.getFirst(), topicPartition.getSecond());
      latestRequests.put(tAndP, new PartitionOffsetRequestInfo(OffsetRequest$.MODULE$.LatestTime(), 1));
      earliestRequests.put(tAndP, new PartitionOffsetRequestInfo(OffsetRequest$.MODULE$.EarliestTime(), 1));
    });
    OffsetRequest latestRequest = new OffsetRequest(latestRequests,
                                                    OffsetRequest$.MODULE$.CurrentVersion(),
                                                    config.clientId());
    OffsetRequest earliestRequest = new OffsetRequest(earliestRequests,
                                                      OffsetRequest$.MODULE$.CurrentVersion(),
                                                      config.clientId());

    SimpleConsumer consumer = null;
    for (String hostPort : kafkaParams.get("bootstrap.servers").split(",")) {
      log.info("Connecting to broker {}", hostPort);
      String[] hp = hostPort.split(":");
      String host = hp[0];
      int port = Integer.parseInt(hp[1]);
      try {
        consumer = new SimpleConsumer(host, port,
                                      config.socketTimeoutMs(),
                                      config.socketReceiveBufferBytes(),
                                      config.clientId());
        break;
      } catch (Exception e) {
        log.warn("Error while connecting to broker {}:{}", host, port, e);
      }
    }
    Objects.requireNonNull(consumer, "No available brokers");

    try {
      OffsetResponse latestResponse = requestOffsets(consumer, latestRequest);
      OffsetResponse earliestResponse = requestOffsets(consumer, earliestRequest);
      offsets.keySet().forEach(topicPartition -> {
        Long latestTopicOffset = getOffset(latestResponse, topicPartition);
        Long currentOffset = offsets.get(topicPartition);
        if (currentOffset == null) {
          if (latestTopicOffset == null) {
            log.info("No initial offset for {}, no latest offset from topic; ignoring");
          } else {
            log.info("No initial offset for {}; using latest offset {} from topic",
                topicPartition, latestTopicOffset);
            offsets.put(topicPartition, latestTopicOffset);
          }
        } else if (latestTopicOffset != null && currentOffset > latestTopicOffset) {
          log.warn("Initial offset {} for {} after latest offset {} from topic! using topic offset",
                   currentOffset, topicPartition, latestTopicOffset);
          log.warn("Are you using a stale or incorrect oryx.id?");
          offsets.put(topicPartition, latestTopicOffset);
        } else {
          Long earliestTopicOffset = getOffset(earliestResponse, topicPartition);
          if (earliestTopicOffset != null && currentOffset < earliestTopicOffset) {
            log.warn("Initial offset {} for {} before earliest offset {} from topic! using topic offset",
                     currentOffset, topicPartition, earliestTopicOffset);
            log.warn("Are you using a stale or incorrect oryx.id?");
            offsets.put(topicPartition, earliestTopicOffset);
          }
        }
      });
    } finally {
      consumer.close();
    }
    
    offsets.values().removeIf(Objects::isNull);
  }

  private static Long getOffset(OffsetResponse response, Pair<String,Integer> topicPartition) {
    String topic = topicPartition.getFirst();
    int partition = topicPartition.getSecond();
    long[] offsets = response.offsets(topic, partition);
    if (offsets.length > 0) {
      return offsets[0];
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import mezz.jei.api.BlankModPlugin;
import mezz.jei.api.IModRegistry;
import mezz.jei.api.JEIPlugin;
import mezz.jei.util.Translator;
import mod.chiselsandbits.core.ChiselsAndBits;
import mod.chiselsandbits.registry.ModItems;

import java.util.ArrayList;
import java.util.List;

import com.phylogeny.extrabitmanipulation.reference.Reference;

import mezz.jei.util.CycleTimer;
import net.minecraft.client.Minecraft;
import net.minecraft.util.ResourceLocation;


import javax.annotation.Nullable;

import com.phylogeny.extrabitmanipulation.api.jei.icon.CategoryIcon;
import com.phylogeny.extrabitmanipulation.reference.Reference;

import mezz.jei.api.gui.IRecipeLayout;
import mezz.jei.api.ingredients.IIngredients;
import mezz.jei.api.recipe.BlankRecipeCategory;
import mezz.jei.util.Translator;

public class ModelInfoRecipeCategory extends BlankRecipeCategory<ModelInfoRecipe>
{

import javax.annotation.Nullable;

import com.phylogeny.extrabitmanipulation.api.jei.icon.CategoryIconList;
import com.phylogeny.extrabitmanipulation.reference.Reference;

import mezz.jei.api.gui.IRecipeLayout;
import mezz.jei.api.ingredients.IIngredients;
import mezz.jei.api.recipe.BlankRecipeCategory;
import mezz.jei.util.Translator;

public class ShapeInfoRecipeCategory extends BlankRecipeCategory<ShapeInfoRecipe>
{
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
     */
    private final Map<UUID, DockerImage> images = new HashMap<>();

    private final SBuildServer buildServer;
    private final BuildAgentManager agentMgr;

protected void callInternal() throws Exception {
            // Step 1, query the whole list of containers associated with this cloud client.
            Node containers = dockerClient.listContainersWithLabel(DockerCloudUtils.CLIENT_ID_LABEL, uuid.toString());

            List<String> orphanedContainers = new ArrayList<>();

            lock.lock();
            try {
protected void callInternal() throws Exception {
                }

                // Step 2: pro-actively discard unregistered agent that are no longer referenced, they are lost to us.
                for (SBuildAgent agent : agentMgr.getUnregisteredAgents()) {
                    if (uuid.equals(DockerCloudUtils.getClientId(agent))) {
                        UUID instanceId = DockerCloudUtils.getInstanceId(agent);
                        boolean discardAgent = false;
protected void callInternal() throws Exception {
                            discardAgent = true;
                        }
                        if (discardAgent) {
                            try {
                                agentMgr.removeAgent(agent, null);
                            } catch (AgentCannotBeRemovedException e) {
                                LOG.warn("Failed to remove unregistered agent.", e);
                            }
                        }
                    }
                }
protected void callInternal() throws Exception {
                lock.unlock();
            }

            if (!orphanedContainers.isEmpty()) {
                LOG.info("The following orphaned containers will be removed: " + orphanedContainers);
            }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static public String getUtxoString(String b58) throws IOException {
        String response = "";
        url = new URL("https://testnet.blockexplorer.com/api/addr/" + b58 + "/utxo");
        HttpsURLConnection con = (HttpsURLConnection) url.openConnection();
        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));
        String line;
        while ((line = in.readLine()) != null) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public static Type getFieldType(final Class<?> clazz, final Type type, Type fiel
            ParameterizedType parameterizedFieldType = (ParameterizedType) fieldType;

            Type[] arguments = parameterizedFieldType.getActualTypeArguments();
            TypeVariable<?>[] typeVariables = null;
            ParameterizedType paramType = null;
            if (type instanceof ParameterizedType) {
                paramType = (ParameterizedType) type;
                typeVariables = clazz.getTypeParameters();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                            <tag>${project.version}</tag>
                                        </tags>
                                        <runCmds>
                                            <run>usermod -g root jboss</run>
                                            <run>chmod -R g+rw /opt/jboss/wildfly</run>
                                        </runCmds>
                                        <assembly>
                                            <basedir>/opt/jboss/wildfly</basedir>
                                            <descriptor>${project.basedir}/standalone/assembly-artifacts.xml</descriptor>
                                            <user>jboss:root:root</user>
                                        </assembly>
                                        <user>jboss</user>
                                        <!--  
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
android {
        applicationId "de.westnordost.streetcomplete"
        minSdkVersion 17
        targetSdkVersion 25
        // until #286 is fixed
        maxSdkVersion 25
        versionCode 8
        versionName "0.11"
        multiDexEnabled true
dependencies {
    // tests (perhaps migrate to junit4 later if any features of it seem convenient or necessary)
    testCompile 'junit:junit:3.8.1'
    testCompile 'org.mockito:mockito-core:1.10.19'
    testCompile 'org.objenesis:objenesis:2.2'

    androidTestCompile 'org.mockito:mockito-core:1.10.19'
    androidTestCompile 'org.objenesis:objenesis:2.2'
    androidTestCompile "com.crittercism.dexmaker:dexmaker:1.4"
    androidTestCompile "com.crittercism.dexmaker:dexmaker-dx:1.4"
    androidTestCompile "com.crittercism.dexmaker:dexmaker-mockito:1.4"


    // dependency injection
    compile 'com.google.dagger:dagger:2.5'
    apt 'com.google.dagger:dagger-compiler:2.5'
dependencies {
    }

    // serialization
    compile 'com.esotericsoftware:kryo:4.0.0'

    // map and location
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
apply plugin: 'net.minecraftforge.gradle.forge'
//    id "net.minecraftforge.gradle.forge" version "2.0.2"
//}

version = "2.4.1"
def silentlib_version = "2.2.6"
def buildNum = 0
group = "net.silentchaos512.gems"
Silent's Gems - Changelog

2.4.0
Updated to work with 1.11.2. Support for 1.10.2 on the way.
Added: Config to show chaos bar at all times, instead of just when you gain/lose chaos (disabled by default)
import net.minecraft.client.renderer.Tessellator;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import net.silentchaos512.lib.util.Color;

public class ArmorModelRenderer extends ModelRenderer{
public void render(float scale)
    @SideOnly(Side.CLIENT)
    protected void compileDisplayList(float scale)
    {
        this.displayList = GLAllocation.generateDisplayLists(1);
        GlStateManager.glNewList(this.displayList, 4864);
        BufferBuilder vertexBuffer = Tessellator.getInstance().getBuffer();
package net.silentchaos512.gems.client.render.particle;

import net.minecraft.client.particle.Particle;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.entity.Entity;
import net.minecraft.world.World;

public class ParticleChaosUnused extends Particle {

  public static final int MAX_AGE = 6;
  public static final int MAX_SCALE = 3;
public void onUpdate() {
  }

  @Override
  public void renderParticle(BufferBuilder worldRendererIn, Entity entityIn, float partialTicks,
      float rotationX, float rotationZ, float rotationYZ, float rotationXY, float rotationXZ) {

    float uMin = (float) this.particleTextureIndexX / 16.0F;
package net.silentchaos512.gems.client.render.particle;

import net.minecraft.client.particle.Particle;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.entity.Entity;
import net.minecraft.world.World;

public class ParticleCompass extends Particle {

  public static final int MAX_AGE = 5;
  public static final int MAX_SCALE = 1;
public void onUpdate() {
  }

  @Override
  public void renderParticle(BufferBuilder worldRendererIn, Entity entityIn, float partialTicks,
      float rotationX, float rotationZ, float rotationYZ, float rotationXY, float rotationXZ) {

    float uMin = (float) this.particleTextureIndexX / 16.0F;
package net.silentchaos512.gems.client.render.particle;

import net.minecraft.client.particle.Particle;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.MathHelper;
import net.minecraft.world.World;


public class ParticleFreezing extends Particle {

  public static final int MAX_AGE = 40;
  public static final int MAX_SCALE = 1;
protected ParticleFreezing(World world, double posX, double posY, double posZ) {
    this(world, posX, posY, posZ, 0, 0, 0, MAX_SCALE, MAX_AGE, 0.5f, 0.7f, 1.0f);
  }

  public ParticleFreezing(World world, double posX, double posY, double posZ, double motionX,
      double motionY, double motionZ) {

    this(world, posX, posY, posZ, motionX, motionY, motionZ, MAX_SCALE, MAX_AGE, 0.5f, 0.7f, 1.0f);
  }

  public ParticleFreezing(World world, double posX, double posY, double posZ, double motionX,
      double motionY, double motionZ, float scale, int maxAge, float red, float green, float blue) {

    super(world, posX, posY, posZ, 0, 0, 0);
    this.motionX = motionX;
    this.motionY = motionY;
    this.motionZ = motionZ;
    this.particleTextureIndexX = 7;
    this.particleTextureIndexY = 0; //11;
    this.particleRed = red;
    this.particleGreen = green;
    this.particleBlue = blue;
    this.particleScale = scale;
    this.particleMaxAge = maxAge;
    this.canCollide = false;
    //this.particleGravity = 0.05f;
    //this.particleAlpha = 0.9f;
  }

  @Override
public void onUpdate() {

    this.particleTextureIndexX = (int) (7 - 7 * particleAge / particleMaxAge);
    this.particleScale *= 0.95f;
    //this.particleAlpha -= 0.8f / (particleMaxAge * 1.25f);
  }

  @Override
  public void renderParticle(BufferBuilder buffer, Entity entityIn, float partialTicks,
      float rotationX, float rotationZ, float rotationYZ, float rotationXY, float rotationXZ) {

    float f = 1.5f * ((float)this.particleAge + partialTicks) / (float)this.particleMaxAge * 32.0F;
    f = MathHelper.clamp(f, 0.0F, 1.0F);
    this.particleScale = MAX_SCALE * f;
    super.renderParticle(buffer, entityIn, partialTicks, rotationX, rotationZ, rotationYZ, rotationXY, rotationXZ);
  }
}
package net.silentchaos512.gems.client.render.particle;

import net.minecraft.client.particle.Particle;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.MathHelper;
import net.minecraft.world.World;


public class ParticleShocking extends Particle {

  public static final int MAX_AGE = 10;
  public static final int MAX_SCALE = 1;
protected ParticleShocking(World world, double posX, double posY, double posZ) {
    this(world, posX, posY, posZ, 0, 0, 0, MAX_SCALE, MAX_AGE, 1.0f, 0.9f, 0.4f);
  }

  public ParticleShocking(World world, double posX, double posY, double posZ, double motionX,
      double motionY, double motionZ) {

    this(world, posX, posY, posZ, motionX, motionY, motionZ, MAX_SCALE, MAX_AGE, 1.0f, 0.9f, 0.4f);
  }

  public ParticleShocking(World world, double posX, double posY, double posZ, double motionX,
      double motionY, double motionZ, float scale, int maxAge, float red, float green, float blue) {

    super(world, posX, posY, posZ, 0, 0, 0);
    this.motionX = motionX;
public ParticleShocking(World world, double posX, double posY, double posZ, doub
    this.particleMaxAge = maxAge;
    this.canCollide = false;
    this.particleGravity = 0.5f;
    //this.particleAlpha = 0.9f;
  }

  @Override
public void onUpdate() {

    this.particleTextureIndexX = (int) (7 - 7 * particleAge / particleMaxAge);
    this.particleScale *= 0.95f;
    //this.particleAlpha -= 0.8f / (particleMaxAge * 1.25f);
  }

  @Override
  public void renderParticle(BufferBuilder buffer, Entity entityIn, float partialTicks,
      float rotationX, float rotationZ, float rotationYZ, float rotationXY, float rotationXZ) {

    float f = 1.5f * ((float)this.particleAge + partialTicks) / (float)this.particleMaxAge * 32.0F;
    f = MathHelper.clamp(f, 0.0F, 1.0F);
    this.particleScale = MAX_SCALE * f;
    super.renderParticle(buffer, entityIn, partialTicks, rotationX, rotationZ, rotationYZ, rotationXY, rotationXZ);
  }
}
package net.silentchaos512.gems.client.render.tile;

import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.item.ItemStack;
import net.minecraft.util.ResourceLocation;
import net.silentchaos512.gems.tile.TileChaosFlowerPot;
import net.silentchaos512.lib.client.render.tileentity.TileEntitySpecialRendererSL;
import net.silentchaos512.lib.util.StackHelper;

public RenderTileChaosFlowerPot() {
  public void clRender(TileChaosFlowerPot te, double x, double y, double z, float partialTicks, int destroyStage, float alpha) {

    Tessellator tess = Tessellator.getInstance();
    BufferBuilder buff = tess.getBuffer();

    ItemStack stack = te.getFlowerItemStack();
    if (StackHelper.isEmpty(stack) || stack.getItemDamage() < 0 || stack.getItemDamage() >= TEXTURES.length) {

import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.silentchaos512.gems.skills.SkillLumberjack;
import net.silentchaos512.gems.skills.ToolSkill;
import net.silentchaos512.gems.util.ToolHelper;
import net.silentchaos512.lib.util.LocalizationHelper;
import net.silentchaos512.lib.util.StackHelper;

public void onTooltip(ItemTooltipEvent event) {
    }
  }

  private void onTooltipForToolRod(ItemTooltipEvent event, ItemStack stack, ToolPart part,
      boolean ctrlDown, boolean shiftDown) {

    int index = 1;

private void onTooltipForToolRod(ItemTooltipEvent event, ItemStack stack, ToolPa
    }
  }

  private void onTooltipForToolMaterial(ItemTooltipEvent event, ItemStack stack, ToolPart part,
      boolean ctrlDown, boolean shiftDown) {

    int index = 1;
    final String sep = loc.getMiscText("Tooltip.Separator");
private void renderCrosshairs(RenderGameOverlayEvent event) {
   */
  private void renderArmorExtra(RenderGameOverlayEvent event) {

    if (!GemsConfig.SHOW_BONUS_ARMOR_BAR || !event.isCancelable()
        || event.getType() != ElementType.ARMOR)
      return;

    int width = event.getResolution().getScaledWidth();
private void doAmmoCountWithOffset(ItemStack tool, int width, int height, int xO
    }
  }

  public static void drawTexturedModalRect(int x, int y, int textureX, int textureY, int width,
      int height) {

    float f = 0.00390625F;
    float f1 = 0.00390625F;
    Tessellator tessellator = Tessellator.getInstance();
    BufferBuilder vertexbuffer = tessellator.getBuffer();
    vertexbuffer.begin(7, DefaultVertexFormats.POSITION_TEX);
    vertexbuffer.pos(x + 0, y + height, 0).tex((textureX + 0) * f, (textureY + height) * f1)
        .endVertex();
    vertexbuffer.pos(x + width, y + height, 0).tex((textureX + width) * f, (textureY + height) * f1)
        .endVertex();
    vertexbuffer.pos(x + width, y + 0, 0).tex((textureX + width) * f, (textureY + 0) * f1)
        .endVertex();
    vertexbuffer.pos(x + 0, y + 0, 0).tex((textureX + 0) * f, (textureY + 0) * f1).endVertex();
    tessellator.draw();
  }
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.gui.ScaledResolution;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.block.model.ItemCameraTransforms.TransformType;
import net.silentchaos512.gems.lib.ChaosBuff;
import net.silentchaos512.gems.lib.EnumGem;
import net.silentchaos512.gems.lib.Names;
import net.silentchaos512.lib.registry.RecipeMaker;
import net.silentchaos512.lib.util.ItemHelper;
import net.silentchaos512.lib.util.LocalizationHelper;
public static void renderGameOverlay(Minecraft mc) {
    private static void drawRect(float x, float y, float u, float v, float width, float height) {

      Tessellator tess = Tessellator.getInstance();
      BufferBuilder buff = tess.getBuffer();
      buff.begin(7, DefaultVertexFormats.POSITION_TEX);
      buff.pos(x, y + height, 0).tex(0, 1).endVertex();
      buff.pos(x + width, y + height, 0).tex(1, 1).endVertex();
#Sat Jul 08 13:42:44 CDT 2017
BUILD_NUM=205
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void deserialize(Map<String, Object> map) {

    public boolean isActive() {
        Location loc = new Location(Bukkit.getWorld(getWorld()), getX(), getY(), getZ());
        Block block = loc.getBlock();
        return block.isBlockIndirectlyPowered() || block.isBlockPowered();
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
protected void onCreate(@Nullable Bundle savedInstanceState) {
        timegapLabel = (TextView) findViewById(R.id.tv_timegap_label);
        playPauseButton = (ImageButton) findViewById(R.id.imageButton_play_pause_sensor);
        play = false;


        sensorDock.setVisibility(View.INVISIBLE);
        playPauseButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
public void onClick(View v) {
                }
            }
        });

        FragmentManager fragmentManager = getSupportFragmentManager();
        FragmentTransaction transaction = fragmentManager.beginTransaction();
package org.fossasia.pslab.sensorfragment;

import android.os.Bundle;
import android.support.annotation.Nullable;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentTransaction;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;

/**
 * Created by asitava on 13/7/17.

    private I2C i2c;
    private ScienceLab scienceLab;
    private HashMap<Integer, String> sensorAddr = new HashMap<>();
    private ArrayList<Integer> data = new ArrayList<>();
    private ArrayList<String> dataAddress = new ArrayList<>();
    private ArrayList<String> dataName = new ArrayList<>();
public static SensorFragmentMain newInstance() {
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        scienceLab = ScienceLabCommon.scienceLab;
        i2c = scienceLab.i2c;

        sensorAddr.put(0x60, "MCP4728");
        sensorAddr.put(0x48, "ADS1115");
        sensorAddr.put(0x23, "BH1750");
        sensorAddr.put(0x77, "BMP180");
        sensorAddr.put(0x5A, "MLX90614");
        sensorAddr.put(0x1E, "HMC5883L");
        sensorAddr.put(0x68, "MPU6050");
        sensorAddr.put(0x40, "SHT21");
        sensorAddr.put(0x39, "TSL2561");

        try {
            data = i2c.scan(null);
        } catch (IOException e) {
            e.printStackTrace();
        }
        if (data != null) {
            for (Integer myInt : data) {
                if (sensorAddr.get(myInt) != null) {
                    dataAddress.add(String.valueOf(myInt));
                    dataName.add(sensorAddr.get(myInt));
                }
            }
            for (String s : dataAddress) {
                tvData += s + ":" + sensorAddr.get(Integer.parseInt(s)) + "\n";
            }
        }
        String[] dataDisp = dataName.toArray(new String[dataName.size()]);
        adapter = new ArrayAdapter<>(getContext(), R.layout.sensor_list_item, R.id.tv_sensor_list_item, dataDisp);
    }

    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.sensor_main, container, false);

        Button buttonSensorAutoscan = (Button) view.findViewById(R.id.button_sensor_autoscan);
        tvSensorScan = (TextView) view.findViewById(R.id.tv_sensor_scan);
        tvSensorScan.setText(tvData);
        lvSensor = (ListView) view.findViewById(R.id.lv_sensor);
        lvSensor.setAdapter(adapter);

        buttonSensorAutoscan.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                if (scienceLab.isConnected()) {
public void onClick(View v) {

                    if (data != null) {
                        for (Integer myInt : data) {
                            if (myInt != null && sensorAddr.get(myInt) != null ) {
                                dataAddress.add(String.valueOf(myInt));
                                dataName.add(sensorAddr.get(myInt));
                            }
public void onClick(View v) {
                    String[] dataDisp = dataName.toArray(new String[dataName.size()]);
                    adapter = new ArrayAdapter<>(getContext(), R.layout.sensor_list_item, R.id.tv_sensor_list_item, dataDisp);
                    lvSensor.setAdapter(adapter);
                }
            }
        });
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:focusable="true"
    android:focusableInTouchMode="true"
    app:layout_behavior="@string/appbar_scrolling_view_behavior">
            android:layout_height="wrap_content"
            android:layout_alignParentTop="true"
            android:layout_marginLeft="5dp"
            android:layout_toEndOf="@+id/imageButton_play_pause_sensor"
            android:layout_toLeftOf="@+id/tv_timegap_label"
            android:layout_toRightOf="@+id/imageButton_play_pause_sensor"
<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginEnd="10dp"
        android:layout_marginLeft="10dp"
        android:layout_marginRight="10dp"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:background="@drawable/control_custom_border"
                android:textSize="@dimen/sensor_body_font"
                android:textAlignment="center"
                android:textStyle="bold"
                android:gravity="center"/>
        </android.support.v4.widget.NestedScrollView>

        <TextView
        <ListView
            android:id="@+id/lv_sensor"
            android:layout_width="match_parent"
            android:layout_height="200dp"
            android:layout_marginBottom="10dp"
            android:layout_marginTop="10dp" />
    </LinearLayout>
</ScrollView>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import static com.afollestad.aesthetic.Util.setLightStatusBarCompat;
import static com.afollestad.aesthetic.Util.setNavBarColorCompat;

/** @author Aidan Follestad (afollestad) */
@SuppressWarnings({"WeakerAccess", "unused"})
public class Aesthetic {

private static String key(@Nullable AppCompatActivity activity) {
    return key;
  }

  /** Should be called before super.onCreate() in each Activity. */
  @NonNull
  public static Aesthetic attach(@NonNull AppCompatActivity activity) {
    if (instance == null) {
public static Aesthetic get() {
    return instance;
  }

  /** Should be called in onPause() of each Activity. */
  public static void pause(@NonNull AppCompatActivity activity) {
    if (instance == null) {
      return;
public static void pause(@NonNull AppCompatActivity activity) {
    }
  }

  /** Should be called in onResume() of each Activity. */
  public static void resume(@NonNull AppCompatActivity activity) {
    if (instance == null) {
      return;
public void accept(@io.reactivex.annotations.NonNull Integer themeId) {
                onErrorLogAndRethrow()));
    instance.subs.add(
        Observable.combineLatest(
                instance.colorStatusBar(),
                instance.lightStatusBarMode(),
                new BiFunction<Integer, Integer, Pair<Integer, Integer>>() {
                  @Override
                  public Pair<Integer, Integer> apply(Integer integer, Integer integer2) {
                    return Pair.create(integer, integer2);
                  }
                })
            .compose(Rx.<Pair<Integer, Integer>>distinctToMainThread())
            .subscribe(
                new Consumer<Pair<Integer, Integer>>() {
private static void subscribeBackgroundListeners() {
    instance.backgroundSubscriptions = new CompositeDisposable();
    if (instance.backgroundSubscriberViews.size() > 0) {
      List<ViewObservablePair> pairs = instance.backgroundSubscriberViews.get(instance.context);
      for (ViewObservablePair pair : pairs) {
        instance.backgroundSubscriptions.add(
            pair.observable()
                .compose(Rx.<Integer>distinctToMainThread())
                .subscribeWith(ViewBackgroundSubscriber.create(pair.view())));
      }
    }
  }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.URISyntaxException;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.Vector;

public void installNewServer(String serverName, int heapInM, int debugPort) thro

    //Copy a cutom logback configuration
    Path serverPath = FileSystems.getDefault().getPath(installPath, "server", "lib", "logback-test.xml");
    Files.copy(this.getClass().getResourceAsStream("/logback-test.xml"), serverPath);

    // Create the object representing this single installation and add it to the list for this stripe.
    ServerInstallation installation = new ServerInstallation(this.interlock, this.stateManager, this.stripeVerboseManager, serverName, new File(installPath), heapInM, debugPort);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
protected void onPostExecute(Integer integer) {

            anim.fadeOut(R.id.layout_preset_store_download_installing, 100, 200, parentView, activity);
            anim.fadeIn(R.id.layout_preset_store_action_layout, 300, 200, "actionIn", parentView, activity);
            window.getProgressBar(R.id.layout_preset_store_download_progressbar, activity).setIndeterminate(true);
        }

        @Override
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import android.content.res.ColorStateList;
import android.content.res.Configuration;
import android.graphics.Color;
import android.graphics.drawable.ColorDrawable;
import android.os.Build;
import android.os.Bundle;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.design.widget.AppBarLayout;
import android.support.design.widget.CollapsingToolbarLayout;
import android.support.design.widget.NavigationView;
import android.support.v4.app.ActivityCompat;
import android.support.v4.app.Fragment;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.graphics.drawable.DrawerArrowDrawable;
import android.support.v7.widget.Toolbar;
import android.view.Menu;
import android.view.View;
import android.webkit.URLUtil;
import android.widget.ImageView;
import com.dm.wallpaper.board.services.WallpaperBoardService;
import com.dm.wallpaper.board.utils.Extras;
import com.dm.wallpaper.board.utils.ImageConfig;
import com.dm.wallpaper.board.utils.listeners.InAppBillingListener;
import com.dm.wallpaper.board.utils.listeners.SearchListener;
import com.dm.wallpaper.board.utils.listeners.WallpaperBoardListener;
    NavigationView mNavigationView;
    @BindView(R2.id.drawer_layout)
    DrawerLayout mDrawerLayout;

    private BillingProcessor mBillingProcessor;
    private ActionBarDrawerToggle mDrawerToggle;
public void initMainActivity(@Nullable Bundle savedInstanceState, boolean isLice
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_wallpaper_board);
        ButterKnife.bind(this);
        ViewHelper.setApplicationWindowColor(this);
        ViewHelper.resetNavigationBarTranslucent(this,
                getResources().getConfiguration().orientation);
        registerBroadcastReceiver();

        SoftKeyboardHelper softKeyboardHelper = new SoftKeyboardHelper(this,
public void initMainActivity(@Nullable Bundle savedInstanceState, boolean isLice
        mDonationProductsId = donationProductsId;

        Toolbar toolbar = ButterKnife.findById(this, R.id.toolbar);
        AppBarLayout appBar = ButterKnife.findById(this, R.id.appbar);
        toolbar.setTitle("");
        setSupportActionBar(toolbar);
        appBar.setExpanded(false);

        initNavigationView(toolbar);
        initNavigationViewHeader();
        initTheme();
        initInAppBilling();

        mPosition = mLastPosition = 0;
        if (savedInstanceState != null) {
            mPosition = mLastPosition = savedInstanceState.getInt("position", 0);
        }

        setFragment(getFragment(mPosition));
        checkWallpapers();

        if (Preferences.getPreferences(this).isFirstRun()) {
            if (isLicenseCheckerEnabled) {
                LicenseHelper.getLicenseChecker(this).checkLicense(mLicenseKey, salt);
                return;
            }
        }

        if (isLicenseCheckerEnabled) {
            if (!Preferences.getPreferences(this).isLicensed())
                finish();
        }
    }

protected void onDestroy() {
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        ViewHelper.disableAppBarDrag(ButterKnife.findById(this, R.id.appbar));
        return super.onCreateOptionsMenu(menu);
    }

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        resetNavigationView(newConfig.orientation);
public void onBackPressed() {
            mDrawerLayout.closeDrawers();
            return;
        }
        super.onBackPressed();
    }

public void onRequestPermissionsResult(int requestCode, @NonNull String[] permis
    }

    @Override
    public void OnWallpapersChecked(@Nullable Intent intent) {
        if (intent != null) {
            int size = intent.getIntExtra(Extras.EXTRA_SIZE, 0);
            Database database = new Database(this);
            int offlineSize = database.getWallpapersCount();
public void OnWallpapersChecked(@Nullable Intent intent) {
    }

    @Override
    public void OnInAppBillingInitialized(boolean success) {
        if (!success) mBillingProcessor = null;
    }

    @Override
    public void OnInAppBillingSelected(InAppBilling product) {
        if (mBillingProcessor == null) return;
        mBillingProcessor.purchase(this, product.getProductId());
    }

    @Override
    public void OnInAppBillingConsume(String productId) {
        if (mBillingProcessor == null) return;
        if (mBillingProcessor.consumePurchase(productId)) {
            new MaterialDialog.Builder(this)
public void OnInAppBillingConsume(String productId) {
    }

    @Override
    public void OnSearchExpanded(boolean expand) {
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        CollapsingToolbarLayout collapsingToolbar = (CollapsingToolbarLayout)
                findViewById(R.id.collapsing_toolbar);

        if (expand) {
            int color = ColorHelper.getAttributeColor(this, R.attr.search_toolbar_color);
            ViewHelper.changeSearchViewActionModeColor(this,
                    collapsingToolbar, R.attr.toolbar_color, R.attr.search_toolbar_color);
            ColorHelper.setStatusBarColor(this, color);

            int iconColor = ColorHelper.getAttributeColor(this, R.attr.search_toolbar_icon);
            toolbar.setNavigationIcon(DrawableHelper.getTintedDrawable(
                    this, R.drawable.ic_toolbar_back, iconColor));
            toolbar.setNavigationOnClickListener(view -> onBackPressed());
        } else {
            SoftKeyboardHelper.closeKeyboard(this);
            ColorHelper.setTransparentStatusBar(this, Color.TRANSPARENT);
            collapsingToolbar.setContentScrim(new ColorDrawable(
                    ColorHelper.getAttributeColor(this, R.attr.toolbar_color)));
            mDrawerToggle.setDrawerArrowDrawable(new DrawerArrowDrawable(this));
            toolbar.setNavigationOnClickListener(view ->
                    mDrawerLayout.openDrawer(GravityCompat.START));
public void onDrawerClosed(View drawerView) {
                getResources().getBoolean(R.bool.enable_donation));
        mNavigationView.setItemTextColor(colorStateList);
        mNavigationView.setItemIconTintList(colorStateList);
        mNavigationView.setNavigationItemSelectedListener(item -> {
            int id = item.getItemId();
            if (id == R.id.navigation_view_wallpapers) mPosition = 0;
public void onDrawerClosed(View drawerView) {
        });
    }

    private void initTheme() {
        getWindow().getDecorView().setBackgroundColor(
                ColorHelper.getAttributeColor(this, R.attr.main_background));
        ColorHelper.setStatusBarIconColor(this);
    }

    private void initNavigationViewHeader() {
        String imageUrl = getResources().getString(R.string.navigation_view_header);
        String titleText = getResources().getString(R.string.navigation_view_header_title);
private void initNavigationViewHeader() {
        }

        ImageLoader.getInstance().displayImage(imageUrl, new ImageViewAware(image),
                ImageConfig.getDefaultImageOptions(true), new ImageSize(720, 720), null, null);
    }

    private void initInAppBilling() {
private void checkWallpapers() {

        int size = Preferences.getPreferences(this).getAvailableWallpapersCount();
        if (size > 0) {
            OnWallpapersChecked(new Intent().putExtra(Extras.EXTRA_SIZE, size));
        }
    }

private void setFragment(Fragment fragment) {
        if (fragment == null) return;
        clearBackStack();

        FragmentTransaction ft = mFragManager.beginTransaction().replace(
                R.id.container, fragment, mFragmentTag);
        ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE);
        try {
            ft.commit();
        } catch (Exception e) {
private void resetToolbarLogo() {
    private void clearBackStack() {
        if (mFragManager.getBackStackEntryCount() > 0) {
            mFragManager.popBackStack(null, FragmentManager.POP_BACK_STACK_INCLUSIVE);
            OnSearchExpanded(false);
        }
    }
}
public void initMuzeiActivity(@Nullable Bundle savedInstanceState, @NonNull Clas
        ViewCompat.setNestedScrollingEnabled(mScrollView, false);
        ViewHelper.disableTranslucentNavigationBar(this);
        ColorHelper.setStatusBarColor(this,
                ColorHelper.getAttributeColor(this, R.attr.toolbar_color));
        ColorHelper.setStatusBarIconColor(this);
        ColorHelper.setNavigationBarColor(this, ColorHelper.getDarkerColor(
                ColorHelper.getAttributeColor(this, R.attr.colorAccent), 0.8f));
protected void attachBaseContext(Context newBase) {
    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        ViewHelper.resetNavigationBarBottomPadding(this, mScrollView,
                getResources().getConfiguration().orientation);
    }

    @Override
public void onClick(View view) {
    }

    @Override
    public void OnRefreshDurationSet(int rotateTime, boolean isMinute) {
        mRotateTime = rotateTime;
        mIsMinute = isMinute;
        initRefreshDuration();
import android.widget.TextView;

import com.danimahardhika.cafebar.CafeBar;
import com.dm.wallpaper.board.R;
import com.dm.wallpaper.board.R2;
import com.dm.wallpaper.board.adapters.WallpapersAdapter;
protected void onCreate(@Nullable Bundle savedInstanceState) {
        setContentView(R.layout.activity_wallpaper_preview);
        ButterKnife.bind(this);
        ViewHelper.setApplicationWindowColor(this);
        ViewHelper.resetNavigationBarTranslucent(this,
                getResources().getConfiguration().orientation);
        mIsEnter = true;

        Toolbar toolbar = ButterKnife.findById(this, R.id.toolbar);
        TextView toolbarTitle = ButterKnife.findById(this, R.id.toolbar_title);
        TextView toolbarSubTitle = ButterKnife.findById(this, R.id.toolbar_subtitle);
        ColorHelper.setTransparentStatusBar(this,
                ContextCompat.getColor(this, R.color.wallpaperStatusBar));
        mColor = ColorHelper.getAttributeColor(this, R.attr.colorAccent);
        mProgress.getIndeterminateDrawable().setColorFilter(mColor, PorterDuff.Mode.SRC_IN);

public void onTransitionStart(Transition transition) {
                    public void onTransitionEnd(Transition transition) {
                        if (mIsEnter) {
                            mIsEnter = false;
                            Animator.startSlideDownAnimation(WallpaperBoardPreviewActivity.this,
                                    toolbar, null);
                            loadWallpaper(mUrl);
                        }
                    }
public void onTransitionResume(Transition transition) {
    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        ViewHelper.resetNavigationBarTranslucent(this, newConfig.orientation);
    }

    @Override
public boolean onOptionsItemSelected(MenuItem item) {

                if (target.exists()) {
                    CafeBar.builder(this)
                            .to(findViewById(R.id.rootview))
                            .autoDismiss(false)
                            .swipeToDismiss(false)
                            .floating(true)
                            .maxLines(4)
                            .content(String.format(getResources().getString(R.string.wallpaper_download_exist),
                                    ("\"" +mName + FileHelper.IMAGE_EXTENSION+ "\"")))
                            .icon(R.drawable.ic_toolbar_download)
public void onLoadingFailed(String imageUri, View view, FailReason failReason) {

                int color = ColorHelper.getAttributeColor(
                        WallpaperBoardPreviewActivity.this, R.attr.main_background);
                FrameLayout container = (FrameLayout) findViewById(R.id.container);
                ObjectAnimator colorFade = ObjectAnimator.ofObject(
                        container, "backgroundColor", new ArgbEvaluator(),
                        Color.TRANSPARENT, color);
public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) {
                        int color = palette.getVibrantColor(accent);
                        mColor = color;
                        int text = ColorHelper.getTitleTextColor(color);
                        mFab.setBackgroundTintList(ColorHelper.getColorStateList(
                                android.R.attr.state_pressed,
                                color, ColorHelper.getDarkerColor(color, 0.9f)));
                        OnWallpaperLoaded(text);
                    });
                }

import android.content.Context;
import android.content.Intent;
import android.graphics.PorterDuff;
import android.os.AsyncTask;
import android.os.Bundle;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.v4.content.ContextCompat;
import android.support.v7.app.AppCompatActivity;
import android.util.Log;
import android.view.View;
import android.widget.ProgressBar;
import android.widget.TextView;

import com.dm.wallpaper.board.R;
import com.dm.wallpaper.board.R2;
import com.dm.wallpaper.board.helpers.ColorHelper;
import com.dm.wallpaper.board.utils.Extras;

import java.net.HttpURLConnection;
import java.net.URL;

import butterknife.BindView;
import butterknife.ButterKnife;
import uk.co.chrisjenx.calligraphy.CalligraphyContextWrapper;


public class WallpaperBoardSplashActivity extends AppCompatActivity {

    @BindView(R2.id.progress)
    ProgressBar mProgress;

    private Class<?> mMainActivity;
    private AsyncTask<Void, Void, Boolean> mCheckRszIo;

    @Deprecated
    public void initSplashActivity(@Nullable Bundle savedInstanceState, @NonNull Class<?> mainActivity, int duration) {
public void initSplashActivity(@Nullable Bundle savedInstanceState, @NonNull Cla
    public void initSplashActivity(@Nullable Bundle savedInstanceState, @NonNull Class<?> mainActivity) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_splash);
        ButterKnife.bind(this);
        mMainActivity = mainActivity;

        mProgress.getIndeterminateDrawable().setColorFilter(ColorHelper.getAttributeColor(
                this, R.attr.colorAccent), PorterDuff.Mode.SRC_IN);

        int color = ContextCompat.getColor(this, R.color.splashColor);
        int titleColor = ColorHelper.getTitleTextColor(color);
        TextView splashTitle = ButterKnife.findById(this, R.id.splash_title);
        splashTitle.setTextColor(ColorHelper.setColorAlpha(titleColor, 0.6f ));

        TextView splashLoading = ButterKnife.findById(this, R.id.splash_loading);
        splashLoading.setTextColor(titleColor);
        splashLoading.setText(String.format(
                getResources().getString(R.string.splash_screen_loading),
                getResources().getString(R.string.app_name)));

        checkRszIo();
    }

protected void attachBaseContext(Context newBase) {
    }

    @Override
    protected void onDestroy() {
        if (mCheckRszIo != null) mCheckRszIo.cancel(true);
        super.onDestroy();
    }

    private void checkRszIo() {
        mCheckRszIo = new AsyncTask<Void, Void, Boolean>() {

            final String rszio = "https://rsz.io/";

            @Override
            protected void onPreExecute() {
                super.onPreExecute();
                mProgress.setVisibility(View.VISIBLE);
            }

            @Override
            protected Boolean doInBackground(Void... voids) {
                while ((!isCancelled())) {
                    try {
protected Boolean doInBackground(Void... voids) {
                        int code = connection.getResponseCode();
                        return code == 200;
                    } catch (Exception e) {
                        Log.d(Extras.LOG_TAG, Log.getStackTraceString(e));
                        return false;
                    }
                }
protected Boolean doInBackground(Void... voids) {
            @Override
            protected void onPostExecute(Boolean aBoolean) {
                super.onPostExecute(aBoolean);
                WallpaperBoardActivity.sRszIoAvailable = aBoolean;
                Log.d(Extras.LOG_TAG, "rsz.io availability: " +WallpaperBoardActivity.sRszIoAvailable);
                mCheckRszIo = null;

                startActivity(new Intent(WallpaperBoardSplashActivity.this, mMainActivity));
                overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out);
                finish();
            }
        }.execute();
    }
}
import com.dm.wallpaper.board.R;
import com.dm.wallpaper.board.R2;
import com.dm.wallpaper.board.items.Credit;
import com.dm.wallpaper.board.utils.Extras;

import java.util.List;

public View getView(int position, View view, ViewGroup viewGroup) {
                try {
                    mContext.startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(link)));
                } catch (ActivityNotFoundException e) {
                    Log.d(Extras.LOG_TAG, Log.getStackTraceString(e));
                }
            }
        });
import android.widget.LinearLayout;
import android.widget.TextView;

import com.dm.wallpaper.board.R;
import com.dm.wallpaper.board.R2;
import com.dm.wallpaper.board.activities.WallpaperBoardPreviewActivity;
import com.dm.wallpaper.board.utils.Extras;
import com.dm.wallpaper.board.utils.ImageConfig;
import com.dm.wallpaper.board.utils.listeners.WallpaperListener;
import com.dm.wallpaper.board.utils.views.WallpaperView;
import com.kogitune.activitytransition.ActivityTransitionLauncher;
import com.nostra13.universalimageloader.core.DisplayImageOptions;
import com.nostra13.universalimageloader.core.ImageLoader;
public WallpapersAdapter(@NonNull Context context, @NonNull List<Wallpaper> wall
                mContext.getResources().getDimensionPixelSize(R.dimen.default_image_padding));
        mOptions = ImageConfig.getRawDefaultImageOptions();
        mOptions.resetViewBeforeLoading(true);
        mOptions.cacheInMemory(false);
        mOptions.cacheOnDisk(true);
        mOptions.showImageForEmptyUri(failed);
        mOptions.showImageOnFail(failed);
public int getItemCount() {
        @BindView(R2.id.container)
        LinearLayout container;
        @BindView(R2.id.image)
        WallpaperView image;
        @BindView(R2.id.name)
        TextView name;
        @BindView(R2.id.author)
public void onClick(View view) {
                                    fragment instanceof FavoritesFragment ||
                                    fragment instanceof WallpaperSearchFragment) {
                                WallpaperListener listener = (WallpaperListener) fragment;
                                listener.OnWallpaperSelected(position);
                            }
                        }
                    }
public void onClick(View view) {

                mWallpapers.get(position).setFavorite(!mWallpapers.get(position).isFavorite());
                setFavorite(favorite, name.getCurrentTextColor(), position);
            }
        }

import com.dm.wallpaper.board.R;
import com.dm.wallpaper.board.activities.WallpaperBoardCrashReport;
import com.dm.wallpaper.board.utils.ImageConfig;
import com.nostra13.universalimageloader.core.ImageLoader;

import java.text.SimpleDateFormat;
public void initApplication() {
                .setFontAttrId(R.attr.fontPath)
                .build());

        if (Patterns.EMAIL_ADDRESS.matcher(getResources().getString(R.string.dev_email)).matches()) {
            mHandler = Thread.getDefaultUncaughtExceptionHandler();
            Thread.setDefaultUncaughtExceptionHandler(this::handleUncaughtException);
package com.dm.wallpaper.board.fragments;

import android.content.ActivityNotFoundException;
import android.content.Intent;
import android.content.res.Configuration;
import android.graphics.Color;
import android.net.Uri;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.support.v4.app.Fragment;
import android.support.v4.view.ViewCompat;
import android.support.v4.widget.NestedScrollView;
import android.support.v7.widget.CardView;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.webkit.URLUtil;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;

import com.dm.wallpaper.board.R;
import com.dm.wallpaper.board.R2;
import com.dm.wallpaper.board.fragments.dialogs.CreditsFragment;
import com.dm.wallpaper.board.fragments.dialogs.LicensesFragment;
import com.dm.wallpaper.board.helpers.ColorHelper;
import com.dm.wallpaper.board.helpers.DrawableHelper;
import com.dm.wallpaper.board.helpers.ViewHelper;
import com.dm.wallpaper.board.utils.Extras;
import com.dm.wallpaper.board.utils.ImageConfig;
import com.mikhaellopez.circularimageview.CircularImageView;
import com.nostra13.universalimageloader.core.ImageLoader;

import org.sufficientlysecure.htmltextview.HtmlTextView;

import butterknife.BindView;
import butterknife.ButterKnife;
 * limitations under the License.
 */

public class AboutFragment extends Fragment implements View.OnClickListener {

    @BindView(R2.id.scrollview)
    NestedScrollView mScrollView;
    @BindView(R2.id.card_contributors)
    CardView mCardContributors;
    @BindView(R2.id.contributors)
    LinearLayout mContributors;
    @BindView(R2.id.contributors_icon)
    ImageView mContributorsIcon;
    @BindView(R2.id.licenses)
    LinearLayout mLicenses;
    @BindView(R2.id.licenses_icon)
    ImageView mLicensesIcon;
    @BindView(R2.id.image)
    ImageView mImageView;
    @BindView(R2.id.profile)
    CircularImageView mProfile;
    @BindView(R2.id.about_desc)
    HtmlTextView mAboutDesc;
    @BindView(R2.id.email)
    TextView mEmail;
    @BindView(R2.id.link1)
    TextView mLink1;
    @BindView(R2.id.link2)
    TextView mLink2;
    @BindView(R2.id.dev_google_plus)
    TextView mDevGooglePlus;
    @BindView(R2.id.dev_github)
    TextView mDevGitHub;

    @Nullable
    @Override
public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,
    @Override
    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        ViewCompat.setNestedScrollingEnabled(mScrollView, false);
        ViewHelper.resetNavigationBarBottomPadding(getActivity(), mScrollView,
                getActivity().getResources().getConfiguration().orientation);

        initImageHeader();
        initProfileImage();
        initAbout();

        int color = ColorHelper.getAttributeColor(getActivity(), android.R.attr.textColorPrimary);

        mLicensesIcon.setImageDrawable(DrawableHelper.getTintedDrawable(
                getActivity(), R.drawable.ic_toolbar_licenses, color));

        if (getActivity().getResources().getBoolean(R.bool.show_contributors_dialog)) {
            mContributorsIcon.setImageDrawable(DrawableHelper.getTintedDrawable(
                    getActivity(), R.drawable.ic_toolbar_people, color));
            mContributors.setOnClickListener(this);
            mCardContributors.setVisibility(View.VISIBLE);
        }

        mLicenses.setOnClickListener(this);

        mEmail.setOnClickListener(this);
        mLink1.setOnClickListener(this);
        mLink2.setOnClickListener(this);
        mDevGooglePlus.setOnClickListener(this);
        mDevGitHub.setOnClickListener(this);
    }

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        ViewHelper.resetNavigationBarBottomPadding(getActivity(), mScrollView,
                getActivity().getResources().getConfiguration().orientation);
    }

    @Override
    public void onClick(View view) {
        int id = view.getId();
        if (id == R.id.contributors) {
            CreditsFragment.showCreditsDialog(getActivity().getSupportFragmentManager(), Extras.TYPE_CONTRIBUTORS);
            return;
        } else if (id == R.id.licenses) {
            LicensesFragment.showLicensesDialog(getActivity().getSupportFragmentManager());
            return;
        }

        Intent intent = null;
        if (id == R.id.email) {
            try {
                final Intent email = new Intent(Intent.ACTION_SENDTO, Uri.fromParts(
                        "mailto", getActivity().getResources().getString(
                                R.string.about_email), null));
                email.putExtra(Intent.EXTRA_SUBJECT, (getActivity().getResources().getString(
                        R.string.app_name)));
                getActivity().startActivity(Intent.createChooser(email,
                        getActivity().getResources().getString(R.string.email_client)));
                return;
            }
            catch (ActivityNotFoundException e) {
                Log.d(Extras.LOG_TAG, Log.getStackTraceString(e));
            }
            return;
        } else if (id == R.id.link1) {
            intent = new Intent(Intent.ACTION_VIEW, Uri.parse(
                    getActivity().getResources().getString(R.string.about_link_1_url)));
        } else if (id == R.id.link2) {
            intent = new Intent(Intent.ACTION_VIEW, Uri.parse(
                    getActivity().getResources().getString(R.string.about_link_2_url)));
        } else if (id == R.id.dev_github) {
            intent = new Intent(Intent.ACTION_VIEW, Uri.parse(getActivity()
                    .getResources().getString(R.string.about_dashboard_dev_github_url)));
        } else if (id == R.id.dev_google_plus) {
            intent = new Intent(Intent.ACTION_VIEW, Uri.parse(getActivity()
                    .getResources().getString(R.string.about_dashboard_dev_google_plus_url)));
        }

        try {
            getActivity().startActivity(intent);
        } catch (NullPointerException | ActivityNotFoundException e) {
            Log.d(Extras.LOG_TAG, Log.getStackTraceString(e));
        }
    }

    private void initAbout() {
        String desc = getActivity().getResources().getString(R.string.about_desc);
        mAboutDesc.setHtml(desc);

        String email = getActivity().getResources().getString(R.string.about_email);
        if (email.length() == 0) mEmail.setVisibility(View.GONE);
        String link2 = getActivity().getResources().getString(R.string.about_link_2_url);
        if (link2.length() == 0) mLink2.setVisibility(View.GONE);
    }

    private void initImageHeader() {
        String url = getActivity().getString(R.string.about_image);
        if (ColorHelper.isValidColor(url)) {
            mImageView.setBackgroundColor(Color.parseColor(url));
            return;
        }

        if (!URLUtil.isValidUrl(url)) {
            url = "drawable://" + DrawableHelper.getResourceId(getActivity(), url);
        }

        ImageLoader.getInstance().displayImage(url, mImageView,
                ImageConfig.getDefaultImageOptions(true));
    }

    private void initProfileImage() {
        String url = getActivity().getResources().getString(R.string.about_profile_image);
        if (!URLUtil.isValidUrl(url)) {
            url = "drawable://" + DrawableHelper.getResourceId(getActivity(), url);
        }

        ImageLoader.getInstance().displayImage(url, mProfile,
                ImageConfig.getDefaultImageOptions(true));
    }
}
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.support.v4.app.Fragment;
import android.support.v4.view.ViewCompat;
import android.support.v4.widget.SwipeRefreshLayout;
import android.support.v7.widget.DefaultItemAnimator;
import android.support.v7.widget.GridLayoutManager;
import com.dm.wallpaper.board.databases.Database;
import com.dm.wallpaper.board.helpers.ViewHelper;
import com.dm.wallpaper.board.items.Wallpaper;
import com.dm.wallpaper.board.utils.Extras;
import com.dm.wallpaper.board.utils.listeners.WallpaperListener;
import com.pluscubed.recyclerfastscroll.RecyclerFastScroller;

import java.util.ArrayList;
import java.util.List;

    @BindView(R2.id.recyclerview)
    RecyclerView mRecyclerView;
    @BindView(R2.id.fastscroll)
    RecyclerFastScroller mFastScroll;
    @BindView(R2.id.swipe)
    SwipeRefreshLayout mSwipe;

public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,
    @Override
    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        ViewCompat.setNestedScrollingEnabled(mRecyclerView, false);
        ViewHelper.resetNavigationBarBottomPadding(getActivity(), mRecyclerView,
                getActivity().getResources().getConfiguration().orientation);
        mSwipe.setEnabled(false);

        mRecyclerView.setItemAnimator(new DefaultItemAnimator());
        mRecyclerView.setLayoutManager(new GridLayoutManager(getActivity(),
                getActivity().getResources().getInteger(R.integer.column_num)));
        mRecyclerView.setHasFixedSize(false);
        mFastScroll.attachRecyclerView(mRecyclerView);

        getWallpapers();
    }
public void onActivityCreated(@Nullable Bundle savedInstanceState) {
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        ViewHelper.resetSpanCount(getActivity(), mRecyclerView);
        ViewHelper.resetNavigationBarBottomPadding(getActivity(), mRecyclerView, newConfig.orientation);
    }

    @Override
public void onDestroy() {
    }

    @Override
    public void OnWallpaperSelected(int position) {
        if (mRecyclerView == null) return;
        if (position < 0 || position > mRecyclerView.getAdapter().getItemCount()) return;

protected Boolean doInBackground(Void... voids) {
                        wallpapers = database.getFavoriteWallpapers();
                        return true;
                    } catch (Exception e) {
                        Log.d(Extras.LOG_TAG, Log.getStackTraceString(e));
                        return false;
                    }
                }
import android.support.annotation.Nullable;
import android.support.v4.app.Fragment;
import android.support.v4.view.ViewCompat;
import android.support.v4.widget.NestedScrollView;
import android.support.v7.widget.AppCompatCheckBox;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.Toast;

import com.afollestad.materialdialogs.MaterialDialog;
import com.dm.wallpaper.board.R;
import com.dm.wallpaper.board.R2;
import com.dm.wallpaper.board.helpers.ViewHelper;
import com.dm.wallpaper.board.preferences.Preferences;
import com.dm.wallpaper.board.utils.Extras;

import java.io.File;
import java.text.DecimalFormat;
import java.text.NumberFormat;

import butterknife.BindView;
import butterknife.ButterKnife;
 * limitations under the License.
 */

public class SettingsFragment extends Fragment implements View.OnClickListener {

    @BindView(R2.id.pref_cache_clear)
    LinearLayout mCacheClear;
    @BindView(R2.id.pref_cache_size)
    TextView mCacheSize;
    @BindView(R2.id.pref_dark_theme)
    LinearLayout mDarkTheme;
    @BindView(R2.id.pref_dark_theme_check)
    AppCompatCheckBox mDarkThemeCheck;
    @BindView(R2.id.pref_walls_directory)
    TextView mWallsDirectory;
    @BindView(R2.id.scrollview)
    NestedScrollView mScrollView;

    private File mCache;

    @Nullable
    @Override
public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,
    @Override
    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        ViewCompat.setNestedScrollingEnabled(mScrollView, false);
        ViewHelper.resetNavigationBarBottomPadding(getActivity(), mScrollView,
                getActivity().getResources().getConfiguration().orientation);
        mCacheClear.setOnClickListener(this);
        mDarkTheme.setOnClickListener(this);

        if (Preferences.getPreferences(getActivity()).getWallsDirectory().length() > 0) {
            String directory = Preferences.getPreferences(
                    getActivity()).getWallsDirectory() + File.separator;
            mWallsDirectory.setText(directory);
        }

        initSettings();
    }

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        ViewHelper.resetNavigationBarBottomPadding(getActivity(), mScrollView,
                getActivity().getResources().getConfiguration().orientation);
    }

    @Override
    public void onClick(View view) {
        int id = view.getId();
        if (id == R.id.pref_cache_clear) {
            new MaterialDialog.Builder(getActivity())
                    .title(R.string.pref_data_cache)
                    .content(R.string.pref_data_cache_clear_dialog)
                    .positiveText(R.string.clear)
                    .negativeText(android.R.string.cancel)
                    .onPositive((dialog, which) -> {
                        try {
                            clearCache(mCache);
                            initSettings();

                            Toast.makeText(getActivity(), getActivity()
                                            .getResources().getString(
                                            R.string.pref_data_cache_cleared),
                                    Toast.LENGTH_LONG).show();
                        } catch (Exception e) {
                            Log.d(Extras.LOG_TAG, Log.getStackTraceString(e));
                        }
                    })
                    .show();
        } else if (id == R.id.pref_dark_theme) {
            Preferences.getPreferences(getActivity()).setDarkTheme(!mDarkThemeCheck.isChecked());
            mDarkThemeCheck.setChecked(!mDarkThemeCheck.isChecked());
            getActivity().recreate();
        }
    }

    private void initSettings() {
        mCache = new File(getActivity().getCacheDir().toString());

        double cache = (double) cacheSize(mCache)/1024/1024;
        NumberFormat formatter = new DecimalFormat("#0.00");
        String cacheSize = getActivity().getResources().getString(
                R.string.pref_data_cache_size)
                +" "+ (formatter.format(cache)) + " MB";

        mCacheSize.setText(cacheSize);
        mDarkThemeCheck.setChecked(Preferences.getPreferences(getActivity()).isDarkTheme());
    }

    private void clearCache(File fileOrDirectory) {
        if (fileOrDirectory.isDirectory())
            for (File child : fileOrDirectory.listFiles())
                clearCache(child);
        fileOrDirectory.delete();
    }

    private long cacheSize(File dir) {
        if (dir.exists()) {
            long result = 0;
            File[] fileList = dir.listFiles();
            for (File aFileList : fileList) {
                if (aFileList.isDirectory()) {
                    result += cacheSize(aFileList);
                } else {
                    result += aFileList.length();
                }
            }
            return result;
        }
        return 0;
    }
}
import com.dm.wallpaper.board.helpers.SoftKeyboardHelper;
import com.dm.wallpaper.board.helpers.ViewHelper;
import com.dm.wallpaper.board.items.Wallpaper;
import com.dm.wallpaper.board.utils.Extras;
import com.dm.wallpaper.board.utils.listeners.WallpaperListener;
import com.pluscubed.recyclerfastscroll.RecyclerFastScroller;

import java.util.ArrayList;
import java.util.List;

    @BindView(R2.id.recyclerview)
    RecyclerView mRecyclerView;
    @BindView(R2.id.fastscroll)
    RecyclerFastScroller mFastScroll;
    @BindView(R2.id.swipe)
    SwipeRefreshLayout mSwipe;
    @BindView(R2.id.search_result)
public void onActivityCreated(@Nullable Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        setHasOptionsMenu(true);
        ViewCompat.setNestedScrollingEnabled(mRecyclerView, false);
        ViewHelper.resetNavigationBarBottomPadding(getActivity(), mRecyclerView,
                getActivity().getResources().getConfiguration().orientation);
        mSwipe.setEnabled(false);

        mRecyclerView.setItemAnimator(new DefaultItemAnimator());
        mRecyclerView.setLayoutManager(new GridLayoutManager(getActivity(),
                getActivity().getResources().getInteger(R.integer.column_num)));
        mRecyclerView.setHasFixedSize(false);
        mFastScroll.attachRecyclerView(mRecyclerView);

        getWallpapers();
    }
public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
        super.onCreateOptionsMenu(menu, inflater);
        inflater.inflate(R.menu.menu_wallpaper_search, menu);
        MenuItem search = menu.findItem(R.id.menu_search);
        int color = ColorHelper.getAttributeColor(getActivity(), R.attr.search_toolbar_icon);
        search.setIcon(DrawableHelper.getTintedDrawable(getActivity(),
                R.drawable.ic_toolbar_search, color));

public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
        mSearchView.clearFocus();

        ViewHelper.changeSearchViewTextColor(mSearchView, color,
                ColorHelper.getAttributeColor(getActivity(), R.attr.search_toolbar_hint));
        View view = mSearchView.findViewById(android.support.v7.appcompat.R.id.search_plate);
        if (view != null) view.setBackgroundColor(Color.TRANSPARENT);

public boolean onQueryTextSubmit(String string) {
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        ViewHelper.resetSpanCount(getActivity(), mRecyclerView);
        ViewHelper.resetNavigationBarBottomPadding(getActivity(), mRecyclerView, newConfig.orientation);
    }

    @Override
public void onDestroy() {
    }

    @Override
    public void OnWallpaperSelected(int position) {
        if (mAdapter == null) return;
        if (position < 0 || position > mAdapter.getItemCount()) return;

private void filterSearch(String query) {
            }
            else mSearchResult.setVisibility(View.GONE);
        } catch (Exception e) {
            Log.d(Extras.LOG_TAG, Log.getStackTraceString(e));
        }
    }

protected Boolean doInBackground(Void... voids) {
                        wallpapers = database.getFilteredWallpapers();
                        return true;
                    } catch (Exception e) {
                        Log.d(Extras.LOG_TAG, Log.getStackTraceString(e));
                        return false;
                    }
                }
import android.support.v4.app.FragmentTransaction;
import android.support.v4.content.ContextCompat;
import android.support.v4.view.MenuItemCompat;
import android.support.v4.view.ViewCompat;
import android.support.v4.widget.SwipeRefreshLayout;
import android.support.v7.widget.DefaultItemAnimator;
import android.support.v7.widget.GridLayoutManager;
import com.dm.wallpaper.board.utils.Animator;
import com.dm.wallpaper.board.utils.Extras;
import com.dm.wallpaper.board.utils.ListUtils;
import com.dm.wallpaper.board.utils.listeners.SearchListener;
import com.dm.wallpaper.board.utils.listeners.WallpaperBoardListener;
import com.dm.wallpaper.board.utils.listeners.WallpaperListener;
import com.pluscubed.recyclerfastscroll.RecyclerFastScroller;
import com.rafakob.drawme.DrawMeButton;

import java.io.InputStream;

    @BindView(R2.id.recyclerview)
    RecyclerView mRecyclerView;
    @BindView(R2.id.fastscroll)
    RecyclerFastScroller mFastScroll;
    @BindView(R2.id.swipe)
    SwipeRefreshLayout mSwipe;
    @BindView(R2.id.progress)
public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,
    @Override
    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        ViewCompat.setNestedScrollingEnabled(mRecyclerView, false);
        ViewHelper.resetNavigationBarBottomPadding(getActivity(), mRecyclerView,
                getActivity().getResources().getConfiguration().orientation);

        mProgress.getIndeterminateDrawable().setColorFilter(ColorHelper.getAttributeColor(
                getActivity(), R.attr.colorAccent), PorterDuff.Mode.SRC_IN);

        mRecyclerView.setItemAnimator(new DefaultItemAnimator());
        mRecyclerView.setLayoutManager(new GridLayoutManager(getActivity(),
                getActivity().getResources().getInteger(R.integer.column_num)));
        mRecyclerView.setHasFixedSize(false);
        mFastScroll.attachRecyclerView(mRecyclerView);

        mSwipe.setColorSchemeColors(ColorHelper.getAttributeColor(
                getActivity(), R.attr.colorAccent));
public void onActivityCreated(@Nullable Bundle savedInstanceState) {
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        ViewHelper.resetSpanCount(getActivity(), mRecyclerView);
        ViewHelper.resetNavigationBarBottomPadding(getActivity(), mRecyclerView, newConfig.orientation);
    }

    @Override
public boolean onMenuItemActionExpand(MenuItem item) {

                setHasOptionsMenu(false);
                SearchListener listener = (SearchListener) getActivity();
                listener.OnSearchExpanded(true);

                FragmentTransaction ft = fm.beginTransaction()
                        .replace(R.id.container, new WallpaperSearchFragment(),
public void onDestroy() {
    }

    @Override
    public void OnWallpaperSelected(int position) {
        if (mAdapter == null) return;
        if (position < 0 || position > mAdapter.getItemCount()) return;

public void initPopupBubble() {
                Animator.startAlphaAnimation(getActivity().findViewById(R.id.popup_bubble), 200, View.GONE);
                getWallpapers(true);
            });
            Animator.startSlideDownAnimation(getActivity(), popupBubble, null);
        }
    }

protected Boolean doInBackground(Void... voids) {
                        }
                        return false;
                    } catch (Exception e) {
                        Log.d(Extras.LOG_TAG, Log.getStackTraceString(e));
                        return false;
                    }
                }
protected void onPostExecute(Boolean aBoolean) {
                    mRecyclerView.setAdapter(mAdapter);

                    WallpaperBoardListener listener = (WallpaperBoardListener) getActivity();
                    listener.OnWallpapersChecked(new Intent().putExtra(Extras.EXTRA_SIZE,
                            Preferences.getPreferences(getActivity()).getAvailableWallpapersCount()));
                } else {
                    Toast.makeText(getActivity(), R.string.connection_failed, Toast.LENGTH_LONG).show();
import com.dm.wallpaper.board.adapters.CreditsAdapter;
import com.dm.wallpaper.board.items.Credit;
import com.dm.wallpaper.board.utils.Extras;
import org.xmlpull.v1.XmlPullParser;

import java.util.ArrayList;

public class CreditsFragment extends DialogFragment {

    private static final String TAG = "com.field.guide.dialog.credits";

    private static CreditsFragment newInstance(int type) {
public static void showCreditsDialog(FragmentManager fm, int type) {
        } catch (IllegalStateException | IllegalArgumentException ignored) {}
    }

    @BindView(R2.id.listview)
    ListView mListView;

    private int mType;

    private AsyncTask<Void, Void, Boolean> mGetCredits;

    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
protected Boolean doInBackground(Void... voids) {
                        }
                        return true;
                    } catch (Exception e) {
                        Log.d(Extras.LOG_TAG, Log.getStackTraceString(e));
                        return false;
                    }
                }
protected void onPostExecute(Boolean aBoolean) {
            }
        }.execute();
    }

}

public class FilterFragment extends DialogFragment {

    private boolean mIsMuzei;

    private static final String MUZEI = "muzei";
public static void showFilterDialog(FragmentManager fm, boolean isMuzei) {
        } catch (IllegalArgumentException | IllegalStateException ignored) {}
    }

    @BindView(R2.id.listview)
    ListView listView;

    @NonNull
    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
public void onActivityCreated(Bundle savedInstanceState) {

    @Override
    public void onDismiss(DialogInterface dialog) {
        FragmentManager fm = getActivity().getSupportFragmentManager();
        if (fm == null) return;

import com.anjlab.android.iab.v3.BillingProcessor;
import com.anjlab.android.iab.v3.SkuDetails;
import com.dm.wallpaper.board.R;
import com.dm.wallpaper.board.adapters.InAppBillingAdapter;
import com.dm.wallpaper.board.items.InAppBilling;
import com.dm.wallpaper.board.utils.Extras;
import com.dm.wallpaper.board.utils.listeners.InAppBillingListener;

/*
 * Wallpaper Board
 *

public class InAppBillingFragment extends DialogFragment {

    private static BillingProcessor mBillingProcessor;

    private static final String TAG = "com.dm.wallpaper.board.dialog.inappbilling";
public static void showInAppBillingDialog(@NonNull FragmentManager fm, BillingPr
        } catch (IllegalArgumentException | IllegalStateException ignored) {}
    }

    private ListView mInAppList;
    private ProgressBar mProgress;

    private String mKey;
    private String[] mProductsId;

    private InAppBillingAdapter mAdapter;
    private AsyncTask<Void, Void, Boolean> mLoadInAppProducts;

    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
public Dialog onCreateDialog(Bundle savedInstanceState) {
                    if (mLoadInAppProducts == null) {
                        try {
                            InAppBillingListener listener = (InAppBillingListener) getActivity();
                            listener.OnInAppBillingSelected(mAdapter.getSelectedProduct());
                        } catch (Exception ignored) {}
                        dismiss();
                    }
public Dialog onCreateDialog(Bundle savedInstanceState) {
        dialog.show();
        setCancelable(false);

        mInAppList = (ListView) dialog.findViewById(R.id.inapp_list);
        mProgress = (ProgressBar) dialog.findViewById(R.id.progress);
        return dialog;
    }

protected Boolean doInBackground(Void... voids) {
                        }
                        return true;
                    } catch (Exception e) {
                        Log.d(Extras.LOG_TAG, Log.getStackTraceString(e));
                        return false;
                    }
                }
protected void onPostExecute(Boolean aBoolean) {
                mProgress.setVisibility(View.GONE);
                if (aBoolean) {
                    mAdapter = new InAppBillingAdapter(getActivity(), inAppBillings);
                    mInAppList.setAdapter(mAdapter);
                } else {
                    dismiss();
                    if (!isBillingNotReady)
protected void onPostExecute(Boolean aBoolean) {

        }.execute();
    }

}

import com.afollestad.materialdialogs.MaterialDialog;
import com.dm.wallpaper.board.R;
import com.dm.wallpaper.board.utils.Extras;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;

import butterknife.ButterKnife;

/*

public class LicensesFragment extends DialogFragment {

    private static final String TAG = "com.dm.wallpaper.board.dialog.licenses";

    private static LicensesFragment newInstance() {
public static void showLicensesDialog(FragmentManager fm) {
        } catch (IllegalStateException | IllegalArgumentException ignored) {}
    }

    private WebView mWebView;

    private AsyncTask<Void, Void, Boolean> mLoadLicenses;

    @NonNull
    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
public Dialog onCreateDialog(Bundle savedInstanceState) {
        MaterialDialog dialog = builder.build();
        dialog.show();

        mWebView = ButterKnife.findById(dialog, R.id.webview);
        return dialog;
    }

protected Boolean doInBackground(Void... voids) {
                        bufferedReader.close();
                        return true;
                    } catch (Exception e) {
                        Log.d(Extras.LOG_TAG, Log.getStackTraceString(e));
                        return false;
                    }
                }
protected void onPostExecute(Boolean aBoolean) {

        }.execute();
    }

}


import com.dm.wallpaper.board.R2;
import com.dm.wallpaper.board.helpers.ColorHelper;
import com.dm.wallpaper.board.helpers.DrawableHelper;
import com.dm.wallpaper.board.utils.Extras;
import com.dm.wallpaper.board.utils.listeners.RefreshDurationListener;

import butterknife.BindView;

public class RefreshDurationFragment extends DialogFragment implements View.OnClickListener {

    private static final String MINUTE = "minute";
    private static final String ROTATE_TIME = "rotate_time";
    private static final String TAG = "com.dm.wallpaper.board.dialog.refresh.duration";
public static void showRefreshDurationDialog(FragmentManager fm, int rotateTime,
        } catch (IllegalStateException | IllegalArgumentException ignored) {}
    }

    @BindView(R2.id.number_picker)
    NumberPicker mNumberPicker;
    @BindView(R2.id.minute)
    AppCompatRadioButton mMinute;
    @BindView(R2.id.hour)
    AppCompatRadioButton mHour;

    private int mRotateTime;
    private boolean mIsMinute;

    @NonNull
    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
public void onActivityCreated(Bundle savedInstanceState) {
    @Override
    public void onDismiss(DialogInterface dialog) {
        RefreshDurationListener listener = (RefreshDurationListener) getActivity();
        listener.OnRefreshDurationSet(mNumberPicker.getValue(), mMinute.isChecked());
        super.onDismiss(dialog);
    }

private void setDividerColor (NumberPicker picker) {
                    pf.set(picker, DrawableHelper.getTintedDrawable(
                            getActivity(), R.drawable.numberpicker_divider, color));
                } catch (Exception e) {
                    Log.d(Extras.LOG_TAG, Log.getStackTraceString(e));
                }
                break;
            }

import com.afollestad.materialdialogs.MaterialDialog;
import com.danimahardhika.cafebar.CafeBar;
import com.dm.wallpaper.board.R;
import com.dm.wallpaper.board.helpers.ColorHelper;
import com.dm.wallpaper.board.helpers.DrawableHelper;
import com.dm.wallpaper.board.helpers.FileHelper;

import java.io.File;

/*
 * Wallpaper Board
 *

public class WallpaperOptionsFragment extends DialogFragment implements View.OnClickListener {

    private static final String TAG = "com.dm.wallpaper.board.dialog.wallpaper.options";

    private static WallpaperOptionsFragment newInstance(String url, String name) {
public static void showWallpaperOptionsDialog(FragmentManager fm, String url, St
        } catch (IllegalArgumentException | IllegalStateException ignored) {}
    }

    private LinearLayout mApply;
    private LinearLayout mSave;
    private ImageView mApplyIcon;
    private ImageView mSaveIcon;

    private String mName;
    private String mUrl;

    @NonNull
    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
public Dialog onCreateDialog(Bundle savedInstanceState) {
        MaterialDialog dialog = builder.build();
        dialog.show();

        mApply = (LinearLayout) dialog.findViewById(R.id.apply);
        mSave = (LinearLayout) dialog.findViewById(R.id.save);
        mApplyIcon = (ImageView) dialog.findViewById(R.id.apply_icon);
        mSaveIcon = (ImageView) dialog.findViewById(R.id.save_icon);
        return dialog;
    }

public void onClick(View view) {
                if (target.exists()) {
                    Context context = getActivity();
                    CafeBar.builder(getActivity())
                            .autoDismiss(false)
                            .swipeToDismiss(false)
                            .floating(true)
                            .fitSystemWindow(true)
                            .maxLines(4)
                            .content(String.format(getResources().getString(R.string.wallpaper_download_exist),
                                    ("\"" +mName + FileHelper.IMAGE_EXTENSION+ "\"")))

import com.afollestad.materialdialogs.MaterialDialog;
import com.dm.wallpaper.board.R;
import com.dm.wallpaper.board.preferences.Preferences;

/*
 * Wallpaper Board
 *

public class WallpaperSettingsFragment extends DialogFragment implements View.OnClickListener {

    private static final String TAG = "com.dm.wallpaper.board.dialog.wallpaper.settings";

    private static WallpaperSettingsFragment newInstance() {
        return new WallpaperSettingsFragment();
    }
public static void showWallpaperSettings(FragmentManager fm) {
        } catch (IllegalStateException | IllegalArgumentException ignored) {}
    }

    private AppCompatRadioButton mEnableScrollRadio;
    private AppCompatRadioButton mDisableScrollRadio;
    private LinearLayout mEnableScroll;
    private LinearLayout mDisableScroll;

    @NonNull
    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
public Dialog onCreateDialog(Bundle savedInstanceState) {
        MaterialDialog dialog = builder.build();
        dialog.show();

        mEnableScrollRadio = (AppCompatRadioButton) dialog.findViewById(R.id.enable_scroll_radio);
        mDisableScrollRadio = (AppCompatRadioButton) dialog.findViewById(R.id.disable_scroll_radio);
        mEnableScroll = (LinearLayout) dialog.findViewById(R.id.enable_scroll);
        mDisableScroll = (LinearLayout) dialog.findViewById(R.id.disable_scroll);
        return dialog;
    }

private void toggleRadio() {
        mEnableScrollRadio.setChecked(scroll);
        mDisableScrollRadio.setChecked(!scroll);
    }

}
public static int setColorAlpha(@ColorInt int color, float alpha) {
        return Color.argb(alpha2, red, green, blue);
    }

    public static ColorStateList getColorStateList(int attr, @ColorInt int color, @ColorInt int color2) {
        int[][] states = new int[][] {
                new int[] {attr},
                new int[] {}
        };
        int[] colors = new int[] {
                color,
                color2
        };
        return new ColorStateList(states, colors);
    }

    private static boolean isLightToolbar(@NonNull Context context) {
        int color = getAttributeColor(context, R.attr.toolbar_color);
        int red = Color.red(color);
        int green = Color.green(color);
        int blue = Color.blue(color);

import com.dm.wallpaper.board.BuildConfig;
import com.dm.wallpaper.board.R;
import com.dm.wallpaper.board.utils.Extras;

import java.io.BufferedWriter;
import java.io.File;
public static String buildCrashLog(@NonNull Context context, @NonNull File folde

            return fileDir.toString();
        } catch (Exception | OutOfMemoryError e) {
            Log.d(Extras.LOG_TAG, Log.getStackTraceString(e));
        }
        return null;
    }
public static String getDeviceInfoForCrashReport(@NonNull Context context) {
                "\nApp Name : " +context.getResources().getString(R.string.app_name)
                + "\n"+ getDeviceInfo(context);
    }

}
public static Drawable getTintedDrawable(@NonNull Context context, @DrawableRes
            return null;
        }
    }

}
import android.support.v4.content.FileProvider;
import android.util.Log;

import com.dm.wallpaper.board.utils.Extras;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
public class FileHelper {

    public static final String IMAGE_EXTENSION = ".jpeg";

    static boolean copyFile(@NonNull File file, @NonNull File target) {
        try {
static boolean copyFile(@NonNull File file, @NonNull File target) {
            outputStream.close();
            return true;
        } catch (Exception e) {
            Log.d(Extras.LOG_TAG, Log.getStackTraceString(e));
        }
        return false;
    }
public static Uri getUriFromFile(Context context, String applicationId, File fil
        try {
            return FileProvider.getUriForFile(context, applicationId + ".fileProvider", file);
        } catch (IllegalArgumentException e) {
            Log.d(Extras.LOG_TAG, Log.getStackTraceString(e));
        }
        return null;
    }
public InAppBillingHelper(@NonNull Context context) {
    @Override
    public void onProductPurchased(String productId, TransactionDetails details) {
        InAppBillingListener listener = (InAppBillingListener) mContext;
        listener.OnInAppBillingConsume(productId);
    }

    @Override
public void onPurchaseHistoryRestored() {
    public void onBillingError(int errorCode, Throwable error) {
        if (errorCode == Constants.BILLING_ERROR_FAILED_TO_INITIALIZE_PURCHASE) {
            InAppBillingListener listener = (InAppBillingListener) mContext;
            listener.OnInAppBillingInitialized(false);
        }
    }

    @Override
    public void onBillingInitialized() {
        InAppBillingListener listener = (InAppBillingListener) mContext;
        listener.OnInAppBillingInitialized(true);
    }
}
import android.provider.Settings.Secure;
import android.support.annotation.NonNull;
import android.support.v7.app.AppCompatActivity;
import android.util.Log;
import android.widget.Toast;

import com.afollestad.materialdialogs.MaterialDialog;
import com.dm.wallpaper.board.R;
import com.dm.wallpaper.board.preferences.Preferences;
import com.dm.wallpaper.board.utils.Extras;
import com.google.android.vending.licensing.AESObfuscator;
import com.google.android.vending.licensing.LicenseChecker;
import com.google.android.vending.licensing.LicenseCheckerCallback;
    private final Context mContext;
    private MaterialDialog mDialog;

    public static LicenseHelper getLicenseChecker(@NonNull Context context) {
        return new LicenseHelper(context);
    }
public void checkLicense(String licenseKey, byte[] salt) {
            checker.checkAccess(this);
            getDialog().show();
        } else {
            Log.d(Extras.LOG_TAG, "Unable to check license, random bytes is wrong!");
        }
    }

private void showLicenseDialog(int reason) {
                .content(message)
                .positiveText(R.string.close)
                .onPositive((dialog, which) -> {
                    OnLicenseChecked(reason);
                    dialog.dismiss();
                })
                .cancelable(false)
private void showRetryDialog() {
                .show();
    }

    private void OnLicenseChecked(int reason) {
        Preferences.getPreferences(mContext).setFirstRun(false);
        if (reason == Policy.LICENSED) {
            Preferences.getPreferences(mContext).setLicensed(true);
private int getRandomInt(int size) {
            return 0;
        }
    }

}
public static void requestStoragePermission(@NonNull Context context) {
    public static void showPermissionStorageDenied(@NonNull Context context) {
        Toast.makeText(context, R.string.permission_storage_denied, Toast.LENGTH_LONG).show();
    }

}
public static void openKeyboard(@NonNull Context context) {
        }
    }

/*
     * This code was taken from https://github.com/mikepenz/MaterialDrawer/issues/95#issuecomment-80519589
     */

import android.content.Context;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.graphics.Point;
import android.graphics.drawable.ColorDrawable;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.TransitionDrawable;
import android.os.Build;
import android.support.annotation.AttrRes;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.design.widget.AppBarLayout;
import android.support.design.widget.CollapsingToolbarLayout;
import android.support.design.widget.CoordinatorLayout;
import android.support.v4.view.ViewCompat;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.GridLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.util.Log;
import android.util.TypedValue;
import android.view.Display;
import android.widget.TextView;

import com.dm.wallpaper.board.R;
import com.dm.wallpaper.board.utils.Extras;
import com.nostra13.universalimageloader.core.ImageLoader;

/*

public class ViewHelper {

    public static void resetSpanCount(@NonNull Context context, @NonNull RecyclerView recyclerView) {
        try {
            GridLayoutManager manager = (GridLayoutManager) recyclerView.getLayoutManager();
            manager.setSpanCount(context.getResources().getInteger(R.integer.column_num));
            manager.requestLayout();
        } catch (Exception e) {
            Log.d(Extras.LOG_TAG, Log.getStackTraceString(e));
        }
    }

public static void disableTranslucentNavigationBar(@NonNull Context context) {
        }
    }

    public static void resetNavigationBarBottomPadding(@NonNull Context context, @Nullable View view,
                                                       int orientation) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            if (view != null) {
                int left = view.getPaddingLeft();
                int right = view.getPaddingRight();
                int bottom = view.getPaddingBottom();
                int top = view.getPaddingTop();
                int navBar = getNavigationBarHeight(context);

                if (bottom > navBar) bottom -= navBar;
                boolean tabletMode = context.getResources().getBoolean(R.bool.tablet_mode);

                if (tabletMode || orientation == Configuration.ORIENTATION_PORTRAIT) {
                    view.setPadding(left, top, right, (bottom + navBar));
                    return;
                }

                view.setPadding(left, top, right, bottom);
            }
        }
    }

    public static void disableAppBarDrag(@Nullable AppBarLayout appBar) {
        if (appBar != null) {
            if (ViewCompat.isLaidOut(appBar)) {
                CoordinatorLayout.LayoutParams params = (CoordinatorLayout.LayoutParams)
                        appBar.getLayoutParams();
                AppBarLayout.Behavior behavior = (AppBarLayout.Behavior) params.getBehavior();
                if (behavior != null) {
                    behavior.setDragCallback(new AppBarLayout.Behavior.DragCallback() {
                        @Override
                        public boolean canDrag(@NonNull AppBarLayout appBarLayout) {
                            return false;
                        }
                    });
                }
            }
        }
    }

    public static int getStatusBarHeight(@NonNull Context context) {
public static void setApplicationWindowColor(@NonNull Context context) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            TypedValue typedValue = new TypedValue();
            Resources.Theme theme = context.getTheme();
            theme.resolveAttribute(R.attr.toolbar_color, typedValue, true);
            Bitmap bitmap = ImageLoader.getInstance().loadImageSync("drawable://"
                    +DrawableHelper.getResourceId(context, "icon"));
            ((AppCompatActivity) context).setTaskDescription(new ActivityManager.TaskDescription (
public static void removeSearchViewSearchIcon(@Nullable View view) {
            }
        }
    }

    public static void changeSearchViewActionModeColor(@NonNull Context context, @Nullable View view,
                                                       @AttrRes int original, @AttrRes int target) {
        if (view != null) {
            CollapsingToolbarLayout collapsingToolbar = (CollapsingToolbarLayout) view;
            int originalColor = ColorHelper.getAttributeColor(context, original);
            int targetColor = ColorHelper.getAttributeColor(context, target);

            ColorDrawable cd1 = new ColorDrawable(originalColor);
            ColorDrawable cd2 = new ColorDrawable(targetColor);

            TransitionDrawable td = new TransitionDrawable(new Drawable[]{cd1, cd2});
            collapsingToolbar.setContentScrim(td);
            td.startTransition(200);
        }
    }

}
import android.support.v7.app.AppCompatActivity;
import android.util.Log;
import android.view.View;
import android.widget.Toast;

import com.afollestad.materialdialogs.MaterialDialog;
import com.danimahardhika.cafebar.CafeBar;
import com.danimahardhika.cafebar.CafeBarDuration;
import com.dm.wallpaper.board.R;
import com.dm.wallpaper.board.activities.WallpaperBoardActivity;
import com.dm.wallpaper.board.preferences.Preferences;
import com.dm.wallpaper.board.utils.Extras;
import com.dm.wallpaper.board.utils.ImageConfig;
import com.nostra13.universalimageloader.core.ImageLoader;
import com.nostra13.universalimageloader.core.assist.FailReason;
import com.nostra13.universalimageloader.core.assist.ImageSize;
protected Boolean doInBackground(Void... voids) {
                            return true;
                        }
                    } catch (Exception e) {
                        Log.d(Extras.LOG_TAG, Log.getStackTraceString(e));
                        return false;
                    }
                }
protected void onPostExecute(Boolean aBoolean) {
                super.onPostExecute(aBoolean);
                dialog.dismiss();
                if (aBoolean) {
                    if (Preferences.getPreferences(context).getWallsDirectory().length() == 0)
                        Preferences.getPreferences(context).setWallsDirectory(output.toString());

                    context.sendBroadcast(new Intent(
                            Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.fromFile(
                            new File(file.toString()))));
protected void onPostExecute(Boolean aBoolean) {
        }.execute();
    }

    private static void wallpaperSaved(@NonNull Context context, @ColorInt int color, @NonNull File file) {
        String downloaded = context.getResources().getString(
                R.string.wallpaper_downloaded);
        View rootView = ((AppCompatActivity) context).getWindow().getDecorView().findViewById(R.id.rootview);

        CafeBar.Builder builder = new CafeBar.Builder(context);
        builder.to(rootView)
                .duration(CafeBarDuration.LONG.getDuration())
                .maxLines(4)
                .floating(true)
                .swipeToDismiss(false)
                .content(downloaded + " " + file.toString())
                .icon(R.drawable.ic_toolbar_download)
                .neutralText(R.string.open)
private static void wallpaperSaved(@NonNull Context context, @ColorInt int color
                    cafeBar.dismiss();
                });

        if (rootView == null) {
            builder.fitSystemWindow(true);
        }

        CafeBar cafeBar = builder.build();
public static void applyWallpaper(@NonNull Context context, @Nullable RectF rect
        String imageUri = getWallpaperUri(context, url, name + FileHelper.IMAGE_EXTENSION);

        ImageSize imageSize = getScaledSize(context, url);
        loadBitmap(context, dialog, 1, imageUri, rectF, imageSize.getWidth(), imageSize.getHeight());
    }

    private static void loadBitmap(Context context, MaterialDialog dialog, int call, String imageUri,
                                   RectF rectF, int width, int height) {
        final AsyncTask<Bitmap, Void, Boolean> setWallpaper = getWallpaperAsync(
                context, dialog, rectF, width, height);

        dialog.setOnDismissListener(dialogInterface -> {
            ImageLoader.getInstance().stop();
            setWallpaper.cancel(true);
        });

        ImageLoader.getInstance().handleSlowNetwork(true);
        ImageLoader.getInstance().loadImage(imageUri, new ImageSize(width, height),
                ImageConfig.getWallpaperOptions(), new ImageLoadingListener() {

                    @Override
public void onLoadingFailed(String imageUri, View view, FailReason failReason) {
                        if (failReason.getType() == FailReason.FailType.OUT_OF_MEMORY) {
                            if (call <= 5) {
                                double scaleFactor = 1 - (0.1 * call);
                                int scaledWidth = Double.valueOf(width * scaleFactor).intValue();
                                int scaledHeight = Double.valueOf(height * scaleFactor).intValue();

                                RectF scaledRecF = getScaledRectF(rectF, (float) scaleFactor);
                                loadBitmap(context, dialog, (call + 1), imageUri, scaledRecF, scaledWidth, scaledHeight);
                                return;
                            }
                        }
public void onLoadingCancelled(String imageUri, View view) {
    }

    private static AsyncTask<Bitmap, Void, Boolean> getWallpaperAsync(@NonNull Context context, MaterialDialog dialog,
                                                                      RectF rectF, int width, int height) {
        return new AsyncTask<Bitmap, Void, Boolean>() {

            @Override
protected Boolean doInBackground(Bitmap... bitmaps) {
                            Bitmap bitmap = bitmaps[0];

                            if (!Preferences.getPreferences(context).isScrollWallpaper() && rectF != null) {
                                bitmap = Bitmap.createBitmap(width, height, bitmaps[0].getConfig());
                                Paint paint = new Paint();
                                paint.setFilterBitmap(true);
                                paint.setAntiAlias(true);
                                paint.setDither(true);
                                Canvas canvas = new Canvas(bitmap);
                                canvas.drawBitmap(bitmaps[0], null, rectF, paint);
                            }
protected Boolean doInBackground(Bitmap... bitmaps) {
                        }
                        return false;
                    } catch (Exception | OutOfMemoryError e) {
                        Log.d(Extras.LOG_TAG, Log.getStackTraceString(e));
                        return false;
                    }
                }
protected void onPostExecute(Boolean aBoolean) {
                super.onPostExecute(aBoolean);
                dialog.dismiss();
                if (aBoolean) {
                    Toast.makeText(context, R.string.wallpaper_applied,
                            Toast.LENGTH_LONG).show();
                } else {
                    Toast.makeText(context, R.string.wallpaper_apply_failed,
                            Toast.LENGTH_LONG).show();
@JsonObject
public class WallpaperJson {

    @JsonField(name = "name")
    public String name;

    @JsonField(name = "author")
    public String author;

    @JsonField(name = "url")
    public String url;

    @JsonField(name = "thumbUrl")
    public String thumbUrl;

    @JsonField(name = "category")
    public String category;

    @JsonField(name = "Wallpapers")
package com.dm.wallpaper.board.preferences;

/*
 * Wallpaper Board
 *
 * limitations under the License.
 */

import android.content.Context;
import android.support.annotation.NonNull;

import com.dm.wallpaper.board.helpers.PreferencesHelper;

public class Preferences {

    public static PreferencesHelper getPreferences(@NonNull Context context) {
        return new PreferencesHelper(context);
    }

}
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;

import com.dm.wallpaper.board.utils.listeners.WallpaperBoardListener;

/*

    @Override
    public void onReceive(Context context, Intent intent) {
        WallpaperBoardListener listener = (WallpaperBoardListener) context;
        listener.OnWallpapersChecked(intent);
    }
}
import com.dm.wallpaper.board.items.WallpaperJson;
import com.dm.wallpaper.board.receivers.WallpaperBoardReceiver;
import com.dm.wallpaper.board.utils.Extras;

import java.io.InputStream;
import java.net.HttpURLConnection;
protected void onHandleIntent(Intent intent) {
                if (wallpapersJson == null) return;

                int size = wallpapersJson.getWallpapers.size();
                broadcastIntent.putExtra(Extras.EXTRA_SIZE, size);
                sendBroadcast(broadcastIntent);
            }
        } catch (Exception e) {
            Log.d(Extras.LOG_TAG, Log.getStackTraceString(e));
        }
    }
}
import android.view.animation.AnimationUtils;

import com.dm.wallpaper.board.R;

/*
 * Wallpaper Board
public static void startAlphaAnimation(@Nullable View view, long duration, int v
        view.startAnimation(alphaAnimation);
    }

    public static void startSlideDownAnimation(@NonNull Context context, @NonNull View view, @Nullable View view2) {
        Animation slideDown = AnimationUtils.loadAnimation(context, R.anim.slide_down_from_top);
        slideDown.setAnimationListener(new Animation.AnimationListener() {
            @Override
            public void onAnimationStart(Animation animation) {

            }

            @Override
            public void onAnimationEnd(Animation animation) {
                if (view2 != null) startAlphaAnimation(view2, 200, View.VISIBLE);
            }

            @Override
            public void onAnimationRepeat(Animation animation) {

            }
        });
        view.startAnimation(slideDown);
        view.setVisibility(View.VISIBLE);
    }

    public static void showFab(@Nullable FloatingActionButton fab) {
public static void showFab(@Nullable FloatingActionButton fab) {
        fab.animate().setDuration(200).scaleX(1).scaleY(1).alpha(1)
                .setInterpolator(new LinearOutSlowInInterpolator());
    }

}
    public static final String EXTRA_NAME = "name";
    public static final String EXTRA_AUTHOR = "author";
    public static final String EXTRA_IMAGE = "image";
    public static final String EXTRA_SIZE = "size";
    public static final String EXTRA_KEY = "key";
    public static final String EXTRA_PRODUCT_ID = "productId";
    public static final String EXTRA_TYPE = "type";

    public static final int TYPE_CONTRIBUTORS = 1;

    public static final String LOG_TAG = "WallpaperBoard";

}
import android.support.annotation.NonNull;

import com.dm.wallpaper.board.R;
import com.nostra13.universalimageloader.cache.disc.impl.UnlimitedDiskCache;
import com.nostra13.universalimageloader.core.DisplayImageOptions;
import com.nostra13.universalimageloader.core.ImageLoaderConfiguration;
public static ImageLoaderConfiguration getImageLoaderConfiguration(@NonNull Cont
        L.writeLogs(false);
        L.writeDebugLogs(false);
        return new ImageLoaderConfiguration.Builder(context)
                .diskCacheSize(200 * 1024 * 1024)
                .threadPriority(Thread.NORM_PRIORITY - 2)
                .threadPoolSize(4)
                .tasksProcessingOrder(QueueProcessingType.FIFO)
                .diskCache(new UnlimitedDiskCache(new File(
                        context.getCacheDir().toString() + "/uil-images")))
                .build();
    }

    public static DisplayImageOptions getDefaultImageOptions(boolean cacheOnDisk) {
        DisplayImageOptions.Builder options = new DisplayImageOptions.Builder();
        options.delayBeforeLoading(10)
                .resetViewBeforeLoading(true)
                .bitmapConfig(Bitmap.Config.RGB_565)
                .imageScaleType(ImageScaleType.EXACTLY)
                .displayer(new FadeInBitmapDisplayer(700))
                .cacheOnDisk(cacheOnDisk)
                .cacheInMemory(false);
        return options.build();
    }
public static ImageSize getThumbnailSize(@NonNull Context context) {
        if (quality <= 0) quality = 1;
        return new ImageSize((50 * quality), (50 * quality));
    }

}


public interface InAppBillingListener {

    void OnInAppBillingSelected(InAppBilling product);
    void OnInAppBillingInitialized(boolean success);
    void OnInAppBillingConsume(String productId);

}

public interface RefreshDurationListener {

    void OnRefreshDurationSet(int rotateTime, boolean isMinute);

}

public interface SearchListener {

    void OnSearchExpanded(boolean expand);

}

public interface WallpaperBoardListener {

    void OnWallpapersChecked(@Nullable Intent intent);

}

public interface WallpaperListener {

    void OnWallpaperSelected(int position);

}
        android:viewportHeight="24.0">
    <path
        android:fillColor="#FF000000"
        android:pathData="M21,19V5c0,-1.1 -0.9,-2 -2,-2H5c-1.1,0 -2,0.9 -2,2v14c0,1.1 0.9,2 2,2h14c1.1,0 2,-0.9 2,-2zM8.5,13.5l2.5,3.01L14.5,12l4.5,6H5l3.5,-4.5z"/>
</vector>
        android:viewportWidth="24.0"
        android:viewportHeight="24.0">
    <path
        android:fillColor="?attr/search_toolbar_icon"
        android:pathData="M19,6.41L17.59,5 12,10.59 6.41,5 5,6.41 10.59,12 5,17.59 6.41,19 12,13.41 17.59,19 19,17.59 13.41,12z"/>
</vector>
        android:layout_width="match_parent"
        android:layout_height="?attr/actionBarSize"
        android:minHeight="?attr/actionBarSize"
        android:background="?attr/toolbar_color"
        app:theme="@style/ToolbarStyle">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="match_parent"
            android:gravity="center_vertical"
            android:textColor="?attr/toolbar_icon"
            android:singleLine="true"
            android:ellipsize="end"
            android:text="@string/muzei_settings"
            android:textSize="@dimen/text_toolbar_title"
        android:id="@+id/muzei_save"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:padding="@dimen/card_padding"
        android:orientation="horizontal"
        android:layout_alignParentBottom="true"
        android:gravity="center"
    android:layout_height="match_parent"
    android:fitsSystemWindows="true">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:gravity="center"
        android:layout_centerInParent="true">

        <ImageView
            android:layout_width="@dimen/splash_screen_logo"
            android:layout_height="@dimen/splash_screen_logo"
            android:src="@drawable/ic_splash_screen" />

        <LinearLayout
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_vertical"
            android:layout_marginTop="@dimen/card_padding">

            <ProgressBar
                android:id="@+id/progress"
                android:layout_width="28dp"
                android:layout_height="28dp"
                android:visibility="invisible"
                style="?android:attr/progressBarStyle"/>

            <TextView
                android:id="@+id/splash_loading"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginLeft="@dimen/card_padding"
                android:layout_marginStart="@dimen/card_padding"
                android:textSize="@dimen/text_content"
                android:textColor="?android:attr/textColorPrimary"
                fontPath="fonts/Font-Regular.ttf"/>

        </LinearLayout>

    </LinearLayout>

    <TextView
        android:id="@+id/splash_title"
    android:id="@+id/drawer_layout"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:fitsSystemWindows="true"
    tools:openDrawer="start">

    <include layout="@layout/toolbar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"/>

    <android.support.design.widget.NavigationView
        android:id="@+id/navigation_view"
        android:layout_width="@dimen/navigation_view_width"
        android:layout_height="match_parent"
        android:layout_gravity="start"
        android:fitsSystemWindows="true"
        android:background="?attr/main_background"
        android:theme="@style/NavigationViewStyle"
        app:headerLayout="@layout/navigation_view_header"
        app:itemIconTint="@color/navigation_view_item_highlight"
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    tools:ignore="MissingPrefix"
    android:id="@+id/container"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

        android:layout_height="match_parent"
        android:fitsSystemWindows="true">

        <android.support.design.widget.CoordinatorLayout
            android:id="@+id/rootview"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:fitsSystemWindows="true">

            <android.support.design.widget.FloatingActionButton
                android:id="@+id/fab"
                android:layout_width="@dimen/fab_size"
                android:layout_height="@dimen/fab_size"
                android:layout_gravity="bottom|end"
                android:layout_marginRight="20dp"
                android:layout_marginEnd="20dp"
                android:layout_marginBottom="20dp"
                android:visibility="gone"
                app:backgroundTint="?attr/colorAccent" />

        </android.support.design.widget.CoordinatorLayout>

        <android.support.v7.widget.Toolbar
            android:id="@+id/toolbar"
            android:layout_width="match_parent"
            <LinearLayout
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:paddingTop="@dimen/card_padding"
                android:paddingBottom="@dimen/card_padding"
                android:orientation="vertical">

                <TextView
                    android:layout_height="wrap_content"
                    android:gravity="center_vertical"
                    android:textColor="@android:color/white"
                    android:singleLine="true"
                    android:ellipsize="end"
                    android:textSize="@dimen/text_toolbar_title"
                    fontPath="fonts/Font-Medium.ttf"/>

                <TextView
                    android:layout_height="wrap_content"
                    android:gravity="center_vertical"
                    android:textColor="@android:color/white"
                    android:singleLine="true"
                    android:ellipsize="end"
                    android:textSize="@dimen/text_content_title"
                    fontPath="fonts/Font-Regular.ttf"/>

            </LinearLayout>
        android:visibility="gone"
        style="?android:attr/progressBarStyleLarge"/>

</FrameLayout>
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    tools:ignore="MissingPrefix"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <android.support.v4.widget.NestedScrollView
        android:id="@+id/scrollview"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:clipToPadding="false">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="@dimen/content_padding"
            android:clipToPadding="false">

            <android.support.v7.widget.CardView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                app:cardBackgroundColor="?attr/card_background"
                app:cardElevation="@dimen/card_elevation"
                app:cardUseCompatPadding="true"
                app:cardCornerRadius="@dimen/card_corner_radius">

                <RelativeLayout
                    android:layout_width="match_parent"
                    android:layout_height="match_parent">

                    <ImageView
                        android:id="@+id/image"
                        android:layout_width="match_parent"
                        android:layout_height="@dimen/about_image_height"
                        android:scaleType="centerCrop" />

                    <com.mikhaellopez.circularimageview.CircularImageView
                        android:id="@+id/profile"
                        android:layout_width="@dimen/about_profile"
                        android:layout_height="@dimen/about_profile"
                        android:layout_alignBottom="@+id/image"
                        android:layout_marginBottom="-44dp"
                        android:layout_centerHorizontal="true"
                        app:civ_border_color="?attr/card_background"
                        app:civ_border_width="4dp"
                        app:civ_shadow="true"
                        app:civ_shadow_radius="10"
                        app:civ_shadow_color="#22000000"/>

                    <LinearLayout
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:orientation="vertical"
                        android:layout_below="@+id/image"
                        android:layout_marginTop="44dp">

                        <TextView
                            android:layout_width="match_parent"
                            android:layout_height="wrap_content"
                            android:layout_marginLeft="@dimen/card_padding"
                            android:layout_marginStart="@dimen/card_padding"
                            android:layout_marginRight="@dimen/card_padding"
                            android:layout_marginEnd="@dimen/card_padding"
                            android:gravity="center"
                            android:text="@string/about_title"
                            android:textColor="?android:attr/textColorPrimary"
                            android:textSize="@dimen/text_content_title"
                            fontPath="fonts/Font-Medium.ttf"/>

                        <org.sufficientlysecure.htmltextview.HtmlTextView
                            android:id="@+id/about_desc"
                            android:layout_width="match_parent"
                            android:layout_height="wrap_content"
                            android:layout_marginLeft="@dimen/card_padding"
                            android:layout_marginStart="@dimen/card_padding"
                            android:layout_marginRight="@dimen/card_padding"
                            android:layout_marginEnd="@dimen/card_padding"
                            android:layout_marginTop="2dp"
                            android:gravity="center"
                            android:textColor="?android:attr/textColorSecondary"
                            android:textSize="@dimen/text_content"
                            fontPath="fonts/Font-Regular.ttf"/>

                        <LinearLayout
                            android:layout_width="match_parent"
                            android:layout_height="wrap_content"
                            android:orientation="horizontal"
                            android:baselineAligned="false"
                            android:paddingLeft="@dimen/card_padding"
                            android:paddingStart="@dimen/card_padding"
                            android:paddingRight="@dimen/card_padding"
                            android:paddingEnd="@dimen/card_padding"
                            android:paddingTop="10dp"
                            android:paddingBottom="@dimen/card_padding"
                            android:gravity="end">

                            <TextView
                                android:id="@+id/email"
                                android:layout_width="wrap_content"
                                android:layout_height="wrap_content"
                                android:textAllCaps="true"
                                android:padding="@dimen/button_padding"
                                android:gravity="center"
                                android:text="@string/about_email_title"
                                android:textSize="@dimen/text_content"
                                android:textColor="?attr/colorAccent"
                                android:singleLine="true"
                                android:ellipsize="end"
                                android:background="?attr/selectableItemBackground"
                                android:theme="@style/AccentButtonStyle"
                                fontPath="fonts/Font-Medium.ttf"/>

                            <TextView
                                android:id="@+id/link1"
                                android:layout_width="wrap_content"
                                android:layout_height="wrap_content"
                                android:textAllCaps="true"
                                android:padding="@dimen/button_padding"
                                android:gravity="center"
                                android:text="@string/about_link_1_title"
                                android:textSize="@dimen/text_content"
                                android:textColor="?attr/colorAccent"
                                android:singleLine="true"
                                android:ellipsize="end"
                                android:background="?attr/selectableItemBackground"
                                android:theme="@style/AccentButtonStyle"
                                fontPath="fonts/Font-Medium.ttf"/>

                            <TextView
                                android:id="@+id/link2"
                                android:layout_width="wrap_content"
                                android:layout_height="wrap_content"
                                android:textAllCaps="true"
                                android:padding="@dimen/button_padding"
                                android:gravity="center"
                                android:text="@string/about_link_2_title"
                                android:textSize="@dimen/text_content"
                                android:textColor="?attr/colorAccent"
                                android:singleLine="true"
                                android:ellipsize="end"
                                android:background="?attr/selectableItemBackground"
                                android:theme="@style/AccentButtonStyle"
                                fontPath="fonts/Font-Medium.ttf"/>

                        </LinearLayout>

                    </LinearLayout>

                </RelativeLayout>

            </android.support.v7.widget.CardView>

            <android.support.v7.widget.CardView
                android:id="@+id/card_contributors"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:visibility="gone"
                app:cardBackgroundColor="?attr/card_background"
                app:cardElevation="@dimen/card_elevation"
                app:cardUseCompatPadding="true"
                app:cardCornerRadius="@dimen/card_corner_radius">

                <LinearLayout
                    android:id="@+id/contributors"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="horizontal"
                    android:gravity="center_vertical"
                    android:padding="@dimen/card_padding"
                    android:background="?attr/selectableItemBackground"
                    android:theme="@style/ButtonStyle">

                    <ImageView
                        android:id="@+id/contributors_icon"
                        android:layout_width="28dp"
                        android:layout_height="28dp"
                        android:layout_marginRight="@dimen/card_padding"
                        android:layout_marginEnd="@dimen/card_padding"/>

                    <TextView
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:text="@string/about_contributors_title"
                        android:textSize="@dimen/text_content_title"
                        android:textColor="?android:attr/textColorPrimary"
                        android:gravity="center_vertical"
                        fontPath="fonts/Font-Regular.ttf"/>

                </LinearLayout>

            </android.support.v7.widget.CardView>

            <android.support.v7.widget.CardView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                app:cardBackgroundColor="?attr/card_background"
                app:cardElevation="@dimen/card_elevation"
                app:cardUseCompatPadding="true"
                app:cardCornerRadius="@dimen/card_corner_radius">

                <LinearLayout
                    android:id="@+id/licenses"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="horizontal"
                    android:gravity="center_vertical"
                    android:padding="@dimen/card_padding"
                    android:background="?attr/selectableItemBackground"
                    android:theme="@style/ButtonStyle">

                    <ImageView
                        android:id="@+id/licenses_icon"
                        android:layout_width="28dp"
                        android:layout_height="28dp"
                        android:layout_marginRight="@dimen/card_padding"
                        android:layout_marginEnd="@dimen/card_padding"/>

                    <TextView
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:text="@string/about_open_source_licenses"
                        android:textSize="@dimen/text_content_title"
                        android:textColor="?android:attr/textColorPrimary"
                        android:gravity="center_vertical"
                        fontPath="fonts/Font-Regular.ttf"/>

                </LinearLayout>

            </android.support.v7.widget.CardView>

            <android.support.v7.widget.CardView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                app:cardBackgroundColor="?attr/card_background"
                app:cardElevation="@dimen/card_elevation"
                app:cardUseCompatPadding="true"
                app:cardCornerRadius="@dimen/card_corner_radius">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:padding="@dimen/card_padding">

                    <TextView
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:text="@string/about_dashboard"
                        android:textSize="@dimen/text_content_title"
                        android:textColor="?android:attr/textColorPrimary"
                        fontPath="fonts/Font-Medium.ttf"/>

                    <TextView
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:layout_marginTop="6dp"
                        android:text="@string/about_dashboard_dev"
                        android:textSize="@dimen/text_content"
                        android:textColor="?android:attr/textColorPrimary"
                        fontPath="fonts/Font-Regular.ttf"/>

                    <LinearLayout
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:orientation="horizontal"
                        android:paddingTop="10dp"
                        android:gravity="end">

                        <TextView
                            android:id="@+id/dev_google_plus"
                            android:layout_width="wrap_content"
                            android:layout_height="wrap_content"
                            android:textAllCaps="true"
                            android:padding="@dimen/button_padding"
                            android:gravity="center"
                            android:text="@string/about_dashboard_dev_google_plus_title"
                            android:textSize="@dimen/text_content"
                            android:textColor="?attr/colorAccent"
                            android:singleLine="true"
                            android:ellipsize="end"
                            android:background="?attr/selectableItemBackground"
                            android:theme="@style/AccentButtonStyle"
                            fontPath="fonts/Font-Medium.ttf"/>

                        <TextView
                            android:id="@+id/dev_github"
                            android:layout_width="wrap_content"
                            android:layout_height="wrap_content"
                            android:textAllCaps="true"
                            android:padding="@dimen/button_padding"
                            android:gravity="center"
                            android:text="@string/about_dashboard_dev_github_title"
                            android:textSize="@dimen/text_content"
                            android:textColor="?attr/colorAccent"
                            android:singleLine="true"
                            android:ellipsize="end"
                            android:background="?attr/selectableItemBackground"
                            android:theme="@style/AccentButtonStyle"
                            fontPath="fonts/Font-Medium.ttf"/>

                    </LinearLayout>

                </LinearLayout>

            </android.support.v7.widget.CardView>

        </LinearLayout>

    </android.support.v4.widget.NestedScrollView>

    <View
        android:layout_width="match_parent"
<LinearLayout
    android:id="@+id/container"
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    tools:ignore="MissingPrefix"
    android:layout_height="wrap_content"
    android:layout_width="match_parent"
    android:orientation="vertical"
    android:padding="@dimen/card_padding"
    android:gravity="center_vertical"
    android:background="?attr/selectableItemBackground"
    app:theme="@style/ButtonStyle">

    <TextView
        android:id="@+id/title"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:paddingLeft="@dimen/card_padding"
        android:paddingStart="@dimen/card_padding"
        android:paddingRight="@dimen/card_padding"
        android:paddingEnd="@dimen/card_padding"
        android:textColor="?android:attr/textColorPrimary"
        android:textSize="@dimen/text_content_subtitle"
        fontPath="fonts/Font-Regular.ttf"/>
        android:id="@+id/subtitle"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:paddingLeft="@dimen/card_padding"
        android:paddingStart="@dimen/card_padding"
        android:paddingRight="@dimen/card_padding"
        android:paddingEnd="@dimen/card_padding"
        android:textColor="?android:attr/textColorSecondary"
        android:textSize="@dimen/text_content"
        fontPath="fonts/Font-Regular.ttf"/>
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    tools:ignore="MissingPrefix"
    android:id="@+id/container"
    android:paddingRight="@dimen/dialog_content_padding"
    android:paddingEnd="@dimen/dialog_content_padding"
    android:background="?attr/selectableItemBackground"
    app:theme="@style/ButtonStyle">

    <android.support.v7.widget.AppCompatCheckBox
        android:id="@+id/checkbox"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:clickable="false"
        android:background="@android:color/transparent"
        app:theme="@style/CheckBoxStyle"/>

    <TextView
        android:id="@+id/title"
        android:layout_width="0dp"
        android:layout_weight="1"
        android:layout_height="wrap_content"
        android:paddingLeft="@dimen/card_padding"
        android:paddingStart="@dimen/card_padding"
        android:textSize="@dimen/text_content_title"
        android:singleLine="true"
        android:ellipsize="end"
        android:textColor="?android:attr/textColorPrimary"
        fontPath="fonts/Font-Regular.ttf"/>

<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    tools:ignore="MissingPrefix"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <android.support.v4.widget.NestedScrollView
        android:id="@+id/scrollview"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:clipToPadding="false">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical">

            <LinearLayout
                android:id="@+id/pref_cache_clear"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:padding="@dimen/content_margin"
                android:orientation="vertical"
                android:background="?attr/selectableItemBackground"
                app:theme="@style/ButtonStyle">

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/pref_data_cache"
                    android:textSize="@dimen/text_content_title"
                    android:textColor="?android:attr/textColorPrimary"
                    fontPath="fonts/Font-Medium.ttf"/>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/pref_data_cache_desc"
                    android:textSize="@dimen/text_content"
                    android:layout_marginTop="4dp"
                    android:textColor="?android:attr/textColorSecondary"
                    fontPath="fonts/Font-Regular.ttf"/>

                <TextView
                    android:id="@+id/pref_cache_size"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/pref_data_cache_size"
                    android:textSize="@dimen/text_content"
                    android:layout_marginTop="8dp"
                    android:textColor="?attr/colorAccent"
                    fontPath="fonts/Font-Medium.ttf"/>

            </LinearLayout>

            <View
                android:layout_width="match_parent"
                android:layout_height="1dp"
                android:layout_marginLeft="16dp"
                android:layout_marginStart="16dp"
                android:layout_marginEnd="16dp"
                android:layout_marginRight="16dp"
                android:background="?attr/divider_list"/>

            <LinearLayout
                android:id="@+id/pref_dark_theme"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:gravity="center_vertical"
                android:background="?attr/selectableItemBackground"
                app:theme="@style/ButtonStyle">

                <LinearLayout
                    android:layout_width="0dp"
                    android:layout_weight="1"
                    android:layout_height="wrap_content"
                    android:padding="16dp"
                    android:orientation="vertical">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="@string/pref_theme_dark"
                        android:textSize="@dimen/text_content_title"
                        android:textColor="?android:attr/textColorPrimary"
                        fontPath="fonts/Font-Medium.ttf"/>

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="@string/pref_theme_dark_desc"
                        android:textSize="@dimen/text_content"
                        android:layout_marginTop="4dp"
                        android:textColor="?android:attr/textColorSecondary"
                        android:textAppearance="?android:attr/textAppearanceLarge"
                        fontPath="fonts/Font-Regular.ttf"/>

                </LinearLayout>

                <android.support.v7.widget.AppCompatCheckBox
                    android:id="@+id/pref_dark_theme_check"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:clickable="false"
                    android:background="@android:color/transparent"
                    android:layout_margin="16dp"
                    app:theme="@style/CheckBoxStyle"/>

            </LinearLayout>

            <View
                android:layout_width="match_parent"
                android:layout_height="1dp"
                android:layout_marginLeft="16dp"
                android:layout_marginStart="16dp"
                android:layout_marginEnd="16dp"
                android:layout_marginRight="16dp"
                android:background="?attr/divider_list"/>

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:padding="16dp"
                android:orientation="vertical">

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/pref_wallpaper_location"
                    android:textSize="@dimen/text_content_title"
                    android:textColor="?android:attr/textColorPrimary"
                    fontPath="fonts/Font-Medium.ttf"/>

                <TextView
                    android:id="@+id/pref_walls_directory"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/pref_wallpaper_location_desc"
                    android:textSize="@dimen/text_content"
                    android:layout_marginTop="4dp"
                    android:textColor="?android:attr/textColorSecondary"
                    fontPath="fonts/Font-Regular.ttf"/>

            </LinearLayout>

        </LinearLayout>

    </android.support.v4.widget.NestedScrollView>

    <View
        android:layout_width="match_parent"
            android:paddingStart="@dimen/card_margin_left"
            android:paddingLeft="@dimen/card_margin_left"
            android:paddingBottom="@dimen/card_margin_bottom"
            android:clipToPadding="false"/>

    </android.support.v4.widget.SwipeRefreshLayout>

    <com.pluscubed.recyclerfastscroll.RecyclerFastScroller
        android:id="@+id/fastscroll"
        android:layout_width="wrap_content"
        android:layout_height="match_parent"
        android:layout_gravity="end"
        app:rfs_barColor="?attr/fast_scroll"
        app:rfs_handleNormalColor="?attr/fast_scroll"
        app:rfs_handlePressedColor="?attr/colorAccent"/>

    <ProgressBar
        android:id="@+id/progress"
        android:layout_width="wrap_content"
        android:orientation="vertical"
        android:foreground="?attr/selectableItemBackground"
        android:clickable="true"
        app:theme="@style/ButtonStyle">

        <com.dm.wallpaper.board.utils.views.WallpaperView
            android:id="@+id/image"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:scaleType="centerCrop" />

        <LinearLayout
            android:layout_width="match_parent"
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:padding="@dimen/card_padding"
                android:orientation="vertical">

                <TextView
                    android:layout_height="wrap_content"
                    android:textColor="?android:attr/textColorPrimary"
                    android:textSize="@dimen/text_content"
                    android:singleLine="true"
                    android:ellipsize="end"
                    fontPath="fonts/Font-Medium.ttf"/>

                    android:layout_height="wrap_content"
                    android:textColor="?android:attr/textColorSecondary"
                    android:textSize="@dimen/text_content"
                    android:singleLine="true"
                    android:ellipsize="end"
                    fontPath="fonts/Font-Regular.ttf"/>

                android:layout_marginRight="@dimen/content_padding"
                android:layout_marginEnd="@dimen/content_padding"
                android:background="?attr/selectableItemBackgroundBorderless"
                app:theme="@style/ButtonStyle"/>

        </LinearLayout>

limitations under the License.
</pre>
<ul>
    <li>RecyclerView Fast Scroll</li>
</ul>

<pre>
Copyright (c) 2016 Daniel Ciao

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
</pre>
<ul>
    <li>DrawMe</li>
</ul>

<?xml version="1.0" encoding="utf-8"?>
<resources>

    <integer name="column_num">3</integer>

</resources>
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <integer name="column_num">4</integer>

</resources>
    <dimen name="splash_screen_text">16sp</dimen>

    <!-- About header image height -->
    <dimen name="about_profile">110dp</dimen>
    <dimen name="about_image_height">180dp</dimen>

</resources>
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <integer name="column_num">3</integer>

</resources>
    <!-- Card -->
    <bool name="card_use_compat_padding">false</bool>

    <bool name="tablet_mode">false</bool>

</resources>
    <dimen name="card_margin_left">4dp</dimen>
    <dimen name="card_margin_top">4dp</dimen>
    <dimen name="card_margin_bottom">4dp</dimen>
    <dimen name="card_padding_bottom">4dp</dimen>
    <dimen name="card_elevation">2.5dp</dimen>
    <dimen name="card_corner_radius">2dp</dimen>

</resources>
        <item name="android:windowAllowReturnTransitionOverlap">true</item>
        <item name="android:windowSharedElementEnterTransition">@android:transition/move</item>
        <item name="android:windowSharedElementExitTransition">@android:transition/move</item>
        <item name="android:windowDrawsSystemBarBackgrounds">true</item>
        <item name="android:statusBarColor">@android:color/transparent</item>
        <item name="windowActionModeOverlay">true</item>
        <item name="android:windowTranslucentNavigation">true</item>
    </style>

        <item name="android:windowAllowReturnTransitionOverlap">true</item>
        <item name="android:windowSharedElementEnterTransition">@android:transition/move</item>
        <item name="android:windowSharedElementExitTransition">@android:transition/move</item>
        <item name="android:windowDrawsSystemBarBackgrounds">true</item>
        <item name="android:statusBarColor">@android:color/transparent</item>
        <item name="windowActionModeOverlay">true</item>
        <item name="android:windowTranslucentNavigation">true</item>
    </style>

</resources>
    <attr name="ripple_color" format="color"/>
    <attr name="ripple_accent" format="color"/>
    <attr name="divider_list" format="color"/>
    <attr name="fast_scroll" format="color"/>

    <attr name="toolbar_color" format="color"/>
    <attr name="toolbar_accent" format="color"/>
    <attr name="toolbar_icon" format="color"/>
    <attr name="toolbar_hint" format="color"/>

    <attr name="search_toolbar_color" format="color"/>
    <attr name="search_toolbar_icon" format="color"/>
    <attr name="search_toolbar_hint" format="color"/>

</resources>
    <!-- Card -->
    <bool name="card_use_compat_padding">true</bool>

</resources>
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <color name="colorPrimary">#828282</color>
    <color name="colorPrimaryDark">#E0E0E0</color>
    <color name="colorAccent">#F44336</color>

    <color name="darkColorPrimary">#FFFFFF</color>
    <color name="darkColorPrimaryDark">#121212</color>
    <color name="darkColorAccent">#F44336</color>

    <!-- Splash Screen -->
    <color name="splashColor">#F2F2F2</color>

    <!-- Toolbar -->
    <color name="toolbar">#F5F5F5</color>
    <color name="toolbarDark">#181818</color>
    <color name="toolbarIcon">#424242</color>
    <color name="toolbarIconDark">#BBFFFFFF</color>
    <color name="toolbarHintText">#44FFFFFF</color>
    <color name="toolbarHintTextDark">#44FFFFFF</color>

    <!-- Toolbar Search -->
    <color name="searchToolbar">#F5F5F5</color>
    <color name="searchToolbarDark">#181818</color>
    <color name="searchToolbarIcon">#424242</color>
    <color name="searchToolbarIconDark">#DDFFFFFF</color>
    <color name="searchToolbarHintText">#44000000</color>
    <color name="searchToolbarHintTextDark">#44FFFFFF</color>

    <!-- Popup Bubble -->
    <color name="popupBubble">#F44336</color>
    <color name="popupBubbleText">#FFFFFF</color>

    <!-- Navigation View -->
    <color name="navigationViewTitle">#FFFFFF</color>
    <color name="navigationViewTitleBack">#55000000</color>
    <color name="navigationViewText">#484848</color>
    <color name="navigationViewTextDark">#DDFFFFFF</color>
    <color name="navigationViewTextSelected">#F44336</color>
    <color name="navigationViewTextSelectedDark">#F44336</color>

    <!-- Card -->
    <color name="cardBackground">#FFFFFF</color>
    <color name="cardBackgroundDark">#181818</color>
    <color name="rippleColor">#55000000</color>
    <color name="rippleColorDark">#55FFFFFF</color>
    <color name="rippleAccent">#44F44336</color>
    <color name="rippleAccentDark">#44F44336</color>

    <!-- Attributes -->
    <color name="mainBackground">#FAFAFA</color>
    <color name="mainBackgroundDark">#000000</color>
    <color name="primaryText">#484848</color>
    <color name="primaryTextDark">#EEFFFFFF</color>
    <color name="secondaryText">#777777</color>
    <color name="secondaryTextDark">#99FFFFFF</color>
    <color name="dividerList">#EEEEEE</color>
    <color name="dividerListDark">#22FFFFFF</color>

    <color name="fastScrollTrack">#666666</color>
    <color name="fastScrollTrackDark">#BBBBBB</color>

    <!-- Favorite Wallpaper -->
    <color name="favoriteColor">#F44336</color>

    <!-- Wallpaper Preview -->
    <color name="wallpaperStatusBar">#88000000</color>
    <color name="wallpaperToolbar">#66000000</color>

</resources>
    <string name="wallpaper_scroll_disable_desc">Dashboard will apply wallpaper based on current view of wallpaper.
        Drag to left or right to adjust wallpaper. Pinch or double tap to zoom wallpaper.</string>

    <!-- Muzei -->
    <string name="minute">Minute</string>
    <string name="hour">Hour</string>
    <string name="billing_load_product_failed">Unable to load InApp Purchase products</string>

    <!-- Preferences -->
    <string name="pref_data_cache">Clear Cache</string>
    <string name="pref_data_cache_desc">Remove image cache from your storage created
        after loading cloud wallpaper thumbnails</string>
    <string name="pref_data_cache_size">Cache Size :</string>
    <string name="pref_data_cache_cleared">Cache Cleared</string>
    <string name="pref_data_cache_clear_dialog">Do you really want to clear cache?</string>

    <string name="pref_theme_dark">Dark Theme</string>
    <string name="pref_theme_dark_desc">Switch between dark or light theme</string>

    <string name="pref_wallpaper_location">Wallpaper Save Location</string>
    <string name="pref_wallpaper_location_desc">Try to download at least one wallpaper first.</string>

    <!-- Permission -->
    <string name="permission_storage_denied">Storage permission needed to save wallpaper</string>
    <string name="license_check_retry">Unable to check license, please try again in a few moments</string>

    <!-- Search -->
    <string name="search_result_empty">No result found for %!s(MISSING)</string>

    <!-- Crash Report -->
    <string name="crash_report">Crash Report</string>

    <!-- Splash screen -->
    <string name="splash_screen_title">Wallpaper Board</string>
    <string name="splash_screen_loading">Preparing %!s(MISSING) …</string>

    <!-- DrawerToggle -->
    <string name="txt_open">Open</string>
<resources>

    <dimen name="content_margin">16dp</dimen>
    <dimen name="content_padding">6dp</dimen>

    <!-- Card Global -->
    <dimen name="card_padding">14dp</dimen>
    <dimen name="card_margin_right">3dp</dimen>
    <dimen name="card_margin_left">3dp</dimen>
    <dimen name="card_margin_top">4dp</dimen>
    <dimen name="card_margin_bottom">1dp</dimen>
    <dimen name="card_padding_bottom">4dp</dimen>
    <dimen name="card_elevation">2.5dp</dimen>
    <dimen name="card_corner_radius">0dp</dimen>

    <!-- FAB -->
    <dimen name="fab_size">56dp</dimen>

    <!-- Default Image -->
    <dimen name="default_image_padding">40dp</dimen>

    <!-- Toolbar -->
    <dimen name="toolbar_shadow">8dp</dimen>

    <!-- Dialog -->
    <dimen name="dialog_content_padding">20dp</dimen>
    <dimen name="dialog_item_padding">8dp</dimen>

    <!-- Button -->
    <dimen name="button_padding">10dp</dimen>

    <!-- Text -->
    <dimen name="text_toolbar_logo">22sp</dimen>
    <dimen name="text_toolbar_title">20sp</dimen>
    <dimen name="text_content_header">18sp</dimen>
    <dimen name="text_content_title">16sp</dimen>
    <dimen name="text_content_subtitle">15sp</dimen>
    <dimen name="splash_screen_logo">96dp</dimen>
    <dimen name="splash_screen_text">14sp</dimen>

    <!-- About header image height -->
    <dimen name="about_profile">96dp</dimen>
    <dimen name="about_image_height">120dp</dimen>

</resources>
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <integer name="column_num">2</integer>

</resources>
    <!-- Base Application Theme -->
    <style name="AppBaseTheme" parent="@style/Theme.AppCompat.Light.DarkActionBar">
        <item name="android:windowAnimationStyle">@null</item>
        <item name="windowActionModeOverlay">true</item>
    </style>

    <!-- Base Application Theme -->
    <style name="AppBaseThemeDark" parent="@style/Theme.AppCompat">
        <item name="android:windowAnimationStyle">@null</item>
        <item name="windowActionModeOverlay">true</item>
    </style>

    <!-- App Theme-->
    <style name="AppTheme" parent="AppBaseTheme">
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>
        <item name="windowNoTitle">true</item>
        <item name="windowActionBar">false</item>
        <item name="android:windowNoTitle">true</item>
        <item name="android:windowContentOverlay">@null</item>
        <item name="drawerArrowStyle">@style/DrawerArrowStyle</item>
        <item name="android:textColorPrimary">@color/primaryText</item>
        <item name="android:textColorSecondary">@color/secondaryText</item>

        <item name="main_background">@color/mainBackground</item>
        <item name="card_background">@color/cardBackground</item>
        <item name="ripple_color">@color/rippleColor</item>
        <item name="ripple_accent">@color/rippleAccent</item>
        <item name="divider_list">@color/dividerList</item>
        <item name="fast_scroll">@color/fastScrollTrack</item>
        <item name="toolbar_color">@color/toolbar</item>
        <item name="toolbar_accent">@color/colorAccent</item>
        <item name="toolbar_icon">@color/toolbarIcon</item>
        <item name="toolbar_hint">@color/toolbarHintText</item>
        <item name="search_toolbar_color">@color/searchToolbar</item>
        <item name="search_toolbar_icon">@color/searchToolbarIcon</item>
        <item name="search_toolbar_hint">@color/searchToolbarHintText</item>

        <item name="md_positive_color">@color/colorAccent</item>
        <item name="md_neutral_color">@color/primaryText</item>
        <item name="colorPrimary">@color/darkColorPrimary</item>
        <item name="colorPrimaryDark">@color/darkColorPrimaryDark</item>
        <item name="colorAccent">@color/darkColorAccent</item>
        <item name="windowNoTitle">true</item>
        <item name="windowActionBar">false</item>
        <item name="android:windowNoTitle">true</item>
        <item name="android:windowContentOverlay">@null</item>
        <item name="drawerArrowStyle">@style/DrawerArrowStyle</item>
        <item name="android:textColorPrimary">@color/primaryTextDark</item>
        <item name="android:textColorSecondary">@color/secondaryTextDark</item>

        <item name="main_background">@color/mainBackgroundDark</item>
        <item name="card_background">@color/cardBackgroundDark</item>
        <item name="ripple_color">@color/rippleColorDark</item>
        <item name="ripple_accent">@color/rippleAccentDark</item>
        <item name="divider_list">@color/dividerListDark</item>
        <item name="fast_scroll">@color/fastScrollTrackDark</item>
        <item name="toolbar_color">@color/toolbarDark</item>
        <item name="toolbar_accent">@color/darkColorAccent</item>
        <item name="toolbar_icon">@color/toolbarIconDark</item>
        <item name="toolbar_hint">@color/toolbarHintTextDark</item>
        <item name="search_toolbar_color">@color/searchToolbarDark</item>
        <item name="search_toolbar_icon">@color/searchToolbarIconDark</item>
        <item name="search_toolbar_hint">@color/searchToolbarHintTextDark</item>

        <item name="md_background_color">@color/cardBackgroundDark</item>
        <item name="md_positive_color">@color/darkColorAccent</item>
        <item name="android:listPreferredItemHeightSmall">48dp</item>
    </style>

    <style name="ActionModeStyle" parent="@style/Widget.AppCompat.ActionMode">
        <item name="background">?attr/toolbar_color</item>
        <item name="titleTextStyle">@style/ActionModeTitleStyle</item>
    </style>

    <style name="ActionModeTitleStyle">
        <item name="android:textColor">?attr/toolbar_icon</item>
        <item name="android:textSize">@dimen/text_toolbar_title</item>
        <item name="fontPath">fonts/Font-Medium.ttf</item>
    </style>

    <style name="ButtonStyle">
        <item name="colorControlHighlight">?attr/ripple_color</item>
    </style>

    <style name="AccentButtonStyle">
        <item name="colorControlHighlight">?attr/ripple_accent</item>
    </style>

    <style name="CheckBoxStyle">
        <item name="colorControlActivated">?attr/colorAccent</item>
    </style>

    <style name="ToolbarStyle" parent="@style/Theme.AppCompat.Light.DarkActionBar">
        <item name="colorPrimary">?attr/toolbar_color</item>
        <item name="colorAccent">?attr/toolbar_accent</item>
        <item name="colorControlNormal">?attr/toolbar_icon</item>
        <item name="actionModeStyle">@style/ActionModeStyle</item>
        <item name="actionModeCloseDrawable">@drawable/ic_toolbar_back</item>
    </style>

</resources>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 * resource directory.
 */
public class Robot extends IterativeRobot {

  public static final DriveTrain driveTrain = new DriveTrain();
  public static final Vision vision = new Vision();
  public static final Shooter shooter = new Shooter();
  public static final Feeder feeder = new Feeder();
  

  public static final GearManipulator gearManipulator = new GearManipulator();

  public static final DriveJoystickCommand driveJoystickCommand = new DriveJoystickCommand();
  public static OperatorInterface operatorInterface;
  Command autonomousCommand;
  SendableChooser<Command> chooser = new SendableChooser<>();

  /**
   * This function is run when the robot is first started up and should be used for any
   * initialization code.
   */
  @Override
  public void robotInit() {
    operatorInterface = new OperatorInterface();
    // chooser.addDefault("Default Auto", new ExampleCommand());
    // chooser.addObject("My Auto", new MyAutoCommand());
    SmartDashboard.putData("Auto mode", chooser);
import com.ctre.CANTalon;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import org.ligerbots.steamworks.RobotMap;

/**
public Shooter() {
    shooterMaster.setP(0.22);
    shooterMaster.setI(0);
    shooterMaster.setD(0);
    // luckily, CANSpeedController does the heavy lifting of dashboard PID configuration for us
    SmartDashboard.putData("Shooter PID", shooterMaster);
    LiveWindow.addActuator("Shooter", "Talon", shooterMaster);

    shooterSlave = new CANTalon(RobotMap.CT_ID_SHOOTER_SLAVE);
public void initDefaultCommand() {

  /**
   * Constantly checks 775pro current and kills the shooter if it gets close to stall current.
   */
  private void shooterWatchdogThread() {
    while (true) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.logging.Logger;

import org.baderlab.csplugins.enrichmentmap.PropertyManager;
import org.baderlab.csplugins.enrichmentmap.model.EMCreationParameters;
import org.baderlab.csplugins.enrichmentmap.resolver.DataSetParameters;
import org.baderlab.csplugins.enrichmentmap.resolver.ResolverTask;
import org.baderlab.csplugins.enrichmentmap.task.CreateEnrichmentMapTaskFactory;
import org.cytoscape.application.CyUserLog;
import org.cytoscape.work.AbstractTask;
import org.cytoscape.work.SynchronousTaskManager;
import org.cytoscape.work.TaskIterator;
	public double combinedConstant = LegacySupport.combinedConstant_default;
	
	
	private static final Logger logger = Logger.getLogger(CyUserLog.NAME);

	@Inject private SynchronousTaskManager<?> taskManager;
	@Inject private LegacySupport legacySupport;
	@Inject private CreateEnrichmentMapTaskFactory.Factory taskFactoryFactory;
public ResolverCommandTask(PropertyManager propertyManager) {
	
	
	@Override
	public void run(TaskMonitor taskMonitor) throws Exception {
		logger.info("Running EnrichmentMap Data Set Resolver Task");
		
		EdgeStrategy strategy;
		try {
public void run(TaskMonitor taskMonitor) throws Exception {
		taskManager.execute(new TaskIterator(resolverTask)); // blocks
		List<DataSetParameters> dataSets = resolverTask.getDataSetResults();
		
		logger.info("resolved " + dataSets.size() + " data sets");
		dataSets.forEach(params -> logger.info(params.toString()));
		
		
		// Common gmt and expression files
		// Overwrite all the expression files if the common file has been provided
public void run(TaskMonitor taskMonitor) throws Exception {
		String info = String.format(
			"prefix:%!s(MISSING), pvalue:%!f(MISSING), qvalue:%!f(MISSING), nesFilter:%!s(MISSING), minExperiments:%!d(MISSING), similarityMetric:%!s(MISSING), similarityCutoff:%!f(MISSING), combinedConstant:%!f(MISSING)", 
			prefix, pvalue, qvalue, nesf, minExperiments, sm, similarityCutoff, combinedConstant);
		logger.info(info);
		
		EMCreationParameters params = 
				new EMCreationParameters(prefix, pvalue, qvalue, nesf, Optional.ofNullable(minExperiments), 
public void run(TaskMonitor taskMonitor) throws Exception {
		TaskIterator tasks = taskFactory.createTaskIterator();
		taskManager.execute(tasks);
		
		logger.info("Done.");
	}
	
	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import io.reactivex.Observable;
import io.reactivex.functions.Consumer;
import io.reactivex.schedulers.Schedulers;
import org.apache.commons.lang3.CharEncoding;
import org.apache.commons.lang3.StringUtils;

public static void changeExternalPrivateCgeoDir(final SettingsActivity fromActiv
                final File currentDataDir = new File(getExternalPrivateCgeoDirectory(), GEOCACHE_DATA_DIR_NAME);
                Log.i("Moving geocache data to " + newDataDir.getAbsolutePath());
                final File[] files = currentDataDir.listFiles();
                progress.setMaxProgressAndReset(files.length);
                progress.setProgress(0);
                boolean success = true;
                for (final File geocacheDataDir : files) {
                    success &= FileUtils.moveTo(geocacheDataDir, newDataDir);
                    progress.incrementProgressBy(1);
                }

                Settings.setExternalPrivateCgeoDirectory(newExtDir);
public static long getSize(final File file) {
        if (file.isDirectory()) {
            long result = 0;
            final File[] fileList = file.listFiles();
            for (final File aFileList : fileList) {
                result += getSize(aFileList);
            }
            return result; // return the file size
        }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CREATE TABLE IF NOT EXISTS  DM_DEVICE_TYPE (
  ID BIGSERIAL PRIMARY KEY,
  NAME VARCHAR(300) DEFAULT NULL,
  PROVIDER_TENANT_ID INTEGER DEFAULT 0,
  SHARED_WITH_ALL_TENANTS BOOLEAN NOT NULL DEFAULT FALSE,
  UNIQUE(NAME, PROVIDER_TENANT_ID)
);

CREATE INDEX IDX_DEVICE_TYPE ON DM_DEVICE_TYPE (NAME, PROVIDER_TENANT_ID);

CREATE TABLE IF NOT EXISTS DM_GROUP (
  ID          BIGSERIAL NOT NULL PRIMARY KEY,
  DESCRIPTION TEXT         DEFAULT NULL,
  NAME        VARCHAR(100) DEFAULT NULL,
  OWNER       VARCHAR(45)  DEFAULT NULL,
  TENANT_ID   INTEGER      DEFAULT 0
);

CREATE TABLE IF NOT EXISTS DM_ROLE_GROUP_MAP (
  ID        BIGSERIAL NOT NULL PRIMARY KEY,
  GROUP_ID  INTEGER     DEFAULT NULL,
  ROLE      VARCHAR(45) DEFAULT NULL,
  TENANT_ID INTEGER     DEFAULT 0,
  PRIMARY KEY (ID),
  CONSTRAINT fk_DM_ROLE_GROUP_MAP_DM_GROUP2 FOREIGN KEY (GROUP_ID)
  REFERENCES DM_GROUP (ID) ON DELETE NO ACTION ON UPDATE NO ACTION
);

CREATE TABLE IF NOT EXISTS  DM_DEVICE (
  ID                    BIGSERIAL NOT NULL PRIMARY KEY,
  DESCRIPTION           TEXT DEFAULT NULL,
CREATE TABLE IF NOT EXISTS DM_DEVICE_GROUP_MAP (
  DEVICE_ID INTEGER DEFAULT NULL,
  GROUP_ID  INTEGER DEFAULT NULL,
  TENANT_ID INTEGER DEFAULT 0,
  PRIMARY KEY (ID),
  CONSTRAINT fk_DM_DEVICE_GROUP_MAP_DM_DEVICE2 FOREIGN KEY (DEVICE_ID)
  REFERENCES DM_DEVICE (ID) ON DELETE NO ACTION ON UPDATE NO ACTION,
  CONSTRAINT fk_DM_DEVICE_GROUP_MAP_DM_GROUP2 FOREIGN KEY (GROUP_ID)
CREATE TABLE IF NOT EXISTS  DM_POLICY_COMPLIANCE_FEATURES (
  ON UPDATE NO ACTION
);

CREATE TABLE IF NOT EXISTS DM_DEVICE_GROUP_POLICY (
  ID BIGSERIAL NOT NULL PRIMARY KEY,
  DEVICE_GROUP_ID INT NOT NULL,
  POLICY_ID INT NOT NULL,
  TENANT_ID INT NOT NULL,
  CONSTRAINT FK_DM_DEVICE_GROUP_DM_POLICY
    FOREIGN KEY (POLICY_ID)
    REFERENCES DM_POLICY (ID)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION
);

CREATE TABLE IF NOT EXISTS  DM_ENROLMENT (
  ID BIGSERIAL NOT NULL PRIMARY KEY,
  DEVICE_ID INTEGER NOT NULL,
  OWNER VARCHAR(50) NOT NULL,
  OWNERSHIP VARCHAR(45) DEFAULT NULL,
  STATUS VARCHAR(50) NULL,
  DATE_OF_ENROLMENT TIMESTAMP NULL DEFAULT NULL,
  DATE_OF_LAST_UPDATE TIMESTAMP NULL DEFAULT NULL,
  TENANT_ID INT NOT NULL,
  CONSTRAINT fk_dm_device_enrolment FOREIGN KEY (DEVICE_ID) REFERENCES
    DM_DEVICE (ID) ON DELETE NO ACTION ON UPDATE NO ACTION
);

CREATE TABLE IF NOT EXISTS  DM_APPLICATION (
  ID BIGSERIAL NOT NULL PRIMARY KEY,
  NAME VARCHAR(150) NOT NULL,
CREATE TABLE IF NOT EXISTS DM_DEVICE_APPLICATION_MAPPING (

-- POLICY RELATED TABLES  FINISHED --

-- DEVICE GROUP TABLES --

CREATE TABLE IF NOT EXISTS DM_GROUP (
  ID BIGSERIAL NOT NULL PRIMARY KEY,
  GROUP_NAME VARCHAR(100) DEFAULT NULL,
  DESCRIPTION BYTEA DEFAULT NULL,
  DATE_OF_CREATE INTEGER DEFAULT NULL,
  DATE_OF_LAST_UPDATE INTEGER DEFAULT NULL,
  OWNER VARCHAR(45) DEFAULT NULL,
  TENANT_ID INTEGER NOT NULL
);

CREATE TABLE IF NOT EXISTS DM_DEVICE_GROUP_MAP (
  ID BIGSERIAL NOT NULL PRIMARY KEY,
  DEVICE_ID INTEGER DEFAULT NULL,
  GROUP_ID  INTEGER DEFAULT NULL,
  TENANT_ID INTEGER DEFAULT 0,
  CONSTRAINT fk_DM_DEVICE_GROUP_MAP_DM_DEVICE2 FOREIGN KEY (DEVICE_ID)
  REFERENCES DM_DEVICE (ID) ON DELETE NO ACTION ON UPDATE NO ACTION,
  CONSTRAINT fk_DM_DEVICE_GROUP_MAP_DM_GROUP2 FOREIGN KEY (GROUP_ID)
  REFERENCES DM_GROUP (ID) ON DELETE NO ACTION ON UPDATE NO ACTION
);

-- END OF DEVICE GROUP TABLES --

-- POLICY AND DEVICE GROUP MAPPING --

CREATE TABLE IF NOT EXISTS DM_DEVICE_GROUP_POLICY (
CREATE TABLE IF NOT EXISTS DM_DEVICE_DETAIL (
  DEVICE_MODEL VARCHAR(45) NULL,
  VENDOR VARCHAR(45) NULL,
  OS_VERSION VARCHAR(45) NULL,

  OS_BUILD_DATE VARCHAR(100) NULL,
  BATTERY_LEVEL DECIMAL(4) NULL,
  INTERNAL_TOTAL_MEMORY DECIMAL(30,3) NULL,
DM_DEVICE.DEVICE_TYPE_ID = DM_DEVICE_TYPE.ID AND
DM_DEVICE.ID = DM_DEVICE_DETAIL.DEVICE_ID
ORDER BY TENANT_ID, DEVICE_ID;

-- END OF DASHBOARD RELATED VIEWS --

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void onUnbind(long messageId, AudioContentViewControl view) {
            player.setOnCompletionListener(new MediaPlayer.OnCompletionListener() {
                @Override
                public void onCompletion(MediaPlayer mp) {
                    getAudioFragment().seekPlayerTo(0);
                    setAudioStatus(AudioContentView.STATUS_ENDED);
                }
            });
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public String getDescription() {
        return "LaTeX";
    }

    @Override
    public Icon getBigIcon() {
        return TexifyIcons.LATEX_MODULE;
    }

    @Override
    public Icon getNodeIcon(@Deprecated boolean isOpened) {
public void setCompilerPath(String compilerPath) {

    @Override
    public boolean isGeneratedName() {
        return mainFile.getNameWithoutExtension().equals(getName());
    }

    @Nullable
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void beforeCraft(PrepareItemCraftEvent event)
                    case 1:
                        break;
                    default:
                        if (event.getRecipe().getResult() == null)
                            return;
                        if (event.getRecipe().getResult().getType().equals(Material.TNT))
                        {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
## [2.0.0-SNAPSHOT](https://github.com/cucumber/cucumber-jvm/compare/v1.2.5...master) (In Git)

* [Core] Show explicit error message when field name missed in table header ([#1014](https://github.com/cucumber/cucumber-jvm/pull/1014) Mykola Gurov) 
* [Examples] Properly quit selenium in webbit examples ([#1146](https://github.com/cucumber/cucumber-jvm/pull/1146) Alberto Scotto)
* [JUnit] Use AssumptionFailed to mark scenarios/steps as skipped ([#1142](https://github.com/cucumber/cucumber-jvm/pull/1142) Björn Rasmusson)
        final String[] member = getMemberReference(constantPool);
        final int parameterCount = interfac3.getTypeParameters().length;

        final jdk.internal.org.objectweb.asm.Type[] argumentTypes = jdk.internal.org.objectweb.asm.Type.getArgumentTypes(member[REFERENCE_ARGUMENT_TYPES]);

        // If we are one parameter short, this is a
        return typeArguments;
    }

    private static String[] getMemberReference(ConstantPool constantPool) {
        int size = constantPool.getSize();

                <artifactId>android-examples</artifactId>
                <version>${project.version}</version>
            </dependency>

            <!-- Spring stuff -->
            <dependency>
            </activation>
            <modules>
                <module>java8</module>
            </modules>
        </profile>

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void sendNoResponse(ClientDescriptor clientDescriptor, EntityResponse mes
    Future<Void> waiter = connection.createClientResponseFuture();
    
    // We know that the entity better exist, by this point, to use the service.
    CommonServerEntity<?, ?> entity = this.container.entity;
    Assert.assertTrue(null != entity);
    byte[] payload = serialize(this.container.codec, entityMessage);
    PassthroughMessage message = PassthroughMessageCodec.createMessageToClient(clientInstanceID, payload);
   * so we use this class in order to describe where an entity will eventually live when creating the service instance for
   * this entity.
   * The reason for this is that the entity constructor may ask to get a service which means that the entity isn't yet known
   * to the platform.  So long as the entity doesn't try to use a built-in service in its constructor, but only requests it,
   * then this allows us to defer the connection.
   */
  public static class DeferredEntityContainer {
    public CommonServerEntity<?, ?> entity;
    public MessageCodec<?, ?> codec;
  }
}
 */
package org.terracotta.passthrough;

import org.terracotta.entity.EntityMessage;
import org.terracotta.entity.IEntityMessenger;
import org.terracotta.entity.MessageCodec;
import org.terracotta.entity.MessageCodecException;
import org.terracotta.passthrough.PassthroughImplementationProvidedServiceProvider.DeferredEntityContainer;


public class PassthroughMessengerService implements IEntityMessenger {
  private final PassthroughTimerThread timerThread;
  private final PassthroughServerProcess passthroughServerProcess;
  private final PassthroughConnection pseudoConnection;
  private final DeferredEntityContainer entityContainer;
  private final String entityClassName;
  private final String entityName;
  
  public PassthroughMessengerService(PassthroughTimerThread timerThread, PassthroughServerProcess passthroughServerProcess, PassthroughConnection pseudoConnection, DeferredEntityContainer entityContainer, String entityClassName, String entityName) {
    this.timerThread = timerThread;
public PassthroughMessengerService(PassthroughTimerThread timerThread, Passthrou
    this.entityContainer = entityContainer;
    this.entityClassName = entityClassName;
    this.entityName = entityName;
  }

  @Override
public void messageSelfAndDeferRetirement(EntityMessage originalMessageToDefer,
  @Override
  public ScheduledToken messageSelfAfterDelay(EntityMessage message, long millisBeforeSend) throws MessageCodecException {
    final PassthroughMessage passthroughMessage = makePassthroughMessage(message);
    // We need to have the entity at this point.
    Assert.assertTrue(null != this.entityContainer.entity);
    long token = this.timerThread.scheduleAfterDelay(new Runnable(){
      @Override
      public void run() {
        // If the entity disappeared, we are implicitly cancelled.
        if (null != PassthroughMessengerService.this.entityContainer.entity) {
          commonSendMessage(passthroughMessage);
        } else {
          System.err.println("WARNING:  Cancelled SINGLE delayed message to destroyed entity");
        }
      }}, millisBeforeSend);
    return new TokenWrapper(token);
  }

  @Override
  public ScheduledToken messageSelfPeriodically(EntityMessage message, long millisBetweenSends) throws MessageCodecException {
    final PassthroughMessage passthroughMessage = makePassthroughMessage(message);
    // We need to have the entity at this point.
    Assert.assertTrue(null != this.entityContainer.entity);
    SelfCancellingRunnable runnable = new SelfCancellingRunnable(passthroughMessage);
    long token = this.timerThread.schedulePeriodically(runnable, millisBetweenSends);
    runnable.setToken(token);
    return new TokenWrapper(token);
  }

  @Override
  public void cancelTimedMessage(ScheduledToken token) {
    // If this is the wrong type, the ClassCastException is a reasonable error since it means we got something invalid.
    this.timerThread.cancelMessage(((TokenWrapper)token).token);
  }


public void setToken(Long token) {
    public void run() {
      Assert.assertTrue(this.token > 0);
      // If the entity disappeared, we are implicitly cancelled.
      if (null != PassthroughMessengerService.this.entityContainer.entity) {
        commonSendMessage(this.message);
      } else {
        PassthroughMessengerService.this.timerThread.cancelMessage(this.token);
public void run() {


  private static class TokenWrapper implements ScheduledToken {
    public final long token;
    public TokenWrapper(long token) {
      this.token = token;
    }
  }
}
public void start(boolean shouldLoadStorage) {
        // We don't expect a version mismatch here or other failure in this test system.
        Assert.unexpected(e);
      }
      PassthroughEntityTuple entityTuple = new PassthroughEntityTuple(entityData.className, entityData.entityName);
      CommonServerEntity<?, ?> newEntity = null;
      try {
public void start(boolean shouldLoadStorage) {
        Assert.unexpected(e);
      }
      // We can now store the entity into the deferred container.
      container.entity = newEntity;
      container.codec = service.getMessageCodec();
      // Tell the entity to load itself from storage.
      if (newEntity instanceof ActiveServerEntity) {
        ((ActiveServerEntity<?, ?>)newEntity).loadExisting();
public synchronized void create(String entityClassName, String entityName, long
    EntityServerService<?, ?> service = getServerEntityServiceForVersion(entityClassName, entityName, version);
    // This is an entity consumer so we use the deferred container.
    DeferredEntityContainer container = new DeferredEntityContainer();
    this.consumerToLiveContainerMap.put(consumerID, container);
    PassthroughServiceRegistry registry = getNextServiceRegistry(entityClassName, entityName, container);
    // Before we create the entity, we want to store this information regarding class and name, since that might be needed by a service in its start up.
public synchronized void create(String entityClassName, String entityName, long
      // Wrap this and re-throw.
      throw new EntityConfigurationException(entityClassName, entityName, e);
    }
    container.entity = newEntity;
    container.codec = service.getMessageCodec();
    
    // Store the tuple for this entity, so it can see itself via monitoring.
    if (null != this.serviceInterface) {
public synchronized boolean destroy(String entityClassName, String entityName) t
        } catch (IOException e) {
          Assert.unexpected(e);
        }
        container.entity = null;
      }
      if (success && null != this.activeEntities) {
        boolean didRemove = false;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.feilong.core.net.ParamUtil;
import com.feilong.core.util.MapUtil;
import com.feilong.servlet.http.entity.RequestIdentity;
public RequestLogBuilder(HttpServletRequest request, RequestLogSwitch requestLog

        // _errorInfos
        if (opRequestLogSwitch.getShowErrors()){
            MapUtil.putIfValueNotNullOrEmpty(map, "errorInfos", getErrorMap());
        }
        // _forwardInfos
        if (opRequestLogSwitch.getShowForwardInfos()){
            MapUtil.putIfValueNotNullOrEmpty(map, "forwardInfos", getForwardMap());
        }
        // _includeInfos
        if (opRequestLogSwitch.getShowIncludeInfos()){
            MapUtil.putIfValueNotNullOrEmpty(map, "includeInfos", getIncludeMap());
        }
        return map;
    }
private String getSessionId(){
        }
    }

    //*******************************************************************************

    /**
     * 获得 forward map.
     *
     * @return the forward map
     */
    private Map<String, String> getForwardMap(){
        String[] array = { FORWARD_CONTEXT_PATH, FORWARD_REQUEST_URI, FORWARD_SERVLET_PATH, FORWARD_PATH_INFO, FORWARD_QUERY_STRING };
        return getAttributeMapIfValueNotNull(array);
    }

    /**
     * 获得 include map.
     *
     * @return the include map
     */
    private Map<String, String> getIncludeMap(){
        String[] array = { INCLUDE_CONTEXT_PATH, INCLUDE_PATH_INFO, INCLUDE_QUERY_STRING, INCLUDE_REQUEST_URI, INCLUDE_SERVLET_PATH };
        return getAttributeMapIfValueNotNull(array);
    }

    /**
private String getSessionId(){
     * @return 如果request 有 {@link RequestAttributes#ERROR_STATUS_CODE}属性,则返回error 相关属性 封装到map,<br>
     *         如果 request没有 {@link RequestAttributes#ERROR_STATUS_CODE}属性,返回null
     */
    private Map<String, String> getErrorMap(){
        String[] array = { ERROR_STATUS_CODE, ERROR_REQUEST_URI, ERROR_EXCEPTION, ERROR_EXCEPTION_TYPE, ERROR_MESSAGE, ERROR_SERVLET_NAME };
        return getAttributeMapIfValueNotNull(array);
    }

    /**
     * 将指定的attributeName当作key,request找到属性值,设置到map中(当且仅当 <code>null != map && null != value </code>才将key/value put到map中).
     *
private String getSessionId(){
     * @return the attribute map if value not null
     * @since 1.7.3
     */
    private Map<String, String> getAttributeMapIfValueNotNull(String...attributeNames){
        Map<String, String> map = newLinkedHashMap(attributeNames.length);
        for (String attributeName : attributeNames){
            MapUtil.putIfValueNotNull(map, attributeName, RequestUtil.<String> getAttribute(request, attributeName));
        }
        return map;
    }

    /**
     * 获得 about url map.
     * 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void writeToParcel(Parcel out, int flags) {
        out.writeParcelable(gameType, 0);
        out.writeParcelable(difficulty, 0);
        out.writeParcelable(gameBoard, 0);
        out.writeParcelable(undoRedoManager, 0);

        out.writeTypedList(errorList);
    }
private GameController(Parcel in) {
        gameType = in.readParcelable(GameType.class.getClassLoader());
        difficulty = in.readParcelable(GameDifficulty.class.getClassLoader());
        gameBoard = in.readParcelable(GameBoard.class.getClassLoader());
        undoRedoManager = in.readParcelable(UndoRedoManager.class.getClassLoader());

        in.readTypedList(errorList, CellConflict.CREATOR);

import android.content.Intent;
import android.os.Handler;
import android.os.IBinder;
import android.support.annotation.IntDef;
import android.support.annotation.Nullable;
import android.support.v4.content.ContextCompat;
import org.secuso.privacyfriendlysudoku.ui.view.R;

import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

    private final List<Pair<GameType, GameDifficulty>> generationList = new LinkedList<>();
    private final DatabaseHelper dbHelper = new DatabaseHelper(this);


    public GeneratorService() {
        super("Generator Service");
    }

    private void buildGenerationList() {
        generationList.clear();

private void buildGenerationList() {

    private void handleGenerationStop() {
        stopForeground(true);
        stopSelf();
    }

    private void handleGenerationStart(Intent intent) {
        GameType gameType = intent.getParcelableExtra(EXTRA_GAMETYPE);
        GameDifficulty gameDifficulty = intent.getParcelableExtra(EXTRA_DIFFICULTY);

        if(gameType == null || gameDifficulty == null) {
            generateLevels();
        } else {
            generateLevel(gameType, gameDifficulty);
private void showNotification(GameType gameType, GameDifficulty gameDifficulty)
        builder.setSmallIcon(R.drawable.splash_icon);
        startForeground(50, builder.build());
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    protected void onHandleIntent(@Nullable Intent intent) {
        if (intent != null) {
protected void onCreate(Bundle savedInstanceState) {

            Bundle extras = getIntent().getExtras();
            if (extras != null) {
                Object o = extras.get("gameType");
                if (o instanceof GameType) {
                    gameType = (GameType) extras.get("gameType");
                }
                gameDifficulty = (GameDifficulty) (extras.get("gameDifficulty"));
                loadLevel = extras.getBoolean("loadLevel", false);
                if (loadLevel) {
                    loadLevelID = extras.getInt("loadLevelID");
public void onClick(View view) {

                    // send everything to game activity
                    i = new Intent(this, GameActivity.class);
                    i.putExtra("gameType", (Serializable)gameType);
                    i.putExtra("gameDifficulty", (Serializable)gameDifficulty);
                } else {
                    newLevelManager.checkAndRestock();
                    Toast t = Toast.makeText(getApplicationContext(), R.string.generating, Toast.LENGTH_SHORT);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public CodeGeneratorManager(Context context) {
            public void onServiceConnected(ComponentName className, IBinder binder) {
                try {
                    if (!mResumed) {
                        mContext.unbindService(mCodeGenerationConnection);
                    } else {
                        mGeneratorService = ((CodeGeneratorService.CodeGeneratorBinder) binder).getService();

public void onServiceDisconnected(ComponentName arg0) {
     */
    public void onPause() {
        mResumed = false;
        if (isBound()) {
            mContext.unbindService(mCodeGenerationConnection);
        }
    }

    /**
public void onResume() {
    }

    /**
     * Calls the Service to request code generation for the workspace passed in.
     *
     * @param codeGenerationRequest the request to generate code.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

package org.kontalk.service.msgcenter.group;

import org.jivesoftware.smack.XMPPConnection;
import org.jivesoftware.smack.packet.Message;
import org.jivesoftware.smack.packet.Stanza;
else if (command instanceof AddRemoveMembersCommand) {
            KontalkAddRemoveMembersCommand addRemove = (KontalkAddRemoveMembersCommand) command;
            String[] added = addRemove.getAddedMembers();
            String[] members = addRemove.getMembers();
            String[] filteredMembers = members;
            if (added != null) {
                // remove added users from members list
                filteredMembers = new String[members.length - added.length];
                int fi = 0;
                for (String member : members) {
                    if (!SystemUtils.contains(added, member)) {
                        filteredMembers[fi++] = member;
                    }
                }
            }
            group.addRemoveMembers(addRemove.getSubject(), filteredMembers,
                addRemove.getAddedMembers(), addRemove.getRemovedMembers(), packet);
        }
        else if (command instanceof PartCommand) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private CameraUpdate addCircle(GoogleMap map, LatLng latlng, int radius, Observa
                include(SphericalUtil.computeOffset(latlng, radius, 180)).
                include(SphericalUtil.computeOffset(latlng, radius, 270)).build();

        return CameraUpdateFactory.newLatLngBounds(bounds, radius);
    }

    public void addMapPosition(final GoogleMap map, Observation observation, BetterJSONObject observationJson) {
public void addMapPosition(final GoogleMap map, Observation observation, BetterJ
        map.setOnMapLoadedCallback(new GoogleMap.OnMapLoadedCallback() {
            @Override
            public void onMapLoaded() {
                if (finalCameraUpdate != null) map.moveCamera(finalCameraUpdate);
            }
        });

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
protected void updateUI() {

        if (mToggleEncryptionMenu != null) {
            Context context = getActivity();
            if (mConversation != null && Preferences.getEncryptionEnabled(context)) {
                boolean encryption = mConversation.isEncryptionEnabled();
                mToggleEncryptionMenu
                    .setVisible(true)
                    .setEnabled(true)
                    .setChecked(encryption);
            }
            else {
                mToggleEncryptionMenu
                    .setVisible(false)
                    .setEnabled(false)
                    .setChecked(false);
            }
        }
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private boolean processFile( FileHeaderTransformer transformer, File file, File
        }

        char lastchar = ' ';
        while ( lastchar != '\n' )
        {
            lastchar = content.charAt( ( --firstIndex ) );
        }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        android:id="@+id/pagerLayout">

        <!-- fullscreen pager for hosting the photo -->
        <android.support.v4.view.ViewPager
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:id="@+id/pager"
                android:layout_height="match_parent"
                android:id="@+id/fullscreen_photo"/>

        </android.support.v4.view.ViewPager>

        <!-- caption layout -->
        <LinearLayout
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
