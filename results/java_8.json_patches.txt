import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
private void cleanCache(FileStore store, File volume, Config config) throws IOEx
        // start deleting  the oldest cache files first
        // before we start deleting the cache files for
        // the current os/arch
        cacheDirs.sort(new Comparator<CacheDir>() {
            @Override
            public int compare(CacheDir o1, CacheDir o2) {
                return new Date(o1.lastModified).compareTo(new Date(o2.lastModified));
private CacheDir constructCacheDir(File volume, OS os, Arch arch, boolean isDebu
            return null;
        List<File> objFiles = new ArrayList<File>((Collection<File>) FileUtils.listFiles(dir, new String[] { "o" },
                true));
        objFiles.sort(new Comparator<File>() {
            @Override
            public int compare(File f1, File f2) {
                return new Date(f2.lastModified()).compareTo(new Date(f1.lastModified()));
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
subprojects {

// apply Java and JRuby stuff for all subprojects except the distribution
configure(subprojects.findAll { !it.name.endsWith('-distribution') }) {
  dependencies {
    testCompile "junit:junit:$junitVersion"
    testCompile "org.hamcrest:hamcrest-library:$hamcrestVersion"
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        return new DefaultPollEvent<T>(this, timeKeeper);
    }
    
    static <T> Condition<T> match(Callable<T> item, CheckedPredicate<? super T> predicate) {
        return new AbstractCondition<T>() {
            private T lastResult = null;
            
public T lastResult() {
    }
    
    static <T> Condition<T> match(T item, CheckedPredicate<? super T> predicate) {
        return match(new Callable<T>() {
            
            @Override
            public T call() throws Exception {
default T waitUpTo(long timeout, ChronoUnit unit) {
    }

    default PollEvent<T> or(T item, CheckedPredicate<? super T> predicate) {
        return or(new Callable<T>() {

            @Override
            public T call() throws Exception {
                return item;
            }

        }, predicate);
    }

    default PollEvent<T> or(Callable<T> item, CheckedPredicate<? super T> predicate) {
        return or(Condition.match(item, predicate));
    }

    default PollEvent<T> or(T item, Matcher<? super T> matcher) {
        return or(new Callable<T>() {

            @Override
            public T call() throws Exception {
                return item;
            }

        }, matcher);
    }

    default PollEvent<T> or(Callable<T> item, Matcher<? super T> matcher) {
        return or(new HamcrestCondition<>(item, matcher));
    }

public T call() throws Exception {
    }

    default <R> FailPollEvent<T> failIf(R item, CheckedPredicate<? super R> predicate) {
        return failIf(new Callable<R>() {

            @Override
            public R call() throws Exception {
                return item;
            }

        }, predicate);
    }

    default <R> FailPollEvent<T> failIf(Callable<R> item, CheckedPredicate<? super R> predicate) {
        return failIf(Condition.match(item, predicate));
    }

    default <R> FailPollEvent<T> failIf(R item, Matcher<? super R> matcher) {
        return failIf(new Callable<R>() {

            @Override
            public R call() throws Exception {
                return item;
            }

        }, matcher);
    }

    default <R> FailPollEvent<T> failIf(Callable<R> item, Matcher<? super R> matcher) {
        return failIf(new HamcrestCondition<>(item, matcher));
    }

public R call() throws Exception {
     * @see #andThenExpect(Condition)
     */
    default <U> PollEvent<U> andThenExpect(U item, CheckedPredicate<? super U> predicate) {
        return andThenExpect(new Callable<U>() {

            @Override
            public U call() throws Exception {
                return item;
            }

        }, predicate);
    }

    /**
     * @see #andThenExpect(Condition)
     */
    default <U> PollEvent<U> andThenExpect(Callable<U> item, CheckedPredicate<? super U> predicate) {
        return andThenExpect(Condition.match(item, predicate));
    }

    /**
     * @see #andThenExpect(Condition)
     */
    default <U> PollEvent<U> andThenExpect(U item, Matcher<? super U> matcher) {
        return andThenExpect(new Callable<U>() {

            @Override
            public U call() throws Exception {
                return item;
            }

        }, matcher);
    }

    /**
     * @see #andThenExpect(Condition)
     */
    default <U> PollEvent<U> andThenExpect(Callable<U> item, Matcher<? super U> matcher) {
        return andThenExpect(new HamcrestCondition<>(item, matcher));
    }
}
    private Matcher<? super T> matcher;
    private T lastResult = null;
    
    public static <T> HamcrestCondition<T> match(Callable<T> item, Matcher<? super T> matcher) {
        return new HamcrestCondition<T>(item, matcher);
    }

private Synq() {
    }

    public static <T> PollEvent<T> expect(T item, CheckedPredicate<? super T> predicate) {
        return expect(new Callable<T>() {

            @Override
            public T call() throws Exception {
                return item;
            }

        }, predicate);
    }

    public static <T> PollEvent<T> expect(Callable<T> item, CheckedPredicate<? super T> predicate) {
        return expect(Condition.match(item, predicate));
    }

    public static <T> PollEvent<T> expect(T item, Matcher<? super T> matcher) {
        return expect(new Callable<T>() {

            @Override
            public T call() throws Exception {
                return item;
            }

        }, matcher);
    }

    public static <T> PollEvent<T> expect(Callable<T> item, Matcher<? super T> matcher) {
        return expect(new HamcrestCondition<>(item, matcher));
    }

public T call() throws Exception {
    }

    public static <T> FailPollEvent<T> failIf(T item, CheckedPredicate<? super T> predicate) {
        return failIf(new Callable<T>() {

            @Override
            public T call() throws Exception {
                return item;
            }

        }, predicate);
    }

    public static <T> FailPollEvent<T> failIf(Callable<T> item, CheckedPredicate<? super T> predicate) {
        return failIf(Condition.match(item, predicate));
    }

    public static <T> FailPollEvent<T> failIf(T item, Matcher<? super T> matcher) {
        return failIf(new Callable<T>() {

            @Override
            public T call() throws Exception {
                return item;
            }

        }, matcher);
    }

    public static <T> FailPollEvent<T> failIf(Callable<T> item, Matcher<? super T> matcher) {
        return failIf(new HamcrestCondition<>(item, matcher));
    }

public After(Runnable action) {
        }

        public <T> PollEvent<T> expect(T item, CheckedPredicate<? super T> predicate) {
            return expect(new Callable<T>() {

                @Override
                public T call() throws Exception {
                    return item;
                }

            }, predicate);
        }

        public <T> PollEvent<T> expect(Callable<T> item, CheckedPredicate<? super T> predicate) {
            return expect(Condition.match(item, predicate));
        }

        public <T> PollEvent<T> expect(T item, Matcher<? super T> matcher) {
            return expect(new Callable<T>() {

                @Override
                public T call() throws Exception {
                    return item;
                }

            }, matcher);
        }

        public <T> PollEvent<T> expect(Callable<T> item, Matcher<? super T> matcher) {
            return expect(new HamcrestCondition<>(item, matcher));
        }

public T call() throws Exception {
        }

        public <T> FailPollEvent<T> failIf(T item, CheckedPredicate<? super T> predicate) {
            return failIf(new Callable<T>() {

                @Override
                public T call() throws Exception {
                    return item;
                }

            }, predicate);
        }

        public <T> FailPollEvent<T> failIf(Callable<T> item, CheckedPredicate<? super T> predicate) {
            return failIf(Condition.match(item, predicate));
        }

        public <T> FailPollEvent<T> failIf(T item, Matcher<? super T> matcher) {
            return failIf(new Callable<T>() {

                @Override
                public T call() throws Exception {
                    return item;
                }

            }, matcher);
        }

        public <T> FailPollEvent<T> failIf(Callable<T> item, Matcher<? super T> matcher) {
            return failIf(new HamcrestCondition<>(item, matcher));
        }
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public DBI build(Environment environment,
        dbi.registerArgumentFactory(new OptionalZonedDateTimeArgumentFactory(timeZone));

        dbi.registerColumnMapper(new JodaDateTimeMapper(timeZone));
        dbi.registerColumnMapper(new InstantMapper(timeZone));
        dbi.registerColumnMapper(new LocalDateMapper());
        dbi.registerColumnMapper(new LocalDateTimeMapper());
        dbi.registerColumnMapper(new OffsetDateTimeMapper());
        dbi.registerColumnMapper(new ZonedDateTimeMapper());

        return dbi;
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*.DS_Store
/testreport
*~
import org.objectweb.asm.ClassWriter;

import java.io.IOException;
import java.util.*;

import static org.objectweb.asm.ClassWriter.COMPUTE_MAXS;
public IndividualClassLoader(String teamPackageName) throws InstrumentationExcep
                byte[] classBytes;
                try {
                    classBytes = instrument(name, false, teamPackageName);
                    //dumpToFile(name,classBytes);
                } catch (InstrumentationException ie) {
                    teamsWithErrors.add(teamPackageName);
                    throw ie;
public IndividualClassLoader(String teamPackageName) throws InstrumentationExcep
        cr.accept(cv, 0);        //passing false lets debug info be included in the transformation, so players get line numbers in stack traces
        return cw.toByteArray();
    }
}
private static boolean shouldAddInstrumentedPrefix(String className) {
        if (className.startsWith("instrumented/"))
            return false;

        if (className.startsWith("java/util/jar") ||
                className.startsWith("java/util/zip") ||
                className.equals("java/util/Iterator") ||
                className.equals("java/util/concurrent/TimeUnit"))
            return false;

        if (className.startsWith("java/util/") ||
                className.startsWith("java/math/"))
            return true;

public void visitOuterClass(String owner, String name, String desc) {
     * @inheritDoc
     */
    public void visitInnerClass(String name, String outerName, String innerName, int access) {
        super.visitInnerClass(ClassReferenceUtil.classReference(name, teamPackageName, checkDisallowed), ClassReferenceUtil.classReference(outerName, teamPackageName, checkDisallowed), innerName, access);
    }

}
public void visitMaxs(int maxStack, int maxLocals) {
                case INSN:
                    visitInsnNode((InsnNode) node);
                    break;
                case LDC_INSN:
                    visitLdcInsnNode((LdcInsnNode) node);
                    break;
private void visitLdcInsnNode(LdcInsnNode n) {
        }
    }

    private void visitMethodInsnNode(MethodInsnNode n) {
        // do various function replacements

        if (n.name.equals("hashCode") && n.desc.equals("()I") && n.getOpcode() != INVOKESTATIC) {
            bytecodeCtr++;
            endOfBasicBlock(n);
java/io
java/lang
java/math
java/util
java/util/regex
battlecode/common
scala
scala/collection
public void testIllegalMethodsFail() throws Exception {
            fail("Didn't outlaw illegal class: "+className);
        }
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public BundleWriterBase(UserOption userOption) {

    @Override
    public void setBundle(EnumResourceBundle<E> bundle) {
        this.setBundle(bundle);
    }

    /**
protected DefaultPatternSource(@SupportedLocales Set<Locale> supportedLocales, U


    /**
     * Returns the translated String pattern for {@code key}, for {@code locale}, or {@link Optional.isAbsent()} if
     * there is no pattern for the key.
     * <p>
     * Each bundle source relevant to {@code key} is tried, as specified by {@link #bundleSourceOrder(I18NKey)}
     * <p>
     * Available sources are determined by bindings in the I18NModule or its sub-class
     * <p>
     *
     * @param key
     *         the key to look up
     * @param locale
     *         the locale the pattern is required for
     *
     * @return the String pattern for {@code key}, or {@link Optional.isAbsent()} if there is no pattern for the key in
     * any of the available sources
     */
    @Override
    public <E extends Enum<E> & I18NKey> Optional<String> retrievePattern(E key, Locale locale) {
protected DefaultPatternSource(@SupportedLocales Set<Locale> supportedLocales, U
        for (String source : bundleSourceOrder(key)) {
            EnumResourceBundle<E> bundle = getBundle(source, key, locale);
            String pattern = bundle.getValue((E) key);
            if (!StringUtils.isEmpty(pattern)) {
                result = Optional.of(pattern);
                break;
            } else {
                if (getAutoStub()) {
                    // this call does not overwrite an existing entry
                    generateStub(source, key, locale);
                }
            }
        }

/**
 * Used with {@link ResourceBundle} to make the selection of I18N sources configurable through Guice.
 * <p/>
 * Created by David Sowerby on 18/11/14.
 */
public class EnumResourceBundleControl extends ResourceBundle.Control {
public ResourceBundle newBundle(String baseName, Locale locale, String format, C
    }

    /**
     * This callback is used by {@link resourceBundle} to determine the available "formats" (sources in Krail terms)
     * and the order in which they are called to provide a bundle.  The order used by Krail is the first found for a
     * key class, in the following sequence<ol>
     * <li> UserOption, property sourceOrder, for a specific key class</li>
     * <li> UserOption, property sourceOrderDefault, for all key classes</li>
     * <li> {@link #bundleSourceOrder}, which can be defined in the I18NModule, and applies to a specific key
     * class</li>
     * <li> {@link #bundleSourceOrderDefault}, which can be defined in the I18Module, and applies to all key
     * classes</li>
     * <li> the natural order of #bundleReaders keySet</li>
     * <p>
     * </ol>
     *
public ResourceBundle newBundle(String baseName, Locale locale, String format, C
    @Override
    public List<String> getFormats(String baseName) {
        List<String> list = new ArrayList<>();
        list.add(format);return list;
    }


public ResourceBundle newBundle(String baseName, Locale locale, String format, C
    }




    //    needs reload
    //    :
    //
package uk.q3c.util;

import edu.uci.ics.jung.graph.DelegateForest;
import edu.uci.ics.jung.graph.Forest;
import edu.uci.ics.jung.graph.Tree;
import org.apache.commons.lang3.StringUtils;
import java.util.List;

/**
 * A very simple semantic wrapper for the <a href=http://jung.sourceforge.net/site/index.html> Jung</a> library, to use
 * the more familiar language of trees. Underneath is it a proper implementation of a graph - there are many methods
 * not
 * exposed through this wrapper, but you can access those via {@link #getGraph()}
 * <p/>
 * The E (edge) parameter for the underlying graph is a simple Integer
 *
 * @param <V>
 *         the type of object to be contained (the 'node'). Must implement equals
    private Forest<V, Integer> graph;

    public BasicForest() {
        graph = new DelegateForest<V, Integer>();
    }

    public boolean hasChild(V parentNode, V childNode) {
public void setKeyValueAndReset() {
        source.setKeyValue("class", TestLabelKey.Blank, Locale.ITALY, "New Blank");
        source.setKeyValue("class", TestLabelKey.Opt, Locale.ITALY, "New Opt");

        String pattern1 = source.retrievePattern(TestLabelKey.Home, Locale.ITALY)
                                .get();
        String pattern2 = source.retrievePattern(TestLabelKey.Blank, Locale.ITALY)
                                .get();
        String pattern3 = source.retrievePattern(TestLabelKey.Opt, Locale.ITALY)
                                .get();
        //then new values set
        assertThat(pattern1).isEqualTo("New Home");
        assertThat(pattern2).isEqualTo("New Blank");
        assertThat(pattern3).isEqualTo("New Opt");

        //when reset
        source.reset("class", TestLabelKey.Yes);
        pattern1 = source.retrievePattern(TestLabelKey.Home, Locale.ITALY)
                         .get();
        pattern2 = source.retrievePattern(TestLabelKey.Blank, Locale.ITALY)
                         .get();
        pattern3 = source.retrievePattern(TestLabelKey.Opt, Locale.ITALY)
                         .get();

        //then original values set
        assertThat(pattern1).isEqualTo("it_Home");
        assertThat(pattern2).isEqualTo("");
        assertThat(pattern3).isEqualTo("option");  // default because now there is no key in italian


    }
public void bundleSourceOrder() {
        Set<String> tags = new LinkedHashSet<>();
        tags.add("class");
        tags.add("boots");
        bundleSourceOrder.put("TestLabels", tags);
        createPatternSource(TestLabelKey.class);
        //when

public void bundleSourceOrder() {
        assertThat(orderTestLabelKey).containsExactly("eat", "hat");

        //given user option changes for a single bundleName
        patternSource.setOptionSourceOrder("TestLabels", "fat", "cat");
        //when
        orderAny = patternSource.bundleSourceOrder(LabelKey._nullkey_);
        orderTestLabelKey = patternSource.bundleSourceOrder(TestLabelKey.Blank);
import java.util.*;

import static org.assertj.core.api.Assertions.assertThat;

@RunWith(MycilaJunitRunner.class)
@GuiceContext({TestI18NModule.class, UserOptionModule.class})
public class EnumResourceBundleControlTest {

    @Test
    public void getFormats() {
        //given we just have the readers
        bundleReaders.put("class", new ClassBundleReader());
        bundleReaders.put("props", new PropertiesBundleReader());
        //when
        createControl(TestLabelKey.class);
        List<String> orderAny = bundleControl.getFormats("any");
        //then
        assertThat(orderAny).containsExactly("class", "props");

        //given we specify a default order in I18NModule
        bundleSourceOrderDefault.add("props");
        bundleSourceOrderDefault.add("class");
        createControl(TestLabelKey.class);
        //when
        orderAny = bundleControl.getFormats("any");
        //then
        assertThat(orderAny).containsExactly("props", "class");

        //given we change the order for just one bundleName
        Set<String> tags = new LinkedHashSet<>();
        tags.add("class");
        tags.add("boots");
        bundleSourceOrder.put("TestLabels", tags);
        createControl(TestLabelKey.class);
        //when
        orderAny = bundleControl.getFormats("any");
        List<String> orderTestLabelKey = bundleControl.getFormats("TestLabels");
        //then
        assertThat(orderAny).containsExactly("props", "class");
        assertThat(orderTestLabelKey).containsExactly("class", "boots");

        //given user option changes the default
        //        bundleControl.setOptionSourceOrderDefault("eat", "hat");
        //when
        orderAny = bundleControl.getFormats("any");
        orderTestLabelKey = bundleControl.getFormats("TestLabels");
        //then
        assertThat(orderAny).containsExactly("eat", "hat");
        assertThat(orderTestLabelKey).containsExactly("eat", "hat");

        //given user option changes for a single bundleName
        //        bundleControl.setOptionSourceOrder("TestLabels", "fat", "cat");
        //when
        orderAny = bundleControl.getFormats("any");
        orderTestLabelKey = bundleControl.getFormats("TestLabels");
        //then
        assertThat(orderAny).containsExactly("eat", "hat");
        assertThat(orderTestLabelKey).containsExactly("fat", "cat");

    }

private void createControl(Class<? extends Enum> keyClass) {
        bundleControl.setEnumKeyClass(keyClass);
    }

    @Test
    public void getSourceOrder() {
        //given

        //when

        //then
        assertThat(true).isFalse();
    }

    @Test
    public void getSourceOrderDefault() {
        //given

        //when

        //then
        assertThat(true).isFalse();
    }
}
public void tostring() {
        // when
        addAllNodes();
        // then
        assertThat(tree.toString()).isEqualTo("\n-0\n--2\n---2.1\n---2.2\n--1\n---1.2\n----1.2.1\n---1.1\n----1.1.1\n");
    }

    @Test
public void text() {
        tree.text(s0, buf, 0);
        String s = buf.toString();
        // then
        assertThat(s).isEqualTo("-0\n--2\n---2.1\n---2.2\n--1\n---1.2\n----1.2.1\n---1.1\n----1.1.1\n");
    }

    @Test
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
dependencies {
    compile 'com.github.rjeschke:txtmark:0.10'
    compile 'org.reflections:reflections:0.9.8'
    compile 'com.itextpdf:itextpdf:5.3.2' //5.3.3 and later remove MultiColumnText, need adjustment
    compile 'com.google.code.gson:gson:2.2.4'
    compile 'de.idos.updates:updates-core:1.2.0'
import net.sf.anathema.framework.preferences.elements.PreferenceView;
import net.sf.anathema.framework.preferences.elements.RegisteredPreferencePresenter;
import net.sf.anathema.framework.preferences.persistence.PreferencePto;
import net.sf.anathema.interaction.Command;
import net.sf.anathema.interaction.Tool;
import net.sf.anathema.lib.file.RelativePath;

private void initIndividualPresentations() {
  private void addSaveButtonToNavigation() {
    Tool tool = preferencesNavigation.addTool();
    tool.setIcon(new RelativePath("icons/TaskBarSave24.png"));
    tool.setCommand(new Command() {
      @Override
      public void execute() {
        PreferencesPresenter.this.savePreferences();
        tool.disable();
      }
    });
    dirtyProxy.whenDirtied(new Command() {
      @Override
      public void execute() {
        tool.enable();
      }
    });
    tool.disable();
  }

allprojects {
        maven { //JRE
            url 'http://anathema.butatopanto.de:8081/maven/releases/'
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private String getBody(DefaultClass javaClass, WorkingCopy workingCopy) {
                            keyBuidler.append("for( int i=0;i<").append(name).append(".size();i++){"); 
                            keyBuidler.append("field[i]= new ");
                            if (type == PRIMITIVE_ARRAY) {
                                keyBuidler.append(getWrapperType(dataType))  ;
                            } else {
                                keyBuidler.append(dataType);
                            }
    }
    
    public static String getPrimitiveType(String wrapperType) {
        String primitiveType = WRAPPER_DATA_TYPES.get(wrapperType);
        if (primitiveType != null) {
            return primitiveType;
        } else {
            return wrapperType;
        }
    }

    private static final Map<String, String> PRIMITIVE_DATA_TYPES = WRAPPER_DATA_TYPES.entrySet().stream().collect(Collectors.toMap(Entry::getValue, Entry::getKey));

    public static String getWrapperType(String primitiveType) {
        if (isArray(primitiveType)) {
            primitiveType = primitiveType.substring(0, primitiveType.length() - 2);
        }
        String wrapperType = PRIMITIVE_DATA_TYPES.get(primitiveType);
        if (wrapperType != null) {
            return wrapperType;
        } else {
            return primitiveType;
        }
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
def __init__(self, args, shell_env):
    self.processes_to_monitor = {}

    self.state_managers = []

  @staticmethod
  def parse_args(args):
def _get_java_instance_cmd(self, instance_info):
    retval = {}
    # TO DO (Karthik) to be moved into keys and defaults files
    code_cache_size_mb = 64
    perm_gen_size_mb = 128
    for (instance_id, component_name, global_task_id, component_index) in instance_info:
      total_jvm_size = int(self.component_rammap[component_name] / (1024 * 1024))
      heap_size_mb = total_jvm_size - code_cache_size_mb - perm_gen_size_mb
      Log.info("component name: %!s(MISSING), ram request: %!d(MISSING), total jvm size: %!d(MISSING)M, "
               "cache size: %!d(MISSING)M, perm size: %!d(MISSING)M"
               %!((MISSING)component_name, self.component_rammap[component_name],
                  total_jvm_size, code_cache_size_mb, perm_gen_size_mb))
      xmn_size = int(heap_size_mb / 2)
      instance_cmd = [os.path.join(self.heron_java_home, 'bin/java'),
                      '-Xmx%!d(MISSING)M' %!h(MISSING)eap_size_mb,
                      '-Xms%!d(MISSING)M' %!h(MISSING)eap_size_mb,
                      '-Xmn%!d(MISSING)M' %!x(MISSING)mn_size,
                      '-XX:MaxPermSize=%!d(MISSING)M' %!p(MISSING)erm_gen_size_mb,
                      '-XX:PermSize=%!d(MISSING)M' %!p(MISSING)erm_gen_size_mb,
                      '-XX:ReservedCodeCacheSize=%!d(MISSING)M' %!c(MISSING)ode_cache_size_mb,
                      '-XX:+CMSScavengeBeforeRemark',
                      '-XX:TargetSurvivorRatio=90',
def _get_java_instance_cmd(self, instance_info):
      retval[instance_id] = instance_cmd
    return retval

  # Returns the processes for each Python Heron Instance
  def _get_python_instance_cmd(self, instance_info):
    # pylint: disable=fixme
def _run_process(self, name, cmd, env=None):
    self.processes.append(ProcessInfo(popen, name, cmd))
    return popen

class HeronExecutorTest(unittest.TestCase):
  """Unittest for Heron Executor"""

def get_expected_metricscachemgr_command():

  def get_expected_instance_command(component_name, instance_id, container_id):
    instance_name = "container_%!d(MISSING)_%!s(MISSING)_%!d(MISSING)" %!((MISSING)container_id, component_name, instance_id)
    return "heron_java_home/bin/java -Xmx320M -Xms320M -Xmn160M -XX:MaxPermSize=128M " \
           "-XX:PermSize=128M -XX:ReservedCodeCacheSize=64M -XX:+CMSScavengeBeforeRemark " \
           "-XX:TargetSurvivorRatio=90 -XX:+PrintCommandLineFlags -verbosegc -XX:+PrintGCDetails " \
           "-XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintGCCause " \
           "-XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=100M " \
private static int runSyncProcess(
    final StringBuilder builder = outputBuilder == null ? new StringBuilder() : outputBuilder;

    // Log the command for debugging
    LOG.log(Level.INFO, "Running synced process: ``{0}''''", String.join(" ", cmdline));
    ProcessBuilder pb = getProcessBuilder(isInheritIO, cmdline, workingDirectory, envs);
    /* combine input stream and error stream into stderr because
       1. this preserves order of process's stdout/stderr message
public static Process runASyncProcess(String command) {

  private static Process runASyncProcess(String[] command, File workingDirectory,
      Map<String, String> envs, String logFileUuid, boolean logStderr) {
    LOG.log(Level.INFO, "Running async process: ``{0}''''", String.join(" ", command));

    // the log file can help people to find out what happened between pb.start()
    // and the async process started
public static boolean extractPackage(
    return ret == 0;
  }

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# 1.9

- Fixes a bug that required a dependency on Servlet. [#13](https://github.com/alexnederlof/Jasper-report-maven-plugin/issues/13)
	<groupId>com.alexnederlof</groupId>
	<artifactId>jasperreports-plugin</artifactId>

	<parent>
		<groupId>org.sonatype.oss</groupId>
		<artifactId>oss-parent</artifactId>
		<version>9</version>
	</parent>

	<packaging>maven-plugin</packaging>
	<version>1.10-SNAPSHOT</version>
	<name>jasperreport-plugin</name>
	<description>A Jasper compiler plugin</description>
	<url>http://github.com/alexnederlof/Jasper-report-maven-plugin</url>


	<properties>
		<maven.compiler.source>1.6</maven.compiler.source>
		<maven.compiler.target>1.6</maven.compiler.target>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
	</properties>

	<prerequisites>
		<maven>3.0.4</maven>
	</prerequisites>

	<scm>
		<tag>HEAD</tag>
	</scm>

	<developers>
		<developer>
			<id>alexnederlof</id>
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.11</version>
			<scope>test</scope>
		</dependency>
		<dependency>
		<dependency>
			<groupId>org.codehaus.plexus</groupId>
			<artifactId>plexus-utils</artifactId>
			<version>3.0.17</version>
			<scope>test</scope>
		</dependency>

		<dependency>
			<groupId>net.sf.jasperreports</groupId>
			<artifactId>jasperreports</artifactId>
			<version>6.0.0</version>
		</dependency>

		<dependency>
		<dependency>
			<groupId>org.apache.maven</groupId>
			<artifactId>maven-plugin-api</artifactId>
			<version>3.0.4</version>
		</dependency>

		<dependency>
			<groupId>net.sf.jasperreports</groupId>
			<artifactId>jasperreports-fonts</artifactId>
			<version>6.0.0</version>
		</dependency>

		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>slf4j-simple</artifactId>
			<version>1.7.7</version>
		</dependency>
		<dependency>
			<groupId>org.codehaus.plexus</groupId>
			<artifactId>plexus-compiler-api</artifactId>
			<version>2.3</version>
		</dependency>
		<dependency>
			<groupId>javax.servlet</groupId>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-release-plugin</artifactId>
				<version>2.5</version>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-surefire-plugin</artifactId>
				<version>2.17</version>
				<configuration>
					<useFile>false</useFile>
				</configuration>
			</plugin>
		</plugins>
	</build>

	<licenses>
		<license>
			<name>The Apache Software License, Version 2.0</name>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
programDir=$(cd $(dirname $0);pwd)

if [ $# -eq 1 ]
 then java -jar ${programDir}/umlet.jar -filename="$1"
 else java -jar ${programDir}/umlet.jar "$@"
fi
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import static java.lang.Math.max;
import static java.lang.Math.min;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.NoSuchFileException;
import java.nio.file.OpenOption;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.nio.file.attribute.BasicFileAttributes;
import java.nio.file.attribute.FileTime;
import java.util.Set;
public long size() {
  }

  InputStream newInputStream(Set<? extends OpenOption> options, Path path) throws IOException {
    boolean deleteOnClose = options.contains(StandardOpenOption.DELETE_ON_CLOSE);
    boolean sync = options.contains(StandardOpenOption.SYNC);
    return this.newInputStream(deleteOnClose, path);
  }

  OutputStream newOutputStream(Set<? extends OpenOption> options, Path path) throws IOException {
    boolean deleteOnClose = options.contains(StandardOpenOption.DELETE_ON_CLOSE);
    boolean append = options.contains(StandardOpenOption.APPEND);
    boolean sync = options.contains(StandardOpenOption.SYNC);
    if (append) {
      return this.newAppendingOutputStream(deleteOnClose, path);
    } else {
      boolean truncate = options.contains(StandardOpenOption.TRUNCATE_EXISTING);
      if (truncate) {
        this.truncate(0L);
      }
OutputStream newOutputStream(Set<? extends OpenOption> options, Path path) throw
  }

  BlockChannel newChannel(Set<? extends OpenOption> options, Path path) throws IOException {
    boolean append = options.contains(StandardOpenOption.APPEND);
    boolean readable = options.contains(StandardOpenOption.READ);
    boolean deleteOnClose = options.contains(StandardOpenOption.DELETE_ON_CLOSE);
    boolean sync = options.contains(StandardOpenOption.SYNC);
    if (append) {
      return this.newAppendingChannel(readable, deleteOnClose, path);
    } else {
      boolean writable = options.contains(StandardOpenOption.WRITE);
      if (writable) {
        boolean truncate = options.contains(StandardOpenOption.TRUNCATE_EXISTING);
        if (truncate) {
          this.truncate(0L);
        }
import static com.github.marschall.memoryfilesystem.IsAbsoluteMatcher.isAbsolute;
import static com.github.marschall.memoryfilesystem.IsAbsoluteMatcher.isRelative;
import static java.nio.charset.StandardCharsets.US_ASCII;
import static java.nio.file.LinkOption.NOFOLLOW_LINKS;
import static java.nio.file.StandardCopyOption.COPY_ATTRIBUTES;
import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;
public void writeSyncChannelTruncate() throws IOException, InterruptedException,
  }

  @Test
  public void writeAsyncChannelBasicMethods() throws IOException, InterruptedException, ExecutionException {
    FileSystem fileSystem = this.rule.getFileSystem();

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
android {
    lintOptions {
        disable 'InvalidPackage'
    }

    packagingOptions {
        exclude 'META-INF/services/javax.annotation.processing.Processor'
apply plugin: 'java'
apply plugin: 'idea'

configurations {
    provided
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
jdk:
git:
    submodules: false

# Use sed to replace the SSH URL with the public URL, then initialize submodules
before_install:
- sed -i 's/git@github.com:/https:\/\/github.com\//' .gitmodules
- git submodule update --init --recursive


  <!-- Any other property in build.properties can also be overridden. -->
  
  <property file="${user.home}/wpilib/wpilib.properties"/>
  <property file="build.properties"/>
  <property file="${user.home}/wpilib/java/${version}/ant/build.properties"/>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				<version>2.10.3</version>
				<configuration>
					<destDir>javadoc</destDir>
					<skip>false</skip>
				</configuration>
				<reportSets>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public short sendStream(ZirkId sender, ZirkEndPoint receiver, Stream stream,
     * <code>allowedIn</code> and <code>allowedOut</code>, which restrict the messages that can flow
     * into and out of the sphere via the pipe to just those messages belonging to explicitly listed
     * {@link com.bezirk.middleware.messages.ProtocolRole ProtocolRoles's}.
     * <p><mark>TODO:</mark> What happens if you try to use an unauthorized pipe?</p>
     *
     * @param requester  id of Zirk requesting the pipe, as returned by {@link #registerZirk(String)}
     * @param pipe       the pipe the Zirk wants permission to use
import com.google.gson.Gson;

/**
 * A pipe is a user-authorized communication channel used to send messages from a Zirk
 * to a non-Bezirk endpoint on the Internet or between one Zirk and another Zirk in a separate
 * sphere (i.e. pipes allow Zirks that do not share spheres to communicate). Pipes have security
 * policies associated with them, where the policies are instantiations of
 * {@link PipePolicy}. To initiate the authorization process, a Zirk must call
 * {@link com.bezirk.middleware.Bezirk#requestPipeAuthorization(ZirkId, Pipe, PipePolicy, PipePolicy, BezirkListener)}.
 */
public class Pipe {
    protected String type = getClass().getSimpleName();
import java.util.Set;

/**
 * Base class for (1) defining the {@link ProtocolRole ProtocolRoles} that may be transmitted via
 * a pipe and (2) documenting the rationale for allowing each role. These policies may be displayed
 * to the user to help them decide whether or not they want to allow the use of a particular pipe.

/**
 * MainService for uhu-pc which controls the uhu stack
 *
 * @modified AJC6KOR
 */
public class MainService {
    private static final Logger logger = LoggerFactory

/**
 * Hold the Uhu Config
 * <p/>
 * At the moment it holds the data about Uhu PC TODO: Move this file to
 * java-common so that all the configurations are inside this module.
 */
public class UhuConfig {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Require-Bundle: org.eclipse.ui,
 org.jboss.reddeer.swt;bundle-version="[0.8,0.9)",
 org.jboss.reddeer.core;bundle-version="[0.8,0.9)",
 org.jboss.reddeer.common;bundle-version="[0.8,0.9)"
Bundle-RequiredExecutionEnvironment: JavaSE-1.8
Bundle-ActivationPolicy: lazy
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
public static IndexData findIndexFile(File javadocDir) throws BuilderException {
                System.err.println(String.format("Unknown type found. Please submit a bug report. (Text: %!s(MISSING), Name: %!s(MISSING), className: %!s(MISSING))", text, name, className));
                continue;
            }
            final String linkPath = e.attr("href");

            values.add(new SearchIndexValue(name, type, linkPath));
        }
        return values;
    }
public static IndexData findIndexFile(File javadocDir) throws BuilderException {
                System.err.println(String.format("Unknown type found. Please submit a bug report. (Text: %!s(MISSING), Context: %!s(MISSING))", text, lastContext));
                continue;
            }
            final String linkPath = e.attr("href").replaceAll("\\.\\.\\/", "");

            values.add(new SearchIndexValue(text, type, linkPath));
        }
        return values;
    }
private static MatchType getMatchingType(String text, String className) {
        return null;
    }
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					<show>public</show>
					<doctitle>${javadoc-title}</doctitle>
					<use/>
				</configuration>
				<executions>
					<execution>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
language: java

jdk:
  - oraclejdk8
  - oraclejdk7
  - openjdk6

matrix:
  allow_failures:
    jdk:
      - oraclejdk7
      - openjdk6
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import com.badlogic.gdx.backends.lwjgl.LwjglFiles;
import com.badlogic.gdx.backends.lwjgl.LwjglPreferences;
import com.badlogic.gdx.files.FileHandle;
import com.crashinvaders.texturepackergui.App;
import org.lwjgl.LWJGLUtil;
import org.lwjgl.opengl.Display;

/**
 * Saves and loads window position and size across application shutdowns
 */
private void loadWindowParams(LwjglApplicationConfiguration configuration) {
        FileHandle file = new FileHandle(LwjglFiles.externalPath + configuration.preferencesDirectory + "/window_params.xml");
        if (!file.exists()) return;

        Preferences prefs = new LwjglPreferences(file);

        configuration.x = prefs.getInteger("x", configuration.x);
        configuration.y = prefs.getInteger("y", configuration.y);
        configuration.width = prefs.getInteger("width", configuration.width);
        configuration.height = prefs.getInteger("height", configuration.height);
    }

    private void saveWindowParams() {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.util.Set;

@SupportedAnnotationTypes("java.lang.Override") //processor is triggered by Override annotation
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class CallSuperProcessor extends AbstractProcessor {
	private Trees trees;

private boolean doesCallSuper (List list, String methodName) {

		return false;
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
stages:
    build_type: ant
    script: |-
      #!/bin/bash
      ant
- name: Deploy Stage
  inputs:
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	<packaging>eclipse-plugin</packaging>
	
	<profiles>
		<profile>
			<id>doclint-java8-disable</id>
	    		<activation>
				<javadoc.opts>-Xdoclint:none</javadoc.opts>
			</properties>
		</profile>
	</profiles>

	<build>
					<target>${mqttclient.java.version}</target>
				</configuration>
			</plugin>
			<!-- <plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-javadoc-plugin</artifactId>
				<version>2.10.3</version>
					</execution>
				</executions>
			</plugin>
			<plugin>
				<groupId>org.eclipse.tycho.extras</groupId>
				<artifactId>tycho-document-bundle-plugin</artifactId>
		        <executions>
	/**
	 * Creates a new ClientComms object, using the specified module to handle
	 * the network calls.
	 */
	public ClientComms(IMqttAsyncClient client, MqttClientPersistence persistence, MqttPingSender pingSender) throws MqttException {
		this.conState = DISCONNECTED;
void internalSend(MqttWireMessage message, MqttToken token) throws MqttException
	/**
	 * Sends a message to the broker if in connected state, but only waits for the message to be
	 * stored, before returning.
	 */
	public void sendNoWait(MqttWireMessage message, MqttToken token) throws MqttException {
		final String methodName = "sendNoWait";
public void close() throws MqttException {
	 * Sends a connect message and waits for an ACK or NACK.
	 * Connecting is a special case which will also start up the
	 * network connection, receive thread, and keep alive thread.
	 */
	public void connect(MqttConnectOptions options, MqttToken token) throws MqttException {
		final String methodName = "connect";
public void connectComplete( MqttConnack cack, MqttException mex) throws MqttExc
	 * an abnormal disconnection.  The method may be invoked multiple times
	 * in parallel as each thread when it receives an error uses this method
	 * to ensure that shutdown completes successfully.
	 */
	public void shutdownConnection(MqttToken token, MqttException reason) {
		final String methodName = "shutdownConnection";
public void disconnectForcibly(long quiesceTimeout, long disconnectTimeout) thro

	/**
	 * Disconnect the connection and reset all the states.
	 */
	public void disconnectForcibly(long quiesceTimeout, long disconnectTimeout, boolean sendDisconnectPacket) throws MqttException {
		// Allow current inbound and outbound work to complete
private void handleRunException(Exception ex) {
	/**
	 * When Automatic reconnect is enabled, we want ClientComs to enter the
	 * 'resting' state if disconnected. This will allow us to publish messages
	 * @param resting
	 */
	public void setRestingState(boolean resting) {
		this.resting = resting;
public void deleteBufferedMessage(int bufferIndex){
	/**
	 * When the client automatically reconnects, we want to send all messages from the
	 * buffer first before allowing the user to send any messages
	 * @throws MqttException 
	 */
	public void notifyReconnect() {
		final String methodName = "notifyReconnect";
	 * are in the process of being delivered will be delivered to the requested
	 * quality of service next time the client connects.  
	 * @param asyncActionToken associated with the action that has failed
	 */
	public void onFailure(IMqttToken asyncActionToken, Throwable exception);
}
 * <p>
 * It provides applications a simple programming interface to all features of the MQTT version 3.1
 * specification including:
 * <ul>
 * <li>connect
 * <li>publish
 * <li>subscribe
 * <li>unsubscribe
 * <li>disconnect
 * </ul>
 * </p>
 * <p>
 * There are two styles of MQTT client, this one and {@link IMqttClient}.
 * <ul>
 * <li>IMqttAsyncClient provides a set of non-blocking methods that return control to the
 * invoking application after initial validation of parameters and state. The main processing is
 * versions of the MQTT client. In most circumstances it is recommended to use IMqttAsyncClient
 * based clients which allow an application to mix both non-blocking and blocking calls. </li>
 * </ul>
 * </p>
 * <p>
 * An application is not restricted to using one style if an IMqttAsyncClient based client is used
 * as both blocking and non-blocking methods can be used in the same application. If an IMqttClient
 * <p>There are two forms of non-blocking method:
 * <ol>
 *   <li>
 *     <code><pre>
 *     IMqttToken token = asyncClient.method(parms)
 *     </pre></code>
 *     <p>In this form the method returns a token that can be used to track the
 *     progress of the action (method). The method provides a waitForCompletion()
 *     method that once invoked will block until the action completes. Once
 *     completed there are method on the token that can be used to check if the
 *     action completed successfully or not. For example
 * 	   to wait until a connect completes:
 *     <code><pre>
 *      IMqttToken conToken;
 *   	conToken = asyncClient.client.connect(conToken);
 *     ... do some work...
 *   	conToken.waitForCompletion();
 *     </pre></code>
 *	   </p>
 *     <p>To turn a method into a blocking invocation the following form can be used:
 *     <code><pre>
 *     IMqttToken token;
 *     token = asyncClient.method(parms).waitForCompletion();
 *     </pre></code>

 *   </li>
 *
 *   <li>
 *     <code><pre>
 *     IMqttToken token method(parms, Object userContext, IMqttActionListener callback)
 *     </pre></code>
 *     <p>In this form a callback is registered with the method. The callback will be
 *     notified when the action succeeds or fails. The callback is invoked on the thread
 *     managed by the MQTT client so it is important that processing is minimised in the
 *     callback. If not the operation of the MQTT client will be inhibited. For example
 *     to be notified (called back) when a connect completes:
 *     <code><pre>
 *     	IMqttToken conToken;
 *	    conToken = asyncClient.connect("some context",new new MqttAsyncActionListener() {
 *			public void onSuccess(IMqttToken asyncActionToken) {
 *				log ("connect failed" +exception);
 *			}
 *		  });
 *      </pre></code>
 *	    An optional context object can be passed into the method which will then be made
 *      available in the callback. The context is stored by the MQTT client) in the token
 *      which is then returned to the invoker. The token is provided to the callback methods
 *      where the context can then be accessed.
	 * </p>
	 * <p>The method returns control before the connect completes. Completion can
	 * be tracked by:
	 * <ul>
	 * <li>Waiting on the returned token {@link IMqttToken#waitForCompletion()} or</li>
	 * <li>Passing in a callback {@link IMqttActionListener}</li>
	 * </ul>
	 * </p>
	 *
	 * @param options a set of connection parameters that override the defaults.
	 * @param userContext optional object for used to pass context to the callback. Use
	 * <p>This method must not be called from inside {@link MqttCallback} methods.</p>
	 * <p>The method returns control before the disconnect completes. Completion can
	 * be tracked by:
	 * <ul>
	 * <li>Waiting on the returned token {@link IMqttToken#waitForCompletion()} or</li>
	 * <li>Passing in a callback {@link IMqttActionListener}</li>
	 * </ul>
	 * </p>
	 *
	 * @param quiesceTimeout the amount of time in milliseconds to allow for
	 * existing work to finish before disconnecting.  A value of zero or less
public IMqttDeliveryToken publish(String topic, byte[] payload, int qos,
	 * client and will be delivered on a background thread.
	 * In the event the connection fails or the client stops. Messages will be delivered to the
	 * requested quality of service once the connection is re-established to the server on condition that:
	 * <ul>
	 * <li>The connection is re-established with the same clientID
	 * <li>The original connection was made with (@link MqttConnectOptions#setCleanSession(boolean)}
public IMqttDeliveryToken publish(String topic, byte[] payload, int qos,
	 * set to false
	 * <li>Depending when the failure occurs QoS 0 messages may not be delivered.
	 * </ul>
	 * </p>
	 *
	 * <p>When building an application,
	 * the design of the topic tree should take into account the following principles
public IMqttDeliveryToken publish(String topic, byte[] payload, int qos,
	 * 	<li>A leading "/" creates a distinct topic.  For example, <em>/finance</em> is
	 * 	different from <em>finance</em>. <em>/finance</em> matches "+/+" and "/+", but
	 * 	not "+".</li>
	 * 	<li>Do not include the null character (Unicode <samp class="codeph">\x0000</samp>) in
	 * 	any topic.</li>
	 * </ul>
	 *
	 * <p>The following principles apply to the construction and content of a topic
	 * tree:</p>
	 *
	 * <ul>
	 * 	<li>The length is limited to 64k but within that there are no limits to the
	 * 	number of levels in a topic tree.</li>
	 * 	<li>There can be any number of root nodes; that is, there can be any number
	 * 	of topic trees.</li>
	 * 	</ul>
	 * </p>
	 * <p>The method returns control before the publish completes. Completion can
	 * be tracked by:
	 * <ul>
	 * <li>Setting an {@link IMqttAsyncClient#setCallback(MqttCallback)} where the
	 * {@link MqttCallback#deliveryComplete(IMqttDeliveryToken)}
	 * method will be called.</li>
	 * <li>Waiting on the returned token {@link MqttToken#waitForCompletion()} or</li>
	 * <li>Passing in a callback {@link IMqttActionListener} to this method</li>
	 * </ul>
	 * </p>
	 *
	 * @param topic  to deliver the message to, for example "finance/stock/ibm".
	 * @param message to deliver to the server
public IMqttToken subscribe(String topicFilter, int qos, Object userContext, IMq
	 * <p>
	 * If (@link MqttConnectOptions#setCleanSession(boolean)} was set to true
	 * when when connecting to the server then the subscription remains in place
	 * until either:
	 * <ul>
	 * <li>The client disconnects</li>
	 * <li>An unsubscribe method is called to un-subscribe the topic</li>
	 * </li>
	 * </p>
	 * <p>
	 * If (@link MqttConnectOptions#setCleanSession(boolean)} was set to false
	 * when connecting to the server then the subscription remains in place
	 * until either:
	 * <ul>
	 * <li>An unsubscribe method is called to unsubscribe the topic</li>
	 * <li>The next time the client connects with cleanSession set to true</ul>
	 * </li>
	 * With cleanSession set to false the MQTT server will store messages on
	 * behalf of the client when the client is not connected. The next time the
	 * client connects with the <bold>same client ID</bold> the server will
	 * deliver the stored messages to the client.
	 * </p>
	 *
public IMqttToken subscribe(String topicFilter, int qos, Object userContext, IMq
	 * 	<dd><p>The number sign (#) is a wildcard character that matches
	 * 	any number of levels within a topic. For example, if you subscribe to
	 *  <span><span class="filepath">finance/stock/ibm/#</span></span>, you receive
	 * 	messages on these topics:
	 *  <pre>   finance/stock/ibm<br />   finance/stock/ibm/closingprice<br />   finance/stock/ibm/currentprice</pre>
	 *  </p>
	 *  <p>The multi-level wildcard
	 *  can represent zero or more levels. Therefore, <em>finance/#</em> can also match
	 * 	the singular <em>finance</em>, where <em>#</em> represents zero levels. The topic
public IMqttToken subscribe(String topicFilter, int qos, Object userContext, IMq
	 * 	For example, <em>finance/+</em> and <em>finance/+/ibm</em> are both valid.</span></p>
	 * 	</dd>
	 * </dl>
	 * </p>
	 * <p>The method returns control before the subscribe completes. Completion can
	 * be tracked by:
	 * <ul>
	 * <li>Waiting on the supplied token {@link MqttToken#waitForCompletion()} or</li>
	 * <li>Passing in a callback {@link IMqttActionListener} to this method</li>
	 * </ul>
	 * </p>
	 *
	 * @param topicFilters one or more topics to subscribe to, which can include wildcards
	 * @param qos the maximum quality of service to subscribe each topic at.Messages
public IMqttToken unsubscribe(String topicFilter, Object userContext, IMqttActio
	 * </p>
	 * <p>The method returns control before the unsubscribe completes. Completion can
	 * be tracked by:
	 * <ul>
	 * <li>Waiting on the returned token {@link MqttToken#waitForCompletion()} or</li>
	 * <li>Passing in a callback {@link IMqttActionListener} to this method</li>
	 * </ul>
	 * </p>
	 *
	 * @param topicFilters one or more topics to unsubscribe from. Each topicFilter
	 * must match one specified on an earlier subscribe.
public IMqttToken unsubscribe(String[] topicFilters, Object userContext, IMqttAc
	 * Sets a callback listener to use for events that happen asynchronously.
	 * <p>There are a number of events that the listener will be notified about.
	 * These include:
	 * <ul>
	 * <li>A new message has arrived and is ready to be processed</li>
	 * <li>The connection to the server has been lost</li>
	 * <li>Delivery of a message to the server has completed</li>
	 * </ul>
	 * </p>
	 * <p>Other events that track the progress of an individual operation such
	 * as connect and subscribe can be tracked using the {@link MqttToken} returned from
	 * each non-blocking method or using setting a {@link IMqttActionListener} on the
public IMqttToken unsubscribe(String[] topicFilters, Object userContext, IMqttAc
	 * sent.  The default behaviour, when manualAcks is false, is to send the MQTT
	 * acknowledgements automatically at the successful completion of the messageArrived
	 * callback method.
	 * @param manualAcks
	 */
	public void setManualAcks(boolean manualAcks);
	
public IMqttToken unsubscribe(String[] topicFilters, Object userContext, IMqttAc
	 * This will cause the MQTT acknowledgement to be sent to the server.
	 * @param messageId the MQTT message id to be acknowledged
	 * @param qos the MQTT QoS of the message to be acknowledged
	 * @throws MqttException
	 */
	public void messageArrivedComplete(int messageId, int qos) throws MqttException;

 * Enables an application to communicate with an MQTT server using blocking methods.
 * <p>
 * This interface allows applications to utilize all features of the MQTT version 3.1
 * specification including:
 * <ul>
 * <li>connect
 * <li>publish
 * <li>subscribe
 * <li>unsubscribe
 * <li>disconnect
 * </ul>
 * </p>
 * <p>
 * There are two styles of MQTT client, this one and {@link IMqttAsyncClient}.
 * <ul>
 * <li>IMqttClient provides a set of methods that block and return control to the application
 * program once the MQTT action has completed.</li>
 * programs and graphical programs where issuing methods that take time to complete on the the
 * main or GUI thread can cause problems.</li>
 * </ul>
 * </p>
 * <p>
 * The non-blocking client can also be used in a blocking form by turning a non-blocking
 * method into a blocking invocation using the following pattern:
 *     <code><pre>
 *     IMqttToken token;
 *     token = asyncClient.method(parms).waitForCompletion();
 *     </pre></code>
 * Using the non-blocking client allows an application to use a mixture of blocking and
 * non-blocking styles. Using the blocking client only allows an application to use one
 * style. The blocking client provides compatibility with earlier versions
	 * This method must not be called from inside {@link MqttCallback} methods.
	 * </p>
	 *
	 * @see #disconnect(long)
	 */
  public void disconnect() throws MqttException;

	 *
	 * @param topicFilter the topic to subscribe to, which can include wildcards.
	 * @throws MqttException if there was an error registering the subscription.
	 */
  public void subscribe(String topicFilter) throws MqttException, MqttSecurityException;

	 * If (@link MqttConnectOptions#setCleanSession(boolean)} was set to true
	 * when when connecting to the server then the subscription remains in place
	 * until either:
	 * <ul>
	 * <li>The client disconnects</li>
	 * <li>An unsubscribe method is called to un-subscribe the topic</li>
	 * </li>
	 * </p>
	 * <p>
	 * If (@link MqttConnectOptions#setCleanSession(boolean)} was set to false
	 * when when connecting to the server then the subscription remains in place
	 * until either:
	 * <ul>
	 * <li>An unsubscribe method is called to unsubscribe the topic</li>
	 * <li>The client connects with cleanSession set to true</ul>
	 * </li>
	 * With cleanSession set to false the MQTT server will store messages on
	 * behalf of the client when the client is not connected. The next time the
	 * client connects with the <bold>same client ID</bold> the server will
	 * deliver the stored messages to the client.
	 * </p>
	 *
	 * 	<dd><p>The number sign (#) is a wildcard character that matches
	 * 	any number of levels within a topic. For example, if you subscribe to
	 *  <span><span class="filepath">finance/stock/ibm/#</span></span>, you receive
	 * 	messages on these topics:
	 *  <pre>   finance/stock/ibm<br />   finance/stock/ibm/closingprice<br />   finance/stock/ibm/currentprice</pre>
	 *  </p>
	 *  <p>The multi-level wildcard
	 *  can represent zero or more levels. Therefore, <em>finance/#</em> can also match
	 * 	the singular <em>finance</em>, where <em>#</em> represents zero levels. The topic
	 * 	For example, <em>finance/+</em> and <em>finance/+/ibm</em> are both valid.</span></p>
	 * 	</dd>
	 * </dl>
	 * </p>
	 *
	 * <p>This is a blocking method that returns once subscribe completes</p>
	 *
	 * @param topicFilter the topic to subscribe to, which can include wildcards.
	 * @param messageListener a callback to handle incoming messages
	 * @throws MqttException if there was an error registering the subscription.
	 */
public void subscribe(String topicFilter, IMqttMessageListener messageListener) throws MqttException, MqttSecurityException;

	 * <p>
	 * If (@link MqttConnectOptions#setCleanSession(boolean)} was set to true
	 * when when connecting to the server then the subscription remains in place
	 * until either:
	 * <ul>
	 * <li>The client disconnects</li>
	 * <li>An unsubscribe method is called to un-subscribe the topic</li>
	 * </li>
	 * </p>
	 * <p>
	 * If (@link MqttConnectOptions#setCleanSession(boolean)} was set to false
	 * when when connecting to the server then the subscription remains in place
	 * until either:
	 * <ul>
	 * <li>An unsubscribe method is called to unsubscribe the topic</li>
	 * <li>The client connects with cleanSession set to true</ul>
	 * </li>
	 * With cleanSession set to false the MQTT server will store messages on
	 * behalf of the client when the client is not connected. The next time the
	 * client connects with the <bold>same client ID</bold> the server will
	 * deliver the stored messages to the client.
	 * </p>
	 *
	 * 	<dd><p>The number sign (#) is a wildcard character that matches
	 * 	any number of levels within a topic. For example, if you subscribe to
	 *  <span><span class="filepath">finance/stock/ibm/#</span></span>, you receive
	 * 	messages on these topics:
	 *  <pre>   finance/stock/ibm<br />   finance/stock/ibm/closingprice<br />   finance/stock/ibm/currentprice</pre>
	 *  </p>
	 *  <p>The multi-level wildcard
	 *  can represent zero or more levels. Therefore, <em>finance/#</em> can also match
	 * 	the singular <em>finance</em>, where <em>#</em> represents zero levels. The topic
	 * 	For example, <em>finance/+</em> and <em>finance/+/ibm</em> are both valid.</span></p>
	 * 	</dd>
	 * </dl>
	 * </p>
	 *
	 * <p>This is a blocking method that returns once subscribe completes</p>
	 *
	 * <p>
	 * If (@link MqttConnectOptions#setCleanSession(boolean)} was set to true
	 * when when connecting to the server then the subscription remains in place
	 * until either:
	 * <ul>
	 * <li>The client disconnects</li>
	 * <li>An unsubscribe method is called to un-subscribe the topic</li>
	 * </li>
	 * </p>
	 * <p>
	 * If (@link MqttConnectOptions#setCleanSession(boolean)} was set to false
	 * when when connecting to the server then the subscription remains in place
	 * until either:
	 * <ul>
	 * <li>An unsubscribe method is called to unsubscribe the topic</li>
	 * <li>The client connects with cleanSession set to true</ul>
	 * </li>
	 * With cleanSession set to false the MQTT server will store messages on
	 * behalf of the client when the client is not connected. The next time the
	 * client connects with the <bold>same client ID</bold> the server will
	 * deliver the stored messages to the client.
	 * </p>
	 *
	 * 	<dd><p>The number sign (#) is a wildcard character that matches
	 * 	any number of levels within a topic. For example, if you subscribe to
	 *  <span><span class="filepath">finance/stock/ibm/#</span></span>, you receive
	 * 	messages on these topics:
	 *  <pre>   finance/stock/ibm<br />   finance/stock/ibm/closingprice<br />   finance/stock/ibm/currentprice</pre>
	 *  </p>
	 *  <p>The multi-level wildcard
	 *  can represent zero or more levels. Therefore, <em>finance/#</em> can also match
	 * 	the singular <em>finance</em>, where <em>#</em> represents zero levels. The topic
	 * 	For example, <em>finance/+</em> and <em>finance/+/ibm</em> are both valid.</span></p>
	 * 	</dd>
	 * </dl>
	 * </p>
	 *
	 * <p>This is a blocking method that returns once subscribe completes</p>
	 *
	 * <p>
	 * If (@link MqttConnectOptions#setCleanSession(boolean)} was set to true
	 * when when connecting to the server then the subscription remains in place
	 * until either:
	 * <ul>
	 * <li>The client disconnects</li>
	 * <li>An unsubscribe method is called to un-subscribe the topic</li>
	 * </li>
	 * </p>
	 * <p>
	 * If (@link MqttConnectOptions#setCleanSession(boolean)} was set to false
	 * when when connecting to the server then the subscription remains in place
	 * until either:
	 * <ul>
	 * <li>An unsubscribe method is called to unsubscribe the topic</li>
	 * <li>The client connects with cleanSession set to true</ul>
	 * </li>
	 * With cleanSession set to false the MQTT server will store messages on
	 * behalf of the client when the client is not connected. The next time the
	 * client connects with the <bold>same client ID</bold> the server will
	 * deliver the stored messages to the client.
	 * </p>
	 *
	 * 	<dd><p>The number sign (#) is a wildcard character that matches
	 * 	any number of levels within a topic. For example, if you subscribe to
	 *  <span><span class="filepath">finance/stock/ibm/#</span></span>, you receive
	 * 	messages on these topics:
	 *  <pre>   finance/stock/ibm<br />   finance/stock/ibm/closingprice<br />   finance/stock/ibm/currentprice</pre>
	 *  </p>
	 *  <p>The multi-level wildcard
	 *  can represent zero or more levels. Therefore, <em>finance/#</em> can also match
	 * 	the singular <em>finance</em>, where <em>#</em> represents zero levels. The topic
	 * 	For example, <em>finance/+</em> and <em>finance/+/ibm</em> are both valid.</span></p>
	 * 	</dd>
	 * </dl>
	 * </p>
	 *
	 * <p>This is a blocking method that returns once subscribe completes</p>
	 *
	 * Delivers a message to the server at the requested quality of service and returns control
	 * once the message has been delivered. In the event the connection fails or the client
	 * stops, any messages that are in the process of being delivered will be delivered once
	 * a connection is re-established to the server on condition that:
	 * <ul>
	 * <li>The connection is re-established with the same clientID
	 * <li>The original connection was made with (@link MqttConnectOptions#setCleanSession(boolean)}
	 * set to false
	 * <li>The connection is re-established with (@link MqttConnectOptions#setCleanSession(boolean)}
	 * set to false
	 * </ul>
	 * </p>
	 * <p>In the event that the connection breaks or the client stops it is still possible to determine
	 * when the delivery of the message completes. Prior to re-establishing the connection to the server:
	 * <ul>
	 * <li>Register a {@link #setCallback(MqttCallback)} callback on the client and the delivery complete
	 * callback will be notified once a delivery of a message completes
	 * <li>or call {@link #getPendingDeliveryTokens()} which will return a token for each message that
	 * is in-flight.  The token can be used to wait for delivery to complete.
	 * </ul>
	 * </p>
	 *
	 * <p>When building an application,
	 * the design of the topic tree should take into account the following principles
	 * 	<li>A leading "/" creates a distinct topic.  For example, <em>/finance</em> is
	 * 	different from <em>finance</em>. <em>/finance</em> matches "+/+" and "/+", but
	 * 	not "+".</li>
	 * 	<li>Do not include the null character (Unicode<samp class="codeph"> \x0000</samp>) in
	 * 	any topic.</li>
	 * </ul>
	 *
	 * 	<li>There can be any number of root nodes; that is, there can be any number
	 * 	of topic trees.</li>
	 * 	</ul>
	 * </p>
	 *
	 * <p>This is a blocking method that returns once publish completes</p>	 *
	 *

	/**
	 * Sets the callback listener to use for events that happen asynchronously.
	 * <p>There are a number of events that listener will be notified about. These include
	 * <ul>
	 * <li>A new message has arrived and is ready to be processed</li>
	 * <li>The connection to the server has been lost</li>
	 * <li>Delivery of a message to the server has completed.</li>
	 * </ul>
	 * </p>
	 * <p>Other events that track the progress of an individual operation such
	 * as connect and subscribe can be tracked using the {@link MqttToken} passed to the
	 * operation<p>

	/**
	 * Get a topic object which can be used to publish messages.
	 * <p>An alternative method that should be used in preference to this one when publishing a message is:
	 * <ul>
	 * <li>{@link MqttClient#publish(String, MqttMessage)} to publish a message in a blocking manner
	 * <li>or use publish methods on the non-blocking client like {@link IMqttAsyncClient#publish(String, MqttMessage, Object, IMqttActionListener)}
	 * </ul>
	 * </p>
	 * <p>When building an application,
	 * the design of the topic tree should take into account the following principles
	 * of topic name syntax and semantics:</p>
	 * 	<li>A leading "/" creates a distinct topic.  For example, <em>/finance</em> is
	 * 	different from <em>finance</em>. <em>/finance</em> matches "+/+" and "/+", but
	 * 	not "+".</li>
	 * 	<li>Do not include the null character (Unicode<samp class="codeph"> \x0000</samp>) in
	 * 	any topic.</li>
	 * </ul>
	 *
	 * 	number of levels in a topic tree.</li>
	 * 	<li>There can be any number of root nodes; that is, there can be any number
	 * 	of topic trees.</li>
	 * 	</ul>
	 * </p>
	 *
	 * @param topic the topic to use, for example "finance/stock/ibm".
	 * @return an MqttTopic object, which can be used to publish messages to
	 * sent.  The default behaviour, when manualAcks is false, is to send the MQTT
	 * acknowledgements automatically at the successful completion of the messageArrived
	 * callback method.
	 * @param manualAcks
	 */
	public void setManualAcks(boolean manualAcks);
	
	 * This will cause the MQTT acknowledgement to be sent to the server.
	 * @param messageId the MQTT message id to be acknowledged
	 * @param qos the MQTT QoS of the message to be acknowledged
	 * @throws MqttException
	 */
	public void messageArrivedComplete(int messageId, int qos) throws MqttException;

 * be called withe delivery token being passed as a parameter. 
 * </ul>
 * <p> 
 * An action is in progress until either:
 * <ul>
 * <li>isComplete() returns true or 
 * <li>getException() is not null. If a client shuts down before delivery is complete. 
 * an exception is returned.  As long as the Java Runtime is not stopped a delivery token
 * is valid across a connection disconnect and reconnect. In the event the client 
 * is shut down the getPendingDeliveryTokens method can be used once the client is 
 * restarted to obtain a list of delivery tokens for inflight messages.
 * </ul>
 * </p>
 * 
 */

 * An IMqttToken is used to track the state of the operation. An application can use the
 * token to wait for an operation to complete. A token is passed to callbacks
 * once the operation completes and provides context linking it to the original
 * request. A token is associated with a single operation.<p>
 * <p>
 * An action is in progress until either:
 * <ul>
 * <li>isComplete() returns true or
 * <li>getException() is not null.
 * </ul>
 * </p>
 *
 */
public interface IMqttToken {
	 * and in the case where it failed. If the action failed {@link #getException()} will
	 * be non null.
	 * </p>
	 */
	public boolean isComplete();

	/**
	 * Returns the MQTT client that is responsible for processing the asynchronous
	 * action
	 */
	public IMqttAsyncClient getClient();

	 * connect, disconnect and ping operations as there can only ever
	 * be one of these outstanding at a time. For other operations
	 * the MQTT message id flowed over the network.
	 */
	public int getMessageId();
	
	/**
	 * Returns the granted QoS list from a suback 
	 */
	public int[] getGrantedQos();
	
	/**
	 * Returns the session present flag from a connack 
	 */
	public boolean getSessionPresent();
	
	/**
	 * Returns the response wire message
	 */
	public MqttWireMessage getResponse();

 * MQTT action completes on a background thread.
 * This implementation is compatible with all Java SE runtimes from 1.4.2 and up.
 * </p>
 * <p>An application can connect to an MQTT server using:
 * <ul>
 * <li>A plain TCP socket
 * <li>A secure SSL/TLS socket
 * </ul>
 * </p>
 * <p>To enable messages to be delivered even across network and client restarts
 * messages need to be safely stored until the message has been delivered at the requested
 * quality of service. A pluggable persistence mechanism is provided to store the messages.
	 * <p>The address of the server to connect to is specified as a URI. Two types of
	 * connection are supported <code>tcp://</code> for a TCP connection and
	 * <code>ssl://</code> for a TCP connection secured by SSL/TLS.
	 * For example:
	 * <ul>
	 * 	<li><code>tcp://localhost:1883</code></li>
	 * 	<li><code>ssl://localhost:8883</code></li>
	 * </ul>
	 * If the port is not specified, it will
	 * default to 1883 for <code>tcp://</code>" URIs, and 8883 for <code>ssl://</code> URIs.
	 * </p>
public MqttAsyncClient(String serverURI, String clientId) throws MqttException {
		this(serverURI,clientId, new MqttDefaultFilePersistence());
	}
	
	public MqttAsyncClient(String serverURI, String clientId, MqttClientPersistence persistence) throws MqttException {
		this(serverURI,clientId, persistence, new TimerPingSender());
	}
public MqttAsyncClient(String serverURI, String clientId, MqttClientPersistence
	 * <p>The address of the server to connect to is specified as a URI. Two types of
	 * connection are supported <code>tcp://</code> for a TCP connection and
	 * <code>ssl://</code> for a TCP connection secured by SSL/TLS.
	 * For example:
	 * <ul>
	 * 	<li><code>tcp://localhost:1883</code></li>
	 * 	<li><code>ssl://localhost:8883</code></li>
	 * </ul>
	 * If the port is not specified, it will
	 * default to 1883 for <code>tcp://</code>" URIs, and 8883 for <code>ssl://</code> URIs.
	 * </p>
public MqttAsyncClient(String serverURI, String clientId, MqttClientPersistence
	 * @param clientId a client identifier that is unique on the server being connected to
 	 * @param persistence the persistence class to use to store in-flight message. If null then the
 	 * default persistence mechanism is used
	 * @throws IllegalArgumentException if the URI does not start with
	 * "tcp://", "ssl://" or "local://"
	 * @throws IllegalArgumentException if the clientId is null or is greater than 65535 characters in length
public MqttAsyncClient(String serverURI, String clientId, MqttClientPersistence
	

	/**
	 * @param ch
	 * @return returns 'true' if the character is a high-surrogate code unit
	 */
	protected static boolean Character_isHighSurrogate(char ch) {
protected static boolean Character_isHighSurrogate(char ch) {
	 * each of the supplied URIs
	 *
	 * @param address the URI for the server.
	 * @return a network module appropriate to the specified address.
	 */

	// may need an array of these network modules

	protected NetworkModule[] createNetworkModules(String address, MqttConnectOptions options) throws MqttException, MqttSecurityException {
		final String methodName = "createNetworkModules";
		// @TRACE 116=URI={0}
public void disconnectForcibly(long quiesceTimeout, long disconnectTimeout) thro
		comms.disconnectForcibly(quiesceTimeout, disconnectTimeout);
	}

        public void disconnectForcibly(long quiesceTimeout, long disconnectTimeout, boolean sendDisconnectPacket) throws MqttException {
                comms.disconnectForcibly(quiesceTimeout, disconnectTimeout, sendDisconnectPacket);
        }

	/* (non-Javadoc)
	 * @see IMqttAsyncClient#isConnected()
public String getCurrentServerURI(){

	/**
	 * Get a topic object which can be used to publish messages.
	 * <p>There are two alternative methods that should be used in preference to this one when publishing a message:
	 * <ul>
	 * <li>{@link MqttAsyncClient#publish(String, MqttMessage, MqttDeliveryToken)} to publish a message in a non-blocking manner or
	 * <li>{@link MqttClient#publishBlock(String, MqttMessage, MqttDeliveryToken)} to publish a message in a blocking manner
	 * </ul>
	 * </p>
	 * <p>When you build an application,
	 * the design of the topic tree should take into account the following principles
	 * of topic name syntax and semantics:</p>
public String getCurrentServerURI(){
	 * 	<li>A leading "/" creates a distinct topic.  For example, <em>/finance</em> is
	 * 	different from <em>finance</em>. <em>/finance</em> matches "+/+" and "/+", but
	 * 	not "+".</li>
	 * 	<li>Do not include the null character (Unicode<samp class="codeph"> \x0000</samp>) in
	 * 	any topic.</li>
	 * </ul>
	 *
public String getCurrentServerURI(){
	 * 	<li>There can be any number of root nodes; that is, there can be any number
	 * 	of topic trees.</li>
	 * 	</ul>
	 * </p>
	 *
	 * @param topic the topic to use, for example "finance/stock/ibm".
	 * @return an MqttTopic object, which can be used to publish messages to
public IMqttDeliveryToken publish(String topic, MqttMessage message) throws Mqtt
		return this.publish(topic, message, null, null);
	}

	/* (non-Javadoc)
	 * @see org.eclipse.paho.client.mqttv3.IMqttAsyncClient#publish(java.lang.String, org.eclipse.paho.client.mqttv3.MqttMessage, java.lang.Object, org.eclipse.paho.client.mqttv3.IMqttActionListener)
	 */
public IMqttDeliveryToken publish(String topic, MqttMessage message, Object user

	/**
	 * User triggered attempt to reconnect
	 * @throws MqttException
	 */
	public void reconnect() throws MqttException {
		final String methodName = "reconnect";
public void run() {
	
	/**
	 * Sets the DisconnectedBufferOptions for this client
	 * @param bufferOpts
	 */
	public void setBufferOpts(DisconnectedBufferOptions bufferOpts) {
		this.comms.setDisconnectedMessageBuffer(new DisconnectedMessageBuffer(bufferOpts));
	}
	
	public int getBufferedMessageCount(){
		return this.comms.getBufferedMessageCount();
	}
	
	public MqttMessage getBufferedMessage(int bufferIndex){
		return this.comms.getBufferedMessage(bufferIndex);
	}
	
	public void deleteBufferedMessage(int bufferIndex){
		this.comms.deleteBufferedMessage(bufferIndex);
	}
public void close() throws MqttException {

	/**
	 * Return a debug object that can be used to help solve problems.
	 */
	public Debug getDebug() {
		return new Debug(clientId,comms);
 * actions block until they have completed (or timed out).
 * This implementation is compatible with all Java SE runtimes from 1.4.2 and up.
 * </p>
 * <p>An application can connect to an MQTT server using:
 * <ul>
 * <li>A plain TCP socket
 * <li>An secure SSL/TLS socket
 * </ul>
 * </p>
 * <p>To enable messages to be delivered even across network and client restarts
 * messages need to be safely stored until the message has been delivered at the requested
 * quality of service. A pluggable persistence mechanism is provided to store the messages.
	 * <p>The address of the server to connect to is specified as a URI. Two types of
	 * connection are supported <code>tcp://</code> for a TCP connection and
	 * <code>ssl://</code> for a TCP connection secured by SSL/TLS.
	 * For example:
	 * <ul>
	 * 	<li><code>tcp://localhost:1883</code></li>
	 * 	<li><code>ssl://localhost:8883</code></li>
	 * </ul>
	 * If the port is not specified, it will
	 * default to 1883 for <code>tcp://</code>" URIs, and 8883 for <code>ssl://</code> URIs.
	 * </p>
public MqttClient(String serverURI, String clientId) throws MqttException {
	 * <p>The address of the server to connect to is specified as a URI. Two types of
	 * connection are supported <code>tcp://</code> for a TCP connection and
	 * <code>ssl://</code> for a TCP connection secured by SSL/TLS.
	 * For example:
	 * <ul>
	 * 	<li><code>tcp://localhost:1883</code></li>
	 * 	<li><code>ssl://localhost:8883</code></li>
	 * </ul>
	 * If the port is not specified, it will
	 * default to 1883 for <code>tcp://</code>" URIs, and 8883 for <code>ssl://</code> URIs.
	 * </p>
public void disconnectForcibly(long quiesceTimeout, long disconnectTimeout) thro
		aClient.disconnectForcibly(quiesceTimeout, disconnectTimeout);
	}

        public void disconnectForcibly(long quiesceTimeout, long disconnectTimeout, boolean sendDisconnectPacket) throws MqttException {
                aClient.disconnectForcibly(quiesceTimeout, disconnectTimeout, sendDisconnectPacket);
        }

	/*
	 * @see IMqttClient#subscribe(String)
public void publish(String topic, MqttMessage message) throws MqttException,
	 * Set the maximum time to wait for an action to complete.
	 * <p>Set the maximum time to wait for an action to complete before
	 * returning control to the invoking application. Control is returned
	 * when:
	 * <ul>
	 * <li>the action completes
	 * <li>or when the timeout if exceeded
	 * <li>or when the client is disconnect/shutdown
	 * <ul>
	 * The default value is -1 which means the action will not timeout.
	 * In the event of a timeout the action carries on running in the
	 * background until it completes. The timeout is used on methods that
	 * block while the action is in progress.
	 * </p>
	 * @param timeToWaitInMillis before the action times out. A value or 0 or -1 will wait until
	 * the action finishes and not timeout.
	 */
	public void setTimeToWait(long timeToWaitInMillis) throws IllegalArgumentException{
		if (timeToWaitInMillis < -1) {
public void setTimeToWait(long timeToWaitInMillis) throws IllegalArgumentExcepti

	/**
	 * Return the maximum time to wait for an action to complete.
	 * @see MqttClient#setTimeToWait(long)
	 */
	public long getTimeToWait() {
public static String generateClientId() {
		return MqttAsyncClient.generateClientId();
	}
	
	public void reconnect() throws MqttException {
		aClient.reconnect();
	}

	/**
	 * Return a debug object that can be used to help solve problems.
	 */
	public Debug getDebug() {
		return (aClient.getDebug());
	/**
	 * Close the persistent store that was previously opened.
	 * This will be called when a client application disconnects from the broker.
	 * @throws MqttPersistenceException 
	 */	
	public void close() throws MqttPersistenceException;

	
	/**
	 * Remove the data for the specified key.
	 */
	public void remove(String key) throws MqttPersistenceException;

	/**
	 * Returns an Enumeration over the keys in this persistent data store.
	 * @return an enumeration of {@link String} objects.
	 */
	public Enumeration keys() throws MqttPersistenceException;
	
	/**
	 * Clears persistence, so that it no longer contains any persisted data.
	 */
	public void clear() throws MqttPersistenceException;
	
	/**
	 * Returns whether or not data is persisted using the specified key.
	 * @param key the key for data, which was used when originally saving it.
	 */
	public boolean containsKey(String key) throws MqttPersistenceException;
}
	 * The default MqttVersion is 3.1.1 first, dropping back to 3.1 if that fails
	 */
	public static final int MQTT_VERSION_DEFAULT = 0;
	public static final int MQTT_VERSION_3_1 = 3;
	public static final int MQTT_VERSION_3_1_1 = 4;

	protected static final int URI_TYPE_TCP = 0;
public MqttConnectOptions() {

	/**
	 * Sets the password to use for the connection.
	 */
	public void setPassword(char[] password) {
		this.password = password;
public String getUserName() {

	/**
	 * Sets the user name to use for the connection.
	 * @throws IllegalArgumentException if the user name is blank or only
	 * contains whitespace characters.
	 */
private void validateWill(String dest, Object payload) {

	/**
	 * Sets up the will information, based on the supplied parameters.
	 */
	protected void setWill(String topic, MqttMessage msg, int qos, boolean retained) {
		willDestination = topic;
public int getMqttVersion() {
	 * A value of 0 disables keepalive processing in the client.
	 * <p>The default value is 60 seconds</p>
	 *
	 * @param keepAliveInterval the interval, measured in seconds, must be >= 0.
	 */
	public void setKeepAliveInterval(int keepAliveInterval)throws IllegalArgumentException {
		if (keepAliveInterval <0 ) {
public int getMaxInflight() {
     * Sets the "max inflight". 
     * please increase this value in a high traffic environment.
     * <p>The default value is 10</p>
     * @param maxInflight
     */
    public void setMaxInflight(int maxInflight) {
        if (maxInflight < 0) {
public int getConnectionTimeout() {
	 * The default timeout is 30 seconds.
	 * A value of 0 disables timeout processing meaning the client will wait until the
	 * network connection is made successfully or fails.
	 * @param connectionTimeout the timeout value, measured in seconds. It must be >0;
	 */
	public void setConnectionTimeout(int connectionTimeout) {
		if (connectionTimeout <0 ) {
public void setConnectionTimeout(int connectionTimeout) {
	/**
	 * Returns the socket factory that will be used when connecting, or
	 * <code>null</code> if one has not been set.
	 */
	public SocketFactory getSocketFactory() {
		return socketFactory;
public Properties getSSLProperties() {
	}

	/**
	 * Sets the SSL properties for the connection.  Note that these
	 * properties are only valid if an implementation of the Java
	 * Secure Socket Extensions (JSSE) is available.  These properties are
	 * <em>not</em> used if a SocketFactory has been set using
public Properties getSSLProperties() {
	 * "PKIX" or "IBMJ9X509".
	 * </dd>
	 * </dl>
	 */
	public void setSSLProperties(Properties props) {
		this.sslClientProps = props;
public boolean isCleanSession() {
	 * the specified QOS even if the client, server or connection are restarted.
	 * <li> The server will treat a subscription as durable.
	 * </ul>
	 * <lI>If set to true the client and server will not maintain state across
	 * restarts of the client, the server or the connection. This means
	 * <ul>
	 * <li>Message delivery to the specified QOS cannot be maintained if the
	 * client, server or connection are restarted
	 * <lI>The server will treat a subscription as non-durable
	 * </ul>
 	 */
	public void setCleanSession(boolean cleanSession) {
		this.cleanSession = cleanSession;
public void setCleanSession(boolean cleanSession) {
	 * <p>Some MQTT servers support a high availability feature where two or more
	 * "equal" MQTT servers share state. An MQTT client can connect to any of the "equal"
	 * servers and be assured that messages are reliably delivered and durable subscriptions
	 * are maintained no matter which server the client connects to.
	 * <p>The cleansession flag must be set to false if durable subscriptions and/or reliable
	 * message delivery is required.
	 * <li>Hunt List
	 * <p>A set of servers may be specified that are not "equal" (as in the high availability
	 * option). As no state is shared across the servers reliable message delivery and
	 * durable subscriptions are not valid. The cleansession flag must be set to true if the
	 * hunt list mode is used
	 * </ol>
	 * </p>
	 * @param array of serverURIs
	 */
	public void setServerURIs(String[] array) {
public void setServerURIs(String[] array) {

	/**
	 * Validate a URI
	 * @param srvURI
	 * @return the URI type
	 */

	protected static int validateURI(String srvURI) {
		try {
			URI vURI = new URI(srvURI);
else if (vURI.getScheme().equals("local")) {
	 * by using the MQTT_VERSION_3_1_1 or MQTT_VERSION_3_1 options respectively.
	 *
	 * @param MqttVersion the version of the MQTT protocol.
	 */
	public void setMqttVersion(int MqttVersion)throws IllegalArgumentException {
		if (MqttVersion != MQTT_VERSION_DEFAULT && 
public boolean isAutomaticReconnect() {
	 *  it attempts to reconnect, for every failed reconnect attempt, the delay will double
	 *  until it is at 2 minutes at which point the delay will stay at 2 minutes.</li>
	 * </ul>
	 * @param automaticReconnect
	 */
	public void setAutomaticReconnect(boolean automaticReconnect) {
		this.automaticReconnect = automaticReconnect;
	}
	

	public Properties getDebug() {
		final String strNull="null";
		Properties p = new Properties();

	/**
	 * Utility method to validate the supplied QoS value.
	 * @throws IllegalArgumentException if value of QoS is not 0, 1 or 2.
	 */
	public static void validateQos(int qos) {
public MqttMessage() {
	/**
	 * Constructs a message with the specified byte array as a payload,
	 * and all other values set to defaults.
	 */
	public MqttMessage(byte[] payload) {
		setPayload(payload);
public int getQos() {
	 * If a persistence mechanism is not specified, the message will not be
	 * delivered in the event of a client failure.</li>
	 *
	 * If persistence is not configured, QoS 1 and 2 messages will still be delivered
	 * in the event of a network or server problem as the client will hold state in memory.
	 * If the MQTT client is shutdown or fails and persistence is not configured then
public boolean isDuplicate() {
	/**
	 * This is only to be used internally to provide the MQTT id of a message
	 * received from the server.  Has no effect when publishing messages.
	 * @param messageId
	 */
	public void setId(int messageId) {
		this.messageId = messageId;
 * array starting at offset 1 and length 4, plus a payload byte array
 * starting at offset 30 and length 40000. There are three ways in which
 * the persistence implementation may return data to the client on
 * recovery:
 * <ul>
 * <li>It could return the data as it was passed in
 * originally, with the same byte arrays and offsets.</li>
 * and length 40004.
 * This is useful when recovering from a file where the header and payload
 * could be written as a contiguous stream of bytes.</li>
 * </ul>
 * </p>  
 */
public interface MqttPersistable {

	 * The bytes start at {@link #getHeaderOffset()}
	 * and continue for {@link #getHeaderLength()}.
	 * @return the header bytes. 
	 */
	public byte[] getHeaderBytes() throws MqttPersistenceException;

	/**
	 * Returns the length of the header.
	 * @return the header length
	 */
	public int getHeaderLength() throws MqttPersistenceException;

	/**
	 * Returns the offset of the header within the byte array returned by {@link #getHeaderBytes()}.
	 * @return the header offset.
	 * 
	 */
	public int getHeaderOffset() throws MqttPersistenceException;
	 * The bytes start at {@link #getPayloadOffset()}
	 * and continue for {@link #getPayloadLength()}.
	 * @return the payload bytes.  
	 */
	public byte[] getPayloadBytes() throws MqttPersistenceException;

	/**
	 * Returns the length of the payload.
	 * @return the payload length.
	 */
	public int getPayloadLength() throws MqttPersistenceException;

	/**
	 * Returns the offset of the payload within the byte array returned by {@link #getPayloadBytes()}.
	 * @return the payload offset.
	 * 
	 */
	public int getPayloadOffset() throws MqttPersistenceException;

	/**
	 * Initial method. Pass interal state of current client in.
	 * @param  The core of the client, which holds the state information for pending and in-flight messages.
	 */
	public void init(ClientComms comms);

	
	/**
	 * Schedule next ping in certain delay.
	 * @param  delay in milliseconds.
	 */
	public void schedule(long delayInMilliseconds);
	
	private ClientComms comms;
	private String name;
	
	public MqttTopic(String name, ClientComms comms) {
		this.comms = comms;
		this.name = name;
public MqttTopic(String name, ClientComms comms) {
	 * @param payload the byte array to use as the payload
	 * @param qos the Quality of Service.  Valid values are 0, 1 or 2.
	 * @param retained whether or not this message should be retained by the server.
	 * @throws IllegalArgumentException if value of QoS is not 0, 1 or 2.
	 * @see #publish(MqttMessage)
	 * @see MqttMessage#setQos(int)
public MqttDeliveryToken publish(byte[] payload, int qos, boolean retained) thro
	 * 
	 * @param message the message to publish
	 * @return an MqttDeliveryToken for tracking the delivery of the message
	 */
	public MqttDeliveryToken publish(MqttMessage message) throws MqttException, MqttPersistenceException {
		MqttDeliveryToken token = new MqttDeliveryToken(comms.getClient().getClientId());
public String toString() {
	 * @throws IllegalArgumentException if the topic is invalid
	 */
	public static void validate(String topicString, boolean wildcardAllowed) 
			throws IllegalStateException, IllegalArgumentException{
		int topicLen = 0;
		try {
			topicLen = topicString.getBytes("UTF-8").length;
private static void validateSingleLevelWildcard(String topicString) {
	 * 
	 * @param topicFilter topic filter: wildcards allowed
	 * @param topicName topic name: wildcards not allowed
	 * @throws IllegalArgumentException if the topic name or filter is invalid
	 */
	public static boolean isMatched(String topicFilter, String topicName) 
	                    throws IllegalStateException, IllegalArgumentException {
	    int curn = 0,
	        curf = 0;
	    int curn_end = topicName.length();
/**
 * Default ping sender implementation
 *
 * <p>This class implements the {@link IMqttPingSender} pinger interface
 * allowing applications to send ping packet to server every keep alive interval.
 * </p>
 *
private Vector reOrder(Vector list) {
	
	/**
	 * Restores the state information from persistence.
	 */
	protected void restoreState() throws MqttException {
		final String methodName = "restoreState";
private void restoreInflightMessages() {
	 * 
	 * @param message  the message to send
	 * @param token the token that can be used to track delivery of the message
	 * @throws MqttException
	 */
	public void send(MqttWireMessage message, MqttToken token) throws MqttException {
		final String methodName = "send";
else if (message instanceof MqttPubComp)  {
	/**
	 * Persists a buffered message to the persistence layer
	 * 
	 * @param message
	 * @throws MqttPersistenceException
	 */
	public void persistBufferedMessage(MqttWireMessage message) {
		final String methodName = "persistBufferedMessage";
public void persistBufferedMessage(MqttWireMessage message) {
			} catch (MqttPersistenceException mpe){
				//@TRACE 515=Could not Persist, attempting to Re-Open Persistence Store
				log.fine(CLASS_NAME,methodName, "515");
				// TODO - Relies on https://github.com/eclipse/paho.mqtt.java/issues/178
				persistence.open(this.clientComms.getClient().getClientId(), this.clientComms.getClient().getClientId());
				persistence.put(key, (MqttPublish) message);
			}
public void persistBufferedMessage(MqttWireMessage message) {
		} 
	}
	
	public void unPersistBufferedMessage(MqttWireMessage message) throws MqttPersistenceException {
		final String methodName = "unPersistBufferedMessage";
		//@TRACE 515=Un-Persisting Buffered message key={0}
		log.fine(CLASS_NAME,methodName, "513", new Object[]{message.getKey()});
		persistence.remove(getSendBufferedPersistenceKey(message));
	}
	
	/**
	 * This removes the MqttSend message from the outbound queue and persistence.
	 * @param message
	 * @throws MqttPersistenceException
	 */
	protected void undo(MqttPublish message) throws MqttPersistenceException {
		final String methodName = "undo";
protected void undo(MqttPublish message) throws MqttPersistenceException {
	 * 
	 * If a ping has been sent but no data has been received in the 
	 * last keepalive interval then the connection is deamed to be broken. 
	 * 
	 * @return token of ping command, null if no ping command has been sent.
	 */
	public MqttToken checkForActivity(IMqttActionListener pingCallback) throws MqttException {
		final String methodName = "checkForActivity";
public MqttToken checkForActivity(IMqttActionListener pingCallback) throws MqttE
	 *  - there is a message to be sent
	 *  - the keepAlive interval is exceeded, which triggers a ping message
	 *    to be returned
	 *  - {@link #disconnected(MqttException, boolean)} is called
	 * @return the next message to send, or null if the client is disconnected
	 */
	protected MqttWireMessage get() throws MqttException {
		final String methodName = "get";
public void setKeepAliveInterval(long interval) {
		this.keepAlive = interval;
	}
	
	/**
	 * COMMENTED OUT AS NO LONGER USED.
	 * Deduce how long to to wait until a ping is required.
	 * 
	 * In order to keep the connection alive the server must see activity within 
	 * the keepalive interval. If the application is not sending / receiving
	 * any messages then the client will send a ping.  This method works out
	 * the next time that a ping must be sent in order for the server to 
	 * know the client is alive.
	 * @return  time before a ping needs to be sent to keep alive the connection
	long getTimeUntilPing() {
		long pingin = getKeepAlive();
		// If KA is zero which means just wait for work or 
		// if a ping is outstanding return the KA value
		if (connected && (getKeepAlive() > 0) && !pingOutstanding) {
		
			long time = System.currentTimeMillis();
			long timeSinceOut = (time-lastOutboundActivity);
			long timeSinceIn = (time-lastInboundActivity);
			
			if (timeSinceOut > timeSinceIn) {
				pingin = (getKeepAlive()-timeSinceOut);
			} else {
				pingin = (getKeepAlive()-timeSinceIn);
			}
			
			// Unlikely to be negative or zero but in the case it is return a 
			// small value > 0 to cause a ping to occur
			if (pingin <= 0) {
				pingin = 10;
			}
		}
		return (pingin);
	}
	 */
	
    public void notifySentBytes(int sentBytesCount) {
        final String methodName = "notifySentBytes";
        if (sentBytesCount > 0) {
public void notifySentBytes(int sentBytesCount) {
	
	/**
	 * Called by the CommsSender when a message has been sent
	 * @param message
	 */
	protected void notifySent(MqttWireMessage message) {
		final String methodName = "notifySent";
public void notifyReceivedBytes(int receivedBytesCount) {
    /**
	 * Called by the CommsReceiver when an ack has arrived. 
	 * 
	 * @param message
	 * @throws MqttException
	 */
	protected void notifyReceivedAck(MqttAck ack) throws MqttException {
		final String methodName = "notifyReceivedAck";
protected void notifyReceivedAck(MqttAck ack) throws MqttException {
	 * Called by the CommsReceiver when a message has been received.
	 * Handles inbound messages and other flows such as PUBREL. 
	 * 
	 * @param message
	 * @throws MqttException
	 */
	protected void notifyReceivedMsg(MqttWireMessage message) throws MqttException {
		final String methodName = "notifyReceivedMsg";
protected void notifyReceivedMsg(MqttWireMessage message) throws MqttException {
	 * persistence and counters adjusted accordingly. Also tidy up by removing
	 * token from store...
	 * 
	 * @param message
	 * @throws MqttException
	 */
	protected void notifyComplete(MqttToken token) throws MqttException {
		
public void connected() {
	 * is tidied up so it only contains outstanding delivery tokens which are
	 * valid after reconnect (if clean session is false)
	 * @param reason The root cause of the disconnection, or null if it is a clean disconnect
	 */
	public Vector resolveOldTokens(MqttException reason) {
		final String methodName = "resolveOldTokens";
private synchronized int getNextMessageId() throws MqttException {
	 * and preventing the callback on any newly received messages.
	 * After the timeout expires, delete any pending messages except for
	 * outbound ACKs, and wait for those ACKs to complete.
	 */
	public void quiesce(long timeout) {
		final String methodName = "quiesce";
public void setClientState(ClientState clientState) {

	/**
	 * Starts up the Callback thread.
	 */
	public void start(String threadName) {
		synchronized (lifecycle) {
public void connectionLost(MqttException cause) {
	 * An action has completed - if a completion listener has been set on the
	 * token then invoke it with the outcome of the action.
	 * 
	 * @param token
	 */
	public void fireActionEvent(MqttToken token) {
		final String methodName = "fireActionEvent";
public void asyncOperationComplete(MqttToken token) {

	/**
	 * Returns the thread used by this callback.
	 */
	protected Thread getThread() {
		return callbackThread;
public CommsReceiver(ClientComms clientComms, ClientState clientState,CommsToken
	
	/**
	 * Starts up the Receiver's thread.
	 */
	public void start(String threadName) {
		final String methodName = "start";
public CommsSender(ClientComms clientComms, ClientState clientState, CommsTokenS
	
	/**
	 * Starts up the Sender thread.
	 */
	public void start(String threadName) {
		synchronized (lifecycle) {
 * Provides a "token" based system for storing and tracking actions across 
 * multiple threads. 
 * When a message is sent, a token is associated with the message
 * and saved using the {@link #saveToken(MqttToken, MqttWireMessage)} method. Anyone interested
 * in tacking the state can call one of the wait methods on the token or using 
 * the asynchronous listener callback method on the operation. 
 * The {@link CommsReceiver} class, on another thread, reads responses back from 
public MqttToken removeToken(String key) {
	 * Restores a token after a client restart.  This method could be called
	 * for a SEND of CONFIRM, but either way, the original SEND is what's 
	 * needed to re-build the token.
	 */
	protected MqttDeliveryToken restoreToken(MqttPublish message) {
		final String methodName = "restoreToken";
  private boolean reconnect;

/**
   * @param persistence
   * @param client 
   * @param comms
   * @param options 
   * @param userToken  
   * @param userContext
   * @param userCallback
   */
  public ConnectActionListener(
      MqttAsyncClient client,
public ConnectActionListener(
  /**
   * If the connect succeeded then call the users onSuccess callback
   * 
   * @param token 
   */
  public void onSuccess(IMqttToken token) {
	if (originalMqttVersion == MqttConnectOptions.MQTT_VERSION_DEFAULT) {
public void onSuccess(IMqttToken token) {
   * The connect failed, so try the next URI on the list.
   * If there are no more URIs, then fail the overall connect. 
   * 
   * @param token 
   * @param exception 
   */
  public void onFailure(IMqttToken token, Throwable exception) {

public void onFailure(IMqttToken token, Throwable exception) {

  /**
   * Start the connect processing
   * @throws MqttPersistenceException 
   */
  public void connect() throws MqttPersistenceException {
    MqttToken token = new MqttToken(client.getClientId());
public void connect() throws MqttPersistenceException {
  
  /**
   * Set the MqttCallbackExtened callback to receive connectComplete callbacks
   * @param mqttCallbackExtended
   */
  public void setMqttCallbackExtended(MqttCallbackExtended mqttCallbackExtended) {
		this.mqttCallbackExtended = mqttCallbackExtended;
public DisconnectedMessageBuffer(DisconnectedBufferOptions options){
	 * then the 0th item in the buffer will be deleted and the
	 * new message will be added. If it is not enabled then an
	 * MqttException will be thrown.
	 * @param message
	 * @throws MqttException
	 */
	public void putMessage(MqttWireMessage message, MqttToken token) throws MqttException{
		BufferedMessage bufferedMessage = new BufferedMessage(message, token);
public void putMessage(MqttWireMessage message, MqttToken token) throws MqttExce
	
	/**
	 * Retrieves a message from the buffer at the given index.
	 * @param messageIndex
	 * @return
	 * @throws MqttException
	 */
	public BufferedMessage getMessage(int messageIndex){
		synchronized (bufLock) {
public BufferedMessage getMessage(int messageIndex){
	
	/**
	 * Removes a message from the buffer
	 * @param messageIndex
	 * @throws MqttException
	 */
	public void deleteMessage(int messageIndex){
		synchronized (bufLock) {
public void deleteMessage(int messageIndex){
	
	/**
	 * Returns the number of messages currently in the buffer
	 * @return
	 * @throws MqttException
	 */
	public int getMessageCount() {
		synchronized (bufLock) {
public static MqttException createMqttException(Throwable cause) {
	 * Returns whether or not the specified class is available to the current
	 * class loader.  This is used to protect the code against using Java SE
	 * APIs on Java ME.
	 */
	public static boolean isClassAvailable(String className) {
		boolean result = false;
	 * Constructs a new SSLNetworkModule using the specified host and
	 * port.  The supplied SSLSocketFactory is used to supply the network
	 * socket.
	 */
	public SSLNetworkModule(SSLSocketFactory factory, String host, int port, String resourceContext) {
		super(factory, host, port, resourceContext);
public SSLNetworkModule(SSLSocketFactory factory, String host, int port, String

	/**
	 * Returns the enabled cipher suites.
	 */
	public String[] getEnabledCiphers() {
		return enabledCiphers;
	}

	/**
	 * Sets the enabled cipher suites on the underlying network socket.
	 */
	public void setEnabledCiphers(String[] enabledCiphers) {
		final String methodName = "setEnabledCiphers";
	 * Constructs a new TCPNetworkModule using the specified host and
	 * port.  The supplied SocketFactory is used to supply the network
	 * socket.
	 */
	public TCPNetworkModule(SocketFactory factory, String host, int port, String resourceContext) {
		log.setResourceName(resourceContext);
public TCPNetworkModule(SocketFactory factory, String host, int port, String res

	/**
	 * Starts the module, by creating a TCP socket to the server.
	 */
	public void start() throws IOException, MqttException {
		final String methodName = "start";
public OutputStream getOutputStream() throws IOException {

	/**
	 * Stops the module, by closing the TCP socket.
	 */
	public void stop() throws IOException {
		if (socket != null) {
public void stop() throws IOException {
	
	/**
	 * Set the maximum time to wait for a socket to be established
	 * @param timeout
	 */
	public void setConnectTimeout(int timeout) {
		this.conTimeout = timeout;
public void waitForCompletion(long timeout) throws MqttException {
	 * in the case of a NACK.  It does still throw an exception if something else
	 * goes wrong (e.g. an IOException).  This is used for packets like CONNECT, 
	 * which have useful information in the ACK that needs to be accessed.
	 */
	protected MqttWireMessage waitForResponse() throws MqttException {
		return waitForResponse(-1);
 * cipher suites on the socket [see below].</li>
 * </ol>
 * <ul>
 * <li><i>For an MQTT server:</i></li>
 * <ol>
 * <li><b>getKeyStore(configID)</b>: Optionally, to check that if there is no
 * keystore, then that all the enabled cipher suits are anonymous.</li>
 * SSLServerSocket (itself created from the SSLServerSocketFactory) whether
 * client authentication is needed.</li>
 * </ol>
 * <li><i>For an MQTT client:</i></li>
 * <ol>
 * <li><b>createSocketFactory(configID)</b>: to create an SSLSocketFactory.</li>
 * </ol>
 * </ul>
 */
public class SSLSocketFactoryFactory {
public SSLSocketFactoryFactory() {
	/**
	 * Create new instance of class.
	 * Constructor used by the broker.
	 */
	public SSLSocketFactoryFactory(Logger logger) {
		this();
private SSLContext getSSLContext(String configID)
	 * @param configID
	 *            The configuration identifier for selecting a configuration.
	 * @return An SSLSocketFactory
	 * @throws MqttDirectException
	 */
	public SSLSocketFactory createSocketFactory(String configID) 
			throws MqttSecurityException {
public boolean isCloseFlag() {

	/**
	 * Initialise a new WebSocketFrame
	 * @param opcode
	 * @param fin
	 * @param payload
	 */
	public WebSocketFrame(byte opcode, boolean fin, byte[] payload){
		this.opcode = opcode;
public WebSocketFrame(byte opcode, boolean fin, byte[] payload){
	
	/**
	 * Initialise WebSocketFrame from raw Data
	 * @param rawFrame
	 */
	public  WebSocketFrame (byte[] rawFrame){
			
private void setFinAndOpCode(byte incomingByte){
	
	/**
	 * Takes an input stream and parses it into a Websocket frame.
	 * @param input
	 * @throws IOException
	 */
	public WebSocketFrame(InputStream input) throws IOException {
		byte firstByte = (byte) input.read();
public WebSocketFrame(InputStream input) throws IOException {
	
	/**
	 * Appends the Length and Mask to the buffer
	 * @param buffer
	 * @param length
	 * @param mask
	 */
	public static void appendLengthAndMask(ByteBuffer buffer, int length, byte mask[]){
		if(mask != null){
private static void appendLength(ByteBuffer buffer, int length, boolean masked)

	/**
	 * Appends the Fin flag and the OpCode
	 * @param buffer
	 * @param opcode
	 * @param fin
	 */
	public static void appendFinAndOpCode(ByteBuffer buffer, byte opcode, boolean fin){
		byte b = 0x00;
public WebSocketHandshake(InputStream input, OutputStream output, String uri, St
	/**
	 * Executes a Websocket Handshake.
	 * Will throw an IOException if the handshake fails
	 * @throws IOException
	 */
	public void execute() throws IOException {
		String key = "mqtt3-" + (System.currentTimeMillis()/1000);
public WebSocketReceiver(InputStream input, PipedInputStream pipedInputStream) t

	/**
	 * Starts up the WebSocketReceiver's thread
	 */
	public void start(String threadName){
		final String methodName = "start";
	/**
	 * Constructs a new <code>CountingInputStream</code> wrapping the supplied
	 * input stream.
	 */
	public CountingInputStream(InputStream in) {
		this.in = in;
public int read() throws IOException {
	}

	/**
	 * Returns the number of bytes read since the last reset.
	 */
	public int getCounter() {
		return counter;
	/**
	 * Constructor for an on the wire MQTT connect message
	 * 
	 * @param info
	 * @param data
	 * @throws IOException
	 * @throws MqttException
	 */
	public MqttConnect(byte info, byte[] data) throws IOException, MqttException {
		super(MqttWireMessage.MESSAGE_TYPE_CONNECT);
public void close() throws IOException {
	 * If the message cannot be fully read within the socket read timeout,
	 * a null message is returned and the method can be called again until
	 * the message is fully read.
	 */
	public MqttWireMessage readMqttWireMessage() throws IOException, MqttException {
		final String methodName ="readMqttWireMessage";
public void write(int b) throws IOException {

	/**
	 * Writes an <code>MqttWireMessage</code> to the stream.
	 */
	public void write(MqttWireMessage message) throws IOException, MqttException {
		final String methodName = "write";

	/**
	 * Createa a pubrel message based on a pubrec
	 * @param pubRec
	 */
	public MqttPubRel(MqttPubRec pubRec) {
		super(MqttWireMessage.MESSAGE_TYPE_PUBREL);
public MqttPubRel(MqttPubRec pubRec) {
	
	/**
	 * Creates a pubrel based on a pubrel set of bytes read fro the network
	 * @param info
	 * @param data
	 * @throws IOException
	 */
	public MqttPubRel(byte info, byte[] data) throws IOException {
		super(MqttWireMessage.MESSAGE_TYPE_PUBREL);
public MqttPublish(String name, MqttMessage message) {
	 * Constructs a new MqttPublish object.
	 * @param info the message info byte
	 * @param data the variable header and payload bytes
	 */
	public MqttPublish(byte info, byte[] data) throws MqttException, IOException {
		super(MqttWireMessage.MESSAGE_TYPE_PUBLISH);
		message = new MqttReceivedMessage();
		message.setQos((info >> 1) & 0x03);
	/**
	 * Constructor for an on the wire MQTT subscribe message
	 * 
	 * @param info
	 * @param data
	 */
	public MqttSubscribe(byte info, byte[] data) throws IOException {
		super(MqttWireMessage.MESSAGE_TYPE_SUBSCRIBE);

	/**
	 * Constructs an MqttUnsubscribe
	 */
	public MqttUnsubscribe(String[] names) {
		super(MqttWireMessage.MESSAGE_TYPE_UNSUBSCRIBE);
public MqttUnsubscribe(String[] names) {
	/**
	 * Constructor for an on the wire MQTT un-subscribe message
	 * 
	 * @param info
	 * @param data
	 * @throws IOException
	 */
	public MqttUnsubscribe(byte info, byte[] data) throws IOException {
		super(MqttWireMessage.MESSAGE_TYPE_UNSUBSCRIBE);
public MqttWireMessage(byte type) {
	/**
	 * Sub-classes should override this to encode the message info.
	 * Only the least-significant four bits will be used.
	 */
	protected abstract byte getMessageInfo();
	
	/**
	 * Sub-classes should override this method to supply the payload bytes.
	 */
	public byte[] getPayload() throws MqttException {
		return new byte[0];
	}
	
	/**
	 * Returns the type of the message.
	 */
	public byte getType() {
		return type;
	}
	
	/**
	 * Returns the MQTT message ID.
	 */
	public int getMessageId() {
		return msgId;
	}
	
	/**
	 * Sets the MQTT message ID.
	 */
	public void setMessageId(int msgId) {
		this.msgId = msgId;
public String getKey() {


	/**
	 * Returns whether or not this message needs to include a message ID.
	 */
	public boolean isMessageIdRequired() {
		return true;
else if (type == MqttWireMessage.MESSAGE_TYPE_DISCONNECT) {
	
	/**
	 * Decodes an MQTT Multi-Byte Integer from the given stream.
	 */
	protected static MultiByteInteger readMBI(DataInputStream in) throws IOException {
		byte digit;
public MultiByteInteger(long value, int length) {
	}
	
	/**
	 * Returns the number of bytes read when decoding this MBI.
	 */
	public int getEncodedLength() {
		return length;
	}

	/**
	 * Returns the value of this MBI.
	 */
	public long getValue() {
		return value;
 * one of the predefined level constants such as Logger.SEVERE and Logger.FINE
 * with the appropriate log(int level...) or trace(int level...) methods.
 * <p>
 * The levels in descending order are:
 * <ul>
 * <li>SEVERE (log - highest value)</li>
 * <li>WARNING (log)</li>
 * <li>FINER (trace)</li>
 * <li>FINEST (trace - lowest value)</li>
 * </ul>
 * <p>
 */
public interface Logger {
	/**
	/**
	 * Set a name that can be used to provide context with each log record.
	 * This overrides the value passed in on initialise
	 */
	public void setResourceName(String logContext);
	
	 *            would format two inserts into the message.
	 * @param inserts
	 *            Array of parameters to the message, may be null.
	 */
	public void trace(int level, String sourceClass, String sourceMethod, String msg, Object[] inserts, Throwable ex);

	 * @param messageCatalogName the resource bundle containing the logging messages.
	 * @param loggerID  unique name to identify this logger.
	 * @return a suitable Logger.
	 * @throws Exception
	 */
	public static Logger getLogger(String messageCatalogName, String loggerID) {
		String loggerClassName = overrideloggerClassName;
public void close() throws MqttPersistenceException {
	/**
	 * Writes the specified persistent data to the previously specified persistence directory.
	 * This method uses a safe overwrite policy to ensure IO errors do not lose messages.
	 * @param message
	 * @throws MqttPersistenceException
	 */
	public void put(String key, MqttPersistable message) throws MqttPersistenceException {
		checkIsOpen();
public void remove(String key) throws MqttPersistenceException {
	/**
	 * Returns all of the persistent data from the previously specified persistence directory.
	 * @return all of the persistent data from the persistence directory.
	 * @throws MqttPersistenceException
	 */
	public Enumeration keys() throws MqttPersistenceException {
		checkIsOpen();
public void dumpConOptions() {

	/**
	 * Return a set of properties as a formatted string
	 */
	public static String dumpProperties(Properties props, String name) {
		
	 * Checks if the CharSequence equals any character in the given set of characters.
	 * 
	 * @param cs the CharSequence to check
	 * @param first the first CharSequence
	 * @param rest the rest CharSequence
	 * @return true if equals any
	 */
	public static boolean equalsAny(CharSequence cs, CharSequence[] strs) {
514=Failed to persist buffered message key={0}
515=Could not Persist, attempting to Re-Open Persistence Store
516=Restoring all buffered messages.
600=>
601=key={0} message={1}
602=key={0} exception
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ext {
}

/** needed to disable Java 8 doclint which throws errors **/
allprojects {
    tasks.withType(Javadoc) {
        options.addStringOption('Xdoclint:none', '-quiet')
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
else if (transformedName.equals("mods.natura.blocks.crops.Glowshroom"))
	private void hookBlockCrops(ClassNode classNode, MethodNode method)
	{
		JumpInsnNode ifJumpInsn = (JumpInsnNode) ASMHelper.findFirstInstructionWithOpcode(method, IF_ICMPLT);
		AbstractInsnNode ifStartPoint = ASMHelper.findPreviousLabelOrLineNumber(ifJumpInsn).getNext();

		LabelNode endLabel = ASMHelper.findEndLabel(method);
		LabelNode ifFailedLabel = ifJumpInsn.label;
private void hookBlockSapling(ClassNode classNode, MethodNode method)
	{
		JumpInsnNode lightValueIf = (JumpInsnNode) ASMHelper.findFirstInstructionWithOpcode(method, IF_ICMPLT);
		JumpInsnNode randomIf = (JumpInsnNode) ASMHelper.findNextInstructionWithOpcode(lightValueIf, IFNE);
		AbstractInsnNode ifStartPoint = ASMHelper.findPreviousLabelOrLineNumber(lightValueIf).getNext();

		LabelNode ifFailedLabel = lightValueIf.label;
		LabelNode ifAllowedLabel = new LabelNode();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  @SuppressWarnings("unchecked")
  private <T> java.util.concurrent.CompletableFuture<T> call(AsyncCallableWrapper<T> callable) {
    FailsafeFuture<T> future = new FailsafeFuture<T>((FailsafeConfig<T, ?>) this);
    java.util.concurrent.CompletableFuture<T> response = Functions.cancellableFutureOf(future);
    future.inject(response);
    call(callable, future);
    return response;
package net.jodah.failsafe;

import java.util.concurrent.Callable;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Semaphore;
import java.util.function.BiConsumer;

import net.jodah.failsafe.function.AsyncCallable;
import net.jodah.failsafe.function.AsyncRunnable;
public T call() throws Exception {
        try {
          execution.before();
          asyncFutureLock.acquire();
          callable.call(execution).whenComplete(new BiConsumer<T, Throwable>() {
            @Override
            public void accept(T innerResult, Throwable failure) {
              try {
public void accept(T innerResult, Throwable failure) {
      public T call() throws Exception {
        try {
          execution.before();
          callable.call().whenComplete(new BiConsumer<T, Throwable>() {
            @Override
            public void accept(T innerResult, Throwable failure) {
              // Unwrap CompletionException cause
public void accept(T innerResult, Throwable failure) {
      public T call() throws Exception {
        try {
          execution.before();
          callable.call(execution).whenComplete(new BiConsumer<T, Throwable>() {
            @Override
            public void accept(T innerResult, Throwable failure) {
              // Unwrap CompletionException cause
public T call() throws Exception {
    };
  }

  static <T> CompletableFuture<T> cancellableFutureOf(final FailsafeFuture<T> future) {
    return new CompletableFuture<T>() {
      @Override
      public boolean cancel(boolean mayInterruptIfRunning) {
        future.cancel(mayInterruptIfRunning);
        return super.cancel(mayInterruptIfRunning);
      }
    };
  }

  static <T, U, R> CheckedBiFunction<T, U, R> fnOf(final Callable<R> callable) {
    return new CheckedBiFunction<T, U, R>() {
      @Override
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Change log next version
* Fix #634/#632: Add workaround as fix  for Mockito 1+. Wait fix from Mockito team for Mockito 2.
* Fix #648: TestNG SkipException doesn't work with PowerMock
* Fix #652: PowerMock stubbing void method don't work for overloaded methods
* Added support for @TestSubject in EasyMock API. This is the equivalent of @InjectMocks in Mockito (big thanks to Arthur Zagretdinov for pull request)
* Added experimental support for mockito 2.x
* Upgraded commons-logging dependency to version 1.2
            <version>3.20.0-GA</version>
            <scope>compile</scope>
        </dependency>
    </dependencies>
</project>
/*
 * Copyright 2011 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.powermock.core.transformers;

public interface MockTransformer {

	/**
	 * Transforms the <code>Class</code> with name
	 * <code>fullyQualifiedName</code>.
	 * 
	 * @param fullyQualifiedName
	 *            The fully qualified name of the <code>Class</code> to
	 *            transform into a mock enabled class.
	 * @return A <code>CtClass</code> representation of the mocked class.
	 */
/*
 * Copyright 2011 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.powermock.core.transformers.impl;

import javassist.CannotCompileException;
import static org.powermock.core.transformers.TransformStrategy.INST_REDEFINE;
import static org.powermock.core.transformers.TransformStrategy.INST_TRANSFORM;

public class MainMockTransformer implements MockTransformer {

    private static final String VOID = "";

    private final TransformStrategy strategy;

    public MainMockTransformer() {
        this(CLASSLOADER);
    }

    public MainMockTransformer(TransformStrategy strategy) {
        this.strategy = strategy;
    }

    public CtClass transform(final CtClass clazz) throws Exception {
        if (clazz.isFrozen()) {
            clazz.defrost();
        }

        /*
         * Set class modifier to public to allow for mocking of package private
         * classes. This is needed because we've changed to CgLib naming policy
         * to allow for mocking of signed classes.
         */
        final String name = allowMockingOfPackagePrivateClasses(clazz);

        suppressStaticInitializerIfRequested(clazz, name);

        if (clazz.isInterface()) {
            return clazz;
        }

        // This should probably be configurable
        removeFinalModifierFromClass(clazz);

        allowMockingOfStaticAndFinalAndNativeMethods(clazz);

        // Convert all constructors to public
        setAllConstructorsToPublic(clazz);

        // Remove final from all static final fields. Not possible if using a java agent.
        removeFinalModifierFromAllStaticFinalFields(clazz);

        if (strategy != INST_TRANSFORM) {
            clazz.instrument(new PowerMockExpressionEditor(clazz));
        }

        return clazz;
    }

    private String allowMockingOfPackagePrivateClasses(final CtClass clazz) {
        final String name = clazz.getName();
        if (strategy != INST_REDEFINE) {
            try {
private String allowMockingOfPackagePrivateClasses(final CtClass clazz) {
        return name;
    }

    private void suppressStaticInitializerIfRequested(final CtClass clazz, final String name) throws CannotCompileException {
        if (strategy == CLASSLOADER) {
            if (MockGateway.staticConstructorCall(name) != MockGateway.PROCEED) {
                CtConstructor classInitializer = clazz.makeClassInitializer();
private void suppressStaticInitializerIfRequested(final CtClass clazz, final Str
        }
    }

    private void removeFinalModifierFromClass(final CtClass clazz) {
        if (strategy != INST_REDEFINE) {
            if (Modifier.isFinal(clazz.getModifiers())) {
                clazz.setModifiers(clazz.getModifiers() ^ Modifier.FINAL);
private void removeFinalModifierFromClass(final CtClass clazz) {
        }
    }

    private void allowMockingOfStaticAndFinalAndNativeMethods(final CtClass clazz) throws NotFoundException, CannotCompileException {
        if (strategy != INST_TRANSFORM) {
            for (CtMethod m : clazz.getDeclaredMethods()) {
                modifyMethod(m);
            }
        }
    }

    private void removeFinalModifierFromAllStaticFinalFields(final CtClass clazz) {
        if (strategy != INST_REDEFINE) {
            for (CtField f : clazz.getDeclaredFields()) {
                final int modifiers = f.getModifiers();
private void removeFinalModifierFromAllStaticFinalFields(final CtClass clazz) {
        }
    }

    private void setAllConstructorsToPublic(final CtClass clazz) {
        if (strategy == CLASSLOADER) {
            for (CtConstructor c : clazz.getDeclaredConstructors()) {
                final int modifiers = c.getModifiers();
private String getCorrectReturnValueType(final CtClass returnTypeAsCtClass) {
        return returnValue;
    }

    private final class PowerMockExpressionEditor extends ExprEditor {
        private final CtClass clazz;

        private PowerMockExpressionEditor(CtClass clazz) {
            this.clazz = clazz;
        }

/*
 * Copyright 2013 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.powermock.core.transformers.impl;

 * chunking!
 * 3) Restore original test-class constructors` accesses
 * (in case they have all been made public by {@link
 * MainMockTransformer#setAllConstructorsToPublic(javassist.CtClass)})
 * - to avoid that multiple <i>public</i> test-class constructors cause
 * a delegate runner from JUnit (or 3rd party) to bail out with an
 * error message such as "Test class can only have one constructor".
/*
 * Copyright 2011 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.powermock.tests.utils.impl;

import org.powermock.core.spi.PowerMockPolicy;
import org.powermock.core.spi.PowerMockTestListener;
import org.powermock.core.transformers.MockTransformer;
import org.powermock.core.transformers.impl.MainMockTransformer;
import org.powermock.core.transformers.impl.TestClassTransformer;
import org.powermock.reflect.Whitebox;
import org.powermock.reflect.proxyframework.RegisterProxyFramework;
public ClassLoader createNewClassloader(
        if ((classesToLoadByMockClassloader == null || classesToLoadByMockClassloader.length == 0) && !hasMockPolicyProvidedClasses(testClass)) {
            mockLoader = Thread.currentThread().getContextClassLoader();
        } else {
            List<MockTransformer> mockTransformerChain = new ArrayList<MockTransformer>();
            final MainMockTransformer mainMockTransformer = new MainMockTransformer();
            mockTransformerChain.add(mainMockTransformer);
            Collections.addAll(mockTransformerChain, extraMockTransformers);
            final UseClassPathAdjuster useClassPathAdjuster = testClass.getAnnotation(UseClassPathAdjuster.class);
            mockLoader = AccessController.doPrivileged(new PrivilegedAction<MockClassLoader>() {
                @Override
public MockClassLoader run() {
        return mockLoader;
    }

    /**
     * {@inheritDoc}
     */
import org.junit.Test;
import org.powermock.core.classloader.annotations.UseClassPathAdjuster;
import org.powermock.core.transformers.MockTransformer;
import org.powermock.core.transformers.impl.MainMockTransformer;
import org.powermock.reflect.Whitebox;

import java.lang.annotation.Annotation;
public void autoboxingWorks() throws Exception {
        String name = this.getClass().getPackage().getName() + ".HardToTransform";
        final MockClassLoader mockClassLoader = new MockClassLoader(new String[]{name});
        List<MockTransformer> list = new LinkedList<MockTransformer>();
        list.add(new MainMockTransformer());
        mockClassLoader.setMockTransformerChain(list);
        Class<?> c = mockClassLoader.loadClass(name);

public void shouldAddIgnorePackagesToDefer() throws Exception {
    public void canFindResource() throws Exception {
        final MockClassLoader mockClassLoader = new MockClassLoader(new String[0]);
        List<MockTransformer> list = new LinkedList<MockTransformer>();
        list.add(new MainMockTransformer());
        mockClassLoader.setMockTransformerChain(list);

        // Force a ClassLoader that can find 'foo/bar/baz/test.txt' into
public void canFindResource() throws Exception {
    public void canFindResources() throws Exception {
        final MockClassLoader mockClassLoader = new MockClassLoader(new String[0]);
        List<MockTransformer> list = new LinkedList<MockTransformer>();
        list.add(new MainMockTransformer());
        mockClassLoader.setMockTransformerChain(list);

        // Force a ClassLoader that can find 'foo/bar/baz/test.txt' into
public void canFindResources() throws Exception {
    public void resourcesNotDoubled() throws Exception {
        final MockClassLoader mockClassLoader = new MockClassLoader(new String[0]);
        List<MockTransformer> list = new LinkedList<MockTransformer>();
        list.add(new MainMockTransformer());
        mockClassLoader.setMockTransformerChain(list);

        // MockClassLoader will only be able to find 'foo/bar/baz/test.txt' if it
public void canFindDynamicClassFromAdjustedClasspath() throws Exception {
        };
        final MockClassLoader mockClassLoader = new MockClassLoader(new String[0], useClassPathAdjuster);
        List<MockTransformer> list = new LinkedList<MockTransformer>();
        list.add(new MainMockTransformer());
        mockClassLoader.setMockTransformerChain(list);

        // setup custom classloader providing our dynamic class, for MockClassLoader to defer to
public void cannotFindDynamicClassInDeferredClassLoader() throws Exception {

        MockClassLoader mockClassLoader = new MockClassLoader(new String[0]);
        List<MockTransformer> list = new LinkedList<MockTransformer>();
        list.add(new MainMockTransformer());
        mockClassLoader.setMockTransformerChain(list);

        // setup custom classloader providing our dynamic class, for MockClassLoader to defer to
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;

public class MainMockTransformerTest {
    /**
     * This tests that a inner 'public static final class' can be modified to drop the final modifier. Fixes <a
     * href="http://code.google.com/p/powermock/issues/detail?id=95">Issue 95</a>.
     */
    @Test
    public void staticFinalInnerClassesShouldBecomeNonFinal() throws Exception {
        MockClassLoader mockClassLoader = new MockClassLoader(new String[] { MockClassLoader.MODIFY_ALL_CLASSES });
        mockClassLoader.setMockTransformerChain(Collections.<MockTransformer> singletonList(new MainMockTransformer()));
        Class<?> clazz = Class.forName(SupportClasses.StaticFinalInnerClass.class.getName(), true, mockClassLoader);
        assertFalse(Modifier.isFinal(clazz.getModifiers()));
    }
public void staticFinalInnerClassesShouldBecomeNonFinal() throws Exception {
    @Test
    public void finalInnerClassesShouldBecomeNonFinal() throws Exception {
        MockClassLoader mockClassLoader = new MockClassLoader(new String[] { MockClassLoader.MODIFY_ALL_CLASSES });
        mockClassLoader.setMockTransformerChain(Collections.<MockTransformer> singletonList(new MainMockTransformer()));
        Class<?> clazz = Class.forName(SupportClasses.FinalInnerClass.class.getName(), true, mockClassLoader);
        assertFalse(Modifier.isFinal(clazz.getModifiers()));
    }
public void finalInnerClassesShouldBecomeNonFinal() throws Exception {
    @Test
    public void enumClassesShouldBecomeNonFinal() throws Exception {
        MockClassLoader mockClassLoader = new MockClassLoader(new String[] { MockClassLoader.MODIFY_ALL_CLASSES });
        mockClassLoader.setMockTransformerChain(Collections.<MockTransformer> singletonList(new MainMockTransformer()));
        Class<?> clazz = Class.forName(SupportClasses.EnumClass.class.getName(), true, mockClassLoader);
        assertFalse(Modifier.isFinal(clazz.getModifiers()));
    }

    @Test
    public void privateInnerClassesShouldBecomeNonFinal() throws Exception {
        MockClassLoader mockClassLoader = new MockClassLoader(new String[] { MockClassLoader.MODIFY_ALL_CLASSES });
        mockClassLoader.setMockTransformerChain(Collections.<MockTransformer> singletonList(new MainMockTransformer()));
        final Class<?> clazz = Class.forName(SupportClasses.class.getName() + "$PrivateStaticFinalInnerClass", true, mockClassLoader);
        assertFalse(Modifier.isFinal(clazz.getModifiers()));
    }

    @Test
    public void subclassShouldNormallyGetAnAdditionalDeferConstructor() throws Exception {
        MockClassLoader mockClassLoader = new MockClassLoader(new String[] { MockClassLoader.MODIFY_ALL_CLASSES });
        mockClassLoader.setMockTransformerChain(Collections.<MockTransformer> singletonList(new MainMockTransformer()));
        final Class<?> clazz = Class.forName(SupportClasses.SubClass.class.getName(), true, mockClassLoader);
        assertEquals("Original number of constructoprs",
                1, SupportClasses.SubClass.class.getConstructors().length);
MockClassLoader createMockClassLoaderThatPrepare(Class<?> prepare4test) {
            MockClassLoader mockClassLoader =
                    new MockClassLoader(preparations(prepare4test));
            mockClassLoader.setMockTransformerChain(Arrays.asList(
                    new MainMockTransformer(),
                    testClassTransformer));
            return mockClassLoader;
        }
package powermock.test.support;

import org.powermock.core.classloader.MockClassLoader;

/**
 * This class is used when running tests in {@link org.powermock.core.transformers.impl.MainMockTransformerTest}. It is
 * placed in this package because classes in org.powermock.core.* are deferred by:
 * {@link MockClassLoader#packagesToBeDeferred}. Additionally, the class must be modified when it is loaded, and as such
 * not in {@link MockClassLoader#packagesToLoadButNotModify}.
/*
 * Copyright 2011 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.powermock.modules.agent;
import javassist.CtClass;
import org.powermock.core.agent.JavaAgentClassRegister;
import org.powermock.core.transformers.TransformStrategy;
import org.powermock.core.transformers.impl.MainMockTransformer;

import java.io.ByteArrayInputStream;
import java.lang.instrument.ClassFileTransformer;
public void setJavaAgentClassRegister(JavaAgentClassRegister javaAgentClassRegis
        this.javaAgentClassRegister = javaAgentClassRegister;
    }

    private static final MainMockTransformer mainMockTransformer = new MainMockTransformer(TransformStrategy.INST_REDEFINE);

    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {
        if (loader == null || shouldIgnore(className)) {
public void setJavaAgentClassRegister(JavaAgentClassRegister javaAgentClassRegis
                    is.close();
                }
                
                ctClass = mainMockTransformer.transform(ctClass);

                /*
                 * ClassPool may cause huge memory consumption if the number of CtClass
import org.powermock.classloading.ClassloaderExecutor;
import org.powermock.core.classloader.MockClassLoader;
import org.powermock.core.transformers.MockTransformer;
import org.powermock.core.transformers.impl.MainMockTransformer;
import org.powermock.reflect.proxyframework.ClassLoaderRegisterProxyFramework;
import org.powermock.tests.utils.MockPolicyInitializer;
import org.powermock.tests.utils.impl.PowerMockIgnorePackagesExtractorImpl;

    public static ClassloaderExecutor forClass(Class<?> testClass, MockPolicyInitializer mockPolicyInitializer) {
        List<MockTransformer> mockTransformerChain = new ArrayList<MockTransformer>();
        final MainMockTransformer mainMockTransformer = new MainMockTransformer();
        mockTransformerChain.add(mainMockTransformer);
    
        String[] classesToLoadByMockClassloader = new String[0];
        String[] packagesToIgnore = new String[0];

import org.powermock.core.classloader.MockClassLoaderBuilders;
import org.powermock.core.transformers.MockTransformer;
import org.powermock.core.transformers.impl.MainMockTransformer;
import org.powermock.tests.utils.IgnorePackagesExtractor;
import org.powermock.tests.utils.TestClassesExtractor;
import org.powermock.tests.utils.impl.PowerMockIgnorePackagesExtractorImpl;
import org.powermock.tests.utils.impl.PrepareForTestExtractorImpl;
import org.powermock.tests.utils.impl.StaticConstructorSuppressExtractorImpl;

import java.util.Collections;
import java.util.List;

        expectedExceptionsExtractor = new PowerMockExpectedExceptionsExtractorImpl();
        staticConstructorSuppressExtractor = new StaticConstructorSuppressExtractorImpl();

        mockTransformerChain = Collections.singletonList((MockTransformer) new MainMockTransformer());

    }

    ClassLoader createClassLoader(Class<?> testClass) {
        return MockClassLoaderBuilders.mockClassLoaderBuilder()
                                      .addMockTransformerChain(mockTransformerChain)

    <modules>
        <module>junit4</module>
        <module>junit49</module>
        <module>junit4-rule-objenesis</module>
        <module>junit4-rule-xstream</module>
        <module>mockito</module>
        <module>testng</module>
    </modules>
</project>
        <module>module-test</module>
    </modules>

    <dependencies>
        <dependency>
            <groupId>org.assertj</groupId>
            <artifactId>assertj-core</artifactId>
            <version>3.3.0</version>
        </dependency>
    </dependencies>
</project>
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->
<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://maven.apache.org/POM/4.0.0" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.sonatype.oss</groupId>
    <url>http://www.powermock.org</url>
    <description>
        PowerMock allows you to unit test code normally regarded as untestable.
        For instance it is possible to mock static methods, remove static initializers, allow mocking without dependency injection and more.
        PowerMock works by bytecode manipulation.
        PowerMock also contain some utilities that gives you easier access to an objects internal state.
        PowerMock can be used to test otherwise untestable code and also to achieve a cleaner separation between test and production code.
    </description>
    <inceptionYear>2007</inceptionYear>
    <licenses>
                <artifactId>cglib-nodep</artifactId>
                <version>2.2.2</version>
            </dependency>
        </dependencies>
    </dependencyManagement>
</project>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
compile.dependencies = intermine/integrate/main, bio/core/main, bio/postprocess/main

compile.dependencies = intermine/integrate/main, bio/core/main, bio/postprocess/main

compile.dependencies = intermine/integrate/main, bio/core/main, bio/postprocess/main

compile.dependencies = intermine/integrate/main, bio/core/main, bio/postprocess/main
import java.util.Arrays;
import java.util.Date;
import java.util.HashSet;
import java.util.List;

import org.custommonkey.xmlunit.XMLTestCase;
public void testToItemDynamic() throws Exception {
        Company c = (Company) o;
        c.setId(new Integer(1234));
        c.setName("BrokeCompany1");
        c.setDepartments(new HashSet(Arrays.asList(new Object[] {d1, d2})));

        Broke b = (Broke) o;
        b.setDebt(10);
public void testToItemDynamic() throws Exception {
        exp1.setAttribute("interestRate", "0.0");
        List<String> refIds = new ArrayList<String>(Arrays.asList(new String[] {"5678", "6789"}));
        exp1.setCollection("departments", refIds);

        assertEquals(exp1, new ItemFactory(model).makeItem(b));
    }

    public void testToItems() throws Exception {
public void testRenderObjectDynamic() throws Exception {
        Company c = (Company) o;
        c.setId(new Integer(1234));
        c.setName("BrokeCompany1");
        c.setDepartments(new HashSet(Arrays.asList(new Object[] {d1, d2})));

        Broke b = (Broke) o;
        b.setDebt(10);
	<classpathentry combineaccessrules="false" kind="src" path="/testmodel"/>
	<classpathentry kind="src" path="/intermine-model-main"/>
	<classpathentry kind="lib" path="resources"/>
	<classpathentry kind="output" path="bin"/>
</classpath>

package org.intermine.web.filters;

import static org.easymock.EasyMock.*;

import java.io.IOException;
import java.util.Properties;
package org.intermine.web.logic;

import static org.junit.Assert.*;

import java.math.BigDecimal;
import java.util.LinkedHashMap;
package org.intermine.web.logic.template;

import static org.junit.Assert.*;

import java.util.Arrays;
import java.util.Collections;

import org.intermine.MockHttpRequest;
import org.intermine.api.template.TemplateHelper;
import org.intermine.metadata.Model;
import org.intermine.metadata.ConstraintOp;
import org.intermine.pathquery.Constraints;
import org.intermine.pathquery.PathQuery;
import org.intermine.template.SwitchOffAbility;
 *
 */

import org.intermine.metadata.Model;
import org.intermine.metadata.ConstraintOp;
import org.intermine.pathquery.PathConstraint;
import org.intermine.pathquery.PathConstraintAttribute;
import org.intermine.web.logic.widget.config.WidgetConfig;
 */

import org.intermine.api.profile.InterMineBag;
import org.intermine.objectstore.ObjectStore;
import org.intermine.metadata.ConstraintOp;
import org.intermine.objectstore.query.ConstraintSet;
import org.intermine.objectstore.query.ContainsConstraint;
import org.intermine.objectstore.query.Query;
 */
package org.intermine.web.security;

import static org.junit.Assert.*;

import java.security.KeyPairGenerator;
import java.security.PublicKey;
 *
 */

import static org.junit.Assert.*;

import java.security.KeyPair;
import java.security.KeyPairGenerator;
package org.intermine.web.struts;

import static org.easymock.EasyMock.*;
import static org.junit.Assert.*;

import java.util.*;

import javax.servlet.*;
import javax.servlet.http.*;

import org.apache.struts.action.*;
import org.apache.struts.config.*;
import org.intermine.api.*;
import org.intermine.api.results.*;
import org.intermine.metadata.*;
import org.intermine.pathquery.*;
import org.intermine.web.logic.results.*;
import org.junit.*;


public class AddColumnActionTest {
package org.intermine.web.struts;

import static org.easymock.EasyMock.*;
import static org.junit.Assert.*;

import java.util.HashMap;
import java.util.Map;
import org.intermine.api.bag.BagQueryConfig;
import org.intermine.api.bag.BagQueryRunner;
import org.intermine.api.profile.ProfileManager;
import org.intermine.api.template.TemplateSummariser;
import org.intermine.objectstore.ObjectStore;
import org.intermine.objectstore.ObjectStoreSummary;
import org.intermine.objectstore.ObjectStoreWriter;
import org.intermine.api.template.TemplateManager;
import org.intermine.api.types.ClassKeys;

/**
 * InterMineAPITest is a class created only to allow some tests.
package org.intermine.webservice.server.core;

import static org.junit.Assert.*;

import java.util.Arrays;
import java.util.Collections;
package org.intermine.webservice.server.core;

import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.Arrays;
package org.intermine.webservice.server.core;

import static org.intermine.util.DynamicUtil.createObject;
import static java.util.Collections.singleton;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import java.util.HashSet;
import java.util.Set;

import org.intermine.metadata.ClassDescriptor;
import org.intermine.metadata.Model;
import org.intermine.webservice.server.exceptions.BadRequestException;

import junit.framework.TestCase;

public class TestFindCommonType extends TestCase {

    private final static Model testModel = Model.getInstanceByName("testmodel");
import org.intermine.api.profile.TagManager;
import org.intermine.api.query.PathQueryExecutor;
import org.intermine.api.query.WebResultsExecutor;
import org.intermine.api.template.TemplateSummariser;
import org.intermine.api.tracker.TrackerDelegate;
import org.intermine.api.types.ClassKeys;
import org.intermine.metadata.Model;
import org.intermine.model.InterMineObject;
import org.intermine.objectstore.ObjectStore;
import org.intermine.objectstore.ObjectStoreSummary;
import org.intermine.api.template.TemplateManager;

/**
 * A dummy version of the API for testing against.
import org.intermine.objectstore.query.Results;
import org.intermine.objectstore.query.ResultsRow;
import org.intermine.pathquery.PathQuery;

public class JSONObjFormatterTest extends TestCase {

public void testJSONObjectFormatter() {
        assertTrue(fmtr != null);
    }

    public void testFormatHeader() {
        JSONObjectFormatter fmtr = new JSONObjectFormatter();

        String expected = testProps.getProperty("result.header");
public void testFormatFooter() {
        assertEquals(expected, fmtr.formatFooter("this error", 501));
    }

    public void testFormatAll() {
        JSONObjectFormatter fmtr = new JSONObjectFormatter();
        StreamedOutput out = new StreamedOutput(pw, fmtr);
        out.setHeaderAttributes(attributes);
public void testFormatAll() {

        assertTrue(pw == out.getWriter());
        assertEquals(5, out.getResultsCount());
        assertEquals(expected, sw.toString());
    }
}
import org.intermine.objectstore.query.Results;
import org.intermine.objectstore.query.ResultsRow;
import org.intermine.pathquery.PathQuery;

public class JSONObjResultProcessorTest extends TestCase {

public void testJSONObjResultProcessor() {
        assertTrue(processor != null);
    }

    public void testWrite() {
        List<List<String>> expected = Arrays.asList(
            Arrays.asList("{\"objectId\":5,\"name\":\"Tim Canterbury\",\"age\":30,\"class\":\"Employee\"}", ""),
            Arrays.asList("{\"objectId\":6,\"name\":\"Gareth Keenan\",\"age\":32,\"class\":\"Employee\"}", ""),
public void testWrite() {
        JSONObjResultProcessor processor = new JSONObjResultProcessor();
        processor.write(iterator, out);

        assertEquals(expected.toString(), out.getResults().toString());

    }

public void testHeadInWrongPlace() throws Exception {
            // rethrow the fail from within the try
            throw e;
        } catch (JSONFormattingException e) {
            // Test that this is what we thought would happen.
            assertEquals(
                "This result element ( Sales 11 Department) " +
                "does not belong on this map " +
                "({objectId=5, class=Employee, employees=[{objectId=5, name=Tim Canterbury, class=Employee}]}) " +
                "- classes don't match (Department ! isa Employee)",
                e.getMessage());
        } catch (Throwable e){
            // All other exceptions are failures
            fail("Got unexpected error: " + e);
public void testMultipleObjectsWithColls() throws Exception {
    }

    public void testMultipleObjectsWithRefs() throws Exception {
        
        List<String> jsonStrings = new ArrayList<String>();

        jsonStrings.add(
import org.intermine.web.context.InterMineContext;
import org.intermine.web.logic.ClassResourceOpener;
import org.intermine.web.logic.config.WebConfig;

/**
 * @author Alexis Kalderimis
public void testJSONRowFormatter() {
        assertTrue(fmtr != null);
    }

    public void testFormatHeader() {
        JSONRowFormatter fmtr = new JSONRowFormatter();

        String expected = testProps.getProperty("result.header");
public void testFormatFooter() {
        assertEquals(expected, fmtr.formatFooter("Not feeling like it", 400));
    }

    public void testFormatAll() throws IOException {
        JSONRowFormatter fmtr = new JSONRowFormatter();
        StreamedOutput out = new StreamedOutput(pw, fmtr);
        out.setHeaderAttributes(attributes);
public void testFormatAll() throws IOException {
                executionTime);
        assertTrue(pw == out.getWriter());
        assertEquals(5, out.getResultsCount());
        assertEquals(expected, sw.toString());
    }

    public void testFormatAllBad() {
        JSONRowFormatter fmtr = new JSONRowFormatter();
        StreamedOutput out = new StreamedOutput(pw, fmtr);
        out.setHeaderAttributes(attributes);
public void testFormatAllBad() {
                executionTime);
        assertTrue(pw == out.getWriter());
        assertEquals(5, out.getResultsCount());
        assertEquals(expected, sw.toString());

    }
}
import org.intermine.web.context.InterMineContext;
import org.intermine.web.logic.ClassResourceOpener;
import org.intermine.web.logic.config.WebConfig;

/**
 * @author alex
public void testZeroResults() {
        assertEquals(expected.toString(), out.getResults().toString());
    }

    public void testWrite() throws IOException {
        InputStream is = getClass().getResourceAsStream("JSONRowResultProcessorTest.expected");
        StringWriter sw = new StringWriter();
        IOUtils.copy(is, sw);
public void testWrite() throws IOException {
//        fw.write(out.getResults().toString());
//        fw.close();

        assertEquals(expected, out.getResults().toString() + "\n");

    }

import java.util.List;
import java.util.Map;

import org.intermine.api.profile.InterMineBag;
import org.intermine.metadata.Model;
import org.intermine.pathquery.Path;
import org.intermine.pathquery.PathQuery;
import org.intermine.webservice.server.core.Producer;

import junit.framework.AssertionFailedError;
import junit.framework.TestCase;

/**
 * @author Alexis Kalderimis
 *
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void findAndParseTargets(RoundEnvironment roundEnv, Set<? extends TypeEl

  private void createFactoriesForClassesAnnotatedWithScopeAnnotations(RoundEnvironment roundEnv, Set<? extends TypeElement> annotations) {
    for (TypeElement annotation : annotations) {
      if (annotation.getAnnotationsByType(Scope.class).length != 0) {
        createFactoriesForClassesAnnotatedWith(roundEnv, annotation);
      }
    }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public static void setSocketWriteTimeout(Socket s, long timeoutMillis) throws So
        }
    }

    public static void setSSLParameters(
            SSLParameters params, SSLParametersImpl impl, OpenSSLSocketImpl socket) {
        try {
            Method m_getEndpointIdentificationAlgorithm =
                    params.getClass().getMethod("getEndpointIdentificationAlgorithm");
            impl.setEndpointIdentificationAlgorithm(
                    (String) m_getEndpointIdentificationAlgorithm.invoke(params));

            Method m_getUseCipherSuitesOrder =
                    params.getClass().getMethod("getUseCipherSuitesOrder");
            impl.setUseCipherSuitesOrder((boolean) m_getUseCipherSuitesOrder.invoke(params));

            if (Build.VERSION.SDK_INT >= 24) {
                setSocketSniHostname(params, socket);
            }
        } catch (NoSuchMethodException ignored) {
        } catch (IllegalAccessException ignored) {
public static void setSSLParameters(
    }

    @TargetApi(24)
    private static void setSocketSniHostname(SSLParameters params, OpenSSLSocketImpl socket)
            throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
        Method m_getServerNames = params.getClass().getMethod("getServerNames");
        @SuppressWarnings("unchecked")
        List<SNIServerName> serverNames = (List<SNIServerName>) m_getServerNames.invoke(params);
        if (serverNames != null) {
            for (SNIServerName serverName : serverNames) {
                if (serverName.getType() == StandardConstants.SNI_HOST_NAME) {
                    socket.setHostname(((SNIHostName) serverName).getAsciiName());
                    break;
                }
            }
        }
    }

    public static void getSSLParameters(
            SSLParameters params, SSLParametersImpl impl, OpenSSLSocketImpl socket) {
        try {
            Method m_setEndpointIdentificationAlgorithm =
                    params.getClass().getMethod("setEndpointIdentificationAlgorithm", String.class);
            m_setEndpointIdentificationAlgorithm.invoke(
                    params, impl.getEndpointIdentificationAlgorithm());

            Method m_setUseCipherSuitesOrder =
                    params.getClass().getMethod("setUseCipherSuitesOrder", boolean.class);
            m_setUseCipherSuitesOrder.invoke(params, impl.getUseCipherSuitesOrder());

            if (Build.VERSION.SDK_INT >= 24) {
                setParametersSniHostname(params, impl, socket);
private static void setParametersSniHostname(
        }
    }

    /**
     * Tries to return a Class reference of one of the supplied class names.
     */
private static OpenSSLEngineImpl toConscrypt(SSLEngine engine) {
        }

        /**
         * Returns the maximum overhead, in bytes, of sealing a record with SSL.
         */
        public static int maxSealOverhead(SSLEngine engine) {
import javax.net.ssl.SSLEngineResult.Status;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLHandshakeException;
import javax.net.ssl.SSLSession;
import javax.net.ssl.X509ExtendedKeyManager;
import javax.net.ssl.X509KeyManager;
    private static final ByteBuffer EMPTY = ByteBuffer.allocateDirect(0);
    private static final long EMPTY_ADDR = NativeCrypto.getDirectBufferAddress(EMPTY);

    private final SSLParametersImpl sslParameters;

    /**
private void beginHandshakeInternal() throws SSLException {
            final AbstractSessionContext sessionContext = sslParameters.getSessionContext();
            sslNativePointer = NativeCrypto.SSL_new(sessionContext.sslCtxNativePointer);
            networkBio = NativeCrypto.SSL_BIO_new(sslNativePointer);
            sslSession =
                    sslParameters.getSessionToReuse(sslNativePointer, getPeerHost(), getPeerPort());
            sslParameters.setSSLParameters(sslNativePointer, this, this, getPeerHost());
            sslParameters.setCertificateValidation(sslNativePointer);
            sslParameters.setTlsChannelId(sslNativePointer, channelIdPrivateKey);
            if (getUseClientMode()) {
private void beginHandshakeInternal() throws SSLException {
            String message = e.getMessage();
            // Must match error reason string of SSL_R_UNEXPECTED_CCS (in ssl/ssl_err.c)
            if (message.contains("unexpected CCS")) {
                String logMessage = String.format("ssl_unexpected_ccs: host=%!s(MISSING)", getPeerHost());
                Platform.logEvent(logMessage);
            }
            throw new SSLException(e);
public boolean getEnableSessionCreation() {
    }

    @Override
    public HandshakeStatus getHandshakeStatus() {
        synchronized (stateLock) {
            return getHandshakeStatusInternal();
public boolean getNeedClientAuth() {
    @Override
    public SSLSession getSession() {
        if (sslSession == null) {
            return handshakeSession != null ? handshakeSession : SSLNullSession.getNullSession();
        }
        return sslSession;
    }

    @Override
SSLEngineResult unwrap(final ByteBuffer[] srcs, int srcsOffset, final int srcsLe
                throw shutdownWithError("Failed to obtain session after handshake completed");
            }
            sslSession = sslParameters.setupSession(sslSessionCtx, sslNativePointer, sslSession,
                    getPeerHost(), getPeerPort(), true);
            if (sslSession != null && engineState == EngineState.HANDSHAKE_STARTED) {
                engineState = EngineState.READY_HANDSHAKE_CUT_THROUGH;
            } else {
public void verifyCertificateChain(long[] certRefs, String authMethod)
            // Used for verifyCertificateChain callback
            handshakeSession = new OpenSSLSessionImpl(
                    NativeCrypto.SSL_get1_session(sslNativePointer), null, peerCertChain, ocspData,
                    tlsSctData, getPeerHost(), getPeerPort(), null);

            boolean client = sslParameters.getUseClientMode();
            if (client) {
public static void getSSLParameters(SSLParameters params, SSLParametersImpl impl
        }
    }

    /**
     * Tries to return a Class reference of one of the supplied class names.
     */
public static void getSSLParameters(SSLParameters params, SSLParametersImpl impl
        }
    }

    /**
     * Helper function to unify calls to the different names used for each function taking a
     * Socket, SSLEngine, or String (legacy Android).
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
              <links>
                <link>http://docs.hazelcast.org/docs/3.6/javadoc/</link>
              </links>
            </configuration>
          </execution>
        </executions>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Generates the Administrative Curate Form, from which any DSpace object can
 * be curated. 
 * @author tdonohue
 */
public class CurateForm extends AbstractDSpaceTransformer 
{
        private static final Message T_dspace_home = message("xmlui.general.dspace_home");
        private static final Message T_submit_perform = message("xmlui.general.perform");
        private static final Message T_submit_queue = message("xmlui.general.queue");
        private static final Message T_title = message("xmlui.administrative.CurateForm.title");
        private static final Message T_trail = message("xmlui.administrative.CurateForm.trail");
        private static final Message T_task_label_name = message("xmlui.administrative.CurateForm.task_label_name");
        private static final Message T_taskgroup_label_name = message("xmlui.administrative.CurateForm.taskgroup_label_name");
        private static final Message T_object_label_name = message("xmlui.administrative.CurateForm.object_label_name");
        private static final Message T_object_hint = message("xmlui.administrative.CurateForm.object_hint");
        
        public void setup(SourceResolver resolver, Map objectModel, String src,
		          Parameters parameters) throws ProcessingException, SAXException, IOException
		{
        	super.setup(resolver, objectModel, src, parameters);
        	FlowCurationUtils.setupCurationTasks();
		}
        
        /**
         * Initialize the page metadata & breadcrumb trail
         *
         * @param pageMeta
         * @throws WingException
         */
        @Override
        public void addPageMeta(PageMeta pageMeta) throws WingException
        {
                pageMeta.addMetadata("title").addContent(T_title);
                pageMeta.addTrailLink(contextPath + "/", T_dspace_home);
                pageMeta.addTrail().addContent(T_trail);
        }
        
        /** 
         * Add object curation form
         * 
         * @param body
         * @throws WingException
         * @throws SQLException
         * @throws AuthorizeException
         */
        @Override
        public void addBody(Body body)
                throws WingException, SQLException,
                       AuthorizeException, UnsupportedEncodingException
        {
                // Get our parameters and state;
                String objectID = parameters.getParameter("identifier", null);
                String taskSelected = parameters.getParameter("curate_task", null);
                
                // DIVISION: curate
                Division div = body.addInteractiveDivision("curate", contextPath + "/admin/curate", Division.METHOD_MULTIPART,"primary administrative curate");
                div.setHead(T_title);
                
                // Curate Form
                List form = div.addList("curate-form", List.TYPE_FORM);
		
                // Object ID Textbox (required)
                Text id = form.addItem().addText("identifier");
                id.setAutofocus("autofocus");
                id.setLabel(T_object_label_name);
                if (objectID != null)
                {
                    id.setValue(objectID);
                }
                id.setRequired();
                id.setHelp(T_object_hint);
                
                // Selectbox of Curation Task options (required)
                String curateGroup = "";
                try
                {
                	curateGroup = (parameters.getParameter("select_curate_group") != null) ? parameters.getParameter("select_curate_group") : FlowCurationUtils.UNGROUPED_TASKS;
                }
                catch (Exception pe)
                {
                	// noop
                }
                if (!FlowCurationUtils.groups.isEmpty())
                {
                    Select groupSelect = form.addItem().addSelect("select_curate_group");
                    groupSelect = FlowCurationUtils.getGroupSelectOptions(groupSelect);
                    groupSelect.setLabel(T_taskgroup_label_name); 
                    groupSelect.setSize(1);
                    groupSelect.setRequired();
                    groupSelect.setEvtBehavior("submitOnChange");
                    if (curateGroup.equals(""))
                    {
                    	curateGroup = (String) (FlowCurationUtils.groups.keySet().iterator().next());
                    }
                    groupSelect.setOptionSelected(curateGroup);
                }
                Select taskSelect = form.addItem().addSelect("curate_task");
                taskSelect = FlowCurationUtils.getTaskSelectOptions(taskSelect, curateGroup);
                taskSelect.setLabel(T_task_label_name);
                taskSelect.setSize(1);
                taskSelect.setRequired();
                if(taskSelected!=null)
                {    
                    taskSelect.setOptionSelected(taskSelected);
                }
                
                // Buttons: 'curate' and 'queue'
                Para buttonList = div.addPara();
                buttonList.addButton("submit_curate_task").setValue(T_submit_perform);
                buttonList.addButton("submit_queue_task").setValue(T_submit_queue);
                div.addHidden("administrative-continue").setValue(knot.getId());
        }
}
 * and returns an object of type FlowResult, then the flow script can inspect
 * the results object to determine what the next course of action is.
 * 
 * Basically, this results object stores all the errors and continuation states
 * that need to be represented. There are four types of information stored:
 * 
 * 1) Continuation, this is a simple boolean variable that indicates whether
 * the required operation is complete and the user may continue on to the next step.
 * 
 * 2) Notice information, this is a simple encoding of a notice message to be displayed
 * to the user on their next step. There are four parts: outcome, header, message, and
 * characters. See each field for more description on each part. Note: either a message
 * or characters are required.
 * 
 * 3) Errors, this is a list of errors that were encountered during processing. 
 * Typically, it just consists of a list of errored fields. However occasionally there 
 * may be other specialized errors listed.
 * 
 * 4) Parameters, this is a map of attached parameters that may be relevant to the 
 * result. This should be used for things such as generated id's when objects are newly
 * created.
 * 

	/**
	 * Determine whether the operation has been completed enough that the user
	 * may successufully continue on to the next step.
	 */
	private boolean continuep;
	
	 */
	private List<String> errors;
	
	
	/**
	 * Any parameters that may be attached to this result.
	 */
	/**
	 * Set the continuation parameter determining if the
	 * user should progress to the next step in the flow.
	 */
	public void setContinue(boolean continuep)
	{
public void setOutcome(boolean success)
	/**
	 * Get the notice outcome in string form, either success 
	 * or failure. If the outcome is neutral then null is returned.
	 */
	public String getOutcome()
	{
else if (outcome == Outcome.FAILURE)
	 * Set the notice header.
	 * 
	 * This must be an i18n dictionary key
	 */
	public void setHeader(Message header)
	{
		this.header = header;
	}
	
	/**
	 * Return the notice header
	 */
	public String getHeader()
	{
public String getHeader()
	}
	
	/**
	 * Set the notice message
	 * 
	 * This must be an i18n dictionary key
	 */
	public void setMessage(Message message)
	{
		this.message = message;
	}
	
	/**
	 * return the notice message
	 */
	public String getMessage()
	{
public String getMessage()
	}
	
	/**
	 * Set the notice characters
	 */
	public void setCharacters(String characters)
	{
public void setCharacters(String characters)
	
	/**
	 * Return the notice characters
	 */
	public String getCharacters()
	{
public void addError(String newError)
	{
		if (this.errors == null)
        {
            this.errors = new ArrayList<String>();
        }
		
		this.errors.add(newError);
	}
	
	/**
	 * Return the current list of errors.
	 */
	public List<String> getErrors()
	{
public void addError(String newError)
	/**
	 * Return the list of errors in string form, i.e. a comma-separated list
	 * of errors. If there are no errors then null is returned.
	 */
	public String getErrorString()
	{
		if (errors == null || errors.size() == 0)
        {
            return null;
        }
public String getErrorString()
	
	/**
	 * Attach a new parameter to this result object with the specified
	 * name & value.
	 * 
	 * @param name The parameter's name
	 * @param value The parameter's value.
	 */
	public void setParameter(String name, Object value)
	{
		if (this.parameters == null)
        {
            this.parameters = new HashMap<String, Object>();
        }
		
		this.parameters.put(name, value);

/**
 * 
 * Show a form allowing the user to edit a bitstream's metadata, the description & format.
 * 
 * @author Scott Phillips
 */
public class EditBitstreamForm extends AbstractDSpaceTransformer
	protected BitstreamService bitstreamService = ContentServiceFactory.getInstance().getBitstreamService();
	protected BitstreamFormatService bitstreamFormatService = ContentServiceFactory.getInstance().getBitstreamFormatService();

	public void addPageMeta(PageMeta pageMeta) throws WingException
	{
		pageMeta.addMetadata("title").addContent(T_title);
public void addPageMeta(PageMeta pageMeta) throws WingException
        pageMeta.addMetadata("javascript", "static").addContent("static/js/editItemUtil.js");
	}

	public void addBody(Body body) throws SAXException, WingException,
	UIException, SQLException, IOException, AuthorizeException
	{
 * This item may be configured so that it will only display up to a specific depth,
 * and may include or exclude collections from the tree.
 * 
 * The configuration option available: <depth exclude-collections="true">999</depth>
 * 
 * @author Scott Phillips
 */
public class CommunityBrowser extends AbstractDSpaceTransformer implements CacheableProcessingComponent
{
    private static Logger log = Logger.getLogger(CommunityBrowser.class);

    /** Language Strings */
    public static final Message T_dspace_home =
    /**
     * Set the component up, pulling any configuration values from the sitemap
     * parameters.
     */
    public void setup(SourceResolver resolver, Map objectModel, String src,
            Parameters parameters) throws ProcessingException, SAXException,
            IOException
    {
        super.setup(resolver, objectModel, src, parameters);

public void setup(SourceResolver resolver, Map objectModel, String src,
    /**
     * Generate the unique caching key.
     * This key must be unique within the space of this component.
     */
    public Serializable getKey()
    {
    	boolean full = DSpaceServicesFactory.getInstance().getConfigurationService().getBooleanProperty("xmlui.community-list.render.full", true);
public Serializable getKey()
     * 
     * The validity object will include a list of all communities 
     * and collections being browsed along with their logo bitstreams.
     */
    public SourceValidity getValidity()
    {
    	if (validity == null)
    	{
	        try {
	            DSpaceValidity validity = new DSpaceValidity();
	            
	            TreeNode root = buildTree(communityService.findAllTop(context));
	            
	            Stack<TreeNode> stack = new Stack<TreeNode>();
	            stack.push(root);
	            
	            while (!stack.empty())
	            {
	                TreeNode node = stack.pop();
	                
	                validity.add(context, node.getDSO());
	                
	                // If we are configured to use collection strengths (i.e. item counts) then include that number in the validity.
	                boolean showCount = DSpaceServicesFactory.getInstance().getConfigurationService().getBooleanProperty("webui.strengths.show");
public SourceValidity getValidity()
	                    {	//try to determine Collection size (i.e. # of items)
	                    	
	                    	int size = new ItemCounter(context).getCount(node.getDSO());
	                    	validity.add("size:"+size);
	                    }
	                    catch(ItemCountException e) { /* ignore */ }
	        		}
public SourceValidity getValidity()
	            String assumeCacheValidity = DSpaceServicesFactory.getInstance().getConfigurationService().getProperty("xmlui.community-list.cache");
	            if (assumeCacheValidity != null)
                {
                    validity.setAssumedValidityDelay(assumeCacheValidity);
                }
	            
	            this.validity = validity.complete();
	        } 
	        catch (SQLException sqle) 
	        {
public SourceValidity getValidity()

    /**
     * Add a page title and trail links.
     */
    public void addPageMeta(PageMeta pageMeta) throws SAXException,
            WingException, UIException, SQLException, IOException,
            AuthorizeException
public void addPageMeta(PageMeta pageMeta) throws SAXException,
    /**
     * Add a community-browser division that includes references to community and
     * collection metadata.
     */
    public void addBody(Body body) throws SAXException, WingException,
            UIException, SQLException, IOException, AuthorizeException
    {
        Division division = body.addDivision("comunity-browser", "primary");
        division.setHead(T_head);
        division.addPara(T_select);

        TreeNode root = buildTree(communityService.findAllTop(context));
        
        boolean full = DSpaceServicesFactory.getInstance().getConfigurationService().getBooleanProperty("xmlui.community-list.render.full", true);
        
        if (full)
        {
	        ReferenceSet referenceSet = division.addReferenceSet("community-browser",
	                ReferenceSet.TYPE_SUMMARY_LIST,null,"hierarchy");
	        
	        java.util.List<TreeNode> rootNodes = root.getChildrenOfType(Constants.COMMUNITY);
	        
	        for (TreeNode node : rootNodes)
	        {
public void addBody(Body body) throws SAXException, WingException,
        {
        	List list = division.addList("comunity-browser");
        	
        	java.util.List<TreeNode> rootNodes = root.getChildrenOfType(Constants.COMMUNITY);
 	        
 	        for (TreeNode node : rootNodes)
 	        {
public void addBody(Body body) throws SAXException, WingException,
     * 
     * @param referenceSet The include set
     * @param node The current node of the hierarchy.
     */
    public void buildReferenceSet(ReferenceSet referenceSet, TreeNode node) throws WingException
    {
public void buildReferenceSet(ReferenceSet referenceSet, TreeNode node) throws W
     * 
     * @param list The parent list
     * @param node The current node of the hierarchy.
     */
    public void buildList(List list, TreeNode node) throws WingException
    {
else if (dso instanceof Collection)
            name = ((Collection) dso).getName();
        }
        
        String url = contextPath + "/handle/"+dso.getHandle();
        list.addItem().addHighlight("bold").addXref(url, name);
        
        List subList = null;
        
else if (dso instanceof Collection)
                subList.addItemXref(collectionUrl, collectionName);
            }
        }
        
        
        // Add all the sub-communities
        java.util.List<TreeNode> communityNodes = node.getChildrenOfType(Constants.COMMUNITY);
        if (communityNodes != null && communityNodes.size() > 0)
else if (dso instanceof Collection)
        }
    }
    
    /**
     * recycle
     */
    public void recycle() 
    {
        this.root = null;
private TreeNode buildTree(java.util.List<Community> communities) throws SQLExce
        TreeNode newRoot = new TreeNode();

        // Setup for breadth-first traversal
        Stack<TreeNode> stack = new Stack<TreeNode>();

        for (Community community : communities)
        {
private TreeNode buildTree(java.util.List<Community> communities) throws SQLExce
    }

    /**
     * Private class to represent the tree structure of communities & collections. 
     */
    protected static class TreeNode
    {
private TreeNode buildTree(java.util.List<Community> communities) throws SQLExce
        private int level;

        /** All children of this node */
        private java.util.List<TreeNode> children = new ArrayList<TreeNode>();

        /** 
         * Construct a new root level node 
public int getLevel()
        }

        /**
         * @return All children of the given @type.
         */
        public java.util.List<TreeNode> getChildrenOfType(int type)
        {
            java.util.List<TreeNode> results = new ArrayList<TreeNode>();
            for (TreeNode node : children)
            {
                if (node.dso.getType() == type)
    /**
     * Generate the unique caching key.
     * This key must be unique inside the space of this component.
     */
    @Override
    public Serializable getKey() {
public Serializable getKey() {
     * Generate the cache validity object.
     *
     * The validity object will include the item being viewed,
     * along with all bundles & bitstreams.
     */
    @Override
    public SourceValidity getValidity()
public SourceValidity getValidity()
	        try {
	            dso = HandleUtil.obtainHandle(objectModel);

	            DSpaceValidity validity = new DSpaceValidity();
	            validity.add(context, dso);
	            this.validity =  validity.complete();
	        }
	        catch (Exception e)
	        {
public SourceValidity getValidity()

    /**
     * Add the item's title and trail links to the page's metadata.
     */
    @Override
    public void addPageMeta(PageMeta pageMeta) throws SAXException,
else if (doiMatcher.lookingAt())

    /**
     * Display a single item
     */
    @Override
    public void addBody(Body body) throws SAXException, WingException,
public void addBody(Body body) throws SAXException, WingException,

    /**
     * Determine if the full item should be referenced or just a summary.
     */
    public static boolean showFullItem(Map objectModel)
    {
        Request request = ObjectModelHelper.getRequest(objectModel);
        String show = request.getParameter("show");

        if (show != null && show.length() > 0)
        {
            return true;
        }

        return false;
    }

    /**
     * Recycle
     */
    @Override
    public void recycle() {
    	this.validity = null;
 */
public class SendItemRequestAction extends AbstractAction
{
    private static Logger log = Logger.getLogger(SendItemRequestAction.class);

    protected HandleService handleService = HandleServiceFactory.getInstance().getHandleService();
    protected RequestItemService requestItemService = RequestItemServiceFactory.getInstance().getRequestItemService();
    protected BitstreamService bitstreamService = ContentServiceFactory.getInstance().getBitstreamService();

    public Map act(Redirector redirector, SourceResolver resolver, Map objectModel,
            String source, Parameters parameters) throws Exception
    {
public Map act(Redirector redirector, SourceResolver resolver, Map objectModel,
        {
            // Either the user did not fill out the form or this is the
            // first time they are visiting the page.
            Map<String,String> map = new HashMap<String,String>();
            map.put("bitstreamId",bitstreamId);

            if (StringUtils.isEmpty(requesterEmail))
public Map act(Redirector redirector, SourceResolver resolver, Map objectModel,

    /**
     * Get the link to the author in RequestLink email.
     * @param context
     * @param requestItem
     * @return
     * @throws SQLException
     */
    protected String getLinkTokenEmail(Context context, String token)
            throws SQLException
    {
        String base = DSpaceServicesFactory.getInstance().getConfigurationService().getProperty("dspace.url");

        String specialLink = (new StringBuffer()).append(base).append(
                base.endsWith("/") ? "" : "/").append(
                "itemRequestResponse/").append(token)
                .toString()+"/";

        return specialLink;
import org.apache.cocoon.environment.Request;
import org.apache.cocoon.util.HashUtil;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.ArrayUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.excalibur.source.SourceValidity;
import org.apache.log4j.Logger;
import org.dspace.app.util.MetadataExposureServiceImpl;
import org.dspace.app.util.factory.UtilServiceFactory;
import org.dspace.app.util.service.MetadataExposureService;
import org.dspace.app.xmlui.cocoon.AbstractDSpaceTransformer;
import org.dspace.discovery.configuration.DiscoverySortConfiguration;
import org.dspace.discovery.configuration.DiscoverySortConfiguration.SORT_ORDER;
import org.dspace.discovery.configuration.DiscoverySortFieldConfiguration;
import org.dspace.handle.HandleServiceImpl;
import org.dspace.handle.factory.HandleServiceFactory;
import org.dspace.handle.service.HandleService;
import org.xml.sax.SAXException;
 * This is an abstract search page. It is a collection of search methods that
 * are common between different search implementation. An implementer must
 * implement at least three methods: addBody(), getQuery(), and generateURL().
 * <p/>
 * See the SimpleSearch implementation.
 *
 * @author Kevin Van de Velde (kevin at atmire dot com)
    protected MetadataExposureService metadataExposureService = UtilServiceFactory.getInstance().getMetadataExposureService();
    protected HandleService handleService = HandleServiceFactory.getInstance().getHandleService();


    /**
     * Generate the unique caching key.
     * This key must be unique inside the space of this component.
     */
    public Serializable getKey() {
        try {
            String key = "";
public Serializable getKey() {
            return HashUtil.hash(key);
        } catch (RuntimeException re) {
            throw re;
        } catch (Exception e) {
            // Ignore all errors and just don't cache.
            return "0";
        }
    }

    /**
     * Generate the cache validity object.
     * <p/>
     * This validity object should never "over cache" because it will
     * perform the search, and serialize the results using the
     * DSpaceValidity object.
     */
    public SourceValidity getValidity() {
        if (this.validity == null) {
            try {
                DSpaceValidity validity = new DSpaceValidity();

                DSpaceObject scope = getScope();
                validity.add(context, scope);

                performSearch(scope);

                List<DSpaceObject> results = this.queryResults.getDspaceObjects();

                if (results != null) {
                    validity.add("total:"+this.queryResults.getTotalSearchResults());
                    validity.add("start:"+this.queryResults.getStart());
                    validity.add("size:" + results.size());

                    for (DSpaceObject dso : results) {
                        validity.add(context, dso);
                    }
                }

public SourceValidity getValidity() {
                    List<DiscoverResult.FacetResult> facetValues = facetResults.get(facetField);
                    for (DiscoverResult.FacetResult facetResult : facetValues)
                    {
                        validity.add(facetField + facetResult.getAsFilterQuery() + facetResult.getCount());
                    }
                }

                this.validity = validity.complete();
            } catch (RuntimeException re) {
                throw re;
            }
            catch (Exception e) {
                this.validity = null;
            }

public SourceValidity getValidity() {

    /**
     * Build the resulting search DRI document.
     */
    public abstract void addBody(Body body) throws SAXException, WingException,
            UIException, SQLException, IOException, AuthorizeException;

public abstract void addBody(Body body) throws SAXException, WingException,
     * This form will be used for all discovery queries, filters, ....
     * At the moment however this form is only used to track search result hits
     * @param searchDiv the division to add the form to
     */
    protected void buildMainForm(Division searchDiv) throws WingException, SQLException {
        Request request = ObjectModelHelper.getRequest(objectModel);
protected void buildMainForm(Division searchDiv) throws WingException, SQLExcept
     * which contains results for this search query.
     *
     * @param search The search division to contain the search-results division.
     */
    protected void buildSearchResultsDivision(Division search)
            throws IOException, SQLException, WingException, SearchServiceException {
protected void buildSearchResultsDivision(Division search)
            log.error(e.getMessage(), e);
            queryResults = null;
        }
        catch (Exception e) {
            log.error(e.getMessage(), e);
            queryResults = null;
        }
protected void buildSearchResultsDivision(Division search)
            //    lastItemIndex = itemsTotal;
            int currentPage = this.queryResults.getStart() / this.queryResults.getMaxResults() + 1;
            int pagesTotal = (int) ((this.queryResults.getTotalSearchResults() - 1) / this.queryResults.getMaxResults()) + 1;
            Map<String, String> parameters = new HashMap<String, String>();
            parameters.put("page", "{pageNum}");
            String pageURLMask = generateURL(parameters);
            pageURLMask = addFilterQueriesToUrl(pageURLMask);

            results.setMaskedPagination(itemsTotal, firstItemIndex,
protected void buildSearchResultsDivision(Division search)
            dspaceObjectsList = results.addList("search-results-repository",
                    org.dspace.app.xmlui.wing.element.List.TYPE_DSO_LIST, "repository-search-results");

            List<DSpaceObject> commCollList = new ArrayList<DSpaceObject>();
            List<Item> itemList = new ArrayList<Item>();
            for (DSpaceObject resultDso : queryResults.getDspaceObjects())
            {
                if(resultDso.getType() == Constants.COMMUNITY || resultDso.getType() == Constants.COLLECTION)
protected void renderItem(org.dspace.app.xmlui.wing.element.List dspaceObjectsLi
     * Render the given collection, all collection metadata is added to the list
     * @param collection the collection to be rendered
     * @param highlightedResults the highlighted results
     * @throws WingException
     */
    protected void renderCollection(Collection collection, DiscoverResult.DSpaceObjectHighlightResult highlightedResults, org.dspace.app.xmlui.wing.element.List collectionMetadata) throws WingException {

        String description = collectionService.getMetadata(collection, "introductory_text");
        String description_abstract = collectionService.getMetadata(collection, "short_description");
protected void renderCollection(Collection collection, DiscoverResult.DSpaceObje
     * Render the given collection, all collection metadata is added to the list
     * @param community the community to be rendered
     * @param highlightedResults the highlighted results
     * @throws WingException
     */

    protected void renderCommunity(Community community, DiscoverResult.DSpaceObjectHighlightResult highlightedResults, org.dspace.app.xmlui.wing.element.List communityMetadata) throws WingException {
        String description = communityService.getMetadata(community, "introductory_text");
        String description_abstract = communityService.getMetadata(community, "short_description");
        String description_table = communityService.getMetadata(community, "side_bar_text");
protected void renderCommunity(Community community, DiscoverResult.DSpaceObjectH

        if(StringUtils.isNotBlank(description))
        {
            addMetadataField(highlightedResults, "dc.description", communityMetadata.addList(community.getHandle() + ":dc.description"), description);
        }
        if(StringUtils.isNotBlank(description_abstract))
        {
            addMetadataField(highlightedResults, "dc.description.abstract", communityMetadata.addList(community.getHandle() + ":dc.description.abstract"), description_abstract);
        }
        if(StringUtils.isNotBlank(description_table))
        {
            addMetadataField(highlightedResults, "dc.description.tableofcontents", communityMetadata.addList(community.getHandle() + ":dc.description.tableofcontents"), description_table);
        }
        if(StringUtils.isNotBlank(identifier_uri))
        {
            addMetadataField(highlightedResults, "dc.identifier.uri", communityMetadata.addList(community.getHandle() + ":dc.identifier.uri"), identifier_uri);
        }
        if(StringUtils.isNotBlank(rights))
        {
            addMetadataField(highlightedResults, "dc.rights", communityMetadata.addList(community.getHandle() + ":dc.rights"), rights);
        }
        if(StringUtils.isNotBlank(title))
        {
            addMetadataField(highlightedResults, "dc.title", communityMetadata.addList(community.getHandle() + ":dc.title"), title);
        }
    }

protected void renderCommunity(Community community, DiscoverResult.DSpaceObjectH
     * @param value the metadata value
     * @throws WingException
     */
    protected void addMetadataField(DiscoverResult.DSpaceObjectHighlightResult highlightedResults, String metadataKey, org.dspace.app.xmlui.wing.element.List metadataFieldList, String value) throws WingException {
        if(value == null){
            //In the unlikely event that the value is null, do not attempt to render this
            return;
protected void addMetadataField(DiscoverResult.DSpaceObjectHighlightResult highl
    }

    /**
     * Add our metadata value, this value will might contain the highlight ("<em></em>") tags, these will be removed & rendered as highlight wing fields.
     * @param metadataFieldList the metadata list we need to add the value to
     * @param value the metadata value to be rendered
     * @throws WingException
     */
    protected void addMetadataField(org.dspace.app.xmlui.wing.element.List metadataFieldList, String value) throws WingException {
        //We need to put everything in <em> tags in a highlight !
protected void addMetadataField(org.dspace.app.xmlui.wing.element.List metadataF
    /**
     * Add options to the search scope field. This field determines in which
     * communities or collections to search for the query.
     * <p/>
     * The scope list will depend upon the current search scope. There are three
     * cases:
     * <p/>
     * No current scope: All top level communities are listed.
     * <p/>
     * The current scope is a community: All collections contained within the
     * community are listed.
     * <p/>
     * The current scope is a collection: All parent communities are listed.
     *
     * @param scope The current scope field.
     */
    protected void buildScopeList(Select scope) throws SQLException,
            WingException {
protected void buildScopeList(Select scope) throws SQLException,
    /**
     *  Prepare DiscoverQuery given the current scope and query string
     * 
     *  @param scope the dspace object parent
     */
    public DiscoverQuery prepareQuery(DSpaceObject scope, String query, String[] fqs) throws UIException, SearchServiceException {
    	
    	this.queryArgs = new DiscoverQuery();
    	
    	int page = getParameterPage();
    	    	
    	// Escape any special characters in this user-entered query
        query = DiscoveryUIUtils.escapeQueryChars(query);

    	List<String> filterQueries = new ArrayList<String>();

        if (fqs != null) {
            filterQueries.addAll(Arrays.asList(fqs));
public DiscoverQuery prepareQuery(DSpaceObject scope, String query, String[] fqs
     * Query DSpace for a list of all items / collections / or communities that
     * match the given search query.
     *
     *
     * @param scope the dspace object parent
     */
    public void performSearch(DSpaceObject scope) throws UIException, SearchServiceException {

public void performSearch(DSpaceObject scope) throws UIException, SearchServiceE
    protected Map<String, String[]> getParameterFilterQueries()
    {
        try {
            Map<String, String[]> result = new HashMap<String, String[]>();
            result.put("fq", ObjectModelHelper.getRequest(objectModel).getParameterValues("fq"));
            return result;
        }
protected int getParameterEtAl() {
    /**
     * Determine if the scope of the search should fixed or is changeable by the
     * user.
     * <p/>
     * The search scope when performed by url, i.e. they are at the url handle/xxxx/xx/search
     * then it is fixed. However at the global level the search is variable.
     *
     * @return true if the scope is variable, false otherwise.
     */
    protected boolean variableScope() throws SQLException {
        return (HandleUtil.obtainHandle(objectModel) == null);
    }

    /**
     * Extract the query string. Under most implementations this will be derived
     * from the url parameters.
     *
     * @return The query string.
     */
    protected abstract String getQuery() throws UIException;

    /**
     * Generate a url to the given search implementation with the associated
     * parameters included.
     *
     * @param parameters
     * @return The post URL
     */
    protected abstract String generateURL(Map<String, String> parameters)
            throws UIException;


    /**
     * Recycle
     */
    public void recycle() {
        this.queryArgs = null;
        this.queryResults = null;
        this.validity = null;
        super.recycle();
    }


    protected void buildSearchControls(Division div)
            throws WingException, SQLException {

protected void buildSearchControls(Division div)
     * specified then null is returned.
     *
     * @return The current scope.
     */
    protected DSpaceObject getScope() throws SQLException {
        Request request = ObjectModelHelper.getRequest(objectModel);
     */
    protected DiscoverQuery queryArgs;

    private int DEFAULT_PAGE_SIZE = 10;

    public static final String OFFSET = "offset";
    public static final String FACET_FIELD = "field";
public BrowseFacet() {
    /**
     * Generate the unique caching key.
     * This key must be unique inside the space of this component.
     */
    public Serializable getKey() {
        try {
            DSpaceObject dso = HandleUtil.obtainHandle(objectModel);
public Serializable getKey() {

    /**
     * Generate the cache validity object.
     * <p/>
     * The validity object will include the collection being viewed and
     * all recently submitted items. This does not include the community / collection
     * hierarchy, when this changes they will not be reflected in the cache.
     */
    public SourceValidity getValidity() {
        if (this.validity == null) {

            try {
                DSpaceValidity validity = new DSpaceValidity();

                DSpaceObject dso = HandleUtil.obtainHandle(objectModel);

                if (dso != null) {
                    // Add the actual collection;
                    validity.add(context, dso);
                }

                // add recently submitted items, serialize solr query contents.
                DiscoverResult response = getQueryResponse(dso);

                validity.add("numFound:" + response.getDspaceObjects().size());

                for (DSpaceObject resultDso : response.getDspaceObjects()) {
                    validity.add(context, resultDso);
                }

                for (String facetField : response.getFacetResults().keySet()) {
                    validity.add(facetField);

                    List<DiscoverResult.FacetResult> facetValues = response.getFacetResults().get(facetField);
                    for (DiscoverResult.FacetResult facetValue : facetValues) {
                        validity.add(facetValue.getAsFilterQuery() + facetValue.getCount());
                    }
                }


                this.validity = validity.complete();
            }
            catch (Exception e) {
                // Just ignore all errors and return an invalid cache.
public SourceValidity getValidity() {
     * Get the recently submitted items for the given community or collection.
     *
     * @param scope The collection.
     */
    protected DiscoverResult getQueryResponse(DSpaceObject scope) {

private Date getLowestDateValue(Context context, String query, String dateField,

    /**
     * Add a page title and trail links.
     */
    public void addPageMeta(PageMeta pageMeta) throws SAXException, WingException, SQLException, IOException, AuthorizeException {
        Request request = ObjectModelHelper.getRequest(objectModel);
        String facetField = request.getParameter(FACET_FIELD);

public void addBody(Body body) throws SAXException, WingException, UIException,
            Map<String, List<DiscoverResult.FacetResult>> facetFields = this.queryResults.getFacetResults();
            if (facetFields == null)
            {
                facetFields = new LinkedHashMap<String, List<DiscoverResult.FacetResult>>();
            }

//            facetFields.addAll(this.queryResults.getFacetDates());
public void addBody(Body body) throws SAXException, WingException, UIException,

                    Table singleTable = results.addTable("browse-by-" + facetField + "-results", (int) (queryResults.getDspaceObjects().size() + 1), 1);

                    List<String> filterQueries = new ArrayList<String>();
                    if(request.getParameterValues("fq") != null)
                    {
                        filterQueries = Arrays.asList(request.getParameterValues("fq"));
public void addBody(Body body) throws SAXException, WingException, UIException,
    }

    private String getNextPageURL(Request request) {
        Map<String, String> parameters = new HashMap<String, String>();
        parameters.put(FACET_FIELD, request.getParameter(FACET_FIELD));
        if (queryArgs.getFacetOffset() != -1)
        {
            parameters.put(OFFSET, String.valueOf(queryArgs.getFacetOffset() + DEFAULT_PAGE_SIZE));
        }

        // Add the filter queries
        String url = generateURL("browse-discovery", parameters);
        String[] fqs = getParameterFacetQueries();
        if (fqs != null) {
            StringBuilder urlBuilder = new StringBuilder(url);
            for (String fq : fqs) {
                urlBuilder.append("&fq=").append(fq);
            }

            url = urlBuilder.toString();
        }

        return url;
    }

    private String getPreviousPageURL(Request request) {
private String getPreviousPageURL(Request request) {
            return null;
        }

        Map<String, String> parameters = new HashMap<String, String>();
        parameters.put(FACET_FIELD, request.getParameter(FACET_FIELD));
        if (queryArgs.getFacetOffset() != -1)
        {
            parameters.put(OFFSET, String.valueOf(queryArgs.getFacetOffset() - DEFAULT_PAGE_SIZE));
        }

        // Add the filter queries
        String url = generateURL("browse-discovery", parameters);
        String[] fqs = getParameterFacetQueries();
        if (fqs != null) {
            StringBuilder urlBuilder = new StringBuilder(url);
            for (String fq : fqs) {
                urlBuilder.append("&fq=").append(fq);
            }

            url = urlBuilder.toString();
        }

        return url;
    }


    /**
     * Recycle
     */
    public void recycle() {
        // Clear out our item's cache.
        this.queryResults = null;
public void setup(SourceResolver resolver, Map objectModel, String src, Paramete
    /**
     * Generate the unique caching key.
     * This key must be unique inside the space of this component.
     */
    public Serializable getKey() {
        try {
            DSpaceObject dso = HandleUtil.obtainHandle(objectModel);
public Serializable getKey() {

    /**
     * Generate the cache validity object.
     * <p/>
     * The validity object will include the collection being viewed and
     * all recently submitted items. This does not include the community / collection
     * hierarchy, when this changes they will not be reflected in the cache.
     */
    public SourceValidity getValidity() {
        if (this.validity == null) {

            try {
                DSpaceValidity validity = new DSpaceValidity();

                DSpaceObject dso = getScope();

                if (dso != null) {
                    // Add the actual collection;
                    validity.add(context, dso);
                }

                // add recently submitted items, serialize solr query contents.
                DiscoverResult response = getQueryResponse(dso);

                validity.add("numFound:" + response.getDspaceObjects().size());

                for (DSpaceObject resultDso : queryResults.getDspaceObjects()) {
                    validity.add(context, resultDso);
                }

                for (String facetField : queryResults.getFacetResults().keySet()) {
                    validity.add(facetField);

                    java.util.List<DiscoverResult.FacetResult> facetValues = queryResults.getFacetResults().get(facetField);
                    for (DiscoverResult.FacetResult facetValue : facetValues) {
                        validity.add(facetField + facetValue.getAsFilterQuery() + facetValue.getCount());
                    }
                }


                this.validity = validity.complete();
            }
            catch (Exception e) {
                // Just ignore all errors and return an invalid cache.
public SourceValidity getValidity() {
     * Get the recently submitted items for the given community or collection.
     *
     * @param scope The collection.
     */
    protected DiscoverResult getQueryResponse(DSpaceObject scope) {

protected DiscoverResult getQueryResponse(DSpaceObject scope) {
        String facetField = request.getParameter(SearchFilterParam.FACET_FIELD);
        DiscoverFacetField discoverFacetField;
        // Enumerations don't handle mixed cases, setting to uppercase to match convention
        SORT sortOrder = getSortOrder(request);
        if(request.getParameter(SearchFilterParam.STARTS_WITH) != null)
        {
            discoverFacetField = new DiscoverFacetField(facetField, DiscoveryConfigurationParameters.TYPE_TEXT, getPageSize() + 1, sortOrder, request.getParameter(SearchFilterParam.STARTS_WITH).toLowerCase());
        }else{
            discoverFacetField = new DiscoverFacetField(facetField, DiscoveryConfigurationParameters.TYPE_TEXT, getPageSize() + 1, sortOrder);
        }


        queryArgs.addFacetField(discoverFacetField);


        try {
            queryResults = searchService.search(context, scope, queryArgs);
        } catch (SearchServiceException e) {
private SORT getSortOrder(Request request) {

        /**
     * Add a page title and trail links.
     */
    public void addPageMeta(PageMeta pageMeta) throws SAXException, WingException, SQLException, IOException, AuthorizeException {
        Request request = ObjectModelHelper.getRequest(objectModel);
        String facetField = request.getParameter(SearchFilterParam.FACET_FIELD);

        pageMeta.addMetadata("title").addContent(message("xmlui.Discovery.AbstractSearch.type_" + facetField));


        pageMeta.addTrailLink(contextPath + "/", T_dspace_home);

        DSpaceObject dso = HandleUtil.obtainHandle(objectModel);
public void addBody(Body body) throws SAXException, WingException, UIException,
            Map<String, List<DiscoverResult.FacetResult>> facetFields = this.queryResults.getFacetResults();
            if (facetFields == null)
            {
                facetFields = new LinkedHashMap<String, List<DiscoverResult.FacetResult>>();
            }

//            facetFields.addAll(this.queryResults.getFacetDates());
private void addBrowseJumpNavigation(Division div, SearchFilterParam browseParam
        Division jump = div.addInteractiveDivision("filter-navigation", action,
                Division.METHOD_POST, "secondary navigation");

        Map<String, String> params = new HashMap<String, String>();
        params.putAll(browseParams.getCommonBrowseParams());
        // Add all the query parameters as hidden fields on the form
        for(Map.Entry<String, String> param : params.entrySet()){
private void renderFacetField(SearchFilterParam browseParams, DSpaceObject dso,
            cell.addContent(displayedValue + " (" + value.getCount() + ")");
        } else {
            //Add the basics
            Map<String, String> urlParams = new HashMap<String, String>();
            urlParams.putAll(browseParams.getCommonBrowseParams());
            String url = generateURL(contextPath + (dso == null ? "" : "/handle/" + dso.getHandle()) + "/discover", urlParams);
            //Add already existing filter queries
            url = addFilterQueriesToUrl(url);
            //Last add the current filter query
            url += "&filtertype=" + facetField;
            url += "&filter_relational_operator="+value.getFilterType();
            url += "&filter=" + URLEncoder.encode(value.getAsFilterQuery(), "UTF-8");
            cell.addXref(url, displayedValue + " (" + value.getCount() + ")"
            );
        }
    }
private String getNextPageURL(SearchFilterParam browseParams, Request request) t
            offSet = currentOffset;
        }

        Map<String, String> parameters = new HashMap<String, String>();
        parameters.putAll(browseParams.getCommonBrowseParams());
        parameters.putAll(browseParams.getControlParameters());
        parameters.put(SearchFilterParam.OFFSET, String.valueOf(offSet + getPageSize()));
        parameters.put(SearchFilterParam.ORDER, getSortOrder(request).name());

        // Add the filter queries
        String url = generateURL("search-filter", parameters);
        url = addFilterQueriesToUrl(url);

        return url;
    }

    private String getPreviousPageURL(SearchFilterParam browseParams, Request request) throws UnsupportedEncodingException, UIException {
private String getPreviousPageURL(SearchFilterParam browseParams, Request reques
            return null;
        }

        Map<String, String> parameters = new HashMap<String, String>();
        parameters.putAll(browseParams.getCommonBrowseParams());
        parameters.putAll(browseParams.getControlParameters());
        parameters.put(SearchFilterParam.ORDER, getSortOrder(request).name());
        String offSet = String.valueOf((currentOffset - getPageSize()<0)? 0:currentOffset - getPageSize());
        parameters.put(SearchFilterParam.OFFSET, offSet);

        // Add the filter queries
        String url = generateURL("search-filter", parameters);
        url = addFilterQueriesToUrl(url);
        return url;
    }


    /**
     * Recycle
     */
    public void recycle() {
        // Clear out our item's cache.
        this.queryResults = null;
public String addFilterQueriesToUrl(String url) throws UIException {
    }

    private static class SearchFilterParam {
        private Request request;

        /** The always present commond params **/
        public static final String QUERY = "query";
public String getFacetField(){
        }

        public Map<String, String> getCommonBrowseParams(){
            Map<String, String> result = new HashMap<String, String>();
            result.put(FACET_FIELD, request.getParameter(FACET_FIELD));
            if(request.getParameter(QUERY) != null)
                result.put(QUERY, request.getParameter(QUERY));
public String getFacetField(){
        }

        public Map<String, String> getControlParameters(){
            Map<String, String> paramMap = new HashMap<String, String>();

            paramMap.put(OFFSET, request.getParameter(OFFSET));
            if(request.getParameter(STARTS_WITH) != null)
private void addBrowseControls(Division div, SearchFilterParam params)
            throws WingException
    {
        // Prepare a Map of query parameters required for all links
        Map<String, String> queryParams = new HashMap<String, String>();

        queryParams.putAll(params.getCommonBrowseParams());
        Request request = ObjectModelHelper.getRequest(objectModel);

/**
 * Attempt to authenticate the user based upon their presented credentials. 
 * This action uses the http parameters of login_email, login_password, and 
 * login_realm as credentials.
 * 
 * If the authentication attempt is successful then an HTTP redirect will be
 * sent to the browser redirecting them to their original location in the 
 * system before authenticated or if none is supplied back to the DSpace 
 * homepage. The action will also return true, thus contents of the action will
 * be excuted.
 * 
 * If the authentication attempt fails, the action returns false.
 * 
 * Example use:
 * 
 * <map:act name="Authenticate">
 *   <map:serialize type="xml"/>
 * </map:act>
 * <map:transform type="try-to-login-again-transformer">
 *
 * @author Scott Phillips
 */

    /**
     * Attempt to authenticate the user. 
     */
    public Map act(Redirector redirector, SourceResolver resolver, Map objectModel,
            String source, Parameters parameters) throws Exception
    {

/**
 * Attempt to authenticate the user based upon their presented credentials. This
 * action uses the http parameters of username, ldap_password, and login_realm
 * as credentials.
 * 
 * If the authentication attempt is successful then an HTTP redirect will be
 * sent to the browser redirecting them to their original location in the system
 * before authenticated or if none is supplied back to the DSpace homepage. The
 * action will also return true, thus contents of the action will be excuted.
 * 
 * If the authentication attempt fails, the action returns false.
 * 
 * Example use:
 * 
 * <map:act name="LDAPAuthenticate"> <map:serialize type="xml"/> </map:act>
 * <map:transform type="try-to-login-again-transformer">
 * 
 * @author Jay Paz
 */

	/**
	 * Attempt to authenticate the user.
	 */
	public Map act(Redirector redirector, SourceResolver resolver,
			Map objectModel, String source, Parameters parameters)
			throws Exception {
		// First check if we are performing a new login
		Request request = ObjectModelHelper.getRequest(objectModel);

public Map act(Redirector redirector, SourceResolver resolver,
					redirectURL += AuthenticationUtil
							.resumeInterruptedRequest(objectModel);
				}
                                else
                                {
                                        // Otherwise direct the user to the specified 'loginredirect' page (or homepage by default)
                                        String loginRedirect = DSpaceServicesFactory.getInstance().getConfigurationService().getProperty("xmlui.user.loginredirect");
                                        redirectURL += (loginRedirect != null) ? loginRedirect.trim() : "/";	
                                }

				// Authentication successful send a redirect.
				final HttpServletResponse httpResponse = (HttpServletResponse) objectModel

/**
 * Attempt to authenticate the user based upon their presented shibboleth credentials. 
 * This action uses the http parameters as supplied by Shibboleth SP.
 * Read dspace.cfg for configuration detail.
 * 
 * If the authentication attempt is successful then an HTTP redirect will be
 * sent to the browser redirecting them to their original location in the 
 * system before authenticated or if none is supplied back to the DSpace 
 * homepage. The action will also return true, thus contents of the action will
 * be excuted.
 * 
 * If the authentication attempt fails, the action returns false.
 * 
 * Example use:
 * 
 * <map:act name="Shibboleth">
 *   <map:serialize type="xml"/>
 * </map:act>
 * <map:transform type="try-to-login-again-transformer">
 *
 * @author <a href="mailto:bliong@melcoe.mq.edu.au">Bruc Liong, MELCOE</a>
 */
{

    /**
     * Attempt to authenticate the user. 
     */
    public Map act(Redirector redirector, SourceResolver resolver, Map objectModel,
            String source, Parameters parameters) throws Exception
    {
        try
        {
/**
 * 
 * This action will start the necessary steps to authenticate a user. After the user 
 * successfuly authenticates, the user will resume this request with all parameters
 * and attributes intact. An optional message can be added that will be displayed
 * on the login form. This could be used to provide a reason why the user is being
 * queried for a user name and password.
 * 
 * Possible parameters are:
 * 
 * header: An i18n message that will be used as the header for the message.
 * 
 * message: An i18n message tag.
 * 
 * characters: Characters to be displayed, possibly for untranslated error messages
 * 
 * 
 * <map:action name="StartAuthenticationAction" src="org.dspace.app.xmlui.eperson.StartAuthenticationAction"/>
 * 
 * 
 * <map:act type="StartAuthenticationAction"/>
 * 
 * 
 * Typically, this is used in conjunction with the AuthenticatedSelector as:
 * 
 * <map:select type="AuthenticatedSelector">
 *   <map:when test="eperson">
 *     ...
 *     </map:act>
 *   </map:otherwise>
 * </map:select>
 * 
 * @author Scott Phillips
 */
{
    /**
     * Redirect the user to the login page.
     */
    public Map act(Redirector redirector, SourceResolver resolver,
            Map objectModel, String source, Parameters parameters)
            throws Exception
 * Unauthenticate the current user. There is no way this action will fail, 
 * so any components inside the action will be executed.
 * 
 * This action will always send an HTTP redirect to the DSpace homepage.
 * 
 * Example: 
 * 
 * <map:action name="UnAuthenticateAction" src="org.dspace.app.xmlui.eperson.UnAuthenticateAction"/>
 * 
 * <map:act type="UnAuthenticateAction">
 *   <map:serialize type="xml"/>
 * </map:act>
 * 
 * @author Scott Phillips
 */
    /**
     * Logout the current user.
     * 
     * @param redirector
     * @param resolver
     * @param objectModel
     *            Cocoon's object model
     * @param source
     * @param parameters
     */
    public Map act(Redirector redirector, SourceResolver resolver, Map objectModel,
            String source, Parameters parameters) throws Exception
    {
import org.apache.cocoon.selection.Selector;
import org.apache.log4j.Logger;
import org.dspace.app.xmlui.utils.ContextUtil;
import org.dspace.authorize.AuthorizeServiceImpl;
import org.dspace.authorize.factory.AuthorizeServiceFactory;
import org.dspace.authorize.service.AuthorizeService;
import org.dspace.core.Context;
/**
 * This simple selector operates on the authenticated DSpace user and selects
 * between two levels of access.
 * 
 * <map:selector name="AuthenticatedSelector" src="org.dspace.app.xmlui.AuthenticatedSelector"/>
 * 
 * 
 * 
 * <map:select type="AuthenticatedSelector"> 
 *   <map:when test="administrator">
 *     ...
 *     ...
 *   </map:otherwise> 
 * </map:select>
 * 
 * There are only two defined test expressions: "administrator" and "eperson".
 * Remember an administrator is also an eperson so if you need to check for
 * administrators distinct from epersons that select must come first.
 * 
 * @author Scott Phillips
 */

public class AuthenticatedSelector extends AbstractLogEnabled implements
        Selector
{

    private static Logger log = Logger.getLogger(AuthenticatedSelector.class);

    /** Test expressiots */
    public static final String EPERSON = "eperson";

    public static final String ADMINISTRATOR = "administrator";

    /**
     * Determine if the authenticated eperson matches the given expression.
     */
    public boolean select(String expression, Map objectModel,
            Parameters parameters)
    {
 * back to the indicated form fields in the window that launched it.
 * Some necessary logic is in JavaScript, see choice-control.js.
 *
 * Expected Parameters:
 *  field - name of metadata field in "_" notation, eg: dc_contributor_author
 *  value - maybe-partial value of field
 *  formID - the @id of <form> tag in calling window containing the inputs we are to set.
 *  valueInput - @name of input field in DOM for value.
 *  authorityInput - @name of input field in DOM for authority value
 *  isRepeating - true if metadata value can be repeated
 *  isName - true if this is a name value (i.e. last/first boxes)
 *  start - starting index, default 0
 *  limit - maximum values to return, default 0 (none)
 *
 * Configuration Properties:
 *  xmlui.lookup.select.size = 12  (default, entries to show in SELECT widget.)
 *
 * For each FIELD, e.g. dc.contributor.author, these message properties
 * will OVERRIDE the corresponding i18n message catalog entries:
 *  xmlui.lookup.field.FIELD.title = title of lookup page
 *   (e.g. xmlui.lookup.field.dc_contributor_author.title = Author..)
 *  xmlui.lookup.field.FIELD.nonauthority = template for "non-authority" label in options
 *  xmlui.lookup.field.FIELD.help = help message for single input
 *    (NOTE this is still required even for name inputs)
 *  xmlui.lookup.field.FIELD.help.last = help message for last name of Name-oriented input
 *  xmlui.lookup.field.FIELD.help.first = help message for first name of Name-oriented input
 *
 * @author  Larry Stone
 */

    protected ChoiceAuthorityService choicheAuthorityService = ContentAuthorityServiceFactory.getInstance().getChoiceAuthorityService();

    public void addBody(Body body) throws SAXException, WingException,
            UIException, SQLException, IOException, AuthorizeException
    {
public void addBody(Body body) throws SAXException, WingException,
        cancel.setValue(T_cancel);
    }

    public void addPageMeta(PageMeta pageMeta) throws SAXException,
            WingException, UIException, SQLException, IOException,
            AuthorizeException
 * returns true if the Item in the request has not been modified since that
 * date.  The expression is ignored since the test is inherent in the request.
 *
 * Typical sitemap usage:
 *
 *  <map:match type="HandleTypeMatcher" pattern="item">
 *    <map:select type="IfModifiedSinceSelector">
 *      <map:when test="true">
 *      </map:otherwise>
 *    </map:select>
 *  </map:match>
 *
 * @author Larry Stone
 */
public class IfModifiedSinceSelector implements Selector
{

    private static Logger log = Logger.getLogger(IfModifiedSinceSelector.class);

    /**
     * Check for If-Modified-Since header on request,
     *
     * @param expression is ignored
     * @param objectModel
     *            environment passed through via cocoon
     * @return null or map containing value of sitemap parameter 'pattern'
     */
    public boolean select(String expression, Map objectModel,
            Parameters parameters)
    {
 * this transformer is used after an action has been performed to let the
 * user know if an operation succeeded or failed.
 * 
 * The possible paramaters are:
 * 
 * outcome: The outcome determines whether the notice is positive or negative. 
 * Possible values are: "success", "failure", or "neutral". If no values are 
 * supplied then neutral is assumed.
 * 
 * header: An i18n dictionary key referencing the text that should be used
 * as a header for this notice.
 * 
 * message: An i18n dictionary key referencing the text that should be used as
 * the content for this notice. 
 * 
 * characters: Plain text string that should be used as the content for this
 * notice. Normally, all messages should be i18n dictionary keys, however this
 * parameter is useful for error messages that are not necessarily translated.
 * 
 * All parameters are optional but you must supply at least the message or the 
 * characters
 *
 *
 * 
 * Example:
 * <map:transformer type="notice">
 *   <map:parameter name="outcome" value="success"/>
 *   <map:parameter name="message" value="xmlui.<aspect>.<class>.<type>"/>
 * </map:transformer>
 * 
 * @author Scott Phillips
 * @author Alexey Maslov
	
	/**
	 * Add the notice div to the body.
	 */
	public void addBody(Body body) throws WingException, SQLException, AuthorizeException 
	{
		String outcome = parameters.getParameter("outcome",null);
 */
public abstract class AbstractStep extends AbstractDSpaceTransformer 
{
	private static Logger log = Logger.getLogger(AbstractStep.class);

    /** General Language Strings */
    protected static final Message T_submission_title = 
	 * 
	 * If the implementer set any required parameters then ensure that 
	 * they are all present.
	 */
	public void setup(SourceResolver resolver, Map objectModel, String src, Parameters parameters) 
	throws ProcessingException, SAXException, IOException
	{ 
public void setup(SourceResolver resolver, Map objectModel, String src, Paramete

	/** 
	 * Base pageMeta that is added to ALL submission stages 
	 */
	public void addPageMeta(PageMeta pageMeta) throws SAXException,
	WingException, UIException, SQLException, IOException,
	AuthorizeException
	{
		if (submission instanceof WorkspaceItem)
		{
else if (submissionInfo != null && submissionInfo.isInWorkflow())
	 * Add a submission progress list to the current div for this step. 
	 * 
	 * @param div The division to add the list to.
	 */
	public void addSubmissionProgressList(Division div) throws WingException
	{
public void addSubmissionProgressList(Division div) throws WingException
     * @param stepAndPage
     *          The step and page (a double of the form 'step.page', e.g. 1.2)
     *          which this button will jump back to
     */
    public void addJumpButton(List list, Message buttonText, StepAndPage stepAndPage)
        throws WingException
public void addJumpButton(List list, Message buttonText, StepAndPage stepAndPage
    }
    
    /**
     * Adds the "<-Previous", "Save/Cancel" and "Next->" buttons 
     * to a given form.  This method ensures that the same
     * default control/paging buttons appear on each submission page.
     * <P>
     * Note: A given step may define its own buttons as necessary,
     * and not call this method (since it must be explicitly invoked by
     * the step's addBody() method)
     *
     * @param controls
     *          The List which will contain all control buttons
     */
    public void addControlButtons(List controls)
        throws WingException
public boolean isLastStep()
     * Find the maximum step and page that the user has 
     * reached in the submission processes. 
     * If this submission is a workflow then return max-int.
     */
    public StepAndPage getMaxStepAndPageReached() throws SQLException {

public StepAndPage getMaxStepAndPageReached() throws SQLException {
	 * Retrieve error fields from the list of parameters
	 * and return a List of all fields which had errors
	 *
	 * @return java.util.List of field names with errors
	 */
	public java.util.List<String> getErrorFields(Parameters parameters)
	{
		java.util.List<String> fields = new ArrayList<String>();
		
		String errors = parameters.getParameter("error_fields","");
		
else if (givenStepAndPage.compareTo(getMaxStepAndPageReached())>0)
        }  
	}
	
	
	/**
	 * Recycle
	 */
	public void recycle() 
	{
		this.id = null;
    // Only access this through getObjectManager, so that we don't have to create one if we don't want to.
    private ObjectManager objectManager;

    public void setup(SourceResolver resolver, Map objectModel, String src,
            Parameters parameters) throws ProcessingException, SAXException,
            IOException
public void setup(SourceResolver resolver, Map objectModel, String src,
        }
    }

    protected void handleException(Exception e) throws SAXException
    {
        throw new SAXException(
                "An error was encountered while processing the '"+this.getComponentName()+"' Wing based component: "
                        + this.getClass().getName(), e);
    }

    /** What to add at the end of the body */
    public void addBody(Body body) throws SAXException, WingException,
            UIException, SQLException, IOException, AuthorizeException, ProcessingException
    {
        // Do nothing
    }

    /** What to add to the options list */
    public void addOptions(Options options) throws SAXException, WingException,
            UIException, SQLException, IOException, AuthorizeException
    {
        // Do nothing
    }

    /** What user metadata to add to the document */
    public void addUserMeta(UserMeta userMeta) throws SAXException,
            WingException, UIException, SQLException, IOException,
            AuthorizeException
    {
        // Do nothing
    }

    /** What page metadata to add to the document */
    public void addPageMeta(PageMeta pageMeta) throws SAXException,
            WingException, UIException, SQLException, IOException,
            AuthorizeException
    {
        // Do nothing
    }
    
    public ObjectManager getObjectManager() 
    {
        if (this.objectManager == null)
public ObjectManager getObjectManager()
        return this.objectManager;
    }
    
    /** What is a unique name for this component? */
    public String getComponentName()
    {
        String name = this.getClass().getName();
public String getComponentName()
     * @param unencodedString
     *            The unencoded string.
     * @return The encoded string
     */
    public static String encodeForURL(String unencodedString) throws UIException
    {
public static String encodeForURL(String unencodedString) throws UIException
     * @param encodedString
     *            The encoded string.
     * @return The unencoded string
     */
    public static String decodeFromURL(String encodedString) throws UIException
    {
public static String decodeFromURL(String encodedString) throws UIException

    /**
     * Generate a URL for the given base URL with the given parameters. This is
     * a convenance method to make it easier to generate URL references with
     * parameters.
     * 
     * Example
     * Map<String,String> parameters = new Map<String,String>();
     * parameters.put("arg1","value1");
     * parameters.put("arg2","value2");
     * parameters.put("arg3","value3");
     * String url = genrateURL("/my/url",parameters);
     * 
     * would result in the string:
     * url == "/my/url?arg1=value1&arg2=value2&arg3=value3"
     * 
     * @param baseURL The baseURL without any parameters.
     * @param parameters The parameters to be encoded on in the URL.
public static String generateURL(String baseURL,
    }
    
    
    /**
     * Recyle
     */
    public void recycle() {
    	this.objectModel = null;
        this.context = null;
public void recycle() {
    	super.recycle();
    }

    /**
     * Dispose
     */
    public void dispose() {
    	this.objectModel = null;
        this.context = null;
{

    /** log4j category */
    private static Logger log = Logger.getLogger(XMLUIConfiguration.class);
    
    /** The configured Aspects */
    private static List<Aspect> aspects = new ArrayList<Aspect>();

    /** The configured Theme rules */
    private static List<Theme> themes = new ArrayList<Theme>(); 

    /**
     * Initialize the XMLUI Configuration.
     * supplied but only the first valid file (exists and readable) will
     * be used.
     * 
     * @param configPaths Multiple paths configuration paths may be specified
     */
    public static void loadConfig(String ... configPaths) throws IOException,
            JDOMException
    {
        if (configPaths == null || configPaths.length == 0)
        {
import org.xml.sax.helpers.AttributesImpl;
import org.xml.sax.helpers.NamespaceSupport;


/**
 * This is the abstract adapter containing all the common elements between
 * the three types of adapters: item, container, and repository. Each adapter
 * translate a given type of DSpace object into a METS document for rendering
 * into the DRI document.
 * 
 * This class provides the chassis for those unique parts of the document to be
 * built upon. There are seven rendering methods that may be overridden for each
 * section of the METS document.
 * 
 * Header
 * Descriptive Section
 * Administrative Section
 * File Section
 * Structure Map
 * Structural Link
 * Behavioral Section
 * 
 * @author Scott Phillips
 */

public abstract class AbstractAdapter
{
    /** Namespace declaration for METS & XLINK */
    public static final String METS_URI = "http://www.loc.gov/METS/";
    public static final Namespace METS = new Namespace(METS_URI);
    public static final String XLINK_URI = "http://www.w3.org/TR/xlink/";
public AbstractAdapter(String contextPath)
    }

    /** The variables that dictate what part of the METS document to render */
    List<String> sections = new ArrayList<String>();
    List<String> dmdTypes = new ArrayList<String>();
    Map<String,List> amdTypes = new HashMap<String,List>();
    List<String> fileGrpTypes = new ArrayList<String>();
    List<String> structTypes = new ArrayList<String>();
    
    /**
     * A comma-separated list of METS sections to render. If no value 
public final void setDmdTypes(String dmdTypes)
     * Store information about what will be rendered in the METS administrative
     * metadata section.  HashMap format: keys = amdSec, value = List of mdTypes
     *
     * @param amdSec Section of <amdSec> where this administrative metadata
     *                will be rendered
     * @param mdTypes Comma-separated list of METS metadata types.
     */
    public final void setAmdTypes(String amdSec, String mdTypes)
public final void setAmdTypes(String amdSec, String mdTypes)
            return;
        }

        List<String> mdTypeList = new ArrayList<String>();
    	for (String mdType : mdTypes.split(","))
    	{
    		mdTypeList.add(mdType);
public final void setStructTypes(String structTypes)
    
    
    /**
     * @return the URL for this item in the interface
     */
    protected abstract String getMETSOBJID() throws WingException;

public final void setStructTypes(String structTypes)

    /**
     * @return the METS ID of the mets document.
     */
    protected abstract String getMETSID() throws WingException;

    /**
     * @return The Profile this METS document conforms to.
     */
    protected abstract String getMETSProfile() throws WingException;

    /**
     * @return The label of this METS document.
     */
    protected abstract String getMETSLabel() throws WingException;

    
	/**
	 * Render the complete METS document.
	 */
    public final void renderMETS(Context context, ContentHandler contentHandler, LexicalHandler lexicalHandler) throws WingException, SAXException, CrosswalkException, IOException, SQLException
    {
    		this.contentHandler = contentHandler;
    		this.lexicalHandler = lexicalHandler;
public final void renderMETS(Context context, ContentHandler contentHandler, Lex
    		startElement(METS,"METS",attributes);

    		// If the user requested no specific sections then render them all.
    		boolean all = (sections.size() == 0);
    		
    		if (all || sections.contains("metsHdr"))
            {
public final void renderMETS(Context context, ContentHandler contentHandler, Lex

    }
	
    /**
     * Each of the METS sections
     */
	protected void renderHeader() throws WingException, SAXException, CrosswalkException, IOException, SQLException  {}
protected void renderExtraSections() throws WingException, SAXException, Crosswa
    /**
     * Generate a METS file element for a given bitstream.
     *
     * @param item
     *            If the bitstream is associated with an item provide the item
     *            otherwise leave null.
protected void renderExtraSections() throws WingException, SAXException, Crosswa
     * @param groupID
     *            The group id for this file, if it is derived from another file
     *            then they should share the same groupID.
     */
	protected final void renderFile(Context context, Item item, Bitstream bitstream, String fileID, String groupID) throws SAXException, SQLException
    {
       renderFile(context, item, bitstream, fileID, groupID, null);
    }

	/**
     * Generate a METS file element for a given bitstream.
     * 
     * @param item
     *            If the bitstream is associated with an item, provide the item,
     *            otherwise leave null.
protected final void renderFile(Context context, Item item, Bitstream bitstream,
     * @param admID
     *            The IDs of the administrative metadata sections which pertain
     *            to this file
     */
	protected final void renderFile(Context context, Item item, Bitstream bitstream, String fileID, String groupID, String admID) throws SAXException, SQLException
    {
		AttributeMap attributes;
		
protected final String getGenericID(String prefix)
     * Return a dissemination crosswalk for the given name.
     * 
     * @param crosswalkName
     * @return The crosswalk or throw an exception if not found.
     */
    public final DisseminationCrosswalk getDisseminationCrosswalk(String crosswalkName) throws WingException 
    {
public final boolean isDefinedMETStype(String metadataType)
     *            (Required) The local name of this element.
     * @param attributes
     *            (May be null) Attributes for this element
     */
    protected final void startElement(Namespace namespace, String name,
            AttributeMap... attributes) throws SAXException
protected final void startElement(Namespace namespace, String name,
     * 
     * @param characters
     *            (May be null) Characters to send.
     */
    protected final void sendCharacters(String characters) throws SAXException
    {
protected final void sendCharacters(String characters) throws SAXException
     *            (Required) The namespace of this element.
     * @param name
     *            (Required) The local name of this element.
     */
    protected final void endElement(Namespace namespace, String name)
            throws SAXException

/**
 * This is an adapter which translates DSpace containers 
 * (communities & collections) into METS documents. This adapter follows
 * the DSpace METS profile, however that profile does not define how a
 * community or collection should be described, but we make the obvious 
 * decisions to deviate when necessary from the profile.
    private static final Logger log = Logger.getLogger(ContainerAdapter.class);

    /** The community or collection this adapter represents. */
    private DSpaceObject dso;

    /** A space-separated list of descriptive metadata sections */
    private StringBuffer dmdSecIDS;
    
    /** Current DSpace context **/
    private Context dspaceContext;

    protected CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();
   	protected CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();
    /**
     * Construct a new CommunityCollectionMETSAdapter.
     * 
     * @param dso
     *            A DSpace Community or Collection to adapt.
     * @param contextPath
public ContainerAdapter(Context context, DSpaceObject dso,String contextPath)
        this.dspaceContext = context;
    }

    /** Return the container, community or collection, object */
    public DSpaceObject getContainer()
    {
    	return this.dso;
public DSpaceObject getContainer()
     */
    
    /**
     * Return the URL of this community/collection in the interface
     */
    protected String getMETSOBJID()
    {
    	if (dso.getHandle() != null)
protected String getMETSOBJID()
    /**
     * @return Return the URL for editing this item
     */
    protected String getMETSOBJEDIT()
    {
        return null;
    }
    
    /**
     * Use the handle as the id for this METS document
     */
    protected String getMETSID()
    {
    	if (dso.getHandle() == null)
protected String getMETSID()
    /**
     * Return the profile to use for communities and collections.
     * 
     */
    protected String getMETSProfile() throws WingException
    {
    	return "DSPACE METS SIP Profile 1.0";
    }

    /**
     * Return a friendly label for the METS document to say we are a community
     * or collection.
     */
    protected String getMETSLabel()
    {
        if (dso instanceof Community)
protected String getMETSLabel()
    }

    /**
     * Return a unique id for the given bitstream
     */
    protected String getFileID(Bitstream bitstream)
    {
        return "file_" + bitstream.getID();
    }

    /**
     * Return a group id for the given bitstream
     */
    protected String getGroupFileID(Bitstream bitstream)
    {
protected String getGroupFileID(Bitstream bitstream)
     * Render the METS descriptive section. This will create a new metadata
     * section for each crosswalk configured.
     * 
     * Example:
     * <dmdSec>
     *  <mdWrap MDTYPE="MODS">
     *    <xmlData>
     *      ... content from the crosswalk ...
     *    </xmlDate>
     *  </mdWrap>
     * </dmdSec
     */
    protected void renderDescriptiveSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException 
    {
        AttributeMap attributes;
protected void renderDescriptiveSection() throws WingException, SAXException, Cr
        // Add DIM descriptive metadata if it was requested or if no metadata types 
        // were specified. Furthermore, since this is the default type we also use a 
        // faster rendering method that the crosswalk API.
        if(dmdTypes.size() == 0 || dmdTypes.contains("DIM"))
        {
            // Metadata element's ID
            String dmdID = getGenericID("dmd_");
else if (dso.getType() == Constants.COMMUNITY)
     * Render the METS file section. If a logo is present for this
     * container then that single bitstream is listed in the 
     * file section.
     * 
     * Example:
     * <fileSec>
     *   <fileGrp USE="LOGO">
     *     <file ... >
     *       <fLocate ... >
     *     </file>
     *   </fileGrp>
     * </fileSec>
     */
    @Override
    protected void renderFileSection(Context context) throws SAXException, SQLException
protected void renderFileSection(Context context) throws SAXException, SQLExcept
     * to the container's logo, if available, otherwise it is an empty 
     * division that just states it is a DSpace community or Collection.
     * 
     * Example:
     * <structMap TYPE="LOGICAL" LABEL="DSpace">
     *   <div TYPE="DSpace Collection" DMDID="space-separated list of ids">
     *     <fptr FILEID="logo id"/>
     *   </div>
     * </structMap>
     */
    protected void renderStructureMap() throws SQLException, SAXException
    {
    	AttributeMap attributes;
private void createField(String schema, String element, String qualifier, String
					
					xmlDocument = document.getRootElement();
	        	} 
	        	catch (Exception e) 
				{
                    log.trace("Caught exception", e);
				}
import java.sql.SQLException;
import java.util.*;


/**
 * This is an adapter which translates a DSpace item into a METS document
 * following the DSpace METS profile, err well mostly. At least if you use
 * the proper configuration it will be fully compliant with the profile,
 * however this adapter will allow you to configure it to be incorrect.
 *
 * When we are configured to be non-compliant with the profile, the MET's
 * profile is changed to reflect the deviation. The DSpace profile states
 * that metadata should be given in MODS format. However, you can configure
 * this adapter to use any metadata crosswalk. When that case is detected we
 * change the profile to say that we are deviating from the standard profile
 * and it lists what metadata has been added.
 *
 * There are four parts to an item's METS document: descriptive metadata,
 * file section, structural map, and extra sections.
 * 
 * Request item-support
 * Original Concept, JSPUI version:    Universidade do Minho   at www.uminho.pt
 * Sponsorship of XMLUI version:    Instituto Oceanogrfico de Espaa at www.ieo.es
 * 
 * @author Scott Phillips
 * @author Adn Romn Ruiz at arvo.es (for request item support) 
 */

public class ItemAdapter extends AbstractAdapter
{
    /** The item this METS adapter represents */
    private Item item;

    /** List of bitstreams which should be publicly viewable */
    private List<Bitstream> contentBitstreams = new ArrayList<Bitstream>();

    /** The primary bitstream, or null if none specified */
    private Bitstream primaryBitstream;
    
    /** A hashmap of all Files and their corresponding space separated list of
        administrative metadata sections */
    private Map<String,StringBuffer> fileAmdSecIDs = new HashMap<String,StringBuffer>();

    // DSpace DB context
    private Context context;

    protected AuthorizeService authorizeService = AuthorizeServiceFactory.getInstance().getAuthorizeService();
    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();
    /**
     * Construct a new ItemAdapter
     *
     * @param item
     *            The DSpace item to adapt.
     * @param contextPath
     *            The contextpath for this webapplication.
     */
    public ItemAdapter(Context context, Item item,String contextPath)
    {
public ItemAdapter(Context context, Item item,String contextPath)
        this.context = context;
    }

    /** Return the item */
    public Item getItem()
    {
        return this.item;
public Item getItem()
     */

    /**
     * Return the URL of this item in the interface
     */
    protected String getMETSOBJID()
    {
        if (item.getHandle() != null)
protected String getMETSOBJID()
    }

    /**
     * @return Return the URL for editing this item
     */
    protected String getMETSOBJEDIT()
    {
        return contextPath+"/admin/item?itemID=" + item.getID();
    }

    /**
     * Return the item's handle as the METS ID
     */
    protected String getMETSID()
    {
        if (item.getHandle() == null)
protected String getMETSID()
    }

    /**
     * Return the official METS SIP Profile.
     */
    protected String getMETSProfile() throws WingException
    {
        return "DSPACE METS SIP Profile 1.0";
    }

    /**
     * Return a helpful label that this is a DSpace Item.
     */
    protected String getMETSLabel()
    {
        return "DSpace Item";
    }
    
    /**
     * Return a unique id for a bitstream.
     */
    protected String getFileID(Bitstream bitstream)
    {
        return "file_" + bitstream.getID();
    }

    /**
     * Return a group id for a bitstream.
     */
    protected String getGroupFileID(Bitstream bitstream)
    {
        return "group_file_" + bitstream.getID();
    }

    /**
     * Return a techMD id for a bitstream.
     */
    protected String getAmdSecID(String admSecName, String mdType, DSpaceObject dso)
    {
protected String getAmdSecID(String admSecName, String mdType, DSpaceObject dso)
     * has been added that will add MODS descriptive metadata if it is
     * available in DSpace.
     *
     * Example:
     * <dmdSec>
     *  <mdWrap MDTYPE="MODS">
     *    <xmlData>
     *      ... content from the crosswalk ...
     *    </xmlDate>
     *  </mdWrap>
     * </dmdSec
     */
    protected void renderDescriptiveSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException
    {
        AttributeMap attributes;
protected void renderDescriptiveSection() throws WingException, SAXException, Cr
        // Add DIM descriptive metadata if it was requested or if no metadata types
        // were specified. Furthermore, since this is the default type we also use a
        // faster rendering method that the crosswalk API.
        if(dmdTypes.size() == 0 || dmdTypes.contains("DIM"))
        {
                // Metadata element's ID
                String dmdID = getGenericID("dmd_");
protected void renderDescriptiveSection() throws WingException, SAXException, Cr
    /**
     * Render the METS administrative section.
     *
     * Example:
     * <amdSec>
     *  <mdWrap MDTYPE="OTHER" OTHERMDTYPE="METSRights">
     *    <xmlData>
     *      ... content from the crosswalk ...
     *    </xmlDate>
     *  </mdWrap>
     * </amdSec>
     */
    protected void renderAdministrativeSection() throws WingException, SAXException, CrosswalkException, IOException, SQLException
    {
        AttributeMap attributes;
protected void renderAdministrativeSection() throws WingException, SAXException,
     * Render a sub-section of the administrative metadata section.
     * Valid sub-sections include: techMD, rightsMD, sourceMD, digiprovMD
     *
     * Example:
     * <techMD>
     *   <mdWrap MDTYPE="PREMIS">
     *     <xmlData>
     *       [PREMIS content ... ]
     *     </xmlData>
     *   </mdWrap>
     * </techMD>
     *
     * @param amdSecName Name of administrative metadata section
     * @param mdType Type of metadata section (e.g. PREMIS)
     * @param crosswalk The DisseminationCrosswalk to use to generate this section
     * @param dso The current DSpace object to use the crosswalk on
     */
    protected void renderAmdSubSection(String amdSecName, String mdType, DisseminationCrosswalk crosswalk, DSpaceObject dso)
            throws WingException, SAXException, CrosswalkException, IOException, SQLException
protected void renderAmdSubSection(String amdSecName, String mdType, Disseminati
          String fileID = getFileID((Bitstream) dso);
          if(fileAmdSecIDs.containsKey(fileID))
          {
              fileAmdSecIDs.get(fileID).append(" " + amdSecID);
          }
          else
          {
else if (dso.getType() == Constants.ITEM)
     * Render the METS file section. This will contain a list of all bitstreams in the
     * item. Each bundle, even those that are not typically displayed will be listed.
     *
     * Example:
     * <fileSec>
     *   <fileGrp USE="CONTENT">
     *     <file ... >
else if (dso.getType() == Constants.ITEM)
     *     </file>
     *   </fileGrp>
     * </fileSec>
     */
    @Override
    protected void renderFileSection(Context context) throws SQLException, SAXException
protected void renderFileSection(Context context) throws SQLException, SAXExcept
     * content bitstreams, those are bitstreams that are typically
     * viewable by the end user.
     *
     * Example:
     * <structMap TYPE="LOGICAL" LABEL="DSpace">
     *   <div TYPE="DSpace Item" DMDID="space-separated list of ids">
     *     <fptr FILEID="primary bitstream"/>
     *     ... a div for each content bitstream.
     *   </div>
     * </structMap>
     */
    protected void renderStructureMap() throws SQLException, SAXException
    {
        AttributeMap attributes;
protected void renderStructureMap() throws SQLException, SAXException
     * Render any extra METS section. If the item contains a METS.xml document
     * then all of that document's sections are included in this document's
     * METS document.
     */
    protected void renderExtraSections() throws SAXException, SQLException, IOException
    {
        Boolean include = DSpaceServicesFactory.getInstance().getConfigurationService().getBooleanProperty("xmlui.bitstream.mets");
protected void renderExtraSections() throws SAXException, SQLException, IOExcept
     * If none specifically requested, then all Bundles are returned.
     *
     * @return List of enabled bundles
     */
    protected List<Bundle> findEnabledBundles() throws SQLException
    {
        // Check if the user is requested a specific bundle or
        // the all bundles.
        List<Bundle> bundles;
        if (fileGrpTypes.size() == 0)
        {
            bundles = item.getBundles();
        }
        else
        {
                bundles = new ArrayList<Bundle>();
                for (String fileGrpType : fileGrpTypes)
                {
                        for (Bundle newBundle : itemService.getBundles(item, fileGrpType))
protected void renderExtraSections() throws SAXException, SQLException, IOExcept
     *            the derived bitstream
     *
     * @return the corresponding original bitstream (or null)
     */
    protected static Bitstream findOriginalBitstream(Item item,Bitstream derived) throws SQLException
    {
protected static Bitstream findOriginalBitstream(Item item,Bitstream derived) th
        // Didn't find it
        return null;
    }
    /**
     * Generate a METS file element for a given bitstream.
     * 
protected static Bitstream findOriginalBitstream(Item item,Bitstream derived) th
     * @param admID
     *            The IDs of the administrative metadata sections which pertain
     *            to this file
     */
    
    // FIXME: this method is a copy of the one inherited. However the
 * document. Unfortunately, there is no real definition of what this is. So
 * we just kind of made it up based upon what we saw for the item profile.
 * 
 * The basic structure is simply two parts, the descriptive metadata and a 
 * structural map. The descriptive metadata is a place to put metadata about 
 * the whole repository. The structural map is used to map relationships
 * between communities & collections in dspace. 
 * 
 * @author Scott Phillips
 */
    private String dmdSecIDS;
    
    /** Dspace context to be able to look up additional objects */
    private Context context;


    protected CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();
    protected HandleService handleService = HandleServiceFactory.getInstance().getHandleService();
     *            The DSpace context to look up communities / collections.
     * 
     * @param contextPath
     *            The contextPath of this webapplication.
     */
    public RepositoryAdapter(Context context, String contextPath)
    {
public RepositoryAdapter(Context context, String contextPath)
     */

    /**
     * Return the handle prefix as the identifier.
     */
    protected String getMETSID()
    {
        return handleService.getPrefix();
protected String getMETSID()
	/**
	 * The OBJID is used to encode the URL to the object, in this
	 * case the repository which is just at the contextPath.
	 */
	protected String getMETSOBJID() throws WingException {
		
		if (contextPath == null)
protected String getMETSOBJID() throws WingException {
    /**
     * @return  Return the URL for editing this item
     */
    protected String getMETSOBJEDIT()
    {
        return null;
    }

    /**
     * Return the profile this METS document conforms to...
     * 
     * FIXME: It doesn't conform to a profile. This needs to be fixed.
     */
    protected String getMETSProfile()
    {
        return "DRI DSPACE Repository Profile 1.0";
    }

    /**
     * Return a friendly label for the METS document stating that this is a
     * DSpace repository.
     */
    protected String getMETSLabel()
    {
        return "DSpace Repository";
protected String getMETSLabel()
     * section, such as the name, hostname, handle prefix, and 
     * default language.
     * 
     */
	protected void renderDescriptiveSection() throws SAXException
    {
    	AttributeMap attributes;
protected void renderDescriptiveSection() throws SAXException
     * Render the repository's structure map. This map will include a reference to
     * all the community and collection objects showing how they are related to
     * one another. 
     */
	protected void renderStructureMap() throws SQLException, SAXException
    {
    	AttributeMap attributes;
 * This is a validity object specifically implemented for the caching 
 * needs of DSpace, Manakin, and Cocoon.
 * 
 * The basic idea is that each time a DSpace object rendered by a cocoon 
 * component the object and everything about it that makes it unique should 
 * be reflected in the validity object for the component. By following this 
 * principle if the object has been updated externally then the cache will be
 * invalidated.
 * 
 * This DSpaceValidity object makes this processes easier by abstracting out
 * the processes of determining what is unique about a DSpace object. A class
 * is expected to create a new DSpaceValidity object and add() to it all 
 * DSpaceObjects that are rendered by the component. This validity object will 
 * serialize all those objects to a string, take a hash of the string and compare
 * the hash of the string for any updates.
 * 
 * 
 * @author Scott Phillips
 */

public DSpaceValidity()
     * Complete this validity object. After the completion no more
     * objects may be added to the validity object and the object
     * will return as valid.
     */
    public DSpaceValidity complete() 
    {    
public void setAssumedValidityDelay(long milliseconds )
    	// Also add the delay time to the validity hash so if the
    	// admin changes the delay time then all the previous caches
    	// are invalidated.
    	this.validityKey.append("AssumedValidityDelay:"+milliseconds);
    }
    
    /**
     * Set the time delay for how long this cache will be assumed to be valid.
     * 
     * This method takes a string which is parsed for the delay time, the string 
     * must be of the following form: "<integer> <scale>" where scale is days,
     * hours, minutes, or seconds.
     * 
     * Examples: "1 day" or "12 hours" or "1 hour" or "30 minutes"
     * 
     * See the setAssumedValidityDelay(long) for more information.
     * 
     * @param delay The delay time in a variable scale.
     */
else if (scale.equals("seconds") || scale.equals("second"))
     * validity object is created.
     * 
     * Below are the following transitive rules for adding 
     * objects, i.e. if an item is added then all the items 
     * bundles & bitstreams will also be added.
     * 
     * Communities -> logo bitstream
     * Collection -> logo bitstream
     * Item -> bundles -> bitstream
     * Bundles -> bitstreams
     * EPeople -> groups
     * 
     * @param dso
     *          The object to add to the validity.
     */
    public void add(Context context, DSpaceObject dso) throws SQLException
    {
else if (dso instanceof Group)
     *
     * @param nonDSpaceObject
     *          The non-DSpace object to add to the validity.
     */
    public void add(String nonDSpaceObject) throws SQLException
    {
        validityKey.append("String:");
        validityKey.append(nonDSpaceObject);
    }
    
    
    
    
    
    
    
    
    /**
     * This method is used during serializion. When Tomcat is shutdown, Cocoon's in-memory 
     * cache is serialized and written to disk to later be read back into memory on start 
private void readObject(java.io.ObjectInputStream in) throws IOException, ClassN
    	this.assumedValidityTime = 0;
    }
    
    
    /**
     * Reset the assume validity time. This should be called only when the validity of this cache
     * has been confirmed to be accurate. This will reset the assume valid timer based upon the
private void resetAssumedValidityTime()
    
    /**
     * Determine if the cache is still valid
     */
    public int isValid()
    {
        // Return true if we have a hash.
public int isValid()
     * 
     * @param otherObject 
     *          The other validity object.
     */
    public int isValid(SourceValidity otherObject)
    {
        if (this.completed && otherObject instanceof DSpaceValidity)
     * framework. It must be called after the component's setup has been called
     * and the implementing object setup.
     * 
     */
    public void setupWing() throws WingException
    {
public void setupWing() throws WingException
        this.wingContext.setObjectManager(this.getObjectManager());

        feederDocument = this.createWingDocument(wingContext);
        this.stack = new Stack<WingMergeableElement>();
    }

    /**
     * Receive notification of the beginning of a document.
     */
    public void startDocument() throws SAXException
    {
        needNewNamespaceContext = true;
public void startDocument() throws SAXException

    /**
     * Receive notification of the end of a document.
     */
    public void endDocument() throws SAXException
    {
        wingContext.dispose();
public void endDocument() throws SAXException
     *            The Namespace prefix being declared.
     * @param uri
     *            The Namespace URI the prefix is mapped to.
     */
    public void startPrefixMapping(String prefix, String uri)
            throws SAXException
    {
public void startPrefixMapping(String prefix, String uri)
     * 
     * @param prefix
     *            The prefix that was being mapping.
     */
    public void endPrefixMapping(String prefix) throws SAXException
    {
        if (!needNewNamespaceContext)
public void endPrefixMapping(String prefix) throws SAXException
     * @param attributes
     *            The attributes attached to the element. If there are no
     *            attributes, it shall be an empty Attributes object.
     */
    public void startElement(String namespaceURI, String localName,
            String qName, Attributes attributes) throws SAXException
    {
public void startElement(String namespaceURI, String localName,
            
            // Deal with the stack jump start issue of having a document all
            // ready on the stack.
            if (stack.size() == 0)
            {
                if (feederDocument.mergeEqual(namespaceURI, localName, qName,
                        attributes))
else if (child instanceof Options)
     * @param qName
     *            The raw XML 1.0 name (with prefix), or the empty string if raw
     *            names are not available.
     */
    public void endElement(String namespaceURI, String localName, String qName)
            throws SAXException
    {
public void endElement(String namespaceURI, String localName, String qName)
     * 
     * @param e
     *            The thrown exception
     */

    protected void handleException(Exception e) throws SAXException
    {
        throw new SAXException(
                "An error was incountered while processing the Wing based component: "
                        + this.getClass().getName(), e);
    }

protected void handleException(Exception e) throws SAXException
     * 
     * @param wingContext
     *            The current wing context this transformer is operating under.
     */
    protected WingDocument createWingDocument(WingContext wingContext)
            throws WingException
    {
        return new WingDocument(wingContext);
    }

    /** Abstract implementations of WingTransformer */

    public void addBody(Body body) throws Exception
    {
        // Do nothing
    }

    public void addOptions(Options options) throws Exception
    {
        // do nothing
    }

    public void addUserMeta(UserMeta userMeta) throws Exception
    {
        // Do nothing
    }

    public void addPageMeta(PageMeta pageMeta) throws Exception
    {
        // Do nothing
public void addPageMeta(PageMeta pageMeta) throws Exception
    /** 
     * Return the ObjectManager associated with this component. If no 
     * objectManager needed then return null.
     */
    public ObjectManager getObjectManager()
    {
public ObjectManager getObjectManager()
    /**
     * Return the name of this component. Typically the name is just 
     * the class name of the component.
     */
    public String getComponentName()
    {
        return this.getClass().getName();
public String getComponentName()
    /**
     * Return the default i18n message catalogue that should be used 
     * when no others are specified.
     */
    public static String getDefaultMessageCatalogue()
    {
public static Message message(String catalogue, String key)
    }
    
    /**
     * Recyle
     */
    public void recycle() 
    {
        this.namespaces = null;
public void recycle()
    }

    /**
     * Dispose
     */
    public void dispose() {
        this.namespaces = null;
public String put(String key, int value)
     * strings. The values "yes" or "no" will be used in replacement of the
     * boolean value.
     * 
     * @param key
     * @param value
     * @return previous value bound to the key, if any.
     */
    public String put(String key, boolean value)
 * Include metadata in the resulting DRI document as derived from the sitemap
 * parameters.
 *
 * Parameters should consist of a dublin core name and value. The format for
 * a parameter name must follow the form: "<element>.<qualifier>.<language>#order"
 * The qualifier, language, and order are all optional components. The order
 * component is an integer and is needed to ensure that parameter names are
 * unique. Since Cocoon's parameters are Hashes duplicate names are not allowed
 * the order syntax allows the sitemap programer to specify an order in which
 * these metadata values should be placed inside the document.
 *
 * The following are a valid examples:
 *
 * <map:parameter name="theme.name.en" value="My Theme"/>
 *
 * <map:parameter name="theme.path" value="/MyTheme/"/>
 *
 * <map:parameter name="theme.css#1" value="style.css"/>
 *
 * <map:parameter name="theme.css#2" value="style.css-ie"/>
 *
 * <map:parameter name="theme.css#2" value="style.css-ff"/>
 *
 * @author Scott Phillips
 * @author Roel Van Reeth (roel at atmire dot com)
     *
     * @return The generated key hashes the src
     */
    public Serializable getKey()
    {
        String key = "";
public Serializable getKey()
     * @return The generated validity object or <code>null</code> if the
     *         component is currently not cacheable.
     */
    public SourceValidity getValidity()
    {
        return NOPValidity.SHARED_INSTANCE;
public SourceValidity getValidity()

    /**
     * Extract the metadata name value pairs from the sitemap parameters.
     */
    public void setup(SourceResolver resolver, Map objectModel, String src,
            Parameters parameters) throws ProcessingException, SAXException,
            IOException
    {
        try
        {
            String[] names = parameters.getNames();
            metadataList = new ArrayList<Metadata>();
            for (String name : names)
            {
            	String[] nameParts = name.split("#");

            	String dcName = null;
            	int order = -1;
            	if (nameParts.length == 1)
            	{
            		dcName = nameParts[0];
            		order = 1;
            	}
            	else if (nameParts.length == 2)
            	{
            		dcName = nameParts[0];
            		order = Integer.valueOf(nameParts[1]);
            	}
            	else
            	{
            		throw new ProcessingException("Unable to parse page metadata name, '" + name + "', into parts.");
            	}

                String[] dcParts = dcName.split("\\.");
                String element = null;
                String qualifier = null;
                String language = null;
                if (dcParts.length == 1)
                {
                    element = dcParts[0];
                }
                else if (dcParts.length == 2)
                {
                    element = dcParts[0];
                    qualifier = dcParts[1];
                }
                else if (dcParts.length == 3)
                {
                    element = dcParts[0];
                    qualifier = dcParts[1];
                    language = dcParts[2];
                }
                else
                {
                    throw new ProcessingException("Unable to parse page metadata name, '" + name + "', into parts.");
                }

else if (dcParts.length == 3)
     */
    private List<Metadata> enableConcatenation() {
        Metadata last = null;
        List<Metadata> newMetadataList = new ArrayList<Metadata>();

        for (Metadata metadata : metadataList)
        {
private boolean checkConcatenateMerge(Metadata last, Metadata current) {
        }

        // only valid nonempty query string is "nominify"
        if(curval.lastIndexOf('?') != -1
                && !"?nominify".equals(curval.substring(curval.lastIndexOf('?')))) {
            return false;
        }

        return true;

    }
    /**
     * Include the metadata in the page metadata.
     */
    public void addPageMeta(PageMeta pageMeta) throws WingException
    {
        for (Metadata metadata : metadataList)
public void addPageMeta(PageMeta pageMeta) throws WingException
     */
    static class Metadata implements Comparable<Metadata> {

    	private String element;
    	private String qualifier;
    	private String language;
    	private int order;
    	private String value;

    	public Metadata(String element,String qualifier, String language, int order, String value)
public String getValue()
    		return this.value;
    	}


    	public int compareTo(Metadata other)
    	{
    		String myName = this.element     + "." +this.qualifier   + "." + this.language;
import java.io.Serializable;

/**
 * 
 * This class represents an i18n message, which is composed of three parts: a 
 * catalogue, a key, and a set of dictionary parameters. The catalogue tells 
 * the translator where to find the key, the key tells the transformer which 
 * specific text should be used, and the parameters are provided for non-translated 
 * data to be inserted into the resulting string.
 * 
 * This class is designed in such a way that the Message object can be made static by any 
 * class that needs to use it. If dicionary parameters are used then a new 
 * instance is created specifically for those parameters, this prevents 
 * concurrent threads from overwriting each other's parameters.
 * 
 * @author Scott Phillips
 */

public String getKey()
     * cloned copy that has been parameterized.
     * 
     * @param dictionaryParameters The dictionary parameters
     */
    public Message parameterize(Object ... dictionaryParameters)
    {
public Message parameterize(Object ... dictionaryParameters)
     *
     * No one outside of this class should even know this class exists,
     * hence the privacy, but having two implementations allows us to
     * separate all the functionality for paramaterization into this
     * one place. Since most of the messages used are unparameterized
     * this is not wasted on them and is only invoked when needed. There 
     * may be some performance increase by doing this but I doubt it is 
public ParameterizedMessage(String catalogue, String key, Object ... dictionaryP
        }
        
        /**
         * Return the dicionary parameters for this message.
         * 
         * @return Any parameters to the catalogue key
         */
        public Object[] getDictionaryParameters()
        {
            return dictionaryParameters;
 * implementation that identifies referenced objects. Since the DRI document includes 
 * references to external resources implementers of this class must know how objects 
 * are referenced.
 * 
 * The specefic implementation of ObjectManager that is used is determened by the
 * WingComponent that is creating the reference.
 * 
 * @author Scott Phillips
 */

     * @param object
     *            The object to be managed.
     * @return true if the object can be managed, otherwise false.
     */
    public boolean manageObject(Object object) throws WingException;  
	
	/**
	 * Return a url referencing the object's metadata. If this is unabvailable 
	 * return null.
	 * 
	 * @param object The object being managed.
	 */
	public String getObjectURL(Object object) throws WingException;
	
	/**
	 * Return a descriptive, repository specfic, type for the object. If 
	 * this is unabvailable return null.
	 * 
	 * @param object The object being managed.
	 */
	public String getObjectType(Object object) throws WingException;
	
	/**
	 * Return a unique identifier of the repository this object is contained 
	 * in. If this is unabvailable return null.
	 * 
	 * @param object The object being managed.
	 */
	public String getRepositoryIdentifier(Object object) throws WingException;
	
	 * Return a list of all repositories managed by this manager. The 
	 * hash should be of the form repository identifier as the key, 
	 * and the value for each key is a metadata URL.
	 */
	public Map<String,String> getAllManagedRepositories() throws WingException;
}
 */
package org.dspace.app.xmlui.wing;

/**
 * A class representing the framework's context, what component is generationg
 * content, where should we log. It's basically a grab bag for framework-wide
 * communication, if all elements need to know about something then it should go
 * here.
 * 
 * @author Scott Phillips
 */

import org.apache.commons.logging.Log;

public class WingContext
{
    /** The naming divider */
public void setComponentName(String componentName)

    /**
     * Return the current transformer's name.
     */
    public String getComponentName()
    {
public void setLogger(Log log)
    /**
     * Generate a unique id based upon the locally unique name and the
     * application.
     * 
     * The format of the unique id typically is:
     * 
     * <componentName> dot <application> dot <unique name>
     * 
     * typically the componentName is the Java class path of the Wing component.
     * 
     * @param application
     *            The application of this element, typically this is the element
     *            type that is being identified. Such as p, div, table, field,
public String generateID(String application, String name)
     * @param subName
     *            An additional name to the original name to further identify it
     *            in cases when just the name alone does not accomplish this.
     */
    public String generateID(String application, String name, String subName)
    {
public String generateID(String application, String name, String subName)
     * @param name
     *            A locally unique name that distinguished this element from
     *            among it's siblings.
     */
    public String generateName(String name)
    {
public ObjectManager getObjectManager() {
    
    /**
     * Check that the context is valid, and able to be used. An error should be
     * thrown if it is not in a valid sate.
     */
    public void checkValidity() throws WingException
    {
public interface WingTransformer
{

    /** What to add at the end of the body */
    public void addBody(Body body) throws Exception;

    /** What to add to the options list */
    public void addOptions(Options options) throws Exception;

    /** What user metadata to add to the document */
    public void addUserMeta(UserMeta userMeta) throws Exception;

    /** What page metadata to add to the document */
    public void addPageMeta(PageMeta pageMeta) throws Exception;

    /** What is a unique name for this component? */
    public String getComponentName();
}
 * methods for sending SAX events that handle namespaces and attributes so that
 * each individual wing element does not.
 * 
 * There are also a set of utility methods for checking method parameters.
 * 
 * @author Scott Phillips
 */
protected AbstractWingElement()
    /**
     * Return the currently registered wing context.
     * 
     */
    protected WingContext getWingContext()
    {
protected void setWingContext(WingContext context)
     *            A non null and none empty string
     * @param message
     *            The exception message thrown if parameter is invalid.
     */
    protected void require(String parameter, String message)
            throws WingInvalidArgument
protected void require(String parameter, String message)
     *            A non null and none empty string
     * @param message
     *            The exception message thrown if parameter is invalid.
     */
    protected void require(Message parameter, String message)
            throws WingInvalidArgument
protected void require(Message parameter, String message)
     *            A list of possible values for the parameter.
     * @param message
     *            The exception message thrown if the parameter is invalid.
     */
    protected void restrict(String parameter, String[] options, String message)
            throws WingInvalidArgument
protected void restrict(String parameter, String[] options, String message)
     *            An int who's value is lesser that greater.
     * @param message
     *            The exception message thrown if the parameter is invalid.
     */
    protected void greater(int parameter, int greater, String message)
            throws WingInvalidArgument
protected void greater(int parameter, int greater, String message)
     *            An int who's value is greater that lesser.
     * @param message
     *            The exception message thrown if the parameter is invalid.
     */
    protected void lesser(int parameter, int lesser, String message)
            throws WingInvalidArgument
protected void lesser(int parameter, int lesser, String message)
     *            A false value.
     * @param message
     *            The exception message thrown if "test" is invalid.
     */
    protected void requireFalse(boolean test, String message)
            throws WingInvalidArgument
protected void requireFalse(boolean test, String message)
     *            A true value.
     * @param message
     *            The exception message thrown if "test" is invalid.
     */
    protected void requireTrue(boolean test, String message)
            throws WingInvalidArgument
protected void requireTrue(boolean test, String message)
     *            (Required) The element's localName
     * @param attributes
     *            (May be null) Attributes for this element.
     */
    protected void startElement(ContentHandler contentHandler,
            NamespaceSupport namespaces, String name, AttributeMap attributes)
protected void startElement(ContentHandler contentHandler,
     *            (Required) The local name of this element.
     * @param attributes
     *            (May be null) Attributes for this element
     */
    protected void startElement(ContentHandler contentHandler,
            NamespaceSupport namespaces, Namespace namespace, String name,
protected void startElement(ContentHandler contentHandler,
     *            should be routed too.
     * @param characters
     *            (May be null) Characters to send.
     */
    protected void sendCharacters(ContentHandler contentHandler,
            String characters) throws SAXException
protected void sendCharacters(ContentHandler contentHandler,
     *            to determine the correct prefix for a given namespace URI.
     * @param name
     *            (Required) The localName of this element.
     */
    protected void endElement(ContentHandler contentHandler,
            NamespaceSupport namespaces, String name) throws SAXException
protected void endElement(ContentHandler contentHandler,
     *            (Required) The namespace of this element.
     * @param name
     *            (Required) The local name of this element.
     */
    protected void endElement(ContentHandler contentHandler,
            NamespaceSupport namespaces, Namespace namespace, String name)
private String qName(String prefix, String localName)
    /**
     * Dispose
     */
    public void dispose()
    {
        this.context = null;

/**
 * A class representing the page division.
 * 
 * The body contains any number of divisions (div elements) which group content
 * into interactive and non interactive display blocks.
 * 
 * @author Scott Phillips
 */
public class Body extends AbstractWingElement implements WingMergeableElement
    private boolean merged = false;

    /** The divisions contained within this body */
    private List<Division> divisions = new ArrayList<Division>();

    /**
     * Generate a new Body framework element. This method will NOT open or close
     * 
     * @param context
     *            (Required) The context this element is contained in.
     */
    protected Body(WingContext context) throws WingException
    {
protected Body(WingContext context) throws WingException
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @return a new division.
     */
    public Division addDivision(String name, String rend) throws WingException
    {
public Division addDivision(String name, String rend) throws WingException
     *            a local identifier used to differentiate the element from its
     *            siblings
     * @return A new division.
     */
    public Division addDivision(String name) throws WingException
    {
public Division addDivision(String name) throws WingException
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @return A new division.
     */
    public Division addInteractiveDivision(String name, String action,
            String method, String rend) throws WingException
    {
        Division div = new Division(context, name, action, method, rend);
        divisions.add(div);
        return div;

    }

    /**
public Division addInteractiveDivision(String name, String action,
     * @param attributes
     *            The element's attributes
     * @return True if it is equivalent.
     */
    public boolean mergeEqual(String namespace, String localName, String qName,
            Attributes attributes) throws SAXException, WingException
    {
        if (!WingConstants.DRI.URI.equals(namespace))
        {
            return false;
        }
        if (!E_BODY.equals(localName))
        {
            return false;
        }
        return true;
    }

    /**
public boolean mergeEqual(String namespace, String localName, String qName,
     * @param attributes
     *            The element's attributes
     * @return the matching Division, or null.
     */
    public WingMergeableElement mergeChild(String namespace, String localName,
            String qName, Attributes attributes)
	throws SAXException, WingException
public WingMergeableElement mergeChild(String namespace, String localName,
     * 
     * @param attributes
     *            The to-be-merged attributes
     */
    public Attributes merge(Attributes attributes) throws SAXException,
            WingException
    {
public Attributes merge(Attributes attributes) throws SAXException,
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */
    public void toSAX(ContentHandler contentHandler,
            LexicalHandler lexicalHandler, NamespaceSupport namespaces)
            throws SAXException
public void toSAX(ContentHandler contentHandler,
    /**
     * dispose
     */
    public void dispose()
    {
        for (Division division : divisions)
 */
package org.dspace.app.xmlui.wing.element;

/**
 * A class representing the Button input control. The button input control
 * allows the user to activate a form submit, where the form information is sent
 * back to the server.
 * 
 * @author Scott Phillips
 */

import org.dspace.app.xmlui.wing.Message;
import org.dspace.app.xmlui.wing.WingContext;
import org.dspace.app.xmlui.wing.WingException;

public class Button extends Field
{
    /**
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     */
    protected Button(WingContext context, String name, String rend)
            throws WingException
protected Button(WingContext context, String name, String rend)
     * Set the button's label, removing any previous label's
     * 
     * @return A button label's value.
     */
    public Value setValue() throws WingException
    {
public Value setValue() throws WingException
     * 
     * @param characters
     *            (May be null) The button's label as a string.
     */
    public void setValue(String characters) throws WingException
    {
public void setValue(String characters) throws WingException
     * @param translated
     *            (Required) A key into the i18n catalogue for translation into
     *            the user's preferred language.
     */
    public void setValue(Message translated) throws WingException
    {
 */
package org.dspace.app.xmlui.wing.element;

/**
 * A class representing a table cell.
 * 
 * The cell element contained in a row of a table carries content for that
 * table. It is a character container, just like p, item, and hi, and its
 * primary purpose is to display textual data, possibly enhanced with
 * hyperlinks, emphasized blocks of text, images and form fields.
 * 
 * @author Scott Phillips
 */

import org.dspace.app.xmlui.wing.AttributeMap;
import org.dspace.app.xmlui.wing.WingContext;
import org.dspace.app.xmlui.wing.WingException;
import org.xml.sax.ContentHandler;
import org.xml.sax.SAXException;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.helpers.NamespaceSupport;

public class Cell extends RichTextContainer implements StructuralElement
{
    /** The name of the cell element */
    public static final String A_COLS = "cols";

    /** The name of this cell */
    private String name;

    /** The role of this cell, see ROLES below */
    private String role;

    /** How many rows does this table span */
    private int rows;

    /** How many cols does this table span */
    private int cols;

    /** Special rendering instructions */
    private String rend;

    /** The possible cell role types */
    public static final String ROLE_DATA = "data";
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     */
    protected Cell(WingContext context, String name, String role, int rows,
            int cols, String rend) throws WingException
protected Cell(WingContext context, String name, String role, int rows,
     * @param namespaces
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */
    public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler,
            NamespaceSupport namespaces) throws SAXException
    {
public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler,
        endElement(contentHandler, namespaces, E_CELL);
    }

    /**
     * dispose
     */
    public void dispose()
    {
        if (contents != null)
 */
package org.dspace.app.xmlui.wing.element;

/**
 * A class representing a CheckBox input control. The checkbox input control is
 * a boolean control which may be toggled by the user. A checkbox may have
 * 
 * @author Scott Phillips
 */

import org.dspace.app.xmlui.wing.Message;
import org.dspace.app.xmlui.wing.WingContext;
import org.dspace.app.xmlui.wing.WingException;

public class CheckBox extends Field
{

     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     */
    protected CheckBox(WingContext context, String name, String rend)
            throws WingException
protected CheckBox(WingContext context, String name, String rend)
     * Enable the add operation for this field. When this is enabled the
     * front end will add a button to add more items to the field.
     * 
     */
    public void enableAddOperation() throws WingException
    {
public void enableAddOperation() throws WingException
     * the front end will provide a way for the user to select fields (probably
     * checkboxes) along with a submit button to delete the selected fields.
     * 
     */
    public void enableDeleteOperation()throws WingException
    {
        this.params.enableDeleteOperation();
    }
    
    
    
    
    
    /**
     * Add an option.
     * 
     * @param returnValue
     *            (Required) The value to be passed back if this option is
     *            selected.
     */
    public Option addOption(String returnValue)
            throws WingException
public Option addOption(String returnValue)
     * @param returnValue
     *            (Required) The value to be passed back if this option is
     *            selected.
     */
    public Option addOption(int returnValue)
            throws WingException
public Option addOption(int returnValue)
     * @param returnValue
     *            (Required) The value to be passed back if this option is
     *            checked.
     */
    public Option addOption(boolean selected, String returnValue)
            throws WingException
public Option addOption(boolean selected, String returnValue)
     *            checked.
     * @param characters
     *            (Required) The text to set as the visible option.
     */
    public void addOption(String returnValue, String characters) throws WingException
    {
public void addOption(String returnValue, String characters) throws WingExceptio
     *            checked.
     * @param characters
     *            (Required) The text to set as the visible option.
     */
    public void addOption(boolean selected,String returnValue, String characters) throws WingException
    {
public void addOption(boolean selected,String returnValue, String characters) th
     *            checked.
     * @param characters
     *            (Required) The text to set as the visible option.
     */
    public void addOption(int returnValue, String characters) throws WingException
    {
public void addOption(int returnValue, String characters) throws WingException
     *            selected.
     * @param characters
     *            (Required) The text to set as the visible option.
     */
    public void addOption(boolean selected, int returnValue, String characters) throws WingException
    {
public void addOption(boolean selected, int returnValue, String characters) thro
     *            (Required) The value to be passed back if this option is
     *            selected.
     * @param message
     *            (Required) The transalted text to set as the visible option.
     */
    public void addOption(String returnValue, Message message) throws WingException
    {
public void addOption(String returnValue, Message message) throws WingException
     *            (Required) The value to be passed back if this option is
     *            selected.
     * @param message
     *            (Required) The transalted text to set as the visible option.
     */
    public void addOption(boolean selected, String returnValue, Message message) throws WingException
    {
public void addOption(boolean selected, String returnValue, Message message) thr
     *            (Required) The value to be passed back if this option is
     *            selected.
     * @param message
     *            (Required) The transalted text to set as the visible option.
     */
    public void addOption(int returnValue, Message message) throws WingException
    {
public void addOption(int returnValue, Message message) throws WingException
     *            (Required) The value to be passed back if this option is
     *            selected.
     * @param message
     *            (Required) The transalted text to set as the visible option.
     */
    public void addOption(boolean selected, int returnValue, Message message) throws WingException
    {
public void addOption(boolean selected, int returnValue, Message message) throws
        addOption(returnValue,message);
    }


    
    
    
    
    
    /**
     * Set the given option as checked.
     * 
     * @param returnValue
     *            (Required) The return value of the option to be selected.
     */
    public void setOptionSelected(String returnValue) throws WingException
    {
public void setOptionSelected(String returnValue) throws WingException
     * 
     * @param returnValue
     *            (Required) The return value of the option to be selected.
     */
    public void setOptionSelected(int returnValue) throws WingException
    {
        Value value = new Value(context,Value.TYPE_OPTION,String.valueOf(returnValue));
        values.add(value);
    }
    
    
    
    
    
    
    
    
    /**
     * Add a field instance
     * @return instance
     */
    public Instance addInstance() throws WingException
    {
 */
package org.dspace.app.xmlui.wing.element;

/**
 * A class representing a composite input control. The composite input control
 * enables multiple input conrols to be combined together into a single control.
 * Some example uses would be names, that are broken up into both a first and
 * last name. Together they represent a single value but the user can interacts
 * two separate text boxes for each part of the name.
 * 
 * @author Scott Phillips
 */
import org.dspace.app.xmlui.wing.WingContext;
import org.dspace.app.xmlui.wing.WingException;

public class Composite extends Field
{

    /**
     * Construct a new field.
     * 
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     */
    protected Composite(WingContext context, String name, String rend)
            throws WingException
protected Composite(WingContext context, String name, String rend)
     * Enable the add operation for this field. When this is enabled the
     * front end will add a button to add more items to the field.
     * 
     */
    public void enableAddOperation() throws WingException
    {
public void enableAddOperation() throws WingException
     * the front end will provide a way for the user to select fields (probably
     * checkboxes) along with a submit button to delete the selected fields.
     * 
     */
    public void enableDeleteOperation()throws WingException
    {
public void enableDeleteOperation()throws WingException
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @return a new checkbox field
     */
    public CheckBox addCheckBox(String name, String rend) throws WingException
    {
public CheckBox addCheckBox(String name, String rend) throws WingException
     *            This is the name of the field use when data is submitted back
     *            to the server.
     * @return A new checkbox field
     */
    public CheckBox addCheckBox(String name) throws WingException
    {
public CheckBox addCheckBox(String name) throws WingException
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @return a new radio field.
     */
    public Radio addRadio(String name, String rend) throws WingException
    {
public Radio addRadio(String name, String rend) throws WingException
     *            to the server.
     * 
     * @return a new radio field
     */
    public Radio addRadio(String name) throws WingException
    {
public Radio addRadio(String name) throws WingException
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @return a new select field
     */
    public Select addSelect(String name, String rend) throws WingException
    {
public Select addSelect(String name, String rend) throws WingException
     *            This is the name of the field use when data is submitted back
     *            to the server.
     * @return a new select field
     */
    public Select addSelect(String name) throws WingException
    {
public Select addSelect(String name) throws WingException
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @return A new text field
     */
    public Text addText(String name, String rend) throws WingException
    {
public Text addText(String name, String rend) throws WingException
     *            This is the name of the field use when data is submitted back
     *            to the server.
     * @return a new text field
     */
    public Text addText(String name) throws WingException
    {
public Text addText(String name) throws WingException
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @return a new text area field
     */
    public TextArea addTextArea(String name, String rend) throws WingException
    {
public TextArea addTextArea(String name, String rend) throws WingException
     *            This is the name of the field use when data is submitted back
     *            to the server.
     * @return a new text area field
     */
    public TextArea addTextArea(String name) throws WingException
    {
public TextArea addTextArea(String name) throws WingException
    /**
     * Add a field instance
     * @return instance
     */
    public Instance addInstance() throws WingException
    {

/**
 * This class represents a generic Wing Container. The Container class adds a
 * simlpe contents list which may be modified by the extending concret classes.
 * When it comes time to process the element a toSAX method is provided that
 * will iterate over the contents. 
 * 
{

    /** The internal contents of this container */
    protected List<AbstractWingElement> contents = new ArrayList<AbstractWingElement>();

    /**
     * @param context
     *            (Required) The context this element is contained in.
     */
    protected Container(WingContext context) throws WingException
    {
protected Container(WingContext context) throws WingException
     * @param namespaces
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */
    public void toSAX(ContentHandler contentHandler,
            LexicalHandler lexicalHandler, NamespaceSupport namespaces)
            throws SAXException
public void toSAX(ContentHandler contentHandler,
        }
    }

    /**
     * Dispose
     */
    public void dispose()
    {

 * This class represents data, by data we mean the translated and untranslated
 * characters in between XML elements.
 * 
 * When data needs to be translated it is enclosed inside the cocoon i18n schema
 * while untranslated data is enclosed inside nothing.
 * 
 * @author Scott Phillips
    /** The name of the translate element */
    public static final String E_TRANSLATE = "translate";

    /** The name of the param element */
    public static final String E_PARAM = "param";

    /** The name of the catalogue attribute (used inside text or i18n message) */
     *            where to route SAX events and what i18n catalogue to use.
     * @param message
     *            (Required) translatable data
     * @throws WingException
     */
    protected Data(WingContext context, Message message)
            throws WingException
protected Data(WingContext context, Message message)
     *            where to route SAX events and what i18n catalogue to use.
     * @param characters
     *            (Required) Untranslated character data.
     * @throws WingException
     */
    protected Data(WingContext context, String characters) throws WingException
    {
protected Data(WingContext context, String characters) throws WingException
     * @param namespaces
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */
    public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler,
            NamespaceSupport namespaces)throws SAXException
    {
 */
package org.dspace.app.xmlui.wing.element;

/**
 * Class representing a Division, or the div element, in the XML UI schema.
 * 
 * The div element represents a major section of content and can contain a wide
 * variety of other elements to present that content to the user. It can contain
 * TEI style paragraphs, tables, and lists, as well as references to artifact
 * information stored in artifactMeta. The div element is also recursive,
 * allowing it to be further divided into other divs.
 * 
 * @author Scott Phillips
 */

import java.util.ArrayList;

import org.dspace.app.xmlui.wing.AttributeMap;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.helpers.NamespaceSupport;

public class Division extends AbstractWingElement implements StructuralElement, WingMergeableElement
{
    /** The name of the division element */
    private boolean merged = false;
    
    /** The name assigned to this div */
    private String name;

    /** Is this division interactive if so then action & method must be defined */
    private boolean interactive;

    /** Does this interactive division support the AJAX behavior? */
    private boolean behaviorAJAXenabled = false;
    
    /** A list of fields which need to be handled specially when using behavior */
    private String behaviorSensitiveFields;
    
    /** Special rendering instructions */
    private String rend;

    /** The head, or label of this division */
    private Head head;
    public static final String[] METHODS = { METHOD_GET, METHOD_POST,
            METHOD_MULTIPART };

    /** The possible pagination types: simple & masked */
    public static final String PAGINATION_SIMPLE = "simple";

    public static final String PAGINATION_MASKED = "masked";
            PAGINATION_MASKED };

    /** All content of this container, items & lists */
    private java.util.List<AbstractWingElement> contents = new ArrayList<AbstractWingElement>();

    /**
     * Construct a non-interactive division.
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     */
    protected Division(WingContext context, String name, String rend)
            throws WingException
protected Division(WingContext context, String name, String rend)
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     */
    protected Division(WingContext context, String name, String action,
            String method, String rend) throws WingException
public void enableAJAX()
     * 
     * @param fieldName
     *            (Required) The name of a single field (with no spaces).
     */
    public void addBehaviorSensitiveField(String fieldName) throws WingException
    {
public void setMaskedPagination(int itemsTotal, int firstItemIndex,

    /**
     * Set the head element which is the label associated with this division.
     */
    public Head setHead() throws WingException
    {
        this.head = new Head(context, null);
        return head;

    }

    /**
     * Set the head element which is the label associated with this division.
     * 
     * @param characters
     *            (May be null) Unprocessed characters to be included
     */
    public void setHead(String characters) throws WingException
    {
        Head head = this.setHead();
        head.addContent(characters);

    }

    /**
public void setHead(String characters) throws WingException
     * @param message
     *            (Required) A key into the i18n catalogue for translation into
     *            the user's preferred language.
     */
    public void setHead(Message message) throws WingException
    {
        Head head = this.setHead();
        head.addContent(message);
    }

    /**
public void setHead(Message message) throws WingException
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @return A new sub Division
     */
    public Division addDivision(String name, String rend) throws WingException
    {
public Division addDivision(String name, String rend) throws WingException
     *            (Required) a local identifier used to differentiate the
     *            element from its siblings.
     * @return A new sub division
     */
    public Division addDivision(String name) throws WingException
    {
public Division addDivision(String name) throws WingException
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @return A new interactive sub division
     */
    public Division addInteractiveDivision(String name, String action,
            String method, String rend) throws WingException
public Division addInteractiveDivision(String name, String action,
     *            method should be used if there are any file fields used within
     *            the division.
     * @return A new interactive sub division
     */
    public Division addInteractiveDivision(String name, String action,
            String method) throws WingException
public Division addInteractiveDivision(String name, String action,
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @return A new paragraph.
     */
    public Para addPara(String name, String rend) throws WingException
    {
public Para addPara(String name, String rend) throws WingException
     * Append an unnamed paragraph to the division
     * 
     * @return A new unnamed paragraph.
     */
    public Para addPara() throws WingException
    {
public Para addPara() throws WingException
     * @param characters
     *            (May be null) Untranslated character data to be included as
     *            the contents of this para.
     */
    public void addPara(String characters) throws WingException
    {
public void addPara(String characters) throws WingException
     * @param message
     *            (Required) Key to the i18n catalogue to translate the content
     *            into the language preferred by the user.
     */
    public void addPara(Message message) throws WingException
    {
public void addPara(Message message) throws WingException
     *            type of list. In the absence of this attribute, the type of a
     *            list will be inferred from the presence and content of labels
     *            on its items. Accepted values are found at
     *            org.dspace.app.xmlui.xmltool.List.TYPES
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * 
     * @return A new List
     */
    public List addList(String name, String type, String rend)
            throws WingException
public List addList(String name, String type, String rend)
     *            type of list. In the absence of this attribute, the type of a
     *            list will be inferred from the presence and content of labels
     *            on its items. Accepted values are found at
     *            org.dspace.app.xmlui.xmltool.List.TYPES
     * 
     * @return A new List
     */
    public List addList(String name, String type) throws WingException
    {
public List addList(String name, String type) throws WingException
     *            (Required) a local identifier used to differentiate the
     *            element from its siblings.
     * @return A new List
     */
    public List addList(String name) throws WingException
    {
public List addList(String name) throws WingException
     *            display of the element.
     * 
     * @return A new table.
     */
    public Table addTable(String name, int rows, int cols, String rend)
            throws WingException
public Table addTable(String name, int rows, int cols, String rend)
     *            (Required) The number of columns in the table.
     * 
     * @return A new table.
     */
    public Table addTable(String name, int rows, int cols) throws WingException
    {
public Table addTable(String name, int rows, int cols) throws WingException
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     */
    public ReferenceSet addReferenceSet(String name, String type, String orderBy,
            String rend) throws WingException
public ReferenceSet addReferenceSet(String name, String type, String orderBy,
     *            element from its siblings.
     * @param type
     *            (Required) The include type, see IncludeSet.TYPES
     */
    public ReferenceSet addReferenceSet(String name, String type)
            throws WingException
public ReferenceSet addReferenceSet(String name, String type)
     * @param name 
     *              (Required) The hidden fields name.
     * @return A new hidden field.
     */
    public Hidden addHidden(String name) throws WingException
    {
public Hidden addHidden(String name) throws WingException
        
        return hiddenFieldsPara.addHidden(name);
    }
    
    
    /**
     * Add a section of translated HTML to the DRI document. This will only handle 
     * simple transformations such as <p>, <b>, <i> and <a> tags.
     * 
     * Depending on the given HTML this may result in multiple paragraphs being 
     * opened and several bold tags being included.
     * 
     * @param blankLines
     * 				(Required) Treat blank lines as paragraphs delimiters.
     * @param HTML 
     * 				(Required) The HTML content
     */
    public void addSimpleHTMLFragment(boolean blankLines, String HTML) throws WingException
    {
public void addSimpleHTMLFragment(boolean blankLines, String HTML) throws WingEx
     *            The element's attributes
     * @return True if this WingElement is equivalent to the given SAX Event.
     */
    public boolean mergeEqual(String namespace, String localName, String qName,
            Attributes attributes) throws SAXException, WingException
    {
public boolean mergeEqual(String namespace, String localName, String qName,

        context.getLogger().debug("Merging a division");
        
        String name = attributes.getValue(A_NAME);
        String interactive = attributes.getValue(A_INTERACTIVE);
        String action = attributes.getValue(A_ACTION);
        String method = attributes.getValue(A_METHOD);
        String render = attributes.getValue(A_RENDER);
        String pagination = attributes.getValue(A_PAGINATION);
        String behavior = attributes.getValue(A_BEHAVIOR);

        context.getLogger().debug("Merging got parameters name="+name+", interactive="+interactive+", action="+action+", method="+method+", render="+render+", pagination="+pagination);
        
        // The name must be identical (but id's can differ)
        if (!this.name.equals(name))
        {
            return false;
        }
else if (!this.rend.equals(render))
        if (this.interactive)
        {
            // Ensure all the interactive fields are identical.
            if (!"yes".equals(interactive))
            {
                return false;
            }
            if (!this.action.equals(action))
            {
                return false;
            }
            if (!this.method.equals(method))
            {
                return false;
            }
else if (!this.rend.equals(render))
            
        } else {
            // Else, ensure that it is also not interactive.
            if (!(interactive == null || "no".equals(interactive)))
            {
                return false;
            }
else if (!this.rend.equals(render))
     *            The element's attributes
     * @return The child element
     */
    public WingMergeableElement mergeChild(String namespace, String localName,
            String qName, Attributes attributes) throws SAXException,
            WingException
public WingMergeableElement mergeChild(String namespace, String localName,
     * 
     * @return The attributes for this merged element
     */
    public Attributes merge(Attributes attributes) throws SAXException,
            WingException
    {
public Attributes merge(Attributes attributes) throws SAXException,
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */
    public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler, 
            NamespaceSupport namespaces) throws SAXException
    {
else if (PAGINATION_MASKED.equals(paginationType))
    /**
     * dispose
     */
    public void dispose()
    {

     * 
     * @param context
     *            (Required) The context this element is contained in
     */
    protected Error(WingContext context) throws WingException
    {
protected Error(WingContext context) throws WingException
     * @param namespaces
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */

    public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler,
            NamespaceSupport namespaces) throws SAXException
    {
 */
package org.dspace.app.xmlui.wing.element;

/**
 * A class representing an an abstract input control (which is just a fancy name
 * for a field :) )
 *
 * The field element is a container for all information necessary to create a
 * form field. The required "type" attribute determines the type of the field,
 * while the children tags carry the information on how to build it. Fields can
 * only occur in divisions of type "interactive".
 *
 * There are several types of possible fields and each of these field types
 * determine the appropriate parameters on the parameter object. This is the
 * only place in the schema where this design pattern is used. It limits the
 * proliferation of elements, such as a special element for textarea, select
 * lists, text fields etc... as HTML does. It also forces us to treat all fields
 * the same.
 *
 * text: A single-line text input control.
 *
 * textarea: A multi-line text input control.
 *
 * password: A single-line text input control where the input text is rendered
 * in such a way as to hide the characters from the user.
 *
 * hidden: An input control that is not rendered on the screen and hidden from
 * the user.
 *
 * button: A button input control that when activated by the user will submit
 * the form, including all the fields, back to the server for processing.
 *
 * checkbox: A boolean input control which may be toggled by the user. A
 * checkbox may have several fields which share the same name and each of those
 * fields may be toggled independently. This is distinct from a radio button
 * where only one field may be toggled.
 *
 * file: An input control that allows the user to select files to be submitted
 * with the form. Note that a form which uses a file field must use the
 * multipart method.
 *
 * radio: A boolean input control which may be toggled by the user. Multiple
 * radio button fields may share the same name. When this occurs only one field
 * may be selected to be true. This is distinct from a checkbox where multiple
 * fields may be toggled.
 *
 * select: A menu input control which allows the user to select from a list of
 * available options.
 *
 * composite: A combination of multile fields into one input control.
 *
 * @author Scott Phillips
 */

import java.util.ArrayList;
import java.util.List;

import org.dspace.app.xmlui.wing.AttributeMap;
import org.dspace.app.xmlui.wing.Message;
import org.dspace.app.xmlui.wing.WingContext;
import org.dspace.app.xmlui.wing.WingException;

import org.xml.sax.ContentHandler;
import org.xml.sax.SAXException;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.helpers.NamespaceSupport;

public abstract class Field extends AbstractWingElement implements
        StructuralElement
{
    protected Help help;
    
    /** Error instructions for this field */
    protected List<Error> errors = new ArrayList<Error>();
    
    /** All sub fields contained within a composite field */
    protected List<Field> fields = new ArrayList<Field>();
    
    /** The value of this field */
    protected List<Option> options = new ArrayList<Option>();
    
    /** The value of this field */
    protected List<Value> values = new ArrayList<Value>();
    
    /** The set of stored values */
    protected List<Instance> instances = new ArrayList<Instance>();

    /**
     * Construct a new field.
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     */
    protected Field(WingContext context, String name, String type,
            String rend) throws WingException
public void setChoices(String fieldKey)
     * select vs. suggest.  Value must match one of the PRESENTATIONS.
     *
     * @param value pre-determined metadata field key
     */
    public void setChoicesPresentation(String value)
        throws WingException
public void setChoicesClosed()
     * The help element provides help instructions to assist the user in using
     * this field.
     *
     */
    public Help setHelp() throws WingException
    {
public Help setHelp() throws WingException
     * @param characters
     *            (May be null) Direct content or a dictionary tag to be
     *            inserted into the element.
     */
    public void setHelp(String characters) throws WingException
    {
public void setHelp(String characters) throws WingException
     * @param message
     *            (Required) A key into the i18n catalogue for translation into
     *            the user's preferred language.
     */
    public void setHelp(Message message) throws WingException
    {
public void setHelp(Message message) throws WingException
     * context. The message contained within the error message will provide
     * assistance to the user in correcting the problem.
     *
     */
    public Error addError() throws WingException
    {
public Error addError() throws WingException
     * @param characters
     *            (May be null) Direct content or a dictionary tag to be
     *            inserted into the element.
     */
    public void addError(String characters) throws WingException
    {
public void addError(String characters) throws WingException
     * @param message
     *            (Required) A key into the i18n catalogue for translation into
     *            the user's preferred language.
     */
    public void addError(Message message) throws WingException
    {
public void addError(Message message) throws WingException
     * The help element provides help instructions to assist the user in using
     * this field.
     *
     */
    public Label setLabel() throws WingException
    {
public Label setLabel() throws WingException
     * @param characters
     *            (May be null) Direct content or a dictionary tag to be
     *            inserted into the element.
     */
    public void setLabel(String characters) throws WingException
    {
public void setLabel(String characters) throws WingException
     * @param message
     *            (Required) A key into the i18n catalogue for translation into
     *            the user's preferred language.
     */
    public void setLabel(Message message) throws WingException
    {
public void setLabel(Message message) throws WingException
     */
    protected void removeValueOfType(String removeType)
    {
        List<Value> found = new ArrayList<Value>();
        for (Value value : values)
        {
            if (value.getType().equals(removeType))
protected void removeValueOfType(String removeType)
     * @param namespaces
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */
    public void toSAX(ContentHandler contentHandler,
            LexicalHandler lexicalHandler, NamespaceSupport namespaces)
            throws SAXException
public void toSAX(ContentHandler contentHandler,
    /**
     * Dispose
     */
    public void dispose()
    {
        if (params != null)
    /** The name of the title attribute */
    public static final String A_TITLE = "title";

    /** The name of the class attribute */
    public static final String A_RENDER = "rend";


    /** The figure's source */
    private String source;

    /** The figure's xref target */
    private String target;


    /** The figure's xref title */
    private String title;

    /** Special rendering hints */
    private String rend;

    /**
     * Construct a new figure.
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @throws WingException
     */
    protected Figure(WingContext context, String source, String target,
            String rend) throws WingException
protected Figure(WingContext context, String source, String target,
     * @param namespaces
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */
    public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler,
            NamespaceSupport namespaces) throws SAXException
    {
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     */
    protected File(WingContext context, String name, String rend)
            throws WingException
    public static final String E_HEAD = "head";

    /** The head's name */
    private String name;

    /**
     * Construct a new head.
     * @param name
     *            (May be null) a local identifier used to differentiate the
     *            element from its siblings.
     */
    protected Head(WingContext context, String name) throws WingException
    {
protected Head(WingContext context, String name) throws WingException
     * @param namespaces
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */
    public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler,
            NamespaceSupport namespaces) throws SAXException
    {
     * 
     * @param context
     *            (Required) The context this element is contained in
     */
    protected Help(WingContext context) throws WingException
    {
protected Help(WingContext context) throws WingException
     * @param namespaces
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */

    public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler,
            NamespaceSupport namespaces) throws SAXException
    {
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     */
    protected Hidden(WingContext context, String name, String rend)
            throws WingException
protected Hidden(WingContext context, String name, String rend)

    /**
     * Set the raw value of the field removing any previous raw values.
     */
    public Value setValue() throws WingException
    {
public Value setValue() throws WingException
     * 
     * @param characters
     *            (May be null) Field value as a string
     */
    public void setValue(String characters) throws WingException
    {
public void setValue(String characters) throws WingException
     * 
     * @param integer
     *            Field value as an integer
     */
    public void setValue(int integer) throws WingException
    {
public void setValue(int integer) throws WingException
     * @param message
     *            (Required) A key into the i18n catalogue for translation into
     *            the user's preferred language.
     */
    public void setValue(Message message) throws WingException
    {
    public static final String E_HIGHLIGHT = "hi";

    /** Special rendering instructions for this highlight */
    private String rend;

    /**
     * Construct a new highlight element.
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     */
    protected Highlight(WingContext context, String rend) throws WingException
    {
protected Highlight(WingContext context, String rend) throws WingException
     * events should be routed to the contentHandler found in the WingContext.
     * 
     * @param contentHandler
     *            (Required) The registered contentHandler where SAX events
     *            should be routed too.
     * @param lexicalHandler
     *            (Required) The registered lexicalHandler where lexical 
     *            events (such as CDATA, DTD, etc) should be routed too.
     * @param namespaces
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */
    public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler,
            NamespaceSupport namespaces) throws SAXException
    {
     * Construct a new field value, when used in a multiple value context
     *
     * @param context
     *            (Required) The context this element is contained in
     */
    protected Instance(WingContext context) throws WingException
    {
protected Instance(WingContext context) throws WingException

    /**
     * Set the raw value of the field removing any previous raw values.
     */
    public Value setValue() throws WingException
    {
public Value setValue() throws WingException
     *
     * @param characters
     *            (May be null) Field value as a string
     */
    public void setValue(String characters) throws WingException
    {
public void setValue(String characters) throws WingException
     * @param message
     *            (Required) A key into the i18n catalogue for translation into
     *            the user's preferred language.
     */
    public void setValue(Message message) throws WingException
    {
public void setValue(Message message) throws WingException
     *
     * @param checked
     *            (Required) Whether the checkbox is checked or not.
     */
    public void setValue(boolean checked) throws WingException
    {
public void setValue(boolean checked) throws WingException
    /**
     * Set the authority value of the field removing any previous authority values.
     * Initialized to an empty value.
     */
    public Value setAuthorityValue() throws WingException
    {
public Value setAuthorityValue() throws WingException
     *
     * @param characters
     *            (May be null) Field value as a string
     */
    public Value setAuthorityValue(String characters, String confidence) throws WingException
    {
public Value setAuthorityValue(String characters, String confidence) throws Wing
     *
     * @param returnValue
     *            (Required) The return value of the option to be selected.
     */
    public void setOptionSelected(String returnValue) throws WingException
    {
public void setOptionSelected(String returnValue) throws WingException
     *
     * @param returnValue
     *            (Required) The return value of the option to be selected.
     */
    public void setOptionSelected(int returnValue) throws WingException
    {
public void setOptionSelected(int returnValue) throws WingException
    /**
     * Set the interpreted value of the field removing any previous interpreted
     * values.
     */
    public Value setInterpretedValue() throws WingException
    {
public Value setInterpretedValue() throws WingException
     *
     * @param characters
     *            (May be null) Field value as a string
     */
    public void setInterpretedValue(String characters) throws WingException
    {
public void setInterpretedValue(String characters) throws WingException
     * @param message
     *            (Required) A key into the i18n catalogue for translation into
     *            the user's preferred language.
     */
    public void setInterpretedValue(Message message) throws WingException
    {
public void setInterpretedValue(Message message) throws WingException
     *
     * @param option
     *            (Required) The return value of the selected option.
     */
    public Value addOptionValue(String option) throws WingException
    {
public Value addOptionValue(String option) throws WingException
     *            (Required) determine if the value is selected or not.
     * @param characters
     *            (may be null) The returned value for this field, if selected.
     */
    public void setCheckedValue(boolean checked, String characters) throws WingException
    {
public void setCheckedValue(boolean checked, String characters) throws WingExcep
     * @param namespaces
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */

    public void toSAX(ContentHandler contentHandler,
            LexicalHandler lexicalHandler, NamespaceSupport namespaces)
            throws SAXException
public void toSAX(ContentHandler contentHandler,
     */
    private void removeValueOfType(String removeType)
    {
        List<Value> found = new ArrayList<Value>();
        for (AbstractWingElement awe : contents)
        {
            if (awe instanceof Value)
    public static final String E_ITEM = "item";

    /** the item's name */
    private String name;

    /** Special rendering hints for this item */
    private String rend;

    /**
     * Construct a new item.
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     */
    protected Item(WingContext context, String name, String rend)
            throws WingException
protected Item(WingContext context, String name, String rend)
     * @param namespaces
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */
    public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler, 
            NamespaceSupport namespaces) throws SAXException
    {
    public static final String E_LABEL = "label";

    /** The label's name */
    private String name;

    /** Special rendering hints */
    private String rend;

    /**
     * Construct a new label.
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @throws WingException
     */
    protected Label(WingContext context, String name, String rend)
            throws WingException
protected Label(WingContext context, String name, String rend)
     * @param namespaces
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */
    public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler,
            NamespaceSupport namespaces) throws SAXException
    {
            TYPE_BULLETED, TYPE_GLOSS, TYPE_PROGRESS, TYPE_FORM, TYPE_DSO_LIST };

    /** The list's name */
    private String name;

    /** The list's type, see types above. * */
    private String type;

    /** Any special rendering instructions * */
    private String rend;

    /** The lists head * */
    private Head head;

    /** All content of this container, items & lists */
    private java.util.List<AbstractWingElement> contents = new ArrayList<AbstractWingElement>();

    /**
     * Construct a new list.
     *            (May be null) a rendering hint used to override the default
     *            display of the element. There are a set of predefined
     *            rendering values, see the class documentation above.
     */
    protected List(WingContext context, String name, String type, String rend)
            throws WingException
protected List(WingContext context, String name, String type, String rend)
     * Set the head element which is the label associated with this list. This
     * method should be called before any other elements have been added to the
     * list.
     */
    public Head setHead() throws WingException
    {
        Head head = new Head(context, null);
        this.head = head;
        return head;
    }

    /**
public Head setHead() throws WingException
     * @param characters
     *            (Required) Untranslated character data to be included as the
     *            list's head.
     */
    public void setHead(String characters) throws WingException
    {
        Head head = setHead();
        head.addContent(characters);
    }

    /**
public void setHead(String characters) throws WingException
     * @param key
     *            (Required) Key to the i18n catalogue to translate the content
     *            into the language preferred by the user.
     */
    public void setHead(Message key) throws WingException
    {
        Head head = setHead();
        head.addContent(key);
    }

    /**
public void setHead(Message key) throws WingException
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     */
    public Label addLabel(String name, String rend) throws WingException
    {
public Label addLabel(String name, String rend) throws WingException
     * 
     * @param characters
     *            (Required) Untranslated character data to be included.
     */
    public void addLabel(String characters) throws WingException
    {
public void addLabel(String characters) throws WingException
     * bullet. This version of label provides no textual label but may be used 
     * to indicate some implicit labeling such as ordered lists.
     * 
     */
    public void addLabel() throws WingException
    {
public void addLabel() throws WingException
     * @param key
     *            (Required) Key to the i18n catalogue to translate the content
     *            into the language preferred by the user.
     */
    public void addLabel(Message key) throws WingException
    {
public void addLabel(Message key) throws WingException
     * Add an empty unnamed item.
     * 
     * @return a new Item
     */
    public Item addItem() throws WingException
    {
public Item addItem() throws WingException
     *            (May be null) a rendering hint used to override the default
     *            display of the element. *
     * @return a new Item
     */
    public Item addItem(String name, String rend) throws WingException
    {
public Item addItem(String name, String rend) throws WingException
     * 
     * @param characters
     *            (Required) Untranslated character data to be included.
     */
    public void addItem(String characters) throws WingException
    {
public void addItem(String characters) throws WingException
     * @param key
     *            (Required) Key to the i18n catalogue to translate the content
     *            into the language preferred by the user.
     */
    public void addItem(Message key) throws WingException
    {
public void addItem(Message key) throws WingException
     * @param characters
     *            (Required) Untranslated character data to be included as the
     *            link's body.
     */
    public void addItemXref(String target, String characters)
            throws WingException
public void addItemXref(String target, String characters)
     * @param key
     *            (Required) i18n key for translating content into the user's
     *            preferred language.
     */
    public void addItemXref(String target, Message key) throws WingException
    {
public void addItemXref(String target, Message key) throws WingException
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @return A new sub list.
     */
    public List addList(String name, String type, String rend)
            throws WingException
public List addList(String name, String type, String rend)
     *            (May be null) determines the list type. If this is blank the
     *            list type is inferred from the context and use.
     * @return A new sub list.
     */
    public List addList(String name, String type)
            throws WingException
public List addList(String name, String type)
     *            (Required) a local identifier used to differentiate the
     *            element from its siblings.
     * @return A new sub list.
     */
    public List addList(String name) throws WingException
    {
        return addList(name, null, null);
    }
    
    
    
    /**
     * Determine if the given SAX startElement event is equivalent to this list.
     * 
public List addList(String name) throws WingException
     *            The element's attributes
     * @return True if this list is equivalent to the given SAX Event.
     */
    public boolean mergeEqual(String namespace, String localName, String qName,
            Attributes attributes)
    {
public boolean mergeEqual(String namespace, String localName, String qName,
        {
            return false;
        }
        String name = attributes.getValue(A_NAME);
        if (name == null)
        {
            return false;
        }
        if (!name.equals(this.name))
        {
            return false;
        }
        return true;
    }

    /**
public boolean mergeEqual(String namespace, String localName, String qName,
     *            The element's attributes
     * @return The child element
     */
    public WingMergeableElement mergeChild(String namespace, String localName,
            String qName, Attributes attributes) throws SAXException,
            WingException
public WingMergeableElement mergeChild(String namespace, String localName,
     * 
     * @return The attributes for this merged element
     */
    public Attributes merge(Attributes attributes) throws SAXException,
            WingException
    {
public Attributes merge(Attributes attributes) throws SAXException,
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */
    public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler, 
            NamespaceSupport namespaces) throws SAXException
    {
public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler,
        }
    }

    /**
     * dispose
     */
    public void dispose()
    {
        if (head != null)
protected Meta(WingContext context) throws WingException
     * Set a new user oriented metadata set.
     * 
     * @return The user oriented metadata set.
     */
    public UserMeta setUserMeta() throws WingException
    {
public UserMeta setUserMeta() throws WingException
     * Set a new page oriented metadata set.
     * 
     * @return The page oriented metadata set.
     */
    public PageMeta setPageMeta() throws WingException
    {
public PageMeta setPageMeta() throws WingException
     * Set a new repository oriented metadata set.
     * 
     * @return The repository oriented metadata set.
     */
    public RepositoryMeta setRepositoryMeta() throws WingException
    {
public RepositoryMeta setRepositoryMeta() throws WingException
     *            The element's attributes
     * @return True if this WingElement is equivalent to the given SAX Event.
     */
    public boolean mergeEqual(String namespace, String localName, String qName,
            Attributes attributes) throws SAXException, WingException
    {
public boolean mergeEqual(String namespace, String localName, String qName,
            return false;
        }

        if (!E_META.equals(localName))
        {
            return false;
        }
        
        return true;
    }

    /**
public boolean mergeEqual(String namespace, String localName, String qName,
     *            The element's attributes
     * @return The child element
     */
    public WingMergeableElement mergeChild(String namespace, String localName,
            String qName, Attributes attributes) throws SAXException,
            WingException
public WingMergeableElement mergeChild(String namespace, String localName,
                && this.userMeta.mergeEqual(namespace, localName, qName,
                        attributes))
        {
            UserMeta userMeta = this.userMeta;
            this.userMeta = null;
            return userMeta;
        }

        // page
        if (this.pageMeta != null
                && this.pageMeta.mergeEqual(namespace, localName, qName,
                        attributes))
        {
            PageMeta pageMeta = this.pageMeta;
            this.pageMeta = null;
            return pageMeta;
        }
        
        // repository
        if (this.repositoryMeta != null
                && this.repositoryMeta.mergeEqual(namespace, localName, qName,
                        attributes))
        {
            RepositoryMeta repositoryMeta = this.repositoryMeta;
            this.repositoryMeta = null;
            return repositoryMeta;
        }
        
        return null;
public WingMergeableElement mergeChild(String namespace, String localName,
     * 
     * @return The attributes for this merged element
     */
    public Attributes merge(Attributes attributes) throws SAXException,
            WingException
    {
public Attributes merge(Attributes attributes) throws SAXException,
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */
    public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler, 
            NamespaceSupport namespaces) throws SAXException
    {
public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler,
        }
    }

    /**
     * dispose
     */
    public void dispose()
    {
        if (this.userMeta != null)
    public static final String A_LANGUAGE = "lang";

    /** The metadata's element */
    private String element;

    /** The metadata's qualifier */
    private String qualifier;

    /** The metadata's language */
    private String language;
    
    /** 
     * Determine the additive model for the metadata, should 
     * the metadata always be added to the document or only if 
     * it does not already exist?
     */
    private boolean allowMultiple;

    /**
	 * Construct a new metadata.
	 * 
	 * @param element
	 *            (Required) The element of this metadata
	 * @param qualifier
	 * @param allowMultiple
	 *            (Required) Are multiple metadata elements with the same element,
	 *            qualifier, and language allowed?
	 */
    protected Metadata(WingContext context, String element, String qualifier,
            String language, boolean allowMultiple) throws WingException
protected Metadata(WingContext context, String element, String qualifier,
     * If an metadata with the same element, qualifier, and language exist
     * within the document should this metadata element be added into the
     * document or should only one metadata be allowed.
     */
    protected boolean allowMultiple()
    {
private boolean stringEqualsWithNulls(String current, String test)
     * @param namespaces
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */
    public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler,
            NamespaceSupport namespaces) throws SAXException
    {

    /** The name of the return value attribute */
    public static final String A_RETURN_VALUE = "returnValue";
    
   
    /** The submited value for this option */
    private String returnValue;

    /**
     *
     *            (Required) The context this element is contained in
     * @param returnValue
     *            (may be null) The options return value.
     */
    protected Option(WingContext context, String returnValue) throws WingException
    {
protected Option(WingContext context, String returnValue) throws WingException
     * @param namespaces
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */

    public void toSAX(ContentHandler contentHandler,
            LexicalHandler lexicalHandler, NamespaceSupport namespaces)
            throws SAXException
    private boolean merged = false;

    /** The lists contained in this Options element */
    private java.util.List<AbstractWingElement> contents = new ArrayList<AbstractWingElement>();

    /**
     * Generate a new Options framework element.
     * 
     * @param context
     *            (Required) The context this element is contained in.
     */
    protected Options(WingContext context) throws WingException
    {
protected Options(WingContext context) throws WingException

    /**
     * Add a new sublist to this item. Note that an item may contain either
     * characters (with formating & fields) or lists but not both.
     * 
     * @param name
     *            (Required) a local identifier used to differentiate the
     *            element from its siblings.
     * 
     * @param type
     *            (May be null) determines the list type. If this is blank the
     *            list type is infered from the context and use.
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @return A new sub list.
     */
    public List addList(String name, String type, String rend)
            throws WingException
public List addList(String name, String type, String rend)

    /**
     * Add a new sublist to this item. Note that an item may contain either
     * characters (with formating & fields) or lists but not both.
     * 
     * @param name
     *            (Required) a local identifier used to differentiate the
     *            element from its siblings.
     * @return A new sub list.
     */
    public List addList(String name) throws WingException
    {
public List addList(String name) throws WingException
     *            The element's attributes
     * @return Return true if this SAX Event an options element?
     */
    public boolean mergeEqual(String namespace, String localName, String qName,
            Attributes attributes)
    {
public boolean mergeEqual(String namespace, String localName, String qName,
        {
            return false;
        }
        if (!E_OPTIONS.equals(localName))
        {
            return false;
        }
        return true;
    }

    /**
public boolean mergeEqual(String namespace, String localName, String qName,
     *            The element's attributes
     * @return Return the sublist
     */
    public WingMergeableElement mergeChild(String namespace, String localName,
            String qName, Attributes attributes) throws SAXException,
            WingException
public WingMergeableElement mergeChild(String namespace, String localName,
     * 
     * @return The attributes for this merged element
     */
    public Attributes merge(Attributes attributes) throws SAXException,
            WingException
    {
public Attributes merge(Attributes attributes) throws SAXException,
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */

    public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler,
            NamespaceSupport namespaces) throws SAXException
    {
public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler,
    /**
     * dispose
     */
    public void dispose()
    {
        for (AbstractWingElement content : contents)
     * metadata. Each of these types are separated so that 
     * we can search through each time as we merge documents.
     */
    private List<Metadata> metadatum = new ArrayList<Metadata>();
    private List<Trail> trails = new ArrayList<Trail>();

    /**
     * Construct a new pageMeta
     * 
     * @param context
     *            (Required) The context this element is contained in, such as
     *            where to route SAX events and what i18n catalogue to use.
     */
    protected PageMeta(WingContext context) throws WingException
    {
protected PageMeta(WingContext context) throws WingException
	 *            (Required) determine if multiple metadata elements with the same
	 *            element, qualifier and language are allowed.
	 * @return A new metadata
	 */
    public Metadata addMetadata(String element, String qualifier,
            String language, boolean allowMultiple) throws WingException
public Metadata addMetadata(String element, String qualifier,
	 * @param language
	 *            (May be null) The metadata language
	 * @return A new metadata
	 */
    public Metadata addMetadata(String element, String qualifier, String language)
            throws WingException
public Metadata addMetadata(String element, String qualifier, String language)
     * @param qualifier
     *            (May be null) The metadata qualifier.
     * @return A new metadata
     */
    public Metadata addMetadata(String element, String qualifier)
            throws WingException
public Metadata addMetadata(String element, String qualifier)
     * @param element
     *            (Required) The metadata element.
     * @return A new metadata
     */
    public Metadata addMetadata(String element) throws WingException
    {
public Metadata addMetadata(String element) throws WingException
     * @param rend
     *            (May be null) Special rendering instructions
     * @return a new trail
     */
    public Trail addTrail(String target, String rend)
            throws WingException
public Trail addTrail(String target, String rend)
     * Add a new trail to the page without a link or render attribute.
     * 
     * @return a new trail
     */
    public Trail addTrail()
            throws WingException
public Trail addTrail()
     *            (May be null) The Target URL for this trail item.
     * @param characters
     *            (May be null) The textual contents of this trail item.
     */
    public void addTrailLink(String target, String characters)
            throws WingException
public void addTrailLink(String target, String characters)
     * @param message
     *            (Required) The textual contents of this trail item to be
     *            translated
     */
    public void addTrailLink(String target, Message message)
            throws WingException
public void addTrailLink(String target, Message message)
     *            The element's attributes
     * @return True if this WingElement is equivalent to the given SAX Event.
     */
    public boolean mergeEqual(String namespace, String localName, String qName,
            Attributes attributes) throws SAXException, WingException
    {
public boolean mergeEqual(String namespace, String localName, String qName,
            return false;
        }

        if (!E_PAGE_META.equals(localName))
        {
            return false;
        }
        return true;
    }

    /**
     * Since metadata can not be merged there are no mergeable children. This
     * just return's null.
     * 
     * @param namespace
     *            The element's name space
     * @param localName
public boolean mergeEqual(String namespace, String localName, String qName,
     *            The element's attributes
     * @return The child element
     */
    public WingMergeableElement mergeChild(String namespace, String localName,
            String qName, Attributes attributes) throws SAXException,
            WingException
public WingMergeableElement mergeChild(String namespace, String localName,
    		String qualifier = attributes.getValue(Metadata.A_QUALIFIER);
    		String language = attributes.getValue(Metadata.A_LANGUAGE);
    		
    		List<Metadata> remove = new ArrayList<Metadata>();
    		for (Metadata metadata : metadatum)
    		{
    			if (metadata.equals(element,qualifier,language) && !metadata.allowMultiple())
public WingMergeableElement mergeChild(String namespace, String localName,
    /**
     * Inform this element that it is being merged with an existing element.
     */
    public Attributes merge(Attributes attributes) throws SAXException,
            WingException
    {
public Attributes merge(Attributes attributes) throws SAXException,
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */
    public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler, 
            NamespaceSupport namespaces) throws SAXException
    {
public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler,
        }
    }

    /**
     * dispose
     */
    public void dispose()
    {
    	for (Metadata metadata : metadatum)
    public static final String E_PARA = "p";

    /** The para's name */
    private String name;

    /** Any special rendering instructions for the para */
    private String rend;

    /**
     * Construct a new paragraph. Typically names for paragraphs are not
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     */
    protected Para(WingContext context, String name, String rend)
            throws WingException
protected Para(WingContext context, String name, String rend)
     * @param namespaces
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */

    public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler, 
            NamespaceSupport namespaces) throws SAXException
    {
     * @param context
     *            (Required) The context this element is contained in, such as
     *            where to route SAX events and what i18n catalogue to use.
     *
     */
    protected Params(WingContext context) throws WingException
protected Params(WingContext context) throws WingException
     * Enable the add operation for this field set. When this is enabled the
     * front end will add a button to add more items to the field.
     *
     */
    public void enableAddOperation() throws WingException
    {
public void enableAddOperation() throws WingException
     * the front end will provide a way for the user to select fields (probably
     * checkboxes) along with a submit button to delete the selected fields.
     *
     */
    public void enableDeleteOperation()throws WingException
    {
public void setAuthorityRequired(boolean value)
    /**
     * Set the field's autofocus attribute, an HTML5 feature.
     * Valid input values to enable autofocus are: autofocus, and empty string.
     * @param value
     */
    public void setAutofocus(String value)
    {
public void setChoices(String fieldKey)
     * select vs. suggest.  Value must match one of the PRESENTATIONS.
     *
     * @param value pre-determined metadata field key
     */
    public void setChoicesPresentation(String value)
        throws WingException
public void setChoicesClosed()
     * @param namespaces
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */
    public void toSAX(ContentHandler contentHandler,
            LexicalHandler lexicalHandler, NamespaceSupport namespaces)
            throws SAXException
public void toSAX(ContentHandler contentHandler,
            attributes.put(A_OPERATIONS, operations);
        }

        
        
        if (this.returnValue != null)
        {
            attributes.put(A_RETURN_VALUE, this.returnValue);
public void toSAX(ContentHandler contentHandler,
            attributes.put(A_SIZE, this.size);
        }


        if (!this.evtBehavior.equals(""))
        {
        	attributes.put(A_EVTBEHAVIOR, this.evtBehavior);
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     */
    protected Password(WingContext context, String name, String rend)
            throws WingException
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     */
    protected Radio(WingContext context, String name, String rend)
            throws WingException
protected Radio(WingContext context, String name, String rend)
     * Enable the add operation for this field. When this is enabled the
     * front end will add a button to add more items to the field.
     * 
     */
    public void enableAddOperation() throws WingException
    {
public void enableAddOperation() throws WingException
     * the front end will provide a way for the user to select fields (probably
     * checkboxes) along with a submit button to delete the selected fields.
     * 
     */
    public void enableDeleteOperation()throws WingException
    {
        this.params.enableDeleteOperation();
    }
    
    
    
    
    
    
    
    /**
     * Add an option.
     * 
     * @param returnValue
     *            (Required) The value to be passed back if this option is
     *            selected.
     */
    public Option addOption(String returnValue)
            throws WingException
public Option addOption(String returnValue)
     * @param returnValue
     *            (Required) The value to be passed back if this option is
     *            selected.
     */
    public Option addOption(boolean selected, String returnValue)
            throws WingException
public Option addOption(boolean selected, String returnValue)
     *            selected.
     * @param characters
     *            (Required) The text to set as the visible option.
     */
    public void addOption(String returnValue, String characters) throws WingException
    {
public void addOption(String returnValue, String characters) throws WingExceptio
     *            selected.
     * @param characters
     *            (Required) The text to set as the visible option.
     */
    public void addOption(boolean selected,String returnValue, String characters) throws WingException
    {
public void addOption(boolean selected,String returnValue, String characters) th
     *            selected.
     * @param characters
     *            (Required) The text to set as the visible option.
     */
    public void addOption(int returnValue, String characters) throws WingException
    {
public void addOption(int returnValue, String characters) throws WingException
     *            selected.
     * @param characters
     *            (Required) The text to set as the visible option.
     */
    public void addOption(boolean selected, int returnValue, String characters) throws WingException
    {
public void addOption(boolean selected, int returnValue, String characters) thro
     *            (Required) The value to be passed back if this option is
     *            selected.
     * @param message
     *            (Required) The transalted text to set as the visible option.
     */
    public void addOption(String returnValue, Message message) throws WingException
    {
public void addOption(String returnValue, Message message) throws WingException
     *            (Required) The value to be passed back if this option is
     *            selected.
     * @param message
     *            (Required) The transalted text to set as the visible option.
     */
    public void addOption(boolean selected, String returnValue, Message message) throws WingException
    {
public void addOption(boolean selected, String returnValue, Message message) thr
     *            (Required) The value to be passed back if this option is
     *            selected.
     * @param message
     *            (Required) The transalted text to set as the visible option.
     */
    public void addOption(int returnValue, Message message) throws WingException
    {
public void addOption(int returnValue, Message message) throws WingException
     *            (Required) The value to be passed back if this option is
     *            selected.
     * @param message
     *            (Required) The transalted text to set as the visible option.
     */
    public void addOption(boolean selected, int returnValue, Message message) throws WingException
    {
public void addOption(boolean selected, int returnValue, Message message) throws
     * 
     * @param returnValue
     *            (Required) The return value of the option to be selected.
     */
    public void setOptionSelected(String returnValue) throws WingException
    {
public void setOptionSelected(String returnValue) throws WingException
     * 
     * @param returnValue
     *            (Required) The return value of the option to be selected.
     */
    public void setOptionSelected(int returnValue) throws WingException
    {
        Value value = new Value(context,Value.TYPE_OPTION,String.valueOf(returnValue));
        values.add(value);
    }
    
    
    
    
    
    /**
     * Add a field instance
     * @return instance
     */
    public Instance addInstance() throws WingException
    {
    private String type;

    /** All content of this container */
    private java.util.List<AbstractWingElement> contents = new ArrayList<AbstractWingElement>();

    /**
     * Construct a new object reference.
     * 
     * @param object
     *            (Required) The referenced object.
     */
    protected Reference(WingContext context, Object object)
            throws WingException
protected Reference(WingContext context, Object object)
     * @param render
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     */
    public ReferenceSet addReferenceSet(String type, String orderBy, String render)
            throws WingException
public ReferenceSet addReferenceSet(String type, String orderBy, String render)
     *            (required) The reference type, see referenceSet.TYPES
     * @param orderBy
     *            (May be null) A statement of ordering for reference sets.
     */
    public ReferenceSet addReferenceSet(String type, String orderBy)
            throws WingException
public ReferenceSet addReferenceSet(String type, String orderBy)
     * 
     * @param type
     *            (required) The include type, see includeSet.TYPES
     */
    public ReferenceSet addReferenceSet(String type) throws WingException
    {
public ReferenceSet addReferenceSet(String type) throws WingException
     * @param namespaces
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */
    public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler, 
            NamespaceSupport namespaces) throws SAXException
    {
public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler,
        endElement(contentHandler, namespaces, E_REFERENCE);
    }

    /**
     * dispose
     */
    public void dispose()
    {
        if (contents != null)
    public static final String[] TYPES = { TYPE_SUMMARY_LIST, TYPE_SUMMARY_VIEW, TYPE_DETAIL_LIST, TYPE_DETAIL_VIEW };

    /** The name assigned to this metadata set */
    private String name;

    /** The ordering mechanism to use. */
    private String orderBy;

    /** The reference type, see TYPES defined above */
    private String type;

    /** Special rendering instructions */
    private String rend;

    /** The head label for this referenceset */
    private Head head;

    /** All content of this container, items & lists */
    private java.util.List<AbstractWingElement> contents = new ArrayList<AbstractWingElement>();

    /**
     * Construct a new referenceSet
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     */
    protected ReferenceSet(WingContext context, boolean childreference, String name, String type, String orderBy, String rend)
            throws WingException
protected ReferenceSet(WingContext context, boolean childreference, String name,

    /**
     * Set the head element which is the label associated with this referenceset.
     */
    public Head setHead() throws WingException
    {
        this.head = new Head(context, null);
        return head;

    }

    /**
     * Set the head element which is the label associated with this referenceset.
     * 
     * @param characters
     *            (May be null) Unprocessed characters to be referenced
     */
    public void setHead(String characters) throws WingException
    {
        Head head = this.setHead();
        head.addContent(characters);

    }

    /**
public void setHead(String characters) throws WingException
     * @param message
     *            (Required) A key into the i18n catalogue for translation into
     *            the user's preferred language.
     */
    public void setHead(Message message) throws WingException
    {
        Head head = this.setHead();
        head.addContent(message);
    }

    /**
     * Add an object reference.
     * 
     * @param object
     *            (Required) The referenced object.
     */
    public Reference addReference(Object object)
            throws WingException
public Reference addReference(Object object)
     * @param namespaces
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */
    public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler, 
            NamespaceSupport namespaces) throws SAXException
    {
public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler,
        endElement(contentHandler, namespaces, E_REFERENCE_SET);
    }

    /**
     * dispose
     */
    public void dispose()
    {
        if (contents != null)
    private boolean merged = false;
    
    /** The registered repositories on this page */
    private Map<String,String> repositories = new HashMap<String,String>();

    /**
     * Construct a new RepositoryMeta
     * 
     * @param context
     *            (Required) The context this element is contained in, such as
     *            where to route SAX events and what i18n catalogue to use.
     */
    protected RepositoryMeta(WingContext context) throws WingException
    {
protected RepositoryMeta(WingContext context) throws WingException
     *            The element's attributes
     * @return True if this WingElement is equivalent to the given SAX Event.
     */
    public boolean mergeEqual(String namespace, String localName, String qName,
            Attributes attributes) throws SAXException, WingException
    {
public boolean mergeEqual(String namespace, String localName, String qName,
            return false;
        }

        if (!E_REPOSITORY_META.equals(localName))
        {
            return false;
        }
        return true;
    }

    /**
public boolean mergeEqual(String namespace, String localName, String qName,
     *            The element's attributes
     * @return The child element
     */
    public WingMergeableElement mergeChild(String namespace, String localName,
            String qName, Attributes attributes) throws SAXException,
            WingException
public WingMergeableElement mergeChild(String namespace, String localName,
    /**
     * Inform this element that it is being merged with an existing element.
     */
    public Attributes merge(Attributes attributes) throws SAXException,
            WingException
    {
public Attributes merge(Attributes attributes) throws SAXException,
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */
    public void toSAX(ContentHandler contentHandler,
            LexicalHandler lexicalHandler, NamespaceSupport namespaces)
            throws SAXException
 */
package org.dspace.app.xmlui.wing.element;

/**
 * A class representing a character container, such as "p", "hi", "item", or
 * "cell"
 * 
 * This class may not be instantiated on it's own instead you must use one of
 * the extending classes listed above. This abstract class implements the
 * methods common to each of those elements.
 * 
 * @author Scott Phillips
 */


import org.dspace.app.xmlui.wing.Message;
import org.dspace.app.xmlui.wing.WingContext;
import org.dspace.app.xmlui.wing.WingException;

public abstract class RichTextContainer extends TextContainer
{
    /**
     * 
     * @param context
     *            (Required) The context this element is contained in.
     */
    protected RichTextContainer(WingContext context) throws WingException
    {
protected RichTextContainer(WingContext context) throws WingException
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @return A new Highlight
     */
    public Highlight addHighlight(String rend) throws WingException
    {
public Highlight addHighlight(String rend) throws WingException
    }

    /**
     * Add a new reference to the character container. The xref element is a
     * reference to an external document. The content will be used as part of
     * the link's visual body.
     * 
     * @param target
     *            (Required) A target URL for the references a destination for
     *            the xref.
     */
    public Xref addXref(String target) throws WingException
    {
public Xref addXref(String target) throws WingException
    }

    /**
     * Add a new reference to the character container. The xref element is a
     * reference to an external document. The characters will be used as the
     * visual part of the link's body
     * 
     * @param target
     *            (Required) A target URL for the references a destination for
     *            the xref.
     * @param characters
     *            (May be null) The link's body
     */
    public void addXref(String target, String characters) throws WingException
    {
public void addXref(String target, String characters) throws WingException
    }
    
    /**
     * Add a new reference to the character container. The xref element is a
     * reference to an external document. The characters will be used as the
     * visual part of the link's body
     * 
     * @param target
     *            (Required) A target URL for the references a destination for
     *            the xref.
     * @param characters
     *            (May be null) The link's body
     * @param rend
     * 			  (May be null) Special rendering instructions.
     */
    public void addXref(String target, String characters, String rend) throws WingException
    {
public void addXref(String target, String characters, String rend) throws WingEx
    }
    
    /**
     * Add a new reference to the character container. The xref element is a
     * reference to an external document. The characters will be used as the
     * visual part of the link's body
     * 
     * @param target
     *            (Required) A target URL for the references a destination for
     *            the xref.
     * @param characters
     *            (May be null) The link's body
     * @param rend
     *            (May be null) Special rendering instructions.
     * @param name
     *            (May be null) local identifier
     */
    public void addXref(String target, String characters, String rend, String name) throws WingException
    {
public void addXref(String target, String characters, String rend, String name)
    }

    /**
     * Add a new reference to the character container. The xref element is a
     * reference to an external document. The translated i18n key will be used
     * as the visual part of the link's body
     * 
     * @param target
     *            (Required) A target URL for the references a destination for
     *            the xref.
     * @param key
     *            (Required) The link's body
     */
    public void addXref(String target, Message key) throws WingException
    {
public void addXref(String target, Message key) throws WingException
    }
    
    /**
     * Add a new reference to the character container. The xref element is a
     * reference to an external document. The translated i18n key will be used
     * as the visual part of the link's body
     * 
     * @param target
     *            (Required) A target URL for the references a destination for
     *            the xref.
     * @param key
     *            (Required) The link's body
     * @param rend
     *  		  (May be null) Special rendering instructions
     */
    public void addXref(String target, Message key, String rend) throws WingException
    {
public void addXref(String target, Message key, String rend) throws WingExceptio
    }

    /**
     * Add a new reference to the character container. The xref element is a
     * reference to an external document. The translated i18n key will be used
     * as the visual part of the link's body
     *
     * @param target
     *            (Required) A target URL for the references a destination for
     *            the xref.
     * @param key
     *            (Required) The link's body
     * @param rend
     *  		  (May be null) Special rendering instructions
     */
    public void addXref(String target, Message key, String rend, String name) throws WingException
    {
public void addXref(String target, Message key, String rend, String name) throws
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     */
    public Figure addFigure(String source, String target, String rend)
            throws WingException
public Figure addFigure(String source, String target, String rend)
     *            (May be null) The target reference for the image if the image
     *            is to operate as a link.
     * @param title
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     */
    public Figure addFigure(String source, String target, String title, String rend)
            throws WingException
public Figure addFigure(String source, String target, String title, String rend)
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @return A new button field.
     */
    public Button addButton(String name, String rend) throws WingException
    {
public Button addButton(String name, String rend) throws WingException
     *            This is the name of the field use when data is submitted back
     *            to the server.
     * @return a new button field
     */
    public Button addButton(String name) throws WingException
    {
public Button addButton(String name) throws WingException
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @return a new checkbox field
     */
    public CheckBox addCheckBox(String name, String rend) throws WingException
    {
public CheckBox addCheckBox(String name, String rend) throws WingException
     *            This is the name of the field use when data is submitted back
     *            to the server.
     * @return A new checkbox field
     */
    public CheckBox addCheckBox(String name) throws WingException
    {
public CheckBox addCheckBox(String name) throws WingException
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @return a new composite field.
     */
    public Composite addComposite(String name, String rend) throws WingException
    {
public Composite addComposite(String name, String rend) throws WingException
     *            (Required) a non-unique local identifier used to differentiate
     *            the element from its siblings within an interactive division.
     * @return a new composite field.
     */
    public Composite addComposite(String name) throws WingException
    {
public Composite addComposite(String name) throws WingException
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @return A new file field
     */
    public File addFile(String name, String rend) throws WingException
    {
public File addFile(String name, String rend) throws WingException
     *            This is the name of the field use when data is submitted back
     *            to the server.
     * @return a new file field
     */
    public File addFile(String name) throws WingException
    {
public File addFile(String name) throws WingException
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @return a new hidden field
     */
    public Hidden addHidden(String name, String rend) throws WingException
    {
public Hidden addHidden(String name, String rend) throws WingException
     *            This is the name of the field use when data is submitted back
     *            to the server.
     * @return a new hidden field.
     */
    public Hidden addHidden(String name) throws WingException
    {
public Hidden addHidden(String name) throws WingException
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @return A new password field
     */
    public Password addPassword(String name, String rend) throws WingException
    {
public Password addPassword(String name, String rend) throws WingException
     *            This is the name of the field use when data is submitted back
     *            to the server.
     * @return a new password field
     */
    public Password addPassword(String name) throws WingException
    {
public Password addPassword(String name) throws WingException
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @return a new radio field.
     */
    public Radio addRadio(String name, String rend) throws WingException
    {
public Radio addRadio(String name, String rend) throws WingException
     *            to the server.
     * 
     * @return a new radio field
     */
    public Radio addRadio(String name) throws WingException
    {
public Radio addRadio(String name) throws WingException
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @return a new select field
     */
    public Select addSelect(String name, String rend) throws WingException
    {
public Select addSelect(String name, String rend) throws WingException
     *            This is the name of the field use when data is submitted back
     *            to the server.
     * @return a new select field
     */
    public Select addSelect(String name) throws WingException
    {
public Select addSelect(String name) throws WingException
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @return A new text field
     */
    public Text addText(String name, String rend) throws WingException
    {
public Text addText(String name, String rend) throws WingException
     *            This is the name of the field use when data is submitted back
     *            to the server.
     * @return a new text field
     */
    public Text addText(String name) throws WingException
    {
public Text addText(String name) throws WingException
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @return a new text area field
     */
    public TextArea addTextArea(String name, String rend) throws WingException
    {
public TextArea addTextArea(String name, String rend) throws WingException
     *            This is the name of the field use when data is submitted back
     *            to the server.
     * @return a new text area field
     */
    public TextArea addTextArea(String name) throws WingException
    {
        return addTextArea(name, null);
    }
    
    
    
    
    
}
    public static final String A_ROLE = "role";

    /** The row's name */
    private String name;

    /** The row's role, see ROLES below */
    private String role;

    /** Special rendering instructions */
    private String rend;

    /** The row (and cell) role types: */
    public static final String ROLE_DATA = "data";
    public static final String[] ROLES = { ROLE_DATA, ROLE_HEADER };

    /** The contents of this row */
    List<AbstractWingElement> contents = new ArrayList<AbstractWingElement>();

    /**
     * Construct a new table row.
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     */
    protected Row(WingContext context, String name, String role, String rend)
            throws WingException
protected Row(WingContext context, String name, String role, String rend)
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @return a new table cell.
     */
    public Cell addCell(String name, String role, int rows, int cols,
            String rend) throws WingException
public Cell addCell(String name, String role, int rows, int cols,
     *            (May be zero for no defined value) determines how many columns
     *            does this cell span.
     * @return a new table cell.
     */
    public Cell addCell(int rows, int cols) throws WingException
    {
public Cell addCell(int rows, int cols) throws WingException
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     * @return a new table cell.
     */
    public Cell addCell(String name, String role, String rend)
            throws WingException
public Cell addCell(String name, String role, String rend)
     *            (May be null) determines what kind of information the cell
     *            carries, either header or data. See cell.ROLES
     * @return a new table cell.
     */
    public Cell addCell(String role) throws WingException
    {
public Cell addCell(String role) throws WingException
     * form fields.
     * 
     * @return a new table cell.
     */
    public Cell addCell() throws WingException
    {
public Cell addCell() throws WingException
     * 
     * @param characters
     *            (Required) Untranslated character data to be included.
     */
    public void addCellContent(String characters) throws WingException
    {
public void addCellContent(String characters) throws WingException
     * @param message
     *            (Required) Key to the i18n catalogue to translate the content
     *            into the language preferred by the user.
     */
    public void addCellContent(Message message) throws WingException
    {
public void addCellContent(Message message) throws WingException
     * @param namespaces
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */
    public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler,
            NamespaceSupport namespaces) throws SAXException
    {
public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler,
        endElement(contentHandler, namespaces, E_ROW);
    }

    /**
     * dispose
     */
    public void dispose()
    {
        for (AbstractWingElement content : contents)
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     */
    protected Select(WingContext context, String name, String rend)
            throws WingException
public void setEvtBehavior(String behavior) {
     * Enable the add operation for this field. When this is enabled the
     * front end will add a button to add more items to the field.
     * 
     */
    public void enableAddOperation() throws WingException
    {
public void enableAddOperation() throws WingException
     * the front end will provide a way for the user to select fields (probably
     * checkboxes) along with a submit button to delete the selected fields.
     * 
     */
    public void enableDeleteOperation()throws WingException
    {
public void enableDeleteOperation()throws WingException
     * @param returnValue
     *            (Required) The value to be passed back if this option is
     *            selected.
     */
    public Option addOption(String returnValue)
            throws WingException
public Option addOption(String returnValue)
     * @param returnValue
     *            (Required) The value to be passed back if this option is
     *            selected.
     */
    public Option addOption(boolean selected, String returnValue)
            throws WingException
public Option addOption(boolean selected, String returnValue)
     *            selected.
     * @param characters
     *            (Required) The text to set as the visible option.
     */
    public void addOption(String returnValue, String characters) throws WingException
    {
public void addOption(String returnValue, String characters) throws WingExceptio
     *            selected.
     * @param characters
     *            (Required) The text to set as the visible option.
     */
    public void addOption(boolean selected,String returnValue, String characters) throws WingException
    {
public void addOption(boolean selected,String returnValue, String characters) th
     *            selected.
     * @param characters
     *            (Required) The text to set as the visible option.
     */
    public void addOption(int returnValue, String characters) throws WingException
    {
public void addOption(int returnValue, String characters) throws WingException
     *            selected.
     * @param characters
     *            (Required) The text to set as the visible option.
     */
    public void addOption(boolean selected, int returnValue, String characters) throws WingException
    {
public void addOption(boolean selected, int returnValue, String characters) thro
     *            (Required) The value to be passed back if this option is
     *            selected.
     * @param message
     *            (Required) The transalted text to set as the visible option.
     */
    public void addOption(String returnValue, Message message) throws WingException
    {
public void addOption(String returnValue, Message message) throws WingException
     *            (Required) The value to be passed back if this option is
     *            selected.
     * @param message
     *            (Required) The transalted text to set as the visible option.
     */
    public void addOption(boolean selected, String returnValue, Message message) throws WingException
    {
public void addOption(boolean selected, String returnValue, Message message) thr
     *            (Required) The value to be passed back if this option is
     *            selected.
     * @param message
     *            (Required) The transalted text to set as the visible option.
     */
    public void addOption(int returnValue, Message message) throws WingException
    {
public void addOption(int returnValue, Message message) throws WingException
     *            (Required) The value to be passed back if this option is
     *            selected.
     * @param message
     *            (Required) The transalted text to set as the visible option.
     */
    public void addOption(boolean selected, int returnValue, Message message) throws WingException
    {
public void addOption(boolean selected, int returnValue, Message message) throws
     * 
     * @param returnValue
     *            (Required) The return value of the option to be selected.
     */
    public void setOptionSelected(String returnValue) throws WingException
    {
public void setOptionSelected(String returnValue) throws WingException
     * 
     * @param returnValue
     *            (Required) The return value of the option to be selected.
     */
    public void setOptionSelected(int returnValue) throws WingException
    {
public void setOptionSelected(int returnValue) throws WingException
    /**
     * Add a field instance
     * @return instance
     */
    public Instance addInstance() throws WingException
    {
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
/**
 * This class represents data that is translated from simple HTML or plain text.
 * 
 * This class represents a simple HTML fragment. It allows for user-supplied
 * HTML to be translated on the fly into DRI.
 * 
 * At the present time it only supports the following tags: h1, h2, h3, h4, h5,
 * p, a, b, i, u, ol, li and img. Each are translated into their DRI equivalents, note
 * the "h" tags are translated into a paragraph of rend=heading.
 * 
 * If the linkbreaks flag is set then line breaks are treated as paragraphs. This 
 * allows plain text files to also be included and they will be mapped into DRI as 
 * well.
 * 
 * @author Scott Phillips
 * @author Jay Paz
 */

public class SimpleHTMLFragment extends AbstractWingElement {

	/** The HTML Fragment */
	private String fragment;

	/** Determine if blank lines mark a new paragraph */
	private boolean blankLines;

	/**
	 * Construct a fragment object for translating into DRI.
	 *            paragraphs delimeters.
	 * @param fragment
	 *            (Required) The HTML Fragment to be translated into DRI.
	 * @throws WingException
	 */
	protected SimpleHTMLFragment(WingContext context, boolean blankLines,
			String fragment) throws WingException {
protected SimpleHTMLFragment(WingContext context, boolean blankLines,
	 * @param namespaces
	 *            (Required) SAX Helper class to keep track of namespaces able
	 *            to determine the correct prefix for a given namespace URI.
	 */
	public void toSAX(ContentHandler contentHandler,
			LexicalHandler lexicalHandler, NamespaceSupport namespaces)
			throws SAXException {
private void removeContent(Content content) {
			// If it's an element replace the content with a text node.
			Element element = (Element) content;

			if (element.getContent().size() == 0) {
				// The element contains nothing, we can use shorthand notation
				// for it.
				StringBuilder replacement = new StringBuilder().append("<").append(element.getName());
private boolean paragraphWrap(Element parent, int index,
	 *            removed.
	 */
	private void limitAttributes(Element element, String... names) {
		Map<String, String> attributes = new HashMap<String, String>();
		for (String name : names) {
			String value = element.getAttributeValue(name);
			if (value != null)
else if ("hi".equals(name)) {
		// Ensure that all top level elements are encapsulated inside
		// a block level element (i.e. a paragraph)
		if (parent.isRootElement()) {
			List<Content> removed = new ArrayList<Content>();
			for (int i = 0; i < parent.getContentSize(); i++) {
				Content current = parent.getContent(i);
				
else if ("hi".equals(name)) {
	 * from the originating HTML fragment, 2) to get around a JDOM bug where it
	 * can not output SAX events for just a document fragment. Since it only
	 * works with documents this class was created to filter out the events.
	 * 
	 * As far as I can tell, the first time the bug was identified is in the
	 * following email, point #1:
	 * 
	 * http://www.servlets.com/archive/servlet/ReadMsg?msgId=491592&listName=jdom-interest
	 * 
	 * I, Scott Phillips, checked the JDOM CVS source tree on 3-8-2006 and the
	 * bug had not been patch at that time.
	 * 
	 */
	public static class SAXFilter implements ContentHandler, LexicalHandler {

		private final String URI = WingConstants.DRI.URI;

		private ContentHandler contentHandler;

		// private LexicalHandler lexicalHandler; may be used in the future
		private NamespaceSupport namespaces;

		public SAXFilter(ContentHandler contentHandler,
				LexicalHandler lexicalHandler, NamespaceSupport namespaces) {
private String qName(String localName) {

		/** ContentHandler methods: */

		public void endDocument() {
			// Filter out endDocument events
		}

		public void startDocument() {
			// filter out startDocument events
		}

		public void characters(char[] ch, int start, int length)
				throws SAXException {
			contentHandler.characters(ch, start, length);
		}

		public void endElement(String uri, String localName, String qName)
				throws SAXException {

			contentHandler.endElement(URI, localName, qName(localName));
		}

		public void endPrefixMapping(String prefix) throws SAXException {
			// No namespaces may be declared.
		}

		public void ignorableWhitespace(char[] ch, int start, int length)
				throws SAXException {
			contentHandler.ignorableWhitespace(ch, start, length);
		}

		public void processingInstruction(String target, String data)
				throws SAXException {
			// filter out processing instructions
		}

		public void setDocumentLocator(Locator locator) {
			// filter out document locators
		}

		public void skippedEntity(String name) throws SAXException {
			contentHandler.skippedEntity(name);
		}

		public void startElement(String uri, String localName, String qName,
				Attributes atts) throws SAXException {
			contentHandler.startElement(URI, localName, qName(localName), atts);
		}

		public void startPrefixMapping(String prefix, String uri)
				throws SAXException {
			// No namespaces can be declared.
		}

		/** Lexical Handler methods: */

		public void startDTD(String name, String publicId, String systemId)
				throws SAXException {
			// filter out DTDs
		}

		public void endDTD() throws SAXException {
			// filter out DTDs
		}

		public void startEntity(String name) throws SAXException {
			// filter out Entities
		}

		public void endEntity(String name) throws SAXException {
			// filter out Entities
		}

		public void startCDATA() throws SAXException {
			// filter out CDATA
		}

		public void endCDATA() throws SAXException {
			// filter out CDATA
		}

		public void comment(char[] ch, int start, int length)
				throws SAXException {
			// filter out comments;
    public static final String A_COLS = "cols";

    /** The name assigned to this table */
    private String name;

    /** Special rendering instructions for this table */
    private String rend;

    /** The number of rows in the table */
    private int rows;

    /** The number of cols in the table */
    private int cols;

    /** The table's head */
    private Head head;

    /** the rows contained in the table */
    private List<AbstractWingElement> contents = new ArrayList<AbstractWingElement>();

    /**
     * Construct a new row.
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     */
    protected Table(WingContext context, String name, int rows, int cols,
            String rend) throws WingException
protected Table(WingContext context, String name, int rows, int cols,

    /**
     * Set the head element which is the label associated with this table.
     */
    public Head setHead() throws WingException
    {
public Head setHead() throws WingException
     * 
     * @param characters
     *            (May be null) Unprocessed characters to be included
     */
    public void setHead(String characters) throws WingException
    {
        Head head = this.setHead();
        head.addContent(characters);

    }

public void setHead(String characters) throws WingException
     * @param message
     *            (Required) A key into the i18n catalogue for translation into
     *            the user's preferred language.
     */
    public void setHead(Message message) throws WingException
    {
        Head head = this.setHead();
        head.addContent(message);
    }

    /**
public void setHead(Message message) throws WingException
     *            display of the element.
     * 
     * @return a new table row
     */
    public Row addRow(String name, String role, String rend)
            throws WingException
public Row addRow(String name, String role, String rend)
     *            carries, either header or data. See row.ROLES
     * 
     * @return a new table row
     */
    public Row addRow(String role) throws WingException
    {
public Row addRow(String role) throws WingException
     * and serves as a container of cell elements.
     * 
     * @return a new table row
     */
    public Row addRow() throws WingException
    {
public Row addRow() throws WingException
     * @param namespaces
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */

    public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler, 
            NamespaceSupport namespaces) throws SAXException
    {
public void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler,
        endElement(contentHandler, namespaces, E_TABLE);
    }

    /**
     * dispose
     */
    public void dispose()
    {
        if (head != null)
     * @param rend
     *            (May be null) a rendering hint used to override the default
     *            display of the element.
     */
    protected Text(WingContext context, String name, String rend)
            throws WingException
public void setSize(int size, int maxLength)
     * Enable the add operation for this field. When this is enabled the
     * front end will add a button to add more items to the field.
     *
     */
    public void enableAddOperation() throws WingException
    {
public void enableAddOperation() throws WingException
     * the front end will provide a way for the user to select fields (probably
     * checkboxes) along with a submit button to delete the selected fields.
     *
     */
    public void enableDeleteOperation()throws WingException
    {
public void enableDeleteOperation()throws WingException

    /**
     * Set the raw value of the field removing any previous raw values.
     */
    public Value setValue() throws WingException
    {
public Value setValue() throws WingException
     *
     * @param characters
     *            (May be null) Field value as a string
     */
    public void setValue(String characters) throws WingException
    {
public void setValue(String characters) throws WingException
     * @param message
     *            (Required) A key into the i18n catalogue for translation into
     *            the user's preferred language.
     */
    public void setValue(Message message) throws WingException
    {
public void setValue(Message message) throws WingException
    /**
     * Set the authority value of the field removing any previous authority values.
     * Initialized to an empty value.
     */
    public Value setAuthorityValue() throws WingException
    {
public Value setAuthorityValue() throws WingException
    /**
     * Set the authority value of the field removing any previous authority values.
     * Initialized to an empty value.
     */
    public Value setAuthorityValue(String characters, String confidence) throws WingException
    {
public Value setAuthorityValue(String characters, String confidence) throws Wing
    /**
     * Add a field instance
     * @return instance
     */
    public Instance addInstance() throws WingException
    {
 */
package org.dspace.app.xmlui.wing.element;


import org.dspace.app.xmlui.wing.Message;
import org.dspace.app.xmlui.wing.WingContext;
import org.dspace.app.xmlui.wing.WingException;
     * 
     * @param context
     *            (Required) The context this element is contained in.
     */
    protected TextContainer(WingContext context) throws WingException
    {
protected TextContainer(WingContext context) throws WingException
     * @param characters
     *            (Required) Direct content or a dictionary tag to be inserted
     *            into the element.
     */
    public void addContent(String characters) throws WingException
    {
public void addContent(String characters) throws WingException
     * 
     * @param integer
     *            (Required) Add the integer into the element's container.
     */
    public void addContent(int integer) throws WingException
    {
public void addContent(int integer) throws WingException
     * @param message
     *            (Required) A key into the i18n catalogue for translation into
     *            the user's preferred language.
     */
    public void addContent(Message message) throws WingException
    {
import org.xml.sax.helpers.NamespaceSupport;

/**
 * This basic interface is implemented by all WingElements, once an element has
 * been created it can be translated into SAX events and disposed of.
 * 
 * @author Scott Phillips
     * @param namespaces
     *            (Required) SAX Helper class to keep track of namespaces able
     *            to determine the correct prefix for a given namespace URI.
     */
    public abstract void toSAX(ContentHandler contentHandler, LexicalHandler lexicalHandler,
            NamespaceSupport namespaces) throws SAXException;
     * @param attributes
     *            The element's attributes
     * @return True if this WingElement is equivalent to the given SAX Event.
     */
    public boolean mergeEqual(String namespace, String localName, String qName,
            Attributes attributes) throws SAXException, WingException;
public boolean mergeEqual(String namespace, String localName, String qName,
     * @param attributes
     *            The element's attributes
     * @return The child element
     */
    public WingMergeableElement mergeChild(String namespace, String localName,
            String qName, Attributes attributes) throws SAXException,
public WingMergeableElement mergeChild(String namespace, String localName,
     * startElement event it may modify the attributes object passed to make
     * changes.
     * 
     * @return The attributes for this merged element
     */
    public Attributes merge(Attributes attributes) throws SAXException,
            WingException;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 *
 */

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Timestamp;

import org.apache.log4j.Logger;

/**
 * Class representing the track
 * @author dbutano
 */
    @Override
    public void store(Connection con) {
        String sql = "";
        PreparedStatement stm = null;
        StringBuffer valuesBuffer = new StringBuffer();
        Object[] values = getFormattedTrack();
        int valuesSize = values.length;
        for (int index = 0; index < valuesSize; index++) {
            valuesBuffer = valuesBuffer.append("?,");
        }
        valuesBuffer = valuesBuffer.deleteCharAt(valuesBuffer.length() - 1);
        try {
            sql = "INSERT INTO " + getTableName() + " VALUES(" + valuesBuffer + ")";
            stm = con.prepareStatement(sql);
            Object value = null;
            for (int index = 0; index < valuesSize; ) {
                value = values[index];
                if (value instanceof Integer) {
                    stm.setInt(++index, (Integer) value);
                } else if (value instanceof Timestamp) {
                    stm.setTimestamp(++index, (Timestamp) value);
                } else {
                    stm.setString(++index, value.toString());
                }
            }
            stm.executeUpdate();
        } catch (SQLException sqe) {
            LOG.error("Problem executing the statement: " + sql, sqe);
            if (stm != null) {
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
public void testXMLRead() throws Exception {
        fieldNames.add("name");

        assertEquals("Wrong number of bags!", 3, stored2.getSavedBags().size());
        List<Integer> expectedBagContents = new ArrayList<Integer>();
        //when we read xml file, we load data into savedbag and bagvalues table but not in the
        //osbag_int loaded after user login
        assertEquals(expectedBagContents,
                (stored2.getSavedBags().get("stored_2_3")).getContentsAsIds());

        List<BagValue> contentsAsKey = (stored2.getSavedBags()
                .get("stored_2_1")).getContents();
public void testTrackTemplate() throws SQLException, InterruptedException {
//        assertEquals(20, trackerDelegate.getUserLogin().size());
//    }
//

    public void testTrackKeywordSearch() throws SQLException, InterruptedException {

        searchActivity();

        String sql = "SELECT COUNT(*) FROM searchtrack";
        Statement stm = conn.createStatement();
        ResultSet rs = stm.executeQuery(sql);
        rs.next();
        assertEquals(20, rs.getInt(1));
        rs.close();
        stm.close();

        assertEquals(20, trackerDelegate.getKeywordSearches().size());
    }

    public void testSecurityKeywordSearch() throws SQLException, InterruptedException {
        String keySearch = "select * from searchtrack";
        trackerDelegate.trackKeywordSearch(keySearch, superUser, "session");
        Thread.sleep(3000);
        Statement stm = conn.createStatement();
        String query = "SELECT * FROM searchtrack";
        ResultSet rs = stm.executeQuery(query);
        rs.next();
        assertEquals(keySearch, rs.getString("keyword"));
        rs.close();
        stm.close();
    }
}

import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.Collection;

import org.apache.log4j.Logger;
import org.intermine.metadata.AttributeDescriptor;
protected StringBuffer getSummary(Source source) {
    /**
     * {@inheritDoc}
     */
    public Collection<InterMineObject> queryEquivalentObjects(InterMineObject obj,
            Source source) throws ObjectStoreException {
        Class<? extends InterMineObject> summaryName = obj.getClass();
        Long soFar = summaryTimes.get(summaryName);
protected StringBuffer getSummary(Source source) {
            summaryTimes.put(summaryName, new Long(time + soFar.longValue()));
            summaryCounts.put(summaryName, new Integer(soFarCount.intValue() + 1));
            summaryCallCounts.put(summaryName, new Integer(soFarCallCount.intValue() + 1));
            @SuppressWarnings("unchecked") Collection<InterMineObject> retval = (Collection) result;
            return retval;
        } else {
            summaryCallCounts.put(summaryName, new Integer(soFarCallCount.intValue() + 1));
            return Collections.emptyList();
        }
    }

public void close(Source source) {
     * {@inheritDoc}
     */
    @Override
    public Collection<InterMineObject> queryEquivalentObjects(InterMineObject obj,
            Source source) throws ObjectStoreException {
        if (source == this.source) {
            Collection<InterMineObject> retval = equivalents.get(obj);
            if (retval != null) {
                //Set expected = super.queryEquivalentObjects(obj, source);
                //if (!retval.equals(expected)) {
protected void doPk(PrimaryKey pk, ClassDescriptor cld, Map<InterMineObject,
                                if (value instanceof InterMineObject) {
                                    Integer id = idMap.get(((InterMineObject) value).getId());
                                    if (id == null) {
                                        Collection<InterMineObject> eqs = results.get(value);
                                        if (eqs == null) {
                                            value = object.getFieldValue(fieldName);
                                            eqs = queryEquivalentObjects((InterMineObject) value,
 */

import java.util.Set;
import java.util.Collection;
import org.intermine.metadata.ClassDescriptor;
import org.intermine.metadata.MetaDataException;
import org.intermine.model.InterMineObject;
public interface EquivalentObjectFetcher
{
    /**
     * Returns a Collection of objects that are equivalent to the given object, according to the
     *  primary keys defined by the given Source.
     *
     * @param obj the Object to look for
     * @param source the data Source
     * @return a Collection of InterMineObjects
     * @throws ObjectStoreException if an error occurs
     */
    Collection<InterMineObject> queryEquivalentObjects(InterMineObject obj,
            Source source) throws ObjectStoreException;

    /**
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.Collection;

import org.apache.log4j.Logger;
import org.intermine.metadata.AttributeDescriptor;
protected StringBuffer getSummary(Source source) {
     * {@inheritDoc}
     */
    @Override
    public Collection<InterMineObject> queryEquivalentObjects(InterMineObject obj, Source source)
        throws ObjectStoreException {
        Class<? extends InterMineObject> summaryName = obj.getClass();
        Integer soFarCallCount = summaryCallCounts.get(summaryName);
public ObjectStoreWriter getObjectStoreWriter() {
     * @return a Set of InterMineObjects
     * @throws ObjectStoreException if an error occurs
     */
    public Collection<InterMineObject> getEquivalentObjects(InterMineObject obj,
            Source source) throws ObjectStoreException {
        lastSource = source;
        if (obj == null) {
 */

import java.lang.reflect.Constructor;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
protected InterMineObject store(FastPathObject nimo, Source source, Source skelS
            }
            InterMineObject o = (InterMineObject) nimo;
            long time1 = System.currentTimeMillis();
            Collection<InterMineObject> equivObjects = getEquivalentObjects(o, source);
            long time2 = System.currentTimeMillis();
            timeSpentEquiv += time2 - time1;
            if ((type != FROM_DB) && ((equivObjects.size() == 0) || ((equivObjects.size() == 1)
protected InterMineObject store(FastPathObject nimo, Source source, Source skelS
     */
    private boolean isDuplicateObject(InterMineObject newObj, InterMineObject objToCheck,
            String fieldName, Source source, Source skelSource, int type,
            Collection<InterMineObject> equivObjects) {
        Source fieldSource = dataTracker.getSource(objToCheck.getId(), fieldName);
        if ((equivObjects.size() == 1) && (fieldSource != null)
            && (fieldSource.equals(source)
private void copyFields(Source source, Source skelSource, int type, InterMineObj
        }
    }

    private InterMineObject shortcut(InterMineObject o, Collection<InterMineObject> equivObjects,
            int type, long time2, Source source, Source skelSource) throws ObjectStoreException,
            IllegalAccessException {
        // Take a shortcut!
        InterMineObject newObj = DynamicUtil.createObject(o.getClass());
 */

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;

import junit.framework.Test;

public void testUpdateObjectManyToManyWithMerge() throws Exception {
        conA.setCompanys(new HashSet<Company>());
        //Contractor sConA = (Contractor) iw.getObjectByExample(conA, Collections.singleton("name"));
        Query equivQuery = iw.beof.createPKQuery(conA, source2, false);
        Collection<InterMineObject> equiv = iw.getEquivalentObjects(conA, source2);
        assertEquals(equiv.getClass().getName() + ": " + equiv + ", " + equivQuery, 2, equiv.size());
        iw.store(conA, source2, skelSource2);
        Contractor rconA = (Contractor) iw.getObjectByExample(conA, Collections.singleton("name"));
public void testGetEquivalentObjects() throws Exception {
        Source source = iw.getMainSource("testsource", "testsource");
        @SuppressWarnings("unused")
        Source skelSource = iw.getSkeletonSource("testsource", "testsource");
        Collection<InterMineObject> objects = iw.getEquivalentObjects(b, source);
        System.out.println(objects);
        assertTrue(objects.isEmpty());
    }
 */

import java.util.List;
import java.util.Collection;
import org.intermine.objectstore.ObjectStoreException;
import org.intermine.objectstore.query.Query;
import org.intermine.objectstore.query.ResultsInfo;
 * @author Matthew Wakeling
 * @param <E> The element type
 */
public interface LazyCollection<E> extends Lazy, Collection<E>
{
    /**
     * Sets this LazyCollection to bypass the optimiser

import java.util.List;
import java.util.Map;
import java.util.Collection;

import org.intermine.objectstore.ObjectStore;
import org.intermine.objectstore.ObjectStoreException;
 * @author Richard Smith
 * @author Matthew Wakeling
 */
public class SingletonResults extends Results implements Collection<Object>
{
    /**
     * Constructor for a SingletonResults object
 *
 */

import java.util.Collection;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import org.intermine.objectstore.ObjectStoreException;
private int removeOrphanTags() {
        QueryClass qc = new QueryClass(Tag.class);
        q.setConstraint(new SimpleConstraint(
                new QueryField(qc, "userProfile"), ConstraintOp.IS_NULL));
        Collection<Object> res;
        try {
            res = osw.executeSingleton(q);
        } catch (Exception e) {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static boolean isInstance(Types types, TypeElement element, String className) {
               extendsClass(types, element, className);
    }

    static boolean implementsInterface(Types types, TypeElement element, String interfaceName) {
        // check name or interfaces
        if (namesEqual(element, interfaceName)) {
            return true;
static boolean implementsInterface(Types types, TypeElement element, String inte
        for (TypeMirror interfaceType : interfaces) {
            interfaceType = types.erasure(interfaceType);
            TypeElement typeElement = (TypeElement) types.asElement(interfaceType);
            if (implementsInterface(types, typeElement, interfaceName)) {
                return true;
            }
        }
        return false;
    }

    static boolean extendsClass(Types types, TypeElement element, String className) {
        if (namesEqual(element, className)) {
            return true;
        }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public void parse() {
      Method[] methods = type.getMethods();
      for (Method method : methods) {
        try {
          parseStatement(method);
        } catch (IncompleteElementException e) {
          configuration.addIncompleteMethod(new MethodResolver(this, method));
        }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
jdk:
git:
    submodules: false

# Use sed to replace the SSH URL with the public URL, then initialize submodules
before_install:
- sed -i 's/git@github.com:/https:\/\/github.com\//' .gitmodules
- git submodule update --init --recursive

  <property name="target" value="10.49.4.2"/>

  <!-- Any other property in build.properties can also be overridden. -->
  
  <property file="${user.home}/wpilib/wpilib.properties"/>
  <property file="build.properties"/>
  <property file="${user.home}/wpilib/java/${version}/ant/build.properties"/>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public updateCheck(Boolean performInBackground) {
			builder = domFactory.newDocumentBuilder();
	        
	        // XPath instanzieren
	        XPathFactory factory = XPathFactory.newInstance();
	        xpath = factory.newXPath();
	        
	        
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 * 
 * @author Alexey Maslov
 * @author Scott Phillips
 * @author Oriol Oliv - DS-3205
 */
public class EditGroupForm extends AbstractDSpaceTransformer   
{
        </profile>

        <!--
           These profiles activate the inclusion of various modules into
           the DSpace Build process. They activate automatically if the
           source module is in the local file system, correctly located
                                <goals>
                                    <goal>aggregate-jar</goal>
                                </goals>
                            </execution>
                        </executions>
                    </plugin>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private void setReservedNames()

    private final Set<String>[] basicclasses=new Set[4];

    private void addSootBasicClasses() {
        basicclasses[SootClass.HIERARCHY] = new HashSet<String>();
        basicclasses[SootClass.SIGNATURES] = new HashSet<String>();
        basicclasses[SootClass.BODIES] = new HashSet<String>();

	addBasicClass("java.lang.Object");
	addBasicClass("java.lang.Class", SootClass.SIGNATURES);

	addBasicClass("java.lang.Void", SootClass.SIGNATURES);
	addBasicClass("java.lang.Boolean", SootClass.SIGNATURES);
	addBasicClass("java.lang.Byte", SootClass.SIGNATURES);
	addBasicClass("java.lang.Character", SootClass.SIGNATURES);
	addBasicClass("java.lang.Short", SootClass.SIGNATURES);
	addBasicClass("java.lang.Integer", SootClass.SIGNATURES);
	addBasicClass("java.lang.Long", SootClass.SIGNATURES);
	addBasicClass("java.lang.Float", SootClass.SIGNATURES);
	addBasicClass("java.lang.Double", SootClass.SIGNATURES);

	addBasicClass("java.lang.String");
	addBasicClass("java.lang.StringBuffer", SootClass.SIGNATURES);

	addBasicClass("java.lang.Error");
	addBasicClass("java.lang.AssertionError", SootClass.SIGNATURES);
	addBasicClass("java.lang.Throwable", SootClass.SIGNATURES);
	addBasicClass("java.lang.NoClassDefFoundError", SootClass.SIGNATURES);
	addBasicClass("java.lang.ExceptionInInitializerError");
	addBasicClass("java.lang.RuntimeException");
	addBasicClass("java.lang.ClassNotFoundException");
	addBasicClass("java.lang.ArithmeticException");
	addBasicClass("java.lang.ArrayStoreException");
	addBasicClass("java.lang.ClassCastException");
	addBasicClass("java.lang.IllegalMonitorStateException");
	addBasicClass("java.lang.IndexOutOfBoundsException");
	addBasicClass("java.lang.ArrayIndexOutOfBoundsException");
	addBasicClass("java.lang.NegativeArraySizeException");
	addBasicClass("java.lang.NullPointerException");
	addBasicClass("java.lang.InstantiationError");
	addBasicClass("java.lang.InternalError");
	addBasicClass("java.lang.OutOfMemoryError");
	addBasicClass("java.lang.StackOverflowError");
	addBasicClass("java.lang.UnknownError");
	addBasicClass("java.lang.ThreadDeath");
	addBasicClass("java.lang.ClassCircularityError");
	addBasicClass("java.lang.ClassFormatError");
	addBasicClass("java.lang.IllegalAccessError");
	addBasicClass("java.lang.IncompatibleClassChangeError");
	addBasicClass("java.lang.LinkageError");
	addBasicClass("java.lang.VerifyError");
	addBasicClass("java.lang.NoSuchFieldError");
	addBasicClass("java.lang.AbstractMethodError");
	addBasicClass("java.lang.NoSuchMethodError");
	addBasicClass("java.lang.UnsatisfiedLinkError");

	addBasicClass("java.lang.Thread");
	addBasicClass("java.lang.Runnable");
	addBasicClass("java.lang.Cloneable");

	addBasicClass("java.io.Serializable");	

	addBasicClass("java.lang.ref.Finalizer");
	
    }

    public void addBasicClass(String name) {
	addBasicClass(name,SootClass.HIERARCHY);
    }
    
    public void addBasicClass(String name,int level) {
	basicclasses[level].add(name);
    }

    /** Load just the set of basic classes soot needs, ignoring those
     *  specified on the command-line. You don't need to use both this and 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
<project name="asterics.imported" basedir="." xmlns:fx="javafx:com.sun.javafx.tools.ant">
	<property name="APE.propertiesFile" value="APE.properties"></property>
	<property name="APE.optionalServicesFile" value="" />
	
	<loadproperties srcFile="${APE.propertiesFile}" />
	
	<condition property="APE.buildDir" value="build/">		
		<not>
			<isset property="APE.buildDir" />
		</not>
	</condition>
	
	<property name="build.merged" location="${APE.buildDir}/merged" />
	<property name="build.merged.ARE" location="${build.merged}/bin/ARE" />
	<property name="build.deploy" location="${APE.buildDir}/deploy" />
	<!-- the build platform is actually also the target platform, so we can differ the services files configuration -->
	<condition property="APE.targetOS" value="windows" else="linux">
		<os family="windows" />
	</condition>

	<!-- create platform dependent property value for services startup when starting the ARE -->
	<property name="APE.servicesFiles" value="services.ini;services-${APE.targetOS}.ini;${APE.optionalServicesFile}" />

	<!-- if property is not set, set it to false -->
	<condition property="APE.embedJava" value="false">
		<not>
			<isset property="APE.embedJava" />
		</not>
	</condition>
	
	<!-- if fx.platform.basedir is not set, java.home will be used as platform -->	
	<condition property="fx.platform.basedir" value="${java.home}">		
			<not>
				<isset property="fx.platform.basedir" />
			</not>
	</condition>
	
	<!-- only if APE.embedJava=true the JRE of the configured platform.basedir will be embedded -->
	<condition property="APE.embedJava.fx.platform.basedir" value="${fx.platform.basedir}" else="">
		<istrue value="${APE.embedJava}"/>
	</condition>
	
	<!-- in case of embeddedjava add a postfix to the application name -->
	<condition property="APE.fx.deploy.outfile" value="${fx.application.name}-javaembedded" else="${fx.application.name}">
		<istrue value="${APE.embedJava}"/>
	</condition>	
	
	<!-- if ARE.baseURI is not set assume that APE is located in the parent folder of basedir -->
	<condition property="APE.baseURI" else="${ARE.baseURI}../APE/" value="${basedir}/../">
		<not>
			<isset property="ARE.baseURI" />
		</not>
	</condition>

	<!--
	<echoproperties>
	</echoproperties>
	-->
	
	<target name="init-fx-tasks">
		<path id="fxant">
			<filelist>
				<file name="${java.home}\..\lib\ant-javafx.jar" />
				<file name="${java.home}\lib\jfxrt.jar" />
				<file name="${basedir}" />
			</filelist>
		</path>

		<taskdef resource="com/sun/javafx/tools/ant/antlib.xml" uri="javafx:com.sun.javafx.tools.ant" classpathref="fxant" />
	</target>

	<target name="cleanup">
		<delete dir="${build.deploy}" failonerror="false" />
		<delete dir="${build.merged.ARE}" failonerror="false"/>
	</target>
	<target name="setup-staging-area">
		<mkdir dir="${build.deploy}" />
		<delete failonerror="false">
			<fileset dir="${build.merged.ARE}" includes="**/*.log" />
		</delete>
		<delete failonerror="false">
			<fileset dir="${build.merged.ARE}/profile/org.eclipse.osgi" />
		</delete>
	</target>
		
	<!-- calls the javafx deployment tasks and creates the requested installers -->
	<target name="make-installer-only" depends="init-fx-tasks">
		<fx:resources id="appRes">
			<fx:fileset dir="${build.merged.ARE}" />
			<fx:fileset dir="${build.merged.ARE}" type="license" includes="LICENSE" />
		</fx:resources>

		<fx:application id="fxApplication" name="${APE.fx.deploy.outfile}" mainClass="org.eclipse.core.runtime.adaptor.EclipseStarter" version="${fx.application.version}" toolkit="swing" />
		<fx:deploy verbose="true" embedJNLP="false" extension="false" includeDT="false" offlineAllowed="true" outdir="${build.deploy}" outfile="${APE.fx.deploy.outfile}" nativeBundles="${fx.deploy.nativeBundles}" updatemode="background">
			<fx:preferences shortcut="${fx.preferences.shortcut}" install="${fx.preferences.install}" menu="${fx.preferences.menu}" />

			<fx:platform basedir="${APE.embedJava.fx.platform.basedir}">
				<property name="osgi.configuration.area" value="profile" />
				<property name="osgi.clean" value="true" />
				<property name="org.osgi.framework.bootdelegation" value="*" />
				<property name="org.osgi.framework.system.packages.extra" value="sun.misc" />
				<property name="Ansi" value="true" />
				<property name="java.util.logging.config.file" value="logging.properties" />
				<!--
				<property name="eu.asterics.ARE.startModel" value="autostart.acs" />
				-->
				<property name="eu.asterics.ARE.ServicesFiles" value="${APE.servicesFiles}" />
			</fx:platform>

			<fx:application refId="fxApplication" />
			<fx:resources refid="appRes" />
			<fx:info title="${fx.info.title}" vendor="${fx.info.vendor}" description="${fx.info.description}" license="${fx.info.license}" category="${fx.info.category}" />
		</fx:deploy>
	</target>

	<!-- call APE tool from build script to copy AsTeRICS resources to ${build.merged.ARE} -->
	<target name="APE-copy">
		<java jar="${APE.baseURI}/APE.jar" fork="true">
			<sysproperty key="APE.projectDir" value="${basedir}"/>	
		</java>	
			
	</target>
</project>
set SPLASH_SWITCH=
@IF NOT DEFINED ARE_DEBUG_STRING set START_CMD=start
@IF NOT DEFINED ARE_DEBUG_STRING set SPLASH_SWITCH=-splash:images/asterics_startup.png

%!S(MISSING)TART_CMD%JAVA_BIN%ARE_DEBUG_STRING%SPLASH_SWITCH%!D(MISSING)osgi.clean=true -Dorg.osgi.framework.bootdelegation=* -Dorg.osgi.framework.system.packages.extra=sun.misc -DAnsi=true -Djava.util.logging.config.file=logging.properties -Deu.asterics.ARE.startModel=%!A(MISSING)UTOSTART_MODEL%!D(MISSING)eu.asterics.ARE.ServicesFiles="services.ini;services-windows.ini;%!A(MISSING)RE_OPTIONAL_SERVICES_INI%!"(MISSING) -jar org.eclipse.osgi_3.6.0.v20100517.jar -configuration %!P(MISSING)ROFILE_PATH%!c(MISSING)onsole
set ARE_LOG_STRING=
set ARE_DEBUG_STRING=

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 */
public enum LookAndFeels
{
    LIQUID("liquid"), LOOKS("looks"), SUBSTANCE("substance"), NIMBUS("nimbus"), KUNSTSTOFF("kunststoff");

    private String name;


        <!-- lafs -->
        <dependency>
            <groupId>org.java.net.substance</groupId>
            <artifactId>substance</artifactId>
        </dependency>
        <dependency>
protected void addGUIPrefs(IXMLElement data) throws CompilerException
                    case KUNSTSTOFF:
                        mergeableList = pathResolver.getMergeableFromPackageName("com/incors/plaf");
                        break;
                    case LIQUID:
                        mergeableList = pathResolver.getMergeableFromPackageName("com/birosoft/liquid/");
                        break;
                    case LOOKS:
                        mergeableList = pathResolver.getMergeableFromPackageName("com/jgoodies/looks");
                        break;
                    case SUBSTANCE:
                        mergeableList = pathResolver.getMergeableJarFromPackageName("org/pushingpixels");
                        mergeableList.addAll(pathResolver.getMergeableFromPackageName("nanoxml"));
                        break;
                    case NIMBUS:
                        // Nimbus was included in JDK 6u10, and in JDK7 changed packages.
public static void run(final String mediaPath) throws Exception
    {
        final InstallerContainer applicationComponent = new GUIInstallerContainer();
        final Container installerContainer = applicationComponent.getComponent(Container.class);
        final SplashScreen splashScreen = installerContainer.getComponent(SplashScreen.class);
        splashScreen.displaySplashScreen();

        SwingUtilities.invokeLater(new Runnable()
        {
            public void run()
            {
                try
                {

                    if (mediaPath != null)
                    {
import java.awt.Dimension;
import java.awt.Toolkit;

import javax.swing.ImageIcon;
import javax.swing.JFrame;

import com.izforge.izpack.installer.gui.SplashScreen;
import org.picocontainer.Characteristics;
import org.picocontainer.MutablePicoContainer;
protected void registerComponents(MutablePicoContainer pico)
     * @param pico the container
     */
    @Override
    protected void resolveComponents(MutablePicoContainer pico)
    {
        super.resolveComponents(pico);
        InstallData installdata = pico.getComponent(InstallData.class);
        pico
                .addConfig("title", getTitle(installdata)) // Configuration of title parameter in InstallerFrame
                .addConfig("frame", initFrame());          // Configuration of frame parameter in languageDialog

        InstallerFrame frame = pico.getComponent(InstallerFrame.class);
        IUnpacker unpacker = pico.getComponent(IUnpacker.class);
        frame.setUnpacker(unpacker);
    }

    private JFrame initFrame()
    {
        IconsDatabase icons = getComponent(IconsDatabase.class);
        // Dummy Frame
        JFrame frame = new JFrame();
        ImageIcon imageIcon = icons.get("JFrameIcon");
        frame.setIconImage(imageIcon.getImage());

        Dimension frameSize = frame.getSize();
        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
        frame.setLocation((screenSize.width - frameSize.width) / 2,
                          (screenSize.height - frameSize.height) / 2 - 10);
        return frame;
    }

    private String getTitle(InstallData installData)
else if (OsVersion.IS_OSX)
            return;
        }

        // Liquid (http://liquidlnf.sourceforge.net/)
        if ("liquid".equals(lookAndFeelName))
        {
            UIManager.setLookAndFeel("com.birosoft.liquid.LiquidLookAndFeel");

            Map<String, String> params = installData.guiPrefs.lookAndFeelParams.get(lookAndFeelName);
            if (params.containsKey("decorate.frames"))
            {
                String value = params.get("decorate.frames");
                if ("yes".equals(value))
                {
                    JFrame.setDefaultLookAndFeelDecorated(true);
                }
            }
            if (params.containsKey("decorate.dialogs"))
            {
                String value = params.get("decorate.dialogs");
                if ("yes".equals(value))
                {
                    JDialog.setDefaultLookAndFeelDecorated(true);
                }
            }

            return;
        }

        // Metouia (http://mlf.sourceforge.net/)
        if ("metouia".equals(lookAndFeelName))
        {
private void checkSubstanceLafLoaded() throws ClassNotFoundException
        ClassLoader classLoader = (cl != null) ? cl : JPanel.class.getClassLoader();
        Class aClass = (Class) defaults.get(uiClassName);

        logger.info("PanelUI : " + uiClassName);
        logger.info("ClassLoader : " + classLoader);
        logger.info("Cached class : " + aClass);
        if (aClass != null)
        {
            return;
        }

        if (classLoader == null)
        {
            logger.info("Using system loader to load " + uiClassName);
            aClass = Class.forName(uiClassName, true, Thread.currentThread().getContextClassLoader());
            logger.info("Done loading");
        }
        else
        {
            logger.info("Using custom loader to load " + uiClassName);
            aClass = classLoader.loadClass(uiClassName);
            logger.info("Done loading");
        }
        if (aClass != null)
        {
            logger.info("Loaded class : " + aClass.getName());
        }
        else
        {
            logger.info("Couldn't load the class");
        }
    }

 */
package com.izforge.izpack.installer.language;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.GraphicsEnvironment;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.GrayFilter;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.ListCellRenderer;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;

import com.izforge.izpack.api.GuiId;
import com.izforge.izpack.api.exception.ResourceException;
import com.izforge.izpack.api.resource.Locales;
import com.izforge.izpack.api.resource.Resources;
import com.izforge.izpack.installer.container.provider.AbstractInstallDataProvider;
import com.izforge.izpack.installer.data.GUIInstallData;
import com.izforge.izpack.installer.requirement.RequirementsChecker;

/**
 * Used to prompt the user for the language. Languages can be displayed in iso3 or the native
 * notation or the notation of the default locale. Revising to native notation is based on code
    private static final long serialVersionUID = 3256443616359887667L;

    /**
     * The parent frame.
     */
    private final JFrame frame;

    /**
     * The installation data.
     */
    private final GUIInstallData installData;
    /**
     * Constructs a {@code LanguageDialog}.
     *
     * @param frame        the parent frame
     * @param resources    the resources
     * @param locales      the locales
     * @param installData  the installation data
     * @param requirements the installation requirements
     */
    public LanguageDialog(JFrame frame, Resources resources, Locales locales, GUIInstallData installData,
                          RequirementsChecker requirements)
    {
        super(frame);
        this.frame = frame;
        this.resources = resources;
        this.locales = locales;
        this.installData = installData;
public void initLangPack() throws Exception
            propagateLocale(codeOfUniqueLanguage);
            break;
        default:
            frame.setVisible(false);
            setVisible(true);
        }


import javax.swing.JFrame;

import org.fest.swing.fixture.DialogFixture;
import org.hamcrest.core.Is;
import org.junit.After;
    private final Locales locales;

    /**
     * The dialog fixture.
     */
    private DialogFixture fixture;
     * @param installData the installation data
     * @param locales     the locales. Must contain locales "eng" and "fra"
     */
    public LanguageDialogTest(Resources resources, GUIInstallData installData, Locales locales)
    {
        this.resources = resources;
        this.installData = installData;
        this.locales = locales;
    }

    /**
private void checkSelectLanguage(String englishDisplayName, String frenchDisplay
    private LanguageDialog createDialog(String langDisplayType)
    {
        installData.guiPrefs.modifier.put("langDisplayType", langDisplayType);
        JFrame frame = new JFrame();
        frame.setLocationRelativeTo(null);
        return new LanguageDialog(frame, resources, locales, installData, Mockito.mock(RequirementsChecker.class));
    }

}
            <scope>test</scope>
        </dependency>
        <dependency>
            <!-- the only maven deployment of substance? -->
            <groupId>net.sf.squirrel-sql.thirdparty-non-maven</groupId>
            <artifactId>substance</artifactId>
            <version>5.2_01</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
 */
package com.izforge.izpack.panels.process;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import javax.swing.LookAndFeel;
import javax.swing.UIManager;

import org.fest.swing.fixture.DialogFixture;
import org.fest.swing.fixture.FrameFixture;
import org.hamcrest.text.StringContains;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.jvnet.substance.skin.SubstanceBusinessLookAndFeel;

import com.izforge.izpack.api.GuiId;
import com.izforge.izpack.api.factory.ObjectFactory;
import com.izforge.izpack.api.resource.Locales;
import com.izforge.izpack.panels.test.AbstractPanelTest;
import com.izforge.izpack.panels.test.TestGUIPanelContainer;
import com.izforge.izpack.test.Container;


/**

      <!-- laf -->
      <dependency>
        <groupId>org.java.net.substance</groupId>
        <artifactId>substance</artifactId>
        <version>6.0</version>
        <exclusions>
          <exclusion>
            <groupId>com.google.android</groupId>
            <artifactId>android</artifactId>
          </exclusion>
          <exclusion>
            <artifactId>ant</artifactId>
            <groupId>ant</groupId>
          </exclusion>
        </exclusions>
      </dependency>
      <dependency>
        <groupId>com.incors</groupId>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 */
package com.github.jknack.handlebars.context;

import com.github.jknack.handlebars.ValueResolver;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.LinkedHashSet;
import java.util.Set;

/**
 * A specialization of {@link MemberValueResolver} with lookup and invocation
 * support for {@link Method}.
protected void members(final Class<?> clazz, final Set<Method> members) {
      }
      if (clazz.getSuperclass() != null) {
        members(clazz.getSuperclass(), members);
      } else if (clazz.isInterface()) {
        for (Class<?> superIfc : clazz.getInterfaces()) {
          members(superIfc, members);
        }
      }
    }
  }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 */
package org.teavm.javascript;

import org.teavm.javascript.ast.AsyncMethodNode;
import org.teavm.javascript.ast.AsyncMethodPart;
import org.teavm.javascript.ast.RegularMethodNode;
import org.teavm.model.Program;
import org.teavm.model.util.AsyncProgramSplitter;

/**
 *
public void optimize(RegularMethodNode method, Program program) {
    }

    public void optimize(AsyncMethodNode method, AsyncProgramSplitter splitter) {
        boolean[] preservedVars = new boolean[method.getVariables().size()];
        int[][] readFrequencies = new int[splitter.size()][];
        for (int i = 0; i < splitter.size(); ++i) {
            ReadWriteStatsBuilder stats = new ReadWriteStatsBuilder(method.getVariables().size());
            stats.analyze(splitter.getProgram(i));
            readFrequencies[i] = stats.reads;
            for (int j = 0; j < stats.writes.length; ++j) {
                if (stats.readUninitialized[j] || stats.writes[j] != 1 && stats.reads[j] > 0) {
                    preservedVars[j] = true;
                }
            }
        }
        for (int i = 0; i < splitter.size(); ++i) {
            AsyncMethodPart part = method.getBody().get(i);
            BreakEliminator breakEliminator = new BreakEliminator();
            breakEliminator.eliminate(part.getStatement());
            OptimizingVisitor optimizer = new OptimizingVisitor(preservedVars, readFrequencies[i]);
            part.getStatement().acceptVisitor(optimizer);
            part.setStatement(optimizer.resultStmt);
        }
public void optimize(AsyncMethodNode method, AsyncProgramSplitter splitter) {
            method.getVariables().set(i, i);
        }
    }
}
class ReadWriteStatsBuilder {
    public int[] reads;
    public int[] writes;
    public boolean[] readUninitialized;

    private ReadWriteStatsBuilder() {
    }

    public ReadWriteStatsBuilder(int variableCount) {
        reads = new int[variableCount];
        writes = new int[variableCount];
        readUninitialized = new boolean[variableCount];
    }

    public ReadWriteStatsBuilder copy() {
public void analyze(Program program) {
                }
                for (Variable var : useExtractor.getUsedVariables()) {
                    reads[var.getIndex()]++;
                    if (writes[var.getIndex()] == 0) {
                        readUninitialized[var.getIndex()] = true;
                    }
                }
            }
            for (Phi phi : block.getPhis()) {
    private Map<Long, Integer> partMap = new HashMap<>();
    private ClassReaderSource classSource;
    private Set<MethodReference> asyncMethods = new HashSet<>();

    public AsyncProgramSplitter(ClassReaderSource classSource, Set<MethodReference> asyncMethods) {
        this.classSource = classSource;
        this.asyncMethods = asyncMethods;
    }

    public void split(Program program) {
        parts.clear();
        Program initialProgram = createStubCopy(program);
        Part initialPart = new Part();
        initialPart.program = initialProgram;
        initialPart.blockSuccessors = new int[program.basicBlockCount()];
        Arrays.fill(initialPart.blockSuccessors, -1);
        parts.add(initialPart);
        partMap.put(0L, 0);
        Step initialStep = new Step();
public void split(Program program) {
                }
                last = i;

                // If this instruction already separates program, end with current block and refer to the
                // existing part
                long key = ((long)step.source << 32) | i;
public void split(Program program) {
                parts.add(part);
                part.blockSuccessors = new int[program.basicBlockCount() + 1];
                Arrays.fill(part.blockSuccessors, -1);

                // Mark current instruction as a separator and remember which part is in charge.
                partMap.put(key, partId);
public int size() {
        return parts.size();
    }

    public Program getProgram(int index) {
        return parts.get(index).program;
    }
public Program getProgram(int index) {
        return Arrays.copyOf(result, result.length);
    }

    private static class Part {
        Program program;
        int[] blockSuccessors;
    }

    private static class Step {
public void visit(NullCheckInstruction insn) {

    @Override
    public void visit(MonitorEnterInstruction insn) {
        
    }

    @Override
    public void visit(MonitorExitInstruction insn) {
        
    }
}
              <targetDirectory>${project.build.directory}/generated/js/teavm</targetDirectory>
              <mainClass>org.teavm.samples.async.AsyncProgram</mainClass>
              <runtime>SEPARATE</runtime>
              <minifying>true</minifying>
              <debugInformationGenerated>true</debugInformationGenerated>
              <sourceMapsGenerated>true</sourceMapsGenerated>
              <sourceFilesCopied>true</sourceFilesCopied>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        </dependency>
        <dependency>
            <groupId>net.sourceforge.pmd</groupId>
            <artifactId>pmd</artifactId>
            <version>5.1.2</version>
            <exclusions>
                <exclusion>
                    <artifactId>asm</artifactId>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import org.joda.time.DateTime;

import com.google.common.base.Objects;
import com.google.common.base.Preconditions;

public boolean isInterval() {

    @Override
    public String toString() {
        return Objects.toStringHelper(TemporalFilter.class)
                .add("op", getOperator())
                .add("begin", getBegin())
                .add("end", getEnd())

import java.math.BigDecimal;

import com.google.common.base.Objects;
import com.google.common.base.Preconditions;
import com.google.common.base.Strings;
public double doubleValue() {

    @Override
    public String toString() {
        return Objects.toStringHelper(this)
                .add("value", this.value())
                .add("unit", this.unit())
                .toString();
 */
package org.envirocar.server.core.util.pagination;

import com.google.common.base.Objects;
import com.google.common.base.Optional;

public boolean equals(Object obj) {

    @Override
    public String toString() {
        return Objects.toStringHelper(this)
                .add("size", this.size)
                .add("page", this.page)
                .toString();
 */
package org.envirocar.server.core.util.pagination;

import com.google.common.base.Objects;
import com.google.common.base.Optional;

/**
public long getTotalCount() {

    @Override
    public String toString() {
        return Objects.toStringHelper(this)
                .add("first", getFirst().orNull())
                .add("previous", getPrevious().orNull())
                .add("current", getCurrent().orNull())
<?xml version="1.0"?>
<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" 
         xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <modelVersion>4.0.0</modelVersion>
    <parent>
            <artifactId>mongo-java-driver</artifactId>
            <groupId>org.mongodb</groupId>
        </dependency>
    </dependencies>
</project>

import javax.annotation.Nullable;

import com.github.jmkgreen.morphia.Datastore;
import com.github.jmkgreen.morphia.Key;
import com.github.jmkgreen.morphia.Morphia;
import com.github.jmkgreen.morphia.converters.DefaultConverters;
import com.github.jmkgreen.morphia.converters.TypeConverter;
import com.github.jmkgreen.morphia.logging.MorphiaLoggerFactory;
import com.github.jmkgreen.morphia.logging.slf4j.SLF4JLogrImplFactory;
import com.google.inject.Singleton;
import com.google.inject.name.Named;
import com.mongodb.BasicDBObject;
import com.mongodb.DBCollection;
import com.mongodb.DBRef;
import com.mongodb.MongoClient;
import com.mongodb.ServerAddress;

import org.envirocar.server.mongo.entity.MongoMeasurement;

import com.mongodb.BasicDBObjectBuilder;

/**
 * TODO JavaDoc
 *
public Mapper getMapper() {
    }

    private void addConverters(Set<TypeConverter> converters) {
        DefaultConverters dc = getMapper().getConverters();
        for (TypeConverter tc : converters) {
            dc.addConverter(tc);
        }
    }

    private void addMappedClasses(Set<Class<?>> mappedClasses) {
        for (Class<?> c : mappedClasses) {
            getMapper().addMappedClass(c);
        }
    }

    /*
     * FIXME remove this once 2dsphere indexes are supported by morphia in v1.3.0
     */
    private void ensureIndexes() {
        DBCollection collection = getDatastore().getCollection(MongoMeasurement.class);
        collection.ensureIndex(new BasicDBObject(MongoMeasurement.GEOMETRY, "2dsphere"));
        collection.ensureIndex(new BasicDBObjectBuilder()
                .append(MongoMeasurement.GEOMETRY, "2dsphere")
                .append(MongoMeasurement.TIME, 1)
                .get());
private void ensureIndexes() {
        List<Iterable<T>> fetched = Lists.newLinkedList();
        for (String kind : kindMap.keySet()) {
            List<Key<T>> kindKeys = kindMap.get(kind);
            List<Object> objIds = new ArrayList<Object>(kindKeys.size());
            Class<T> kindClass = clazz == null
                                 ? (Class<T>) kindKeys.get(0).getKindClass()
                                 : clazz;
            for (Key<T> key : kindKeys) {
                objIds.add(key.getId());
            }
            fetched.add(getDatastore()
                    .find(kind, kindClass)
                    .disableValidation()
 */
package org.envirocar.server.mongo.activities;

import org.bson.types.ObjectId;
import org.envirocar.server.core.activities.Activity;
import org.envirocar.server.core.activities.ActivityType;
import com.github.jmkgreen.morphia.annotations.Transient;
import com.github.jmkgreen.morphia.mapping.Mapper;
import com.github.jmkgreen.morphia.utils.IndexDirection;
import com.google.common.base.Objects;
import com.google.common.base.Objects.ToStringHelper;
import com.google.inject.Inject;
import com.google.inject.assistedinject.Assisted;
import com.google.inject.assistedinject.AssistedInject;
public boolean equals(Object obj) {
            return false;
        }
        final MongoActivity other = (MongoActivity) obj;
        return Objects.equal(this.id, other.getId());
    }

    @Override
public String toString() {
    }

    protected ToStringHelper toStringHelper() {
        return Objects.toStringHelper(this)
                .omitNullValues()
                .add(ID, this.id)
                .add(TYPE, this.type)


import java.util.ArrayList;
import java.util.List;

import org.bson.BSONObject;
void removeTrack(MongoTrack track) {
    }

    List<Key<MongoTrack>> getTrackKeysByBbox(MeasurementFilter filter) {
        ArrayList<DBObject> filters = new ArrayList<DBObject>(4);
        if (filter.hasGeometry()) {
            filters.add(matchGeometry(filter.getGeometry()));
        }
        if (filter.hasUser()) {
            filters.add(matchUser(filter.getUser()));
        }
        if (filter.hasTrack()) {
            filters.add(matchTrack(filter.getTrack()));
        }
        if (filter.hasTemporalFilter()) {
            filters.add(matchTime(filter.getTemporalFilter()));
        }

        final AggregationOutput out;
        if (filters.isEmpty()) {
            out = aggregate(project(), group());
        } else {
            int size = filters.size();
            if (size == 1) {
                out = aggregate(filters.get(0), project(), group());
            } else {
                DBObject first = filters.get(0);
                DBObject[] other = new DBObject[size + 1];
                for (int i = 1; i < size; ++i) {
                    other[i - 1] = filters.get(i);
                }
                other[other.length - 2] = project();
                other[other.length - 1] = group();
                out = aggregate(first, other);
            }
        }
        return toKeyList(out.results());
    }

    private AggregationOutput aggregate(DBObject firstOp,
                                        DBObject... additionalOps) {
        AggregationOutput result = mongoDB.getDatastore()
                .getCollection(MongoMeasurement.class)
                .aggregate(firstOp, additionalOps);
        result.getCommandResult().throwOnError();
        return result;
    }

    private DBObject matchGeometry(Geometry polygon) {
 */
package org.envirocar.server.mongo.dao;

import java.util.List;

import com.github.jmkgreen.morphia.dao.BasicDAO;
import com.github.jmkgreen.morphia.mapping.Mapper;
import com.google.common.collect.Lists;
import com.google.inject.Inject;
import com.mongodb.AggregationOutput;
import com.mongodb.BasicDBObject;
import com.mongodb.BasicDBObjectBuilder;
import com.mongodb.DBObject;
import com.mongodb.DBRef;

import org.envirocar.server.core.dao.StatisticsDao;

import org.envirocar.server.core.entities.Phenomenon;
import org.envirocar.server.core.filter.StatisticsFilter;
import org.envirocar.server.core.statistics.Statistic;
import org.envirocar.server.mongo.entity.MongoStatistics;
import org.envirocar.server.mongo.entity.MongoTrack;
import org.envirocar.server.mongo.entity.MongoUser;

import org.envirocar.server.mongo.util.MongoUtils;
import org.envirocar.server.mongo.util.Ops;

/**
 * TODO JavaDoc
 *
private MongoStatistics getStatistics1(StatisticsFilter request) {
        MongoStatisticKey key = key(request);
        MongoStatistics v = this.dao.get(key);
        if (v == null) {
            AggregationOutput aggregate = aggregate(matches(request),
                                                    project(),
                                                    unwind(),
                                                    group());
            List<MongoStatistic> statistics =
                    parseStatistics(aggregate.results());

            v = new MongoStatistics(key, statistics);
            this.dao.save(v);
        }
private MongoStatisticKey key(StatisticsFilter request) {
                                     mongoDB.key(sensor));
    }

    private AggregationOutput aggregate(DBObject firstOp,
                                        DBObject... additionalOps) {
        AggregationOutput result = mongoDB.getDatastore()
                .getCollection(MongoMeasurement.class)
                .aggregate(firstOp, additionalOps);
        result.getCommandResult().throwOnError();
        return result;
    }

    private List<MongoStatistic> parseStatistics(Iterable<DBObject> results) {
        List<MongoStatistic> l = Lists.newLinkedList();
        for (DBObject o : results) {
import com.github.jmkgreen.morphia.query.Query;
import com.google.inject.Inject;

public class MongoPasswordResetDAO extends AbstractMongoDao<ObjectId, MongoPasswordReset, MongoPasswordResetDAO.MongoPasswordResetStatusCollection> 
	implements PasswordResetDAO {

    private static final Logger logger = LoggerFactory.getLogger(MongoPasswordResetDAO.class);
protected MongoPasswordResetStatusCollection createPaginatedIterable(
		 */
		return null;
	}
	

	public PasswordReset requestPasswordReset(User user) throws BadRequestException {
		MongoPasswordReset status = getPasswordResetStatus(user);
		
		if (status == null || status.isExpired()) {
			MongoPasswordReset result = createNewPasswordReset(user);
			return result;
private MongoPasswordReset createNewPasswordReset(User user) {
		String uuid = UUID.randomUUID().toString();
		Calendar expires = Calendar.getInstance();
		expires.add(Calendar.HOUR, 24);
		
		MongoPasswordReset entity = createMongoPasswordResetStatus();
		entity.setCode(uuid);
		entity.setUser(user);
		
		save((MongoPasswordReset) entity);
		
		return entity;
	}

private MongoPasswordReset createMongoPasswordResetStatus() {
	public MongoPasswordReset getPasswordResetStatus(User user) {
		logger.debug("Querying password reset status for user {} (key={})", user, key(user));
		Query<MongoPasswordReset> result = q().field(MongoPasswordReset.USER).equal(key(user));
		
		if (result.fetch().iterator().hasNext()) {
			return result.fetch().iterator().next();
		}
		
		logger.debug("No result for query.");
		return null;
	}
import com.github.jmkgreen.morphia.annotations.Property;
import com.github.jmkgreen.morphia.annotations.Transient;
import com.github.jmkgreen.morphia.utils.IndexDirection;
import com.google.common.base.Objects;
import com.google.common.base.Objects.ToStringHelper;
import com.google.inject.Inject;

/**
public void setMongoDB(MongoDB mongoDB) {
    }

    protected ToStringHelper toStringHelper() {
        return Objects.toStringHelper(this)
                .omitNullValues()
                .add(CREATION_DATE, this.creationTime)
                .add(LAST_MODIFIED, this.modificationTime);
 */
package org.envirocar.server.mongo.entity;

import org.envirocar.server.core.entities.MeasurementValue;
import org.envirocar.server.core.entities.Phenomenon;

import com.github.jmkgreen.morphia.annotations.Embedded;
import com.github.jmkgreen.morphia.annotations.Property;
import com.google.common.base.Objects;

/**
 * TODO JavaDoc
public boolean hasPhenomenon() {

    @Override
    public String toString() {
        return Objects.toStringHelper(this)
                .add(VALUE, value)
                .add(PHENOMENON, phenomenon)
                .toString();
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(this.value, this.phenomenon);
    }

    @Override
public boolean equals(Object obj) {
            return false;
        }
        final MongoMeasurementValue other = (MongoMeasurementValue) obj;
        return Objects.equal(this.value, other.value) &&
               Objects.equal(this.phenomenon, other.phenomenon);
    }
}
    </modules>
    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <logback-version>1.0.11</logback-version>
        <morphia-version>1.2.3</morphia-version>
        <jersey-version>1.17.1</jersey-version>
        <guice-version>3.0</guice-version>
        <slf4j-version>1.7.5</slf4j-version>
		<geotools.version>8.7</geotools.version>
		<wps.version>3.2.0</wps.version>
    </properties>
            <dependency>
                <groupId>junit</groupId>
                <artifactId>junit</artifactId>
                <version>4.11</version>
                <scope>test</scope>
            </dependency>
            <dependency>
			<dependency>
				<groupId>org.mockito</groupId>
				<artifactId>mockito-all</artifactId>
				<version>1.9.5</version>
			</dependency>
            <dependency>
                <groupId>commons-io</groupId>
            <dependency>
                <groupId>com.google.guava</groupId>
                <artifactId>guava</artifactId>
                <version>12.0</version>
            </dependency>
            <dependency>
                <groupId>com.google.inject</groupId>
                <version>${guice-version}</version>
            </dependency>
            <dependency>
                <artifactId>morphia</artifactId>
                <groupId>com.github.jmkgreen.morphia</groupId>
                <version>${morphia-version}</version>
            <dependency>
                <artifactId>mongo-java-driver</artifactId>
                <groupId>org.mongodb</groupId>
                <version>2.11.1</version>
            </dependency>
            <dependency>
                <groupId>ch.qos.logback</groupId>
            <dependency>
                <groupId>joda-time</groupId>
                <artifactId>joda-time</artifactId>
                <version>2.2</version>
            </dependency>
            <dependency>
                <groupId>com.vividsolutions</groupId>
            <dependency>
                <groupId>org.apache.jena</groupId>
                <artifactId>apache-jena-libs</artifactId>
                <version>2.10.1</version>
                <type>pom</type>
            </dependency>
            <dependency>
                <groupId>commons-codec</groupId>
                <artifactId>commons-codec</artifactId>
                <version>1.8</version>
            </dependency>
            <dependency>
                <groupId>org.n52.sensorweb</groupId>
                <artifactId>oxf-common</artifactId>
                <version>2.0.0-alpha.3-SNAPSHOT</version>
            </dependency>
			<dependency>
				<groupId>org.clojars.ndimiduk</groupId>
            <artifactId>hamcrest-all</artifactId>
        </dependency>
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
        </dependency>

/**
 * TODO: Javadoc
 * 
 * @author Benjamin Pross
 */
@Provider
public class TrackShapefileEncoder extends AbstractShapefileTrackEncoder<Track> {

	private static final Logger log = LoggerFactory
            .getLogger(TrackShapefileEncoder.class);
	
	private SimpleFeatureTypeBuilder typeBuilder;
    private final DataService dataService;
    private CoordinateReferenceSystem crs_wgs84;
	private Properties properties;
    private static final String PROPERTIES = "/export.properties";
    private static final String DEFAULT_PROPERTIES = "/export.default.properties";
    
    @Inject
	public TrackShapefileEncoder(DataService dataService){
    	super(Track.class);
public TrackShapefileEncoder(DataService dataService){
        } finally {
            Closeables.closeQuietly(in);
        }
        
		if (properties != null) {
			String property = properties
					.getProperty(shapefileExportThresholdPropertyName);
public TrackShapefileEncoder(DataService dataService){
			}
		}
	}
	
	@Override
	public File encodeShapefile(Track t, AccessRights rights,
			MediaType mediaType) throws TrackTooLongException {
public File encodeShapefile(Track t, AccessRights rights,
				Measurements measurements = dataService
						.getMeasurements(new MeasurementFilter(t));
				zippedShapeFile = createZippedShapefile(createShapeFile(createFeatureCollection(measurements)));
			}			
		} catch (IOException e) {
			log.debug(e.getMessage());
		} 
		
		return zippedShapeFile;
	}

public File encodeShapefile(Track t, AccessRights rights,
		String idAttributeName = "id";
		String geometryAttributeName = "geometry";
		String timeAttributeName = "time";
		
		SimpleFeatureType sft = null;

		SimpleFeatureBuilder sfb = null;

		typeBuilder = new SimpleFeatureTypeBuilder();
		
		typeBuilder.setCRS(getCRS_WGS84());

		typeBuilder.setNamespaceURI(namespace);
public File encodeShapefile(Track t, AccessRights rights,

		typeBuilder.add(geometryAttributeName, Point.class);
		typeBuilder.add(idAttributeName, String.class);
		typeBuilder.add(timeAttributeName, String.class);		
		
		if (sft == null) {
			sft = buildFeatureType(measurements);
			sfb = new SimpleFeatureBuilder(sft);
		}	
		
        for (Measurement measurement : measurements) {
        	
        	MeasurementValues values = measurement.getValues();

			String id = measurement.getIdentifier();
			
			sfb.set(idAttributeName, id);
			sfb.set(timeAttributeName, measurement.getTime().toString());
			sfb.set(geometryAttributeName, measurement.getGeometry());
			
        	for (MeasurementValue measurementValue : values) {
				
        		Phenomenon phenomenon = measurementValue.getPhenomenon();
        		
				String value = measurementValue.getValue().toString();
				String unit = phenomenon.getUnit();

				/*
				 * create property name
				 */
				String propertyName = getPropertyName(phenomenon.getName(), unit);
				
				if (sfb != null) {
					sfb.set(propertyName, value);
				}
public File encodeShapefile(Track t, AccessRights rights,
				simpleFeatureList.add(sfb.buildFeature(id));
			}
        }
        return  new ListFeatureCollection(sft, simpleFeatureList);		
	}
	
	private SimpleFeatureType buildFeatureType(Measurements measurements) throws TrackTooLongException {

		Set<String> distinctPhenomenonNames = new HashSet<String>();
		
		int count = 0;
		
		for (Measurement measurement : measurements) {

			count++;
			
			MeasurementValues values = measurement.getValues();

			for (MeasurementValue measurementValue : values) {
private SimpleFeatureType buildFeatureType(Measurements measurements) throws Tra
				 * create property name
				 */
				String propertyName = getPropertyName(phenomenon.getName(), unit);
				
				distinctPhenomenonNames.add(propertyName);
			}

		}
		
		if(count >= shapeFileExportThreshold){
			throw new TrackTooLongException(track.getIdentifier(), shapeFileExportThreshold, count);
		}
private SimpleFeatureType buildFeatureType(Measurements measurements) throws Tra
				.iterator();

		while (distinctPhenomenonNamesIterator.hasNext()) {
			String phenomenonNameAndUnit = (String) distinctPhenomenonNamesIterator
					.next();
			typeBuilder.add(phenomenonNameAndUnit,
					String.class);
		}

		return typeBuilder.buildFeatureType();
	}

	private File createShapeFile(FeatureCollection<SimpleFeatureType, SimpleFeature> collection) throws IOException {
		
		String shapeFileSuffix = ".shp";
		
		File tempBaseFile = File.createTempFile("resolveDir", ".tmp");
		tempBaseFile.deleteOnExit();
		File parent = tempBaseFile.getParentFile();
		
		File shpBaseDirectory = new File(parent, UUID.randomUUID().toString());
		
		if (!shpBaseDirectory.mkdir()) {
			throw new IllegalStateException("Could not create temporary shp directory.");
		}
		
		File tempSHPfile = File.createTempFile("shp", shapeFileSuffix, shpBaseDirectory);
		tempSHPfile.deleteOnExit();
		DataStoreFactorySpi dataStoreFactory = new ShapefileDataStoreFactory();
private File createShapeFile(FeatureCollection<SimpleFeatureType, SimpleFeature>
		ShapefileDataStore newDataStore = (ShapefileDataStore) dataStoreFactory
				.createNewDataStore(params);

		newDataStore.createSchema((SimpleFeatureType) collection.getSchema());
		if(collection.getSchema().getCoordinateReferenceSystem()==null){
			newDataStore.forceSchemaCRS(getCRS_WGS84());
		}else{
private File createShapeFile(FeatureCollection<SimpleFeatureType, SimpleFeature>
		File shx = new File(baseName + ".shx");
		File dbf = new File(baseName + ".dbf");
		File prj = new File(baseName + ".prj");
		
		// mark created files for delete
		tempSHPfile.deleteOnExit();
		shx.deleteOnExit();
		dbf.deleteOnExit();
		prj.deleteOnExit();
		shpBaseDirectory.deleteOnExit();
		
		return shpBaseDirectory;
	}
	
	private File createZippedShapefile(File shapeDirectory) throws IOException {
		if (shapeDirectory != null && shapeDirectory.isDirectory()) {
			File[] files = shapeDirectory.listFiles();
private File createZippedShapefile(File shapeDirectory) throws IOException {

		return null;
	}
	
	private String getPropertyName(String propertyName, String unit){
		
		return propertyName + "(" + unit + ")";		
	}
	
	private CoordinateReferenceSystem getCRS_WGS84() {

		if (crs_wgs84 == null) {
private CoordinateReferenceSystem getCRS_WGS84() {
		}
		return crs_wgs84;
	}
	
}
public interface PaginationProvider extends CheckedProvider<Pagination> {

    @Override
    public Pagination get()
            throws BadRequestException;

}
public void finish() throws IOException {
        }

        protected byte[] gunzip(byte[] bytes) throws IOException {
            GZIPInputStream gzin = null;
            ByteArrayInputStream bain = null;
            ByteArrayOutputStream out = null;
            try {
                bain = new ByteArrayInputStream(bytes);
                out = new ByteArrayOutputStream();
                gzin = new GZIPInputStream(bain);
                byte[] buffer = new byte[1024];
                int bytesRead;
                while ((bytesRead = gzin.read(buffer)) > 0) {
                    out.write(buffer, 0, bytesRead);
                }
                out.flush();
                return out.toByteArray();
            } finally {
                Closeables.closeQuietly(bain);
                Closeables.closeQuietly(gzin);
                Closeables.closeQuietly(out);
            }
        }

 */
package org.envirocar.server;

import java.util.logging.Handler;
import java.util.logging.LogManager;
import java.util.logging.Logger;

protected Injector getInjector() {

    protected void configureLogging() {
        Logger rootLogger = LogManager.getLogManager().getLogger("");
        Handler[] handlers = rootLogger.getHandlers();
        for (int i = 0; i < handlers.length; i++) {
            rootLogger.removeHandler(handlers[i]);
        }
        SLF4JBridgeHandler.install();
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
SIMRacingApps Release Notes
For a complete list of issues completed in this version goto 
(https://github.com/SIMRacingApps/SIMRacingApps/milestone/1)

Version: 1.1_Build_2016.09.13
       
    1. Fixed #53 (http://issues.SIMRacingApps.com/53) where SRA would not pick the 
       latest version of Java if the version number of Java was greater than 99. 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import sun.security.x509.*;

import javax.net.ssl.KeyManagerFactory;

import java.io.*;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.Date;

/**
 * Generate a Fake Key Store.
private static X509Certificate createSelfSignedCertificate(KeyPair keyPair) thro

        // Subject & Issuer
        X500Name owner = new X500Name(DN_NAME);
        certInfo.set(X509CertInfo.SUBJECT, new CertificateSubjectName(owner));
        certInfo.set(X509CertInfo.ISSUER, new CertificateIssuerName(owner));

        // Key and algorithm
        certInfo.set(X509CertInfo.KEY, new CertificateX509Key(keyPair.getPublic()));
private static X509Certificate createSelfSignedCertificate(KeyPair keyPair) thro
        newCert.sign(keyPair.getPrivate(), SHA1WITHRSA);

        return newCert;
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
            if (c0_0==null) {
               c0_0 = new CompiledPredicateSourceGeneratorTest$3(v0_A, v0_B, v0_C);
            } else {
               v0_B = _0;
               v0_A = _1;
               v0_C = _2;
            }
            if (!c0_0.evaluate((Term[])null)) {
               return false;
            }
            _0 = v0_B;
            v0_B = v0_B.getTerm();
            _1 = v0_A;
            v0_A = v0_A.getTerm();
            _2 = v0_C;
            v0_C = v0_C.getTerm();
            if (NUMERIC_TERM_COMPARATOR.compare(v0_A, DOUBLE_1_5, kb)!=1) {
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
            if (c0_0==null) {
               c0_0 = new CompiledPredicateSourceGeneratorTest$3(v0_A, v0_B, v0_C);
            } else {
               v0_B = _0;
               v0_A = _1;
               v0_C = _2;
            }
            if (!c0_0.evaluate((Term[])null)) {
               return false;
            }
            _0 = v0_B;
            v0_B = v0_B.getTerm();
            _1 = v0_A;
            v0_A = v0_A.getTerm();
            _2 = v0_C;
            v0_C = v0_C.getTerm();
            if (NUMERIC_TERM_COMPARATOR.compare(v0_A, DOUBLE_1_5, kb)!=1) {
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
         switch (conjunctionCtr) {
            case 0:
            if (inlinedCtr0!=0) {
               v0_Z = _1;
               v0_Y = _2;
               v0_X = _3;
               v0_W = _4;
               _0.backtrack();
            } else {
               _0 = v0_X.getTerm();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  _0.backtrack();
               }
            } while (true);
            _1 = v0_Z;
            v0_Z = v0_Z.getTerm();
            _2 = v0_Y;
            v0_Y = v0_Y.getTerm();
            _3 = v0_X;
            v0_X = v0_X.getTerm();
            _4 = v0_W;
            v0_W = v0_W.getTerm();
            case 1:
            if (inlinedCtr1!=0) {
               v0_Z = _7;
               v0_Y = _8;
               v0_X = _9;
               v0_W = _10;
               _6.backtrack();
            } else {
               _6 = v0_W.getTerm();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  break;
               }
            } while (true);
            _7 = v0_Z;
            v0_Z = v0_Z.getTerm();
            _8 = v0_Y;
            v0_Y = v0_Y.getTerm();
            _9 = v0_X;
            v0_X = v0_X.getTerm();
            _10 = v0_W;
            v0_W = v0_W.getTerm();
            conjunctionCtr = 1;
            if (!IsAtom_1.evaluate(v0_W)) {
               v0_W.backtrack();
               break mainloop;
            }
            case 2:
            if (inlinedCtr2!=0) {
               v0_Z = _12;
               v0_Y = _13;
               v0_X = _14;
               v0_W = _15;
               _11.backtrack();
            } else {
               _11 = v0_Y.getTerm();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  _11.backtrack();
               }
            } while (true);
            _12 = v0_Z;
            v0_Z = v0_Z.getTerm();
            _13 = v0_Y;
            v0_Y = v0_Y.getTerm();
            _14 = v0_X;
            v0_X = v0_X.getTerm();
            _15 = v0_W;
            v0_W = v0_W.getTerm();
            conjunctionCtr = 2;
            // SingleRuleWithSingleImmutableArgumentPredicateGenerator
            if (!v0_W.unify(ATOM)) {
               break mainloop;
            }
            case 3:
            if (inlinedCtr3!=0) {
               v0_Z = _17;
               v0_Y = _18;
               v0_X = _19;
               _16.backtrack();
            } else {
               _16 = v0_Z.getTerm();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  _16.backtrack();
               }
            } while (true);
            _17 = v0_Z;
            v0_Z = v0_Z.getTerm();
            _18 = v0_Y;
            v0_Y = v0_Y.getTerm();
            _19 = v0_X;
            v0_X = v0_X.getTerm();
            conjunctionCtr = 3;
            if (!v0_X.unify(ATOM_0)) {
               break mainloop;
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
            }
            case 4:
            if (inlinedCtr4!=0) {
               v0_Z = _23;
               v0_Y = _24;
               v0_X = _25;
               _20.backtrack();
               _21.backtrack();
               _22.backtrack();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  break;
               }
            } while (true);
            _23 = v0_Z;
            v0_Z = v0_Z.getTerm();
            _24 = v0_Y;
            v0_Y = v0_Y.getTerm();
            _25 = v0_X;
            v0_X = v0_X.getTerm();
            conjunctionCtr = 4;
            return true;
         }
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
         switch (conjunctionCtr) {
            case 0:
            if (inlinedCtr0!=0) {
               v0_Z = _1;
               v0_Y = _2;
               v0_X = _3;
               v0_W = _4;
               _0.backtrack();
            } else {
               _0 = v0_X.getTerm();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  _0.backtrack();
               }
            } while (true);
            _1 = v0_Z;
            v0_Z = v0_Z.getTerm();
            _2 = v0_Y;
            v0_Y = v0_Y.getTerm();
            _3 = v0_X;
            v0_X = v0_X.getTerm();
            _4 = v0_W;
            v0_W = v0_W.getTerm();
            case 1:
            if (inlinedCtr1!=0) {
               v0_Z = _7;
               v0_Y = _8;
               v0_X = _9;
               v0_W = _10;
               _6.backtrack();
            } else {
               _6 = v0_W.getTerm();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  break;
               }
            } while (true);
            _7 = v0_Z;
            v0_Z = v0_Z.getTerm();
            _8 = v0_Y;
            v0_Y = v0_Y.getTerm();
            _9 = v0_X;
            v0_X = v0_X.getTerm();
            _10 = v0_W;
            v0_W = v0_W.getTerm();
            conjunctionCtr = 1;
            if (!IsAtom_1.evaluate(v0_W)) {
               v0_W.backtrack();
               break mainloop;
            }
            case 2:
            if (inlinedCtr2!=0) {
               v0_Z = _12;
               v0_Y = _13;
               v0_X = _14;
               v0_W = _15;
               _11.backtrack();
            } else {
               _11 = v0_Y.getTerm();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  _11.backtrack();
               }
            } while (true);
            _12 = v0_Z;
            v0_Z = v0_Z.getTerm();
            _13 = v0_Y;
            v0_Y = v0_Y.getTerm();
            _14 = v0_X;
            v0_X = v0_X.getTerm();
            _15 = v0_W;
            v0_W = v0_W.getTerm();
            conjunctionCtr = 2;
            if (CompiledPredicateSourceGeneratorTest$DummyUserDefinedPredicateFactory_1_0.spyPoint.isEnabled()) {
               CompiledPredicateSourceGeneratorTest$DummyUserDefinedPredicateFactory_1_0.spyPoint.logCall(CompiledPredicateSourceGeneratorTest$DummyUserDefinedPredicateFactory_1_0, new Term[]{v0_W});
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
            }
            case 3:
            if (inlinedCtr3!=0) {
               v0_Z = _17;
               v0_Y = _18;
               v0_X = _19;
               _16.backtrack();
            } else {
               _16 = v0_Z.getTerm();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  _16.backtrack();
               }
            } while (true);
            _17 = v0_Z;
            v0_Z = v0_Z.getTerm();
            _18 = v0_Y;
            v0_Y = v0_Y.getTerm();
            _19 = v0_X;
            v0_X = v0_X.getTerm();
            conjunctionCtr = 3;
            if (CompiledPredicateSourceGeneratorTest$DummyUserDefinedPredicateFactory_3_0.spyPoint.isEnabled()) {
               CompiledPredicateSourceGeneratorTest$DummyUserDefinedPredicateFactory_3_0.spyPoint.logCall(CompiledPredicateSourceGeneratorTest$DummyUserDefinedPredicateFactory_3_0, new Term[]{v0_X, v0_Y, v0_Z});
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
            }
            case 4:
            if (inlinedCtr4!=0) {
               v0_Z = _23;
               v0_Y = _24;
               v0_X = _25;
               _20.backtrack();
               _21.backtrack();
               _22.backtrack();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  break;
               }
            } while (true);
            _23 = v0_Z;
            v0_Z = v0_Z.getTerm();
            _24 = v0_Y;
            v0_Y = v0_Y.getTerm();
            _25 = v0_X;
            v0_X = v0_X.getTerm();
            conjunctionCtr = 4;
            return true;
         }
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
         switch (conjunctionCtr) {
            case 0:
            if (inlinedCtr2!=0) {
               v2_Y = _1;
               v2_Z = _2;
               v2_X = _3;
               v2_RuleNo = _4;
               _0.backtrack();
            } else {
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  break;
               }
            } while (true);
            _1 = v2_Y;
            v2_Y = v2_Y.getTerm();
            _2 = v2_Z;
            v2_Z = v2_Z.getTerm();
            _3 = v2_X;
            v2_X = v2_X.getTerm();
            _4 = v2_RuleNo;
            v2_RuleNo = v2_RuleNo.getTerm();
            if (!v2_X.unify(ATOM_0)) {
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
            }
            case 1:
            if (inlinedCtr3!=0) {
               v2_Y = _8;
               v2_Z = _9;
               v2_X = _10;
               v2_RuleNo = _11;
               _5.backtrack();
               _6.backtrack();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  break;
               }
            } while (true);
            _8 = v2_Y;
            v2_Y = v2_Y.getTerm();
            _9 = v2_Z;
            v2_Z = v2_Z.getTerm();
            _10 = v2_X;
            v2_X = v2_X.getTerm();
            _11 = v2_RuleNo;
            v2_RuleNo = v2_RuleNo.getTerm();
            conjunctionCtr = 1;
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
               v3_A = new Variable("A");
            }
            if (inlinedCtr4!=0) {
               v3_RuleNo = _15;
               v3_Z = _16;
               v3_A = _17;
               v3_X = _18;
               v3_Y = _19;
               _14.backtrack();
               _13.backtrack();
            } else {
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  break;
               }
            } while (true);
            _15 = v3_RuleNo;
            v3_RuleNo = v3_RuleNo.getTerm();
            _16 = v3_Z;
            v3_Z = v3_Z.getTerm();
            _17 = v3_A;
            v3_A = v3_A.getTerm();
            _18 = v3_X;
            v3_X = v3_X.getTerm();
            _19 = v3_Y;
            v3_Y = v3_Y.getTerm();
            if (!v3_A.unify(v3_X)) {
               v3_X.backtrack();
               v3_A.backtrack();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
         switch (conjunctionCtr) {
            case 0:
            if (inlinedCtr12!=0) {
               v9_Y = _28;
               v9_X = _29;
               v9_Z = _30;
               v9_RuleNo = _31;
               _27.backtrack();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  break;
               }
            } while (true);
            _28 = v9_Y;
            v9_Y = v9_Y.getTerm();
            _29 = v9_X;
            v9_X = v9_X.getTerm();
            _30 = v9_Z;
            v9_Z = v9_Z.getTerm();
            _31 = v9_RuleNo;
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
         switch (conjunctionCtr) {
            case 0:
            if (inlinedCtr2!=0) {
               v2_Y = _1;
               v2_Z = _2;
               v2_X = _3;
               v2_RuleNo = _4;
               _0.backtrack();
            } else {
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  break;
               }
            } while (true);
            _1 = v2_Y;
            v2_Y = v2_Y.getTerm();
            _2 = v2_Z;
            v2_Z = v2_Z.getTerm();
            _3 = v2_X;
            v2_X = v2_X.getTerm();
            _4 = v2_RuleNo;
            v2_RuleNo = v2_RuleNo.getTerm();
            if (!v2_X.unify(ATOM_0)) {
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
            }
            case 1:
            if (inlinedCtr3!=0) {
               v2_Y = _8;
               v2_Z = _9;
               v2_X = _10;
               v2_RuleNo = _11;
               _5.backtrack();
               _6.backtrack();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  break;
               }
            } while (true);
            _8 = v2_Y;
            v2_Y = v2_Y.getTerm();
            _9 = v2_Z;
            v2_Z = v2_Z.getTerm();
            _10 = v2_X;
            v2_X = v2_X.getTerm();
            _11 = v2_RuleNo;
            v2_RuleNo = v2_RuleNo.getTerm();
            conjunctionCtr = 1;
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
               v3_A = new Variable("A");
            }
            if (inlinedCtr4!=0) {
               v3_RuleNo = _15;
               v3_Z = _16;
               v3_A = _17;
               v3_X = _18;
               v3_Y = _19;
               _14.backtrack();
               _13.backtrack();
            } else {
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  break;
               }
            } while (true);
            _15 = v3_RuleNo;
            v3_RuleNo = v3_RuleNo.getTerm();
            _16 = v3_Z;
            v3_Z = v3_Z.getTerm();
            _17 = v3_A;
            v3_A = v3_A.getTerm();
            _18 = v3_X;
            v3_X = v3_X.getTerm();
            _19 = v3_Y;
            v3_Y = v3_Y.getTerm();
            if (!v3_A.unify(v3_X)) {
               v3_X.backtrack();
               v3_A.backtrack();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
         switch (conjunctionCtr) {
            case 0:
            if (inlinedCtr12!=0) {
               v9_Y = _28;
               v9_X = _29;
               v9_Z = _30;
               v9_RuleNo = _31;
               _27.backtrack();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  break;
               }
            } while (true);
            _28 = v9_Y;
            v9_Y = v9_Y.getTerm();
            _29 = v9_X;
            v9_X = v9_X.getTerm();
            _30 = v9_Z;
            v9_Z = v9_Z.getTerm();
            _31 = v9_RuleNo;
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
         switch (conjunctionCtr) {
            case 0:
            if (inlinedCtr0!=0) {
               v0_RuleNo = _1;
               v0_X = _2;
               _0.backtrack();
            } else {
               _0 = v0_X.getTerm();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  _0.backtrack();
               }
            } while (true);
            _1 = v0_RuleNo;
            v0_RuleNo = v0_RuleNo.getTerm();
            _2 = v0_X;
            v0_X = v0_X.getTerm();
            if (!v0_RuleNo.unify(INTEGER_1)) {
               v0_RuleNo.backtrack();
               break mainloop;
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
         switch (conjunctionCtr) {
            case 0:
            if (inlinedCtr9!=0) {
               v7_Y = _12;
               v7_RuleNo = _13;
               _11.backtrack();
            } else {
               _11 = v7_Y.getTerm();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  _11.backtrack();
               }
            } while (true);
            _12 = v7_Y;
            v7_Y = v7_Y.getTerm();
            _13 = v7_RuleNo;
            v7_RuleNo = v7_RuleNo.getTerm();
            if (!v7_RuleNo.unify(INTEGER_8)) {
               v7_RuleNo.backtrack();
               break mainloop;
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
         switch (conjunctionCtr) {
            case 0:
            if (inlinedCtr10!=0) {
               v8_RuleNo = _15;
               v8_X = _16;
               _14.backtrack();
            } else {
               _14 = v8_X.getTerm();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  _14.backtrack();
               }
            } while (true);
            _15 = v8_RuleNo;
            v8_RuleNo = v8_RuleNo.getTerm();
            _16 = v8_X;
            v8_X = v8_X.getTerm();
            case 1:
            if (inlinedCtr11!=0) {
               v8_RuleNo = _18;
               v8_X = _19;
               _17.backtrack();
            } else {
               _17 = v8_X.getTerm();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  _17.backtrack();
               }
            } while (true);
            _18 = v8_RuleNo;
            v8_RuleNo = v8_RuleNo.getTerm();
            _19 = v8_X;
            v8_X = v8_X.getTerm();
            conjunctionCtr = 1;
            if (!v8_RuleNo.unify(INTEGER_9)) {
               v8_RuleNo.backtrack();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
         switch (conjunctionCtr) {
            case 0:
            if (inlinedCtr16!=0) {
               v13_RuleNo = _33;
               v13_X = _34;
               _32.backtrack();
            } else {
               _32 = v13_X.getTerm();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  _32.backtrack();
               }
            } while (true);
            _33 = v13_RuleNo;
            v13_RuleNo = v13_RuleNo.getTerm();
            _34 = v13_X;
            v13_X = v13_X.getTerm();
            if (!v13_RuleNo.unify(INTEGER_14)) {
               v13_RuleNo.backtrack();
               break mainloop;
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
         switch (conjunctionCtr) {
            case 0:
            if (inlinedCtr0!=0) {
               v0_RuleNo = _1;
               v0_X = _2;
               _0.backtrack();
            } else {
               _0 = v0_X.getTerm();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  _0.backtrack();
               }
            } while (true);
            _1 = v0_RuleNo;
            v0_RuleNo = v0_RuleNo.getTerm();
            _2 = v0_X;
            v0_X = v0_X.getTerm();
            if (!v0_RuleNo.unify(INTEGER_1)) {
               v0_RuleNo.backtrack();
               break mainloop;
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
         switch (conjunctionCtr) {
            case 0:
            if (inlinedCtr9!=0) {
               v7_Y = _12;
               v7_RuleNo = _13;
               _11.backtrack();
            } else {
               _11 = v7_Y.getTerm();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  _11.backtrack();
               }
            } while (true);
            _12 = v7_Y;
            v7_Y = v7_Y.getTerm();
            _13 = v7_RuleNo;
            v7_RuleNo = v7_RuleNo.getTerm();
            if (!v7_RuleNo.unify(INTEGER_8)) {
               v7_RuleNo.backtrack();
               break mainloop;
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
         switch (conjunctionCtr) {
            case 0:
            if (inlinedCtr10!=0) {
               v8_RuleNo = _15;
               v8_X = _16;
               _14.backtrack();
            } else {
               _14 = v8_X.getTerm();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  _14.backtrack();
               }
            } while (true);
            _15 = v8_RuleNo;
            v8_RuleNo = v8_RuleNo.getTerm();
            _16 = v8_X;
            v8_X = v8_X.getTerm();
            case 1:
            if (inlinedCtr11!=0) {
               v8_RuleNo = _18;
               v8_X = _19;
               _17.backtrack();
            } else {
               _17 = v8_X.getTerm();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  _17.backtrack();
               }
            } while (true);
            _18 = v8_RuleNo;
            v8_RuleNo = v8_RuleNo.getTerm();
            _19 = v8_X;
            v8_X = v8_X.getTerm();
            conjunctionCtr = 1;
            if (!v8_RuleNo.unify(INTEGER_9)) {
               v8_RuleNo.backtrack();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
         switch (conjunctionCtr) {
            case 0:
            if (inlinedCtr16!=0) {
               v13_RuleNo = _33;
               v13_X = _34;
               _32.backtrack();
            } else {
               _32 = v13_X.getTerm();
public final class %!C(MISSING)LASS_NAME%!i(MISSING)mplements CompiledPredicate {
                  _32.backtrack();
               }
            } while (true);
            _33 = v13_RuleNo;
            v13_RuleNo = v13_RuleNo.getTerm();
            _34 = v13_X;
            v13_X = v13_X.getTerm();
            if (!v13_RuleNo.unify(INTEGER_14)) {
               v13_RuleNo.backtrack();
               break mainloop;
void callUserDefinedPredicate(String compiledPredicateName, boolean isRetryable)
               addLine("} else {");
            }
         }
         beginIf(compiledPredicateVariableName + "==null");

         for (Variable v : variablesInCurrentFunction) {
final void assignTermToTempVariable(Map<String, String> variablesToKeepTempVersi
         return Collections.EMPTY_SET;
      }

      Set<String> alreadyDeclaredVariables = new HashSet<>();
      Set<Variable> variables1 = TermUtils.getAllVariablesInTerm(currentClause.getConsequent());
      for (Variable v : variables1) {
         String variableId = getVariableId(v);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
